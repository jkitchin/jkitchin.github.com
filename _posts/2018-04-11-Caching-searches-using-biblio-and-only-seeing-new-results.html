---
title: Caching searches using biblio and only seeing new results
date: 2018/04/11 20:46:56
updated: 2018/04/11 20:46:56
categories: elisp,arxiv,biblio
tags:
---


<p>
In this <a href="https://github.com/jkitchin/scimax/issues/196">issue</a> in scimax, Robert asked if it was possible to save searches, and then to repeat them every so often and only see the new results. This needs some persistent caching of the records, and a comparison of the current search results with the previous search results.
</p>

<p>
<a href="https://github.com/cpitclaudel/biblio.el">biblio</a> provides a nice interface to searching a range of resources for bibliographic references. In this post, I will focus on arxiv. Out of the box, biblio does not seem to support this use case, but as you will see, it has many of the pieces required to achieve it. Let's start picking those pieces apart.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">biblio</span>)
</pre>
</div>

<pre class="example">
biblio

</pre>

<p>
Here is the first piece we need: a way to run a query, and get results back as a data structure. Here we just look at the first result.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((query <span style="color: #008000;">"alloy segregration"</span>)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (<span style="color: #0000FF;">with-current-buffer</span> cb
                  (funcall backend 'parse-buffer))))
  (car results))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((doi . <span style="color: #008000;">"10.1103/PhysRevB.76.014112"</span>)
 (identifier . <span style="color: #008000;">"0704.2752v2"</span>)
 (year . <span style="color: #008000;">"2007"</span>)
 (title . <span style="color: #008000;">"Modelling Thickness-Dependence of Ferroelectric Thin Film Properties"</span>)
 (authors nil nil nil nil nil nil nil nil nil nil nil nil nil <span style="color: #008000;">"L. Palova"</span> nil <span style="color: #008000;">"P. Chandra"</span> nil <span style="color: #008000;">"K. M. Rabe"</span> nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)
 (container . <span style="color: #008000;">"PRB 76, 014112 (2007)"</span>)
 (category . <span style="color: #008000;">"cond-mat.mtrl-sci"</span>)
 (references <span style="color: #008000;">"10.1103/PhysRevB.76.014112"</span> <span style="color: #008000;">"0704.2752v2"</span>)
 (type . <span style="color: #008000;">"eprint"</span>)
 (url . <span style="color: #008000;">"https://doi.org/10.1103/PhysRevB.76.014112"</span>)
 (direct-url . <span style="color: #008000;">"http://arxiv.org/pdf/0704.2752v2"</span>))
</pre>
</div>

<p>
Next, we need a database to store the results in. I will just use a flat file database with a file for each record. The filename will be the md5 hash of the doi or the record itself. Why is that a good idea? Well, the doi is a constant, so if it exists the md5 will also be a constant. The doi itself is not a good filename in general, but the md5 is. The md5 of the record itself will be fragile to any changes, so if it has a doi, we should use it. If it doesn't and later gets one, we should see it again since that could mean it has been published. Also, if it changes because of some new version we might want to see it again. In any case, the existence of that file will be evidence we have seen that record before, and will indicate we need to remove it from the current view.
</p>

<p>
The flat file database is not super inspired. It is modeled a little after elfeed, but other solutions might work better for large sets of records, but this approach will work fine for this post.
</p>

<p>
Here is a function that returns nil if the record has been seen, and if not, saves the record and returns it.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">db-dir</span> <span style="color: #008000;">"~/.arxiv-db/"</span>)

(<span style="color: #0000FF;">unless</span> (f-dir? db-dir) (make-directory db-dir t))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">unseen-record-p</span> (record)
  <span style="color: #036A07;">"Given a RECORD return it if it is unseen.</span>
<span style="color: #036A07;">Also, save the record so next time it will be marked seen. A</span>
<span style="color: #036A07;">record is seen if we have seen the DOI or the record as a string</span>
<span style="color: #036A07;">before."</span>
  (<span style="color: #0000FF;">let*</span> ((doi (cdr (assoc 'doi record)))
         (contents (<span style="color: #0000FF;">with-temp-buffer</span>
                     (prin1 record (current-buffer))
                     (buffer-string)))
         (hash (md5 (<span style="color: #0000FF;">or</span> doi contents)))
         (fname (expand-file-name hash db-dir)))

    (<span style="color: #0000FF;">if</span> (f-exists? fname)
        nil
      (<span style="color: #0000FF;">with-temp-file</span> fname
        (insert contents))
      record)))
</pre>
</div>

<pre class="example">
unseen-record-p

</pre>

<p>
Now we can use that as a filter that saves records by side effect.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scimax-arxiv</span> (query)
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"Query: "</span>)

  (<span style="color: #0000FF;">let*</span> ((backend 'biblio-arxiv-backend)
         (cb (url-retrieve-synchronously (funcall backend 'url query)))
         (results (-filter 'unseen-record-p (<span style="color: #0000FF;">with-current-buffer</span> cb
                                              (funcall backend 'parse-buffer))))
         (results-buffer (biblio--make-results-buffer (current-buffer) query backend)))
    (<span style="color: #0000FF;">with-current-buffer</span> results-buffer
      (biblio-insert-results results <span style="color: #008000;">""</span>))
    (pop-to-buffer results-buffer)))

(scimax-arxiv <span style="color: #008000;">"alloy segregation"</span>)
</pre>
</div>

<pre class="example">
#&lt;buffer *arXiv search*&gt;

</pre>

<p>
Now, when I run that once I see something like this:
</p>

<p>
<img src="/media/date-11-04-2018-time-20-19-52.png">
</p>


<p>
and if I run it again:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(scimax-arxiv <span style="color: #008000;">"alloy segregation"</span>)
</pre>
</div>

<pre class="example">
#&lt;buffer *arXiv search*&gt;

</pre>

<p>
Then the buffer is empty, since we have seen all the entries before.
</p>


<p>
<img src="/media/date-11-04-2018-time-20-20-37.png">
</p>

<p>
Here are the files in our database:
</p>

<div class="org-src-container">
<pre class="src src-sh">ls ~/.arxiv-db/
</pre>
</div>

<p>
Here are the contents of one of those files:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">with-temp-buffer</span>
 (insert-file-contents <span style="color: #008000;">"~/.arxiv-db/18085fe2512e15d66addc7dfb71f7cd2"</span>)
 (read (buffer-string)))
</pre>
</div>

<pre class="example">
((doi) (identifier . 1101.3464v3) (year . 2011) (title . Characterizing Solute Segregation and Grain Boundary Energy in a Binary
  Alloy Phase Field Crystal Model) (authors nil nil nil nil nil nil nil nil nil nil nil nil nil Jonathan Stolle nil Nikolas Provatas nil nil nil nil nil nil nil nil nil nil nil) (container) (category . cond-mat.mtrl-sci) (references nil 1101.3464v3) (type . eprint) (url . http://arxiv.org/abs/1101.3464v3) (direct-url . http://arxiv.org/pdf/1101.3464v3))

</pre>

<p>
So, if you need to read this in again later, no problem.
</p>

<p>
Now, what could go wrong? I don't know much about how the search results from arxiv are returned. For example, this query returns 10 hits.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((query <span style="color: #008000;">"alloy segregration"</span>)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (<span style="color: #0000FF;">with-current-buffer</span> cb
                  (funcall backend 'parse-buffer))))
  (length results))
</pre>
</div>

<pre class="example">
10

</pre>

<p>
There is just no way there are only 10 hits for this query. So, there must be a bunch more that you get by either changing the requested number in some argument, or by using subsequent queries to get the rest of them. I don't know if there are more advanced query options with biblio, e.g. to find entries newer than the last time it was run. On the advanced search <a href="https://arxiv.org/find">page</a> for arxiv, it looks like there is only a by year option.
</p>

<p>
This is still a good idea, and a lot of the pieces are here,
</p>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results.org">org-mode source</a></p>
<p>Org-mode version = 9.1.6</p>
