---
title: Line integrals in Python with autograd
date: 2018/11/16 08:39:44
updated: 2018/11/16 08:39:44
categories: autograd,python,integration
tags: 
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org107f13d">1. Summary</a></li>
</ul>
</div>
</div>
<p>
A line integral is an integral of a function along a curve in space. We usually represent the curve by a parametric equation, e.g. \(\mathbf{r}(t) = [x(t), y(t), z(t)] = x(t)\mathbf{i} + y(t)\mathbf{j} + z(t)\mathbf{k}\).  So, in general the curve will be a vector function, and the function we want to integrate will also be a vector function.
</p>

<p>
Then, we can write the line integral definition as:
</p>

<p>
\(\int_C \mathbf{F(r)}\cdot d\mathbf{r} = \int_a^b \mathbf{F}({\mathbf{r}(t)) \cdot \mathbf{r'}(t) dt\) where \(\mathbf{r'}(t) = \frac{d\mathbf{r}}{dt}\). This integrand is a scalar function, because of the dot product.
</p>

<p>
The following examples are adapted from Chapter 10 in Advanced Engineering Mathematics by Kreysig.
</p>

<p>
The first example is the evaluation of  a line integral in the plane. We want to evaluate the integral of \(\mathbf{F(r)}=[-y, -xy]\) on the curve \(\mathbf{r(t)}=[-sin(t), cos(t)]\) from t=0 to t = &pi;/2. The answer in the book is given as 0.4521. Here we evaluate this numerically, using autograd for the relevant derivative. Since the curve has multiple outputs, we have to use the jacobian function to get the derivatives. After that, it is a simple bit of matrix multiplication, and a call to the quad function.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> jacobian
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">F</span>(X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -y, -x * y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([-np.sin(t), np.cos(t)])

<span style="color: #BA36A5;">drdt</span> = jacobian(r)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(r(t)) @ drdt(t)

<span style="color: #BA36A5;">I</span>, <span style="color: #BA36A5;">e</span> = quad(integrand, 0.0, np.pi / 2)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The integral is {I:1.4f}.'</span>)
</pre>
</div>

<pre class="example">
The integral is 0.4521.


</pre>

<p>
We get the same result as the analytical solution.
</p>


<p>
The next example is in three dimensions. Find the line integral along \(\mathbf{r}(t)=[cos(t), sin(t), 3t]\) of the function \(\mathbf{F(r)}=[z, x, y]\) from t=0 to t=2 &pi;. The solution is given as 21.99.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> elementwise_grad, grad, jacobian

<span style="color: #0000FF;">def</span> <span style="color: #006699;">F</span>(X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span>, <span style="color: #BA36A5;">z</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [z, x, y]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">C</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([np.cos(t), np.sin(t), 3 * t])

<span style="color: #BA36A5;">dCdt</span> = jacobian(C, 0)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(C(t)) @ dCdt(t)

<span style="color: #BA36A5;">I</span>, <span style="color: #BA36A5;">e</span> = quad(integrand, 0, 2 * np.pi)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The integral is {I:1.2f}.'</span>)
</pre>
</div>

<pre class="example">
The integral is 21.99.


</pre>

<p>
That is also the same as the analytical solution. Note the real analytical solution was 7 &pi;, which is nearly equivalent to our answer.
</p>

<div class="org-src-container">
<pre class="src src-ipython">7 * np.pi - I
</pre>
</div>

<pre class="example">
3.552713678800501e-15

</pre>


<p>
As a final example, we consider an alternate form of the line integral. In this form we do not use a dot product, so the integral results in a vector. This doesn't require anything from autograd, but does require us to be somewhat clever in how to do the integrals since quad can only integrate scalar functions. We need to integrate each component of the integrand independently. Here is one approach where we use lambda functions for each component. You could also manually separate the components.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">F</span>(r):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span>, <span style="color: #BA36A5;">z</span> = r
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x * y, y * z, z

<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([np.cos(t), np.sin(t), 3 * t])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(r(t))

[quad(<span style="color: #0000FF;">lambda</span> t: integrand(t)[i], 0, 2 * np.pi)[0] <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> [0, 1, 2]]
</pre>
</div>

<pre class="example">
[-6.9054847581172525e-18, -18.849555921538755, 59.21762640653615]

</pre>

<p>
The analytical solution in this case was given as:
</p>

<div class="org-src-container">
<pre class="src src-ipython">[0, -6 * np.pi, 6 * np.pi**2]
</pre>
</div>

<pre class="example">
[0, -18.84955592153876, 59.21762640653615]

</pre>

<p>
which is evidently the same as our numerical solution.
</p>

<p>
Maybe an alternative, but more verbose is this vectorized integrate function. We still make temporary functions for integrating, and the vectorization is essentially like the list comprehension above, but we avoid the lambda functions.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #6434A3;">@np.vectorize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrate</span>(i):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(r(t))[i]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">I</span>, <span style="color: #BA36A5;">e</span> = quad(integrand, 0, 2 * np.pi)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> I

integrate([0, 1, 2])
</pre>
</div>

<pre class="example">
array([ -6.90548476e-18,  -1.88495559e+01,   5.92176264e+01])

</pre>

<div id="outline-container-org107f13d" class="outline-2">
<h2 id="org107f13d"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
Once again, autograd provides a convenient way to compute function jacobians which make it easy to evaluate line integrals in Python.</p>
</div>
</div>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/11/16/Line-integrals-in-Python-with-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.1.14</p>