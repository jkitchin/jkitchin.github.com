---
title: Adding new backends to hashcache
date: 2023/09/24 13:14:40
updated: 2023/09/24 13:14:40
categories: programming
tags: 
---


<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org5fd57a7">1. Alternative backends for hashcache</a></li>
<li><a href="#orgac9f2ab">2. a shelve version</a></li>
<li><a href="#org3be8901">3. sqlite version</a></li>
<li><a href="#org32e7950">4. redis</a></li>
<li><a href="#org29b3384">5. Summary</a></li>
</ul>
</div>
</div>
<p>
I have been working on hashcache to make it more flexible. I like the base functionality that uses the filesystem for caching. That still works.
</p>

<p>
Here I set up a timeit decorator to show how this works.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> pycse.hashcache <span style="color: #0000FF;">import</span> hashcache
<span style="color: #0000FF;">import</span> time

!rm -fr ./cache

<span style="color: #0000FF;">def</span> <span style="color: #006699;">timeit</span>(func):
    <span style="color: #0000FF;">def</span> <span style="color: #006699;">wrapper</span>(*args, **kwargs):
        <span style="color: #BA36A5;">t0</span> = time.time()
        <span style="color: #BA36A5;">res</span> = func(*args, **kwargs)
        <span style="color: #006FE0;">print</span>(f<span style="color: #008000;">'Elapsed time = </span>{time.time() - t0}<span style="color: #008000;">s'</span>)
        <span style="color: #0000FF;">return</span> res
    <span style="color: #0000FF;">return</span> wrapper
</pre>
</div>

<p>
Now we decorate a function that is "expensive". The first time we run it, it takes a long time.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #6434A3;">@timeit</span>
<span style="color: #6434A3;">@hashcache</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">expensive_func</span>(x):
    time.sleep(3)
    <span style="color: #0000FF;">return</span> x

expensive_func(2)
</pre>
</div>

<p>
Elapsed time = 3.007030963897705s
2
</p>

<p>
The second time is very fast, since we just look it up.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">expensive_func(2)
</pre>
</div>

<p>
Elapsed time = 0.0012097358703613281s
2
</p>

<p>
Where did we look it up from? It is stored on disk. You can see where by adding a verbose option to the decorator. This shows you all the data that was stored in the cache.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #6434A3;">@hashcache</span>(verbose=<span style="color: #D0372D;">True</span>)
<span style="color: #0000FF;">def</span> <span style="color: #006699;">expensive_func</span>(x):
    time.sleep(3)
    <span style="color: #0000FF;">return</span> x

expensive_func(2)
</pre>
</div>

<p>
{   'args': (2,),
    'cwd': '/Users/jkitchin/Dropbox/emacs/journal/2023/09/23',
    'elapsed_time': 3.0048787593841553,
    'func': 'expensive_func',
    'hash': 'b5436cc21714a7ea619729cc9768b8c5b3a03307',
    'kwargs': {},
    'module': '<span class="underline"><span class="underline">main</span></span>',
    'output': 2,
    'run-at': 1695572717.2020931,
    'run-at-human': 'Sun Sep 24 12:25:17 2023',
    'standardized-kwargs': {'x': 2},
    'user': 'jkitchin',
    'version': '0.0.2'}
2
</p>

<div id="outline-container-org5fd57a7" class="outline-2">
<h2 id="org5fd57a7"><span class="section-number-2">1.</span> Alternative backends for hashcache</h2>
<div class="outline-text-2" id="text-1">
<p>
The file system is an amazing cache with many benefits. There are few reasons you might like something different though. For example, it is slow to search if you have to iterate over all the directories and read the files, and it might be slow to sync lots of directories to another place. 
</p>

<p>
hashcache is more flexible now, so you can define the functions that load and dump the cache. Here we use lmdb as a key-value database. lmdb expects the keys and values to be bytes, so we do some tricks with io.BytesIO to get these as strings from joblib.dump which expects to write to a file.
</p>

<p>
The load function has the signature (<code>hash</code>, <code>verbose</code>), and the dump function has the signature (<code>hash</code>, <code>data</code>, <code>verbose</code>). In both cases, <code>hash</code> will be a string for the key to save data in. <code>data</code> will be a dictionary that should be saved in a way that it can be reloaded. <code>verbose</code> is a flag that you can ignore or use to provide some kind of logging.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> pycse.hashcache <span style="color: #0000FF;">import</span> hashcache

<span style="color: #0000FF;">import</span> io, joblib, lmdb

<span style="color: #0000FF;">def</span> <span style="color: #006699;">lmdb_dump</span>(hsh, data, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #0000FF;">if</span> verbose:
        <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running lmdb_dump'</span>)
    <span style="color: #0000FF;">with</span> io.BytesIO() <span style="color: #0000FF;">as</span> f:
        joblib.dump(data, f)
        value = f.getvalue()

    db = lmdb.Environment(hashcache.cache)
    <span style="color: #0000FF;">with</span> db.begin(write=<span style="color: #D0372D;">True</span>) <span style="color: #0000FF;">as</span> txn:
        txn.put(hsh.encode(<span style="color: #008000;">'utf-8'</span>), value)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">lmdb_load</span>(hsh, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #0000FF;">if</span> verbose:
        <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running lmdb_load'</span>)
    db = lmdb.Environment(hashcache.cache)
    <span style="color: #0000FF;">with</span> db.begin() <span style="color: #0000FF;">as</span> txn:
        val = txn.get(hsh.encode(<span style="color: #008000;">'utf-8'</span>))
        <span style="color: #0000FF;">if</span> val <span style="color: #0000FF;">is</span> <span style="color: #D0372D;">None</span>:
            <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>, <span style="color: #D0372D;">None</span>
        <span style="color: #0000FF;">else</span>:
            <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>, joblib.load(io.BytesIO(val))[<span style="color: #008000;">'output'</span>]
                                    
! rm -fr cache.lmdb

hashcache.cache = <span style="color: #008000;">'cache.lmdb'</span>


<span style="color: #6434A3;">@hashcache</span>(loader=lmdb_load, dumper=lmdb_dump, verbose=<span style="color: #D0372D;">True</span>)
<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
    <span style="color: #0000FF;">return</span> x

f(2)   
</pre>
</div>

<p>
running lmdb_load
running lmdb_dump
2
</p>

<p>
And we can recall the result as easily.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">f(2)
</pre>
</div>

<p>
running lmdb_load
2
</p>
</div>
</div>

<div id="outline-container-orgac9f2ab" class="outline-2">
<h2 id="orgac9f2ab"><span class="section-number-2">2.</span> a shelve version</h2>
<div class="outline-text-2" id="text-2">
<p>
Maybe you prefer a built in library like shelve. This is also quite simple.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> pycse.hashcache <span style="color: #0000FF;">import</span> hashcache

<span style="color: #0000FF;">import</span> io, joblib, shelve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">shlv_dump</span>(hsh, data, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running shlv_dump'</span>)
    <span style="color: #0000FF;">with</span> io.BytesIO() <span style="color: #0000FF;">as</span> f:
        joblib.dump(data, f)
        value = f.getvalue()

    <span style="color: #0000FF;">with</span> shelve.<span style="color: #006FE0;">open</span>(hashcache.cache) <span style="color: #0000FF;">as</span> db:
        db[<span style="color: #BA36A5;">hsh</span>] = value

<span style="color: #0000FF;">def</span> <span style="color: #006699;">shlv_load</span>(hsh, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running shlv_load'</span>)
    <span style="color: #0000FF;">with</span> shelve.<span style="color: #006FE0;">open</span>(hashcache.cache) <span style="color: #0000FF;">as</span> db:
        <span style="color: #0000FF;">if</span> hsh <span style="color: #0000FF;">in</span> db:
            <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>, joblib.load(io.BytesIO(db[hsh]))[<span style="color: #008000;">'output'</span>]
        <span style="color: #0000FF;">else</span>:
            <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>, <span style="color: #D0372D;">None</span>

hashcache.cache = <span style="color: #008000;">'cache.shlv'</span>
! rm -f cache.shlv.db

<span style="color: #6434A3;">@hashcache</span>(loader=shlv_load, dumper=shlv_dump)
<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
    <span style="color: #0000FF;">return</span> x

f(2)
    
</pre>
</div>

<p>
running shlv_load
running shlv_dump
2
</p>

<p>
And again loading is easy.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">f(2)
</pre>
</div>

<p>
running shlv_load
2
</p>
</div>
</div>

<div id="outline-container-org3be8901" class="outline-2">
<h2 id="org3be8901"><span class="section-number-2">3.</span> sqlite version</h2>
<div class="outline-text-2" id="text-3">
<p>
I am a big fan of sqlite. Here I use a simple table mapping a key to a value. I think it could be interesting to consider storing the value as <a href="https://www.sqlite.org/json1.html">json</a> that would make it more searchable, or you could make a more complex table, but here we keep it simple.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> pycse.hashcache <span style="color: #0000FF;">import</span> hashcache

<span style="color: #0000FF;">import</span> io, joblib, sqlite3

<span style="color: #0000FF;">def</span> <span style="color: #006699;">sql_dump</span>(hsh, data, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running sql_dump'</span>)
    <span style="color: #0000FF;">with</span> io.BytesIO() <span style="color: #0000FF;">as</span> f:
        joblib.dump(data, f)
        value = f.getvalue()

    <span style="color: #0000FF;">with</span> con:
        con.execute(<span style="color: #008000;">"INSERT INTO cache(hash, value) VALUES(?, ?)"</span>,
                    (hsh, value))

<span style="color: #0000FF;">def</span> <span style="color: #006699;">sql_load</span>(hsh, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running sql_load'</span>)
    <span style="color: #0000FF;">with</span> con:        
        cur = con.execute(<span style="color: #008000;">"SELECT value FROM cache WHERE hash = ?"</span>,
                          (hsh,))
        value = cur.fetchone()
        <span style="color: #0000FF;">if</span> value <span style="color: #0000FF;">is</span> <span style="color: #D0372D;">None</span>:
            <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>, <span style="color: #D0372D;">None</span>
        <span style="color: #0000FF;">else</span>:
            <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>, joblib.load(io.BytesIO(value[0]))[<span style="color: #008000;">'output'</span>]

! rm -f cache.sql
hashcache.cache = <span style="color: #008000;">'cache.sql'</span>
con = sqlite3.connect(hashcache.cache)
con.execute(<span style="color: #008000;">"CREATE TABLE cache(hash TEXT unique, value BLOB)"</span>)
        
<span style="color: #6434A3;">@hashcache</span>(loader=sql_load, dumper=sql_dump)
<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
    <span style="color: #0000FF;">return</span> x

f(2)    
</pre>
</div>

<p>
running sql_load
running sql_dump
2
</p>

<p>
Once again, running is easy.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">f(2)
</pre>
</div>

<p>
running sql_load
2
</p>
</div>
</div>

<div id="outline-container-org32e7950" class="outline-2">
<h2 id="org32e7950"><span class="section-number-2">4.</span> redis</h2>
<div class="outline-text-2" id="text-4">
<p>
Finally, you might like a server to cache in. This opens the door to running the server remotely so it is accessible by multiple processes using the cache on different machines. We use redis for this example, but only run it locally. Make sure you run <code>redis-server --daemonize yes</code>
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> pycse.hashcache <span style="color: #0000FF;">import</span> hashcache

<span style="color: #0000FF;">import</span> io, joblib, redis

<span style="color: #BA36A5;">db</span> = redis.Redis(host=<span style="color: #008000;">'localhost'</span>, port=6379)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">redis_dump</span>(hsh, data, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running redis_dump'</span>)
    <span style="color: #0000FF;">with</span> io.BytesIO() <span style="color: #0000FF;">as</span> f:
        joblib.dump(data, f)
        value = f.getvalue()

    db.<span style="color: #006FE0;">set</span>(hsh, value)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">redis_load</span>(hsh, verbose=<span style="color: #D0372D;">False</span>):
    <span style="color: #006FE0;">print</span>(<span style="color: #008000;">'running redis_load'</span>)
    <span style="color: #0000FF;">if</span> <span style="color: #0000FF;">not</span> hsh <span style="color: #0000FF;">in</span> db:
        <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">False</span>, <span style="color: #D0372D;">None</span>
    <span style="color: #0000FF;">else</span>:
        <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">True</span>, joblib.load(io.BytesIO(db.get(hsh)))[<span style="color: #008000;">'output'</span>]

    
<span style="color: #0000FF;">import</span> functools    
hashcache_redis = functools.partial(hashcache,
                                    loader=redis_load,
                                    dumper=redis_dump)    

<span style="color: #6434A3;">@hashcache_redis</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
    <span style="color: #0000FF;">return</span> x

f(2)    
</pre>
</div>

<p>
running redis_load
running redis_dump
2
</p>

<p>
No surprise here, loading is the same as before.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python">f(2)
</pre>
</div>

<p>
running redis_load
2
</p>
</div>
</div>

<div id="outline-container-org29b3384" class="outline-2">
<h2 id="org29b3384"><span class="section-number-2">5.</span> Summary</h2>
<div class="outline-text-2" id="text-5">
<p>
I have refactored hashcache to make it much easier to add new backends. You might do that for performance, ease of backup or transferability, to add new capabilities for searching, etc. The new code is a little cleaner than it was before IMO. I am not sure it is API-stable yet, but it is getting there.
</p>
</div>
</div>
<p>Copyright (C) 2023 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2023/09/24/Adding-new-backends-to-hashcache.org">org-mode source</a></p>
<p>Org-mode version = 9.7-pre</p>