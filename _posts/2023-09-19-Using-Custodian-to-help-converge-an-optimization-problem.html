---
title: Using Custodian to help converge an optimization problem
date: 2023/09/19 15:34:21
updated: 2023/09/19 15:35:08
categories: optimization,programming
tags: 
---


<p>
In high-throughput calculations, some fraction of them usually fail for some reason. Sometimes it is easy to fix these calculations and re-run them successfully, for example, you might just need a different initialization, or to increase memory or the number of allowed steps, etc.  <a href="http://materialsproject.github.io/custodian/">custodian</a> is a tool that is designed for this purpose. 
</p>

<p>
The idea is we make a function to do what we want that has arguments that control that. We need a function that can examine the output of the function and determine if it succeeded, and if it didn't succeed to say what new arguments to try next. Then we run the function in custodian and let it take care of rerunning with new arguments until it either succeeds, or tries too many times.
</p>

<p>
The goal here is to use <a href="http://materialsproject.github.io/custodian/">custodian</a> to fix a problem optimization. The example is a little contrived, we set a number of iterations artificially low so that the minimization fails by reaching the maximum number of iterations. Custodian will catch this, and increase the number of iterations until it succeeds. Here is the objective function:
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(x):
    <span style="color: #0000FF;">return</span> np.exp(x**2) - 10*np.exp(x)

<span style="color: #BA36A5;">x</span> = np.linspace(0, 2)
plt.plot(x, objective(x))
plt.xlabel(<span style="color: #008000;">'x'</span>)
plt.ylabel(<span style="color: #008000;">'y'</span>);
</pre>
</div>

<p>
<figure><img src="/media/354616de80c1f529dd249d03f96e5bc023bbd321.png"></figure> 
</p>

<p>
Clearly there is a minimum near 1.75, but with a bad initial guess, and not enough iterations, an optimizer fails here. We can tell it fails from the message here, and the solution is run it again with more iterations.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> minimize

minimize(objective, 0.0, options={<span style="color: #008000;">'maxiter'</span>: 2})
</pre>
</div>

<pre class="example" id="org27fcdb3">
:RESULTS:
  message: Maximum number of iterations has been exceeded.
  success: False
   status: 1
      fun: -36.86289091418059
        x: [ 1.661e+00]
      nit: 2
      jac: [-2.374e-01]
 hess_inv: [[ 6.889e-03]]
     nfev: 20
     njev: 10
:END:
</pre>

<p>
With Custodian you define a "Job". This is a class with  <code>params</code> that contain the adjustable arguments in a dictionary, and a <code>run</code> method that stores the results in the params attribute. This is an important step, because the error handlers only get the params, so you need the results in there to inspect them.
</p>

<p>
The error handlers are another class with a <code>check</code> method that returns True if you should rerun, and a <code>correct</code> method that sets the params to new values to try next. It seems to return some information about what happened. In the <code>correct</code> method, we double the maximum number of iterations allowed, and use the last solution point that failed as the initial guess for the next run.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #0000FF;">from</span> custodian.custodian <span style="color: #0000FF;">import</span> Custodian, Job, ErrorHandler

<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Minimizer</span>(Job):
    <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, params=<span style="color: #D0372D;">None</span>):
        <span style="color: #0000FF;">self</span>.params = params <span style="color: #0000FF;">if</span> params <span style="color: #0000FF;">else</span> {<span style="color: #008000;">'maxiter'</span>: 2, <span style="color: #008000;">'x0'</span>: 0}
        
    <span style="color: #0000FF;">def</span> <span style="color: #006699;">run</span>(<span style="color: #0000FF;">self</span>):
        sol = minimize(objective,
                       <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'x0'</span>],
                       options={<span style="color: #008000;">'maxiter'</span>: <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'maxiter'</span>]})
        <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'sol'</span>] = sol

<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">MaximumIterationsExceeded</span>(ErrorHandler):
    <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, params):
        <span style="color: #0000FF;">self</span>.params = params

    <span style="color: #0000FF;">def</span> <span style="color: #006699;">check</span>(<span style="color: #0000FF;">self</span>):
        <span style="color: #0000FF;">return</span> <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'sol'</span>].message == <span style="color: #008000;">'Maximum number of iterations has been exceeded.'</span>

    <span style="color: #0000FF;">def</span> <span style="color: #006699;">correct</span>(<span style="color: #0000FF;">self</span>):
        <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'maxiter'</span>] *= 2
        <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'x0'</span>] = <span style="color: #0000FF;">self</span>.params[<span style="color: #008000;">'sol'</span>].x        
        <span style="color: #0000FF;">return</span> {<span style="color: #008000;">'errors'</span>: <span style="color: #008000;">'MaximumIterations Exceeded'</span>,
                <span style="color: #008000;">'actions'</span>: <span style="color: #008000;">'maxiter = {self.params["maxiter"]}, x0 = {self.params["x0"]}'</span>}
</pre>
</div>

<p>
Now we setup the initial params to try, create a Custodian object with the handler and job, and then run it. The results and final params are stored in the params object.
</p>

<div class="org-src-container">
<pre class="src src-jupyter-python"><span style="color: #BA36A5;">params</span> = {<span style="color: #008000;">'maxiter'</span>: 1, <span style="color: #008000;">'x0'</span>: 0}

<span style="color: #BA36A5;">c</span> = Custodian([MaximumIterationsExceeded(params)],
              [Minimizer(params)],
               max_errors=5)

c.run()
<span style="color: #0000FF;">for</span> key <span style="color: #0000FF;">in</span> params:
    <span style="color: #006FE0;">print</span>(key, params[key])
</pre>
</div>

<pre class="example" id="orgca61279">
MaximumIterationsExceeded
MaximumIterationsExceeded
maxiter 4
x0 [1.66250127]
sol   message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -36.86307468296398
        x: [ 1.662e+00]
      nit: 1
      jac: [-9.060e-06]
 hess_inv: [[1]]
     nfev: 6
     njev: 3
</pre>



<p>
Note that params is modified, and finally has the maxiter value that worked, and the solution in it. You can see we had to rerun this problem  twice before it succeeded, but this happened automatically after the setup. This example is easy because we can simply increase the maxiter value, and no serious logic is needed. Other use cases might include try it again with another solver, try again with a different initial guess, etc. 
</p>

<p>
It feels a little heavyweight to define the classes, and to store the results in params here, but this was overall under an hour of work to put it all together, starting from scratch with the <a href="http://materialsproject.github.io/custodian/">Custodian documentation</a> from the example on the front page. You can do more sophisticated things, including having multiple error handlers. Overall, for a package designed for molecular simulations, this worked well for a different kind of problem.
</p>
<p>Copyright (C) 2023 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2023/09/19/Using-Custodian-to-help-converge-an-optimization-problem.org">org-mode source</a></p>
<p>Org-mode version = 9.7-pre</p>