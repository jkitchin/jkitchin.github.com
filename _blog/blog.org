* DONE A sexp version of a bibtex entry
  CLOSED: [2015-06-10 Wed 08:54]
  :PROPERTIES:
  :categories: bibtex,lisp
  :date:     2015/06/10 08:54:00
  :updated:  2015/06/10 08:54:00
  :END:

Below you see a typical bibtex entry. Today we explore an alternate approach to represent the information (data) in that entry as s-expressions, i.e. as a lisp data structure. Why? because it seems like an interesting exploration!

#+BEGIN_SRC bibtex
@article{hallenbeck-2013-effec-o2,
  author =	 "Hallenbeck, Alexander P. and Kitchin, John R.",
  title =	 {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a
                  primary-amine based polymeric \ce{CO_2} sorbent},
  keywords =	 {RUA, orgmode},
  journal =	 "Industrial \& Engineering Chemistry Research",
  pages =	 "10788-10794",
  year =	 2013,
  volume =	 {52},
  number =	 {31},
  doi =		 "10.1021/ie400582a",
  url =		 "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
  eprint =	 "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
#+END_SRC

Here is what that same data structure might look like as a sexp-based lisp data structure.
#+BEGIN_SRC emacs-lisp
(article "hallenbeck-2013-effec-o2"
	 (author "Hallenbeck, Alexander P. and Kitchin, John R.")
	 (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
	 (journal "Industrial \& Engineering Chemistry Research")
	 (pages "10788-10794")
         (year 2013)
	 (number 31)
	 (doi "10.1021/ie400582a")
	 (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
	 (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))
#+END_SRC

We can retrieve data from the sexp form pretty easily. Here we get the authors.
#+BEGIN_SRC emacs-lisp
(let* ((art '(article "hallenbeck-2013-effec-o2"
		      (author "Hallenbeck, Alexander P. and Kitchin, John R.")
		      (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		      (journal "Industrial \& Engineering Chemistry Research")
		      (pages "10788-10794")
		      (year 2013)
		      (number 31)
		      (doi "10.1021/ie400582a")
		      (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		      (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a")))
       (fields (cddr art)))
  (cadr (assoc 'author fields)))
#+END_SRC

#+RESULTS:
: Hallenbeck, Alexander P. and Kitchin, John R.

That is simple enough you might just write a little function to streamline it like this, and return a formatted string.

#+BEGIN_SRC emacs-lisp
(defun get-article-field (article field)
  "Return value of FIELD in ARTICLE."
  (cadr (assoc field (cddr article))))

(let ((art '(article "hallenbeck-2013-effec-o2"
		     (author "Hallenbeck, Alexander P. and Kitchin, John R.")
		     (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		     (journal "Industrial \& Engineering Chemistry Research")
		     (pages "10788-10794")
		     (year 2013)
		     (number 31)
		     (doi "10.1021/ie400582a")
		     (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		     (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
  (format "%s, doi:%s (%s)"
	  (get-article-field art 'author)
	  (get-article-field art 'doi)
	  (get-article-field art 'year)))

#+END_SRC

#+RESULTS:
: Hallenbeck, Alexander P. and Kitchin, John R., doi:10.1021/ie400582a (2013)

You might be wondering, why is that even a little bit interesting? One reason is that it looks a little like what lisp returns after parsing an xml file. Another is, the data structure looks kind of like data, but it is also some code, if article was defined as a function!  Let us consider what this might look like. I use a macro to define the field functions since in this case they all do the same thing, and these simply return a string with the field-name and value in curly brackets. We eval the macro to make sure it defines the function. I define an article function that wraps the fields in @bibtex-key{fields}, which defines a bibtex entry.

#+BEGIN_SRC emacs-lisp
(defmacro make-field (field-name)
  "define a field that returns a string"
  `(defun ,(intern field-name) (content)
     (format "  %s = {%s}" ,field-name content)))

(loop for field in '("author" "title" "journal" "pages" "number" "doi" "url" "eprint" "year")
  do (eval `(make-field ,field)))

(defun article (bibtex-key &rest fields)
  (concat
   (format "@article{%s,\n" bibtex-key)
   (mapconcat (lambda (field) (eval field)) fields ",\n")
   "\n}\n"))

(article "hallenbeck-2013-effec-o2"
	 (author "Hallenbeck, Alexander P. and Kitchin, John R.")
	 (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
	 (journal "Industrial \& Engineering Chemistry Research")
	 (pages "10788-10794")
	 (number 31)
         (year 2013)
	 (doi "10.1021/ie400582a")
	 (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
	 (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))
#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2,
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent},
  journal = {Industrial & Engineering Chemistry Research},
  pages = {10788-10794},
  number = {31},
  year = {2013},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a}
}
#+end_example

Wow. We /executed/ our data structure, and got a bibtex entry! That seems moderately interesting to me. Next is an example of taking the same data structure and rendering it as xml. This is some lispy wizardry, rather than use a macro to define functions, I temporarily define functions within a cl-flet macro, which I have to collect as a list of code. Then, I eval the list. This feels pretty odd, but seems like a lispy kind of thing to do.

#+BEGIN_SRC emacs-lisp
(eval
 (list 'cl-flet
       (append (loop for field in '("author" "title" "journal" "pages"
				      "number" "doi" "url" "eprint" "year")
		       collect (list (intern field)
				     '(content)
				     `(format "  <%s>%s</%s>" ,field content ,field)))
	       '((article (bibtex-key &rest fields)
			  (concat
			   (format
			    "<article bibtex-key=\"%s\">\n" bibtex-key)
			   (mapconcat (lambda (field) (eval field)) fields "\n")
			   "\n</article>")))
	       )
       ;; body of cl-flet
       '(article "hallenbeck-2013-effec-o2"
		(author "Hallenbeck, Alexander P. and Kitchin, John R.")
		(title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		(journal "Industrial \& Engineering Chemistry Research")
		(pages "10788-10794")
		(number 31)
		(year 2013)
		(doi "10.1021/ie400582a")
		(url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		(eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
#+END_SRC

#+RESULTS:
#+begin_example
<article bibtex-key="hallenbeck-2013-effec-o2">
  <author>Hallenbeck, Alexander P. and Kitchin, John R.</author>
  <title>Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent</title>
  <journal>Industrial & Engineering Chemistry Research</journal>
  <pages>10788-10794</pages>
  <number>31</number>
  <year>2013</year>
  <doi>10.1021/ie400582a</doi>
  <url>http://pubs.acs.org/doi/abs/10.1021/ie400582a</url>
  <eprint>http://pubs.acs.org/doi/pdf/10.1021/ie400582a</eprint>
</article>
#+end_example

Prefer json? No problem, just reformat the functions!

#+BEGIN_SRC emacs-lisp
(eval
 (list 'cl-flet
       (append (loop for field in '("author" "title" "journal" "pages"
				      "number" "doi" "url" "eprint" "year")
		       collect (list (intern field)
				     '(content)
				     `(format "   \"%s\": \"%s\"" ,field content)))
	       '((article (bibtex-key &rest fields)
			  (concat
			   (format
			    "{\"article\":\n  {\"bibtex-key\": \"%s\",\n" bibtex-key)
			   (mapconcat (lambda (field) (eval field)) fields ",\n")
			   "}\n}"))))
       ;; body of cl-flet
       '(article "hallenbeck-2013-effec-o2"
		(author "Hallenbeck, Alexander P. and Kitchin, John R.")
		(title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		(journal "Industrial \& Engineering Chemistry Research")
		(pages "10788-10794")
		(number 31)
		(year 2013)
		(doi "10.1021/ie400582a")
		(url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		(eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
#+END_SRC

#+RESULTS:
#+begin_example
{"article":
  {"bibtex-key": "hallenbeck-2013-effec-o2",
   "author": "Hallenbeck, Alexander P. and Kitchin, John R.",
   "title": "Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent",
   "journal": "Industrial & Engineering Chemistry Research",
   "pages": "10788-10794",
   "number": "31",
   "year": "2013",
   "doi": "10.1021/ie400582a",
   "url": "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
   "eprint": "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"}
}
#+end_example

Is this useful? Great question. I don't plan to convert by bibtex files to sexp format anytime soon ;) The format I used above is just a simple one. It might be desirable to include individual authors instead of an author string, and maybe support attributes to establish an author order. An author structure might be more complex to include scientific ids like an orcid, alternative names, etc... Finally, the s-exp data structure is super easy to use in lisp, but other languages would have parse it into some native structure the way they parse json or xml. There is limited support for s-expressions in most other non-lispy languages.

I like the idea of data representation as code, and its conversion to some other kind of format. It is subtle here, but notice we /never/ had to write a parser for the sexp notation. That /already exists as the lisp interpreter/. We did write code to use the data, and convert the data. The sexp notation is pretty easy to write, in contrast to the xml or json representations. Some interesting issues might be what to do with fields that are not defined, perhaps a macro would be used on the fly, or in the cl-flet definition. It is hard to imagine doing these things in another language than lisp!

* DONE Converting a DOI to other scientific identifiers in Pubmed
  CLOSED: [2015-06-09 Tue 07:29]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/09 07:29:08
  :updated:  2015/06/09 07:29:08
  :END:

Sometimes it is useful to convert a DOI to another type of identifier. For example, in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/][post]] we converted a DOI to a Scopus EID, and in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/][one]] we got the WOS accession number from a DOI. Today, we consider how to get Pubmed identifiers. Pubmed provides an API for this purpose:

http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/

We will use the DOI tool. According to the documentation, we need to form a URL like this:

DOI: http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195

We will call our tool "org-ref" and use the value of user-mail-address. The URL above returns XML, so we can parse it, and then extract the identifiers. This is a simple http GET request, which we can construct using url-retrieve-synchronously. Here is what we get.

#+BEGIN_SRC emacs-lisp :results value code
(let* ((url-request-method "GET")
       (doi"10.1093/nar/gks1195")
       (my-tool "org-ref")
       (url (format "http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&email=%s&ids=%s"
                    my-tool
                    user-mail-address
                    doi))
       (xml (with-current-buffer  (url-retrieve-synchronously url)
		(xml-parse-region url-http-end-of-headers (point-max)))))
xml)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((pmcids
  ((status . "ok"))
  "\n"
  (request
   ((idtype . "doi")
    (dois . "")
    (versions . "yes")
    (showaiid . "no"))
   "\n"
   (echo nil "tool=org-ref;email=jkitchin%40andrew.cmu.edu;ids=10.1093%2Fnar%2Fgks1195")
   "\n")
  "\n"
  (record
   ((requested-id . "10.1093/NAR/GKS1195")
    (pmcid . "PMC3531190")
    (pmid . "23193287")
    (doi . "10.1093/nar/gks1195"))
   (versions nil
	     (version
	      ((pmcid . "PMC3531190.1")
	       (current . "true")))))
  "\n"))
#+END_SRC

The parsed xml is now just an emacs-lisp data structure. We need to get the record, and then get the attributes of it to extract the identifiers. Next, we create a plist of the identifiers. For fun, we add the Scopus EID and WOS accession number from the previous posts too.

#+BEGIN_SRC emacs-lisp :results value code
(let* ((url-request-method "GET")
       (doi"10.1093/nar/gks1195")
       (my-tool "org-ref")
       (url (format "http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&email=%s&ids=%s"
                    my-tool
                    user-mail-address
                    doi))
       (xml (car (with-current-buffer  (url-retrieve-synchronously url)
		   (xml-parse-region url-http-end-of-headers (point-max)))))
       (record (first  (xml-get-children xml 'record)))
       (doi (xml-get-attribute record 'doi))
       (pmcid (xml-get-attribute record 'pmcid))
       (pmid (xml-get-attribute record 'pmid)))
  (list :doi doi :pmid pmid :pmcid pmcid :eid (scopus-doi-to-eid doi) :wos (wos-doi-to-accession-number doi)))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(:doi "10.1093/nar/gks1195" :pmid "23193287" :pmcid "PMC3531190" :eid "2-s2.0-80053651587" :wos "000312893300006")
#+END_SRC

Well, there you have it, four new scientific document ids from one DOI. /Of course/ we have defined org-mode links for each one of these:

doi:10.1093/nar/gks1195

pmid:23193287

pmcid:PMC3531190

eid:2-s2.0-80053651587

wos:000312893300006

I have not tested this on too many DOIs yet. Not all of them are indexed by Pubmed.

* DONE Getting a WOS Accession number from a DOI
  CLOSED: [2015-06-08 Mon 11:23]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/08 11:23:33
  :updated:  2015/06/09 07:25:39
  :END:
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/][post]] we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j is redirected to
http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44. You can see the wos:000225079300029 in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.

#+BEGIN_SRC emacs-lisp
(cdr (assoc "KeyUT" (url-parse-query-string (url-filename (url-generic-parse-url  "http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44")))))
#+END_SRC

#+RESULTS:
| WOS:000225079300029 |

It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).

#+BEGIN_SRC emacs-lisp
(defvar *wos-redirect* nil)
(defvar *wos-waiting* nil)

(defun wos-get-wos-redirect (url)
  "Return final redirect url for open-url"
  (setq *wos-waiting* t)
  (url-retrieve
   url
   (lambda (status)
     (setq *wos-redirect* (car (last status)))
     (setq *wos-waiting* nil)))
  (while *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(defun wos-doi-to-accession-number (doi)
  "Return a WOS Accession number for a DOI."
  (let* ((open-url (concat "http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/" doi))
	 (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
		 (assoc
		  "KeyUT"
		  (url-parse-query-string
		   (url-filename
		    (url-generic-parse-url redirect)))))
    4)))

(concat "wos:" (wos-doi-to-accession-number "10.1021/jp047349j"))
#+END_SRC

#+RESULTS:
: wos:000225079300029

I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:

http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029

http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029

That might turn out to be handy at some point.

* DONE Getting a Scopus EID from a DOI
  CLOSED: [2015-06-07 Sun 16:29]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/07 16:29:05
  :updated:  2015/06/07 16:54:38
  :END:
[[http://www.scopus.com][Scopus]] is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: http://dev.elsevier.com/myapikey.html and set *scopus-api-key* in Emacs to use this code.

Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:

Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial & Engineering Chemistry Research, 52:10788-10794 (2013)

With the EID, we can construct a URL to the Scopus document page:
#+BEGIN_SRC emacs-lisp
(let ((eid "2-s2.0-84881394200"))
  (format "http://www.scopus.com/record/display.url?eid=%s&origin=resultslist" eid))
#+END_SRC

#+RESULTS:
: http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist

We can construct a URL to citing documents:
#+BEGIN_SRC emacs-lisp
(let ((eid "2-s2.0-84881394200"))
  (format "http://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=%s&src=s&imp=t&sot=cite&sdt=a&sl=0&origin=recordpage" eid))
#+END_SRC

#+RESULTS:
: http://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=2-s2.0-84881394200&src=s&imp=t&sot=cite&sdt=a&sl=0&origin=recordpage

And there are three types of related document urls we can create: by author, keyword or references.

By authors:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat "http://www.scopus.com/search/submit/mlt.url"
                  "?eid=%s&src=s&all=true&origin=recordpage"
                  "&method=aut&zone=relatedDocuments")
            eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments

By keywords:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat "http://www.scopus.com/search/submit/mlt.url"
                  "?eid=%s&src=s&all=true&origin=recordpage"
                  "&method=key&zone=relatedDocuments")
          eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments

And by references:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat  "http://www.scopus.com/search/submit/mlt.url?"
                   "eid=%s&src=s&all=true&origin=recordpage"
                   "&method=ref&zone=relatedDocuments")
           eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments

We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, /not/ the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is doi:10.1021/ie400582a.

The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.

I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.

#+BEGIN_SRC emacs-lisp
(let* ((doi "10.1021/ie400582a")
       (url-request-method "GET")
       (url-mime-accept-string "application/json")
       (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					 '("field" . "eid")))
       (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
       (json-object-type 'plist)
       (json-data (with-current-buffer  (url-retrieve-synchronously url)
		    (json-read-from-string
		     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data :search-results) :entry) 0) :eid))
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.

#+BEGIN_SRC emacs-lisp
(defun scopus-doi-to-eid-json (doi)
  "Return a parsed xml from the Scopus article retrieval api for DOI.
This does not always seem to work for the most recent DOIs."
  (let* ((url-request-method "GET")
	 (url-mime-accept-string "application/json")
	 (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					   '("field" . "eid")))
	 (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
	 (json-object-type 'plist)
	 (json-data (with-current-buffer  (url-retrieve-synchronously url)
		      (json-read-from-string
		       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data :search-results) :entry) 0) :eid)))

(scopus-doi-to-eid "10.1021/ie400582a")
#+END_SRC

XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.

#+BEGIN_SRC emacs-lisp
(let* ((doi "10.1021/ie400582a")
       (url-request-method "GET")
       (url-mime-accept-string "application/xml")
       (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					 '("field" . "eid")))
       (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
       (xml (with-current-buffer  (url-retrieve-synchronously url)
	      (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

Now we wrap this in a function for reusability.
#+BEGIN_SRC emacs-lisp
(defun scopus-doi-to-eid (doi)
  "Get a Scopus eid from a DOI."
  (let* ((url-request-method "GET")
	 (url-mime-accept-string "application/xml")
	 (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					   '("field" . "eid")))
	 (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
	 (xml (with-current-buffer  (url-retrieve-synchronously url)
		(xml-parse-region url-http-end-of-headers (point-max))))
	 (results (car xml))
	 (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid "10.1021/ie400582a")
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

This code is wrapped up in [[https://github.com/jkitchin/org-ref/blob/master/scopus.el][org-ref/scopus.el]]. It provides a new org-mode eid link, e.g. eid:2-s2.0-84881394200 which is functional and provides access to the citing and related article Scopus pages for that eid.

There are also new links and functions for a [[scopus-search:alloy Au segregation]] and [[scopus-advanced-search:auth(kitchin) and title(segregation)]].

Let's not forget the scopusid:7004212771 link to Scopus Author pages.

Now you can use org-mode for reproducible scientific literature searching in Scopus!

* Is an external http(s) link valid?


#+BEGIN_SRC emacs-lisp
(condition-case err
  (url-http-file-exists-p "http://bad.url")
 (error nil))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(condition-case err
  (url-http-file-exists-p "http://kitchingroup.cheme.cmu.edu")
 (error nil))
#+END_SRC

#+RESULTS:
: t

* document similarity
[[http://brandonrose.org/clustering][Document Clustering with Python]]

#+BEGIN_SRC python
import numpy as np
import pandas as pd
import nltk
import re
import os
import codecs
from sklearn import feature_extraction
import mpld3

stopwords = nltk.corpus.stopwords.words('english')
print stopwords[:10]

# load nltk's SnowballStemmer as variabled 'stemmer'
from nltk.stem.snowball import SnowballStemmer
stemmer = SnowballStemmer("english")

# here I define a tokenizer and stemmer which returns the set of stems in the text that it is passed

def tokenize_and_stem(text):
    # first tokenize by sentence, then by word to ensure that punctuation is caught as it's own token
    tokens = [word for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)]
    filtered_tokens = []
    # filter out any tokens not containing letters (e.g., numeric tokens, raw punctuation)
    for token in tokens:
        if re.search('[a-zA-Z]', token):
            filtered_tokens.append(token)
    stems = [stemmer.stem(t) for t in filtered_tokens]
    return stems


def tokenize_only(text):
    # first tokenize by sentence, then by word to ensure that punctuation is caught as it's own token
    tokens = [word.lower() for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)]
    filtered_tokens = []
    # filter out any tokens not containing letters (e.g., numeric tokens, raw punctuation)
    for token in tokens:
        if re.search('[a-zA-Z]', token):
            filtered_tokens.append(token)
    return filtered_tokens
#+END_SRC

#+RESULTS:
: [u'i', u'me', u'my', u'myself', u'we', u'our', u'ours', u'ourselves', u'you', u'your']

#+BEGIN_SRC python
from sklearn.externals import joblib
#+END_SRC

#+RESULTS:

* An experiment in navigation with a  hydra

#+BEGIN_SRC emacs-lisp
(defhydra nav (:color red)
  "navigation"
  ("f" forward-char "forward char")
  ("j" backward-char "backward char")
  ("d" forward-word  "forward word")
  ("k" backward-word "backward word")
  ("l" previous-line "previous line")
  ("s" forward-line "next line")
  (";" scroll-up  "scroll up")
  ("a" scroll-down "scroll down"))

#+END_SRC

#+RESULTS:
: nav/body



#+BEGIN_SRC emacs-lisp
(defhydra hydra-goto-line (goto-map ""
                           :pre (linum-mode 1)
                           :post (linum-mode -1))
  "goto-line"
  ("g" goto-line "go")
  ("m" set-mark-command "mark" :bind nil)
  ("q" nil "quit"))
#+END_SRC

#+RESULTS:
: hydra-goto-line/body

* enumerate and zip in emacs lisp using the loop
here are hand-rolled functions.

#+BEGIN_SRC emacs-lisp :results output
(defun enumerate (lst)
  (loop for i from 0
	for el in lst
	collect (cons i el)))

(loop for (i . el) in (enumerate '(a b c d))
      do (princ (format "%s: %s\n" i el)))
#+END_SRC
#+RESULTS:
: 0: a
: 1: b
: 2: c
: 3: d


#+BEGIN_SRC emacs-lisp
(-annotate
#+END_SRC


#+BEGIN_SRC emacs-lisp :results output
(defun zip (&rest args)
  (unless (memq 'nil args)
    (cons (mapcar 'car args)
	  (apply 'zip (mapcar 'cdr args)))))

(loop for (i j k) in (zip '(a b c) '(1 2 3) '(5 6 7))
  do (princ (format "-%s--%s--%s\n" i j k)))
#+END_SRC
#+RESULTS:
: -a--1--5
: -b--2--6
: -c--3--7

dash provides a zip function
#+BEGIN_SRC emacs-lisp
(require 'dash)
(-zip '(a b c) '(1 2 3) '(5 6 7))
#+END_SRC
#+RESULTS:
| a | 1 | 5 |
| b | 2 | 6 |
| c | 3 | 7 |


* see link message under point

#+BEGIN_SRC emacs-lisp
(defun link-message ()
  (let ((object (org-element-context)))
    (when (eq (car object) 'link)
      (message "%s"
	       (org-element-property :raw-link object)))))

(add-hook 'post-command-hook 'link-message)
#+END_SRC

#+RESULTS:
| link-message | eldoc-schedule-timer |

(org-activate-bracket-links (point-max))

foobar

#+BEGIN_SRC emacs-lisp
; add a tooltip to every instance of foobar
(save-excursion  ;return cursor to current-point
  (goto-char 1)
    (while (search-forward "foobar" (point-max) t)
      (set-text-properties  (match-beginning 0) (match-end 0)
                            `(help-echo "You know... a bar for foos!"
					font-lock-face (:foreground "dark slate gray")
					point-entered (lambda (old-point new-point) (message-box "point-entered %s" new-point))
					point-left (lambda (old-point new-point) (message-box "point-left %s old-point")))
)))

#+END_SRC



* DONE Python data structures to lisp
  CLOSED: [2015-05-16 Sat 10:48]
  :PROPERTIES:
  :categories: python,emacs,lisp
  :date:     2015/05/16 10:47:59
  :updated:  2015/05/16 10:47:59
  :END:
I have an idea in mind that would use the output of python scripts in lisp functions. Xah Lee posted an [[http://ergoemacs.org/emacs/elisp_perl_wrapper.html][idea for writing emacs commands in scripting languages]]. In this post I want to explore an extension of the idea, where a Python script will return output that can be read in Lisp, e.g. we can convert a Python list to a lisp list, or a dictionary to an a-list or p-list. I can already see that simple data structures will be "simple", and arbitrary data structures will offer a lot of challenges, e.g. nested lists or dictionaries...

If I could add some custom functions to the basic builtin types in Python, then I could use another approach to format python objects as lisp data types. This isn't recommended by Pythonistas, but I guess they don't want to use lisp as much as I do ;) I found this approach to modifying builtins:

http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a

We use that almost verbatim here to get what I want. This is a super low level way to add functions to the builtins. I add some simple formatting to floats, ints and strings. I add a more complex recursive formatting function to lists, tuples and dictionaries. A dictionary can be represented as an alist or plist. Both examples are shown, but I leave the alist version commented out. Finally, we add a lispify function to numpy arrays.

#+BEGIN_SRC python :tangle pylisp.py
import ctypes as c

class PyObject_HEAD(c.Structure):
    _fields_ = [('HEAD', c.c_ubyte * (object.__basicsize__ -
                                      c.sizeof(c.c_void_p))),
                ('ob_type', c.c_void_p)]

_get_dict = c.pythonapi._PyObject_GetDictPtr
_get_dict.restype = c.POINTER(c.py_object)
_get_dict.argtypes = [c.py_object]

def get_dict(object):
    return _get_dict(object).contents.value

import collections
import numpy as np

def lispify(L):
    "Convert a Python object L to a lisp representation."
    if (isinstance(L, str)
        or isinstance(L, float)
        or isinstance(L, int)):
        return L.lisp()
    elif (isinstance(L, list)
          or isinstance(L, tuple)
          or isinstance(L, np.ndarray)):
        s = []
        for element in L:
            s += [element.lisp]
        return '(' + ' '.join(s) + ')'
    elif isinstance(L, dict):
        s = []
        for key in L:
            # alist format
            # s += ["({0} . {1})".format(key, L[key].lisp())]
            # plist
            s += [":{0} {1}".format(key, L[key].lisp)]
        return '(' + ' '.join(s) + ')'

get_dict(str)['lisp'] = property(lambda s:'"{}"'.format(str(s)))
get_dict(float)['lisp'] = property(lambda f:'{}'.format(str(f)))
get_dict(int)['lisp'] = property(lambda f:'{}'.format(str(f)))


get_dict(list)['lisp'] = property(lispify)
get_dict(tuple)['lisp'] = property(lispify)
get_dict(dict)['lisp'] = property(lispify)
get_dict(np.ndarray)['lisp'] = property(lispify)
#+END_SRC

#+RESULTS:

Let us test these out.
#+BEGIN_SRC python
from pylisp import *
a = 4.5
print int(a).lisp
print a.lisp
print "test".lisp

print [1, 2, 3].lisp
print (1, 2, 3).lisp

print [[1, 3], (5, 6)].lisp

print {"a": 5}.lisp
print [[1, 3], (5, 6), {"a": 5, "b": "test"}].lisp


A = np.array([1, 3, 4])
print A.lisp
print ({"tree": [5, 6]}, ["a", 4, "list"], 5, 2.0 / 3.0).lisp
#+END_SRC

#+RESULTS:
#+begin_example
4
4.5
"test"
(1 2 3)
(1 2 3)
((1 3) (5 6))
(:a 5)
((1 3) (5 6) (:a 5 :b "test"))
(1 3 4)
((:tree (5 6)) ("a" 4 "list") 5 0.666666666667)
#+end_example


Now, is that better than a single lisp function with a lot of conditionals to handle each type? I am not sure. This seems to work pretty well.


Here is how I imagine using this idea. We would have some emacs-lisp variables and use them to dynamically generate a python script. We run the python script, capturing the output, and read it back in as a lisp data structure. Here is a simple kind of example that generates a dictionary.

#+BEGIN_SRC emacs-lisp :results code
(let* ((elisp-var 6)
       (result)
      (script (format "
from pylisp import *
print {x: [2*y for y in range(x)] for x in range(1, %s)}.lisp()
" elisp-var)))

  ;; start a python process
  (run-python)
  (setq result (read (python-shell-send-string-no-output
   script)))
  (plist-get result :5))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(0 2 4 6 8)
#+END_SRC

That seems to work pretty well. One alternative idea to this is [[https://github.com/pinard/Pymacs][Pymacs]], which I have written about [[http://kitchingroup.cheme.cmu.edu/blog/2014/10/19/Using-Pymacs-to-integrate-Python-into-Emacs/][before]]. This project isn't currently under active development, and I ran into some difficulties with it before.

Here we can solve the problem I previously posed and get the result back as an elisp float, and then reuse the result

#+BEGIN_SRC emacs-lisp
(let* ((myvar 3)
       (script (format "from pylisp import *
from scipy.optimize import fsolve
def objective(x):
    return x - 5

ans, = fsolve(objective, %s)
print ans.lisp()" myvar)))
  (run-python)
  (setq result (read (python-shell-send-string-no-output
		       script)))
  (- 5 result))
#+END_SRC

#+RESULTS:
: 0.0

Bottom line: we can write python code in lisp functions that are dynamically updated, execute them, and get lisp data structures back for simple data types. I think that could be useful in some applications, where it is easier to do parsing/analysis in Python, but you want to do something else that is easier in Lisp.

* Getting VASP output from vasprun.xml


#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('../../gilgamesh-backup/research/cu-pd-au-atat-vasp/CuPd_fcc/10/vasprun.xml') as f:
    vasprun_xml = f.read()


def get_encoded_text(container, xpath):
    '''Return utf-8 encoded text for element at xpath if it is there.'''
    if container is None:
        return None
    result = container.find(xpath)
    if hasattr(result, 'text') and result.text:
        return result.text.encode('utf-8')
    else:
        return None

xml = ET.fromstring(vasprun_xml)

print get_encoded_text(xml, 'generator/i[@name="program"]')
print get_encoded_text(xml, 'generator/i[@name="version"]')
print get_encoded_text(xml, 'generator/i[@name="subversion"]')
#+END_SRC
#+RESULTS:
: vasp
: 5.2.12
: 11Nov11 complex                                                      serial

Next, we see about the incar file. Not all of these elements have a type, so we have to get that attribute.

#+BEGIN_SRC python :session
for el in xml.find('incar'):
    print '{0} ({1}) = {2}'.format(el.attrib['name'], el.attrib.get('type'), el.text)
#+END_SRC
#+RESULTS:
: PREC (string) = high
: IBRION (int) =     -1
: ISIF (int) =      2
: ENCUT (None) =     350.00000000
: NBANDS (int) =     34
: ISMEAR (int) =     -5
: SIGMA (None) =       0.10000000

KPOINTS.

#+BEGIN_SRC python :session
for el in xml.find('kpoints/generation'):
    print '{0} = {1}'.format(el.attrib['name'], el.text)
#+END_SRC
#+RESULTS:
: divisions =        8        8        8
: usershift =       0.00000000       0.00000000       0.00000000
: genvec1 =       0.12500000       0.00000000       0.00000000
: genvec2 =       0.00000000       0.12500000       0.00000000
: genvec3 =       0.00000000       0.00000000       0.12500000
: shift =       0.00000000       0.00000000       0.00000000

#+BEGIN_SRC python :session
print [float(v.text) for v in xml.findall('kpoints/varray[@name="weights"]/v')]
#+END_SRC

#+RESULTS:
: [0.00195312, 0.01171875, 0.01171875, 0.01171875, 0.00585938, 0.01171875, 0.0234375, 0.0234375, 0.0234375, 0.0234375, 0.0234375, 0.01171875, 0.01171875, 0.0234375, 0.0234375, 0.0234375, 0.01171875, 0.01171875, 0.0234375, 0.01171875, 0.00585938, 0.00390625, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.0234375, 0.0234375, 0.0234375, 0.0234375, 0.0234375, 0.01171875, 0.0234375, 0.0234375, 0.0234375, 0.0234375, 0.01171875, 0.0234375, 0.0234375, 0.01171875, 0.01171875, 0.0234375, 0.01171875, 0.00390625, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.0234375, 0.0234375, 0.0234375, 0.01171875, 0.0234375, 0.01171875, 0.01171875, 0.00390625, 0.01171875, 0.01171875, 0.01171875, 0.01171875, 0.00195312]

#+BEGIN_SRC python :session
print xml.find('parameters/separator[@name="electronic"]/i[@name="NELECT"]').text
print xml.find('parameters/separator[@name="electronic"]/separator[@name="electronic mixer"]/i[@name="AMIX"]').text
#+END_SRC

#+RESULTS:
: 43.00000000
: 0.40000000

#+BEGIN_SRC python :session
for el in xml.findall('structure'):  print el.attrib['name']
#+END_SRC
#+RESULTS:
: initialpos
: finalpos

#+BEGIN_SRC python :session
for el in xml.findall('calculation/scstep/energy/i[@name="e_0_energy"]'):
    print float(el.text)
#+END_SRC
#+RESULTS:
: -16.49261096
: -16.50499056
: -16.48925155
: -16.48985986
: -16.48973695
: -16.48985835
: -16.48981957

Get final structure:
#+BEGIN_SRC python :session
positions = [[float(x) for x in el.text.split()]
             for  el in xml.findall('structure[@name="finalpos"]/varray[@name="positions"]/v')]

unit_cell = [[float(x) for x in el.text.split()]
             for el in xml.findall('structure[@name="finalpos"]/crystal/varray[@name="basis"]/v')]

symbols = [el.text for el in xml.findall('atominfo/array[@name="atoms"]/set/rc/c[1]')]

for sym, pos in zip(symbols, positions):
    print '{0}: {1}'.format(sym, pos)

print 'UC = {0}'.format(unit_cell)
#+END_SRC

#+RESULTS:
: Cu: [0.25334331, 0.25334331, 0.25334331]
: Cu: [0.0, 0.0, 0.0]
: Cu: [0.74665669, 0.74665669, 0.74665669]
: Pd: [0.5, 0.5, 0.5]
: UC = [[-5.46362047, 3.5654701, 5.46362047], [-3.5654701, 5.46362047, 5.46362047], [-5.46362047, 5.46362047, 3.5654701]]


* DONE Another approach to embedding org-source in html
  CLOSED: [2015-05-09 Sat 19:19]
  :PROPERTIES:
  :date:     2015/05/09 19:19:10
  :updated:  2015/05/10 09:34:55
  :categories: orgmode, data
  :END:
In this [[http://kitchingroup.cheme.cmu.edu/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts/][post]] I examined a way to embed the org-source in a comment in the html of the post, and developed a reasonably convenient way to extract the source in emacs. One downside of the approach was the need to escape at least the dashes, and then unescape them on extraction. I came across another idea, which is to put the org-source in base64 encoded form in a [[http://en.wikipedia.org/wiki/Data_URI_scheme][data uri]].

First let us see what the encoding means:

#+BEGIN_SRC emacs-lisp
(base64-encode-string "<!-- test-->")
#+END_SRC
#+RESULTS:
: PCEtLSB0ZXN0LS0+

And decoding:

#+BEGIN_SRC emacs-lisp
(base64-decode-string "PCEtLSB0ZXN0LS0+")
#+END_SRC

#+RESULTS:
: <!-- test-->

The encoding looks random, but it is reversible. More importantly, it probably will not have any html like characters in it that need escaped. The idea of a data uri is that the data it serves is embedded in the URL href attribute. This is basically how to make a data uri. We give the url here a class so we can find it later.
#+BEGIN_EXAMPLE
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>
#+END_EXAMPLE

Here is the actual html for the browser. If you click on it, your browser automatically decodes it for you!
#+BEGIN_HTML
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>
#+END_HTML

So, during the blog publish step, we just need to add this little step to the html generation, and it will be included as a data uri. Here is the function that generates the data uri for us, and example of using it. The encoded source is not at all attractive to look at it, but you almost never need to look at it, it is invisible in the browser. Interestingly, if you click on the link, you will see the org source right in your browser!

#+BEGIN_SRC emacs-lisp  :results html
(defun source-data-uri (source)
  "Encode the string in SOURCE to a data uri."
  (format
   "<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,%s\">source</a>"
   (base64-encode-string source)))

(source-data-uri (buffer-string))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBBbm90aGVyIGFwcHJvYWNoIHRvIGVtYmVkZGluZyBvcmctc291cmNlIGluIGh0bWwKSW4gdGhp
cyBbW2h0dHA6Ly9raXRjaGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4t
YWx0ZXJuYXRpdmUtYXBwcm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0
cy9dW3Bvc3RdXSBJIGV4YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEg
Y29tbWVudCBpbiB0aGUgaHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFi
bHkgY29udmVuaWVudCB3YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93
bnNpZGUgb2YgdGhlIGFwcHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhl
IGRhc2hlcywgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNy
b3NzIGFub3RoZXIgaWRlYSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2
NCBlbmNvZGVkIGZvcm0gaW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9V
Uklfc2NoZW1lXVtkYXRhIHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGlu
ZyBtZWFuczoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8
IS0tIHRlc3QtLT4iKQojK0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFu
ZCBkZWNvZGluZzoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5n
ICJQQ0V0TFNCMFpYTjBMUzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+
CgpBbmQgdGhpcyBpcyBiYXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0
aGUgdXJsIGhlcmUgYSBjbGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFN
UExFCjxhIGNsYXNzPSJvcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9FWEFNUExF
CgpIZXJlIGlzIHRoZSBhY3R1YWwgaHRtbCBmb3IgdGhlIGJyb3dzZXI6IAojK0JFR0lOX0hUTUwK
PGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFT
Q0lJO2Jhc2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0hUTUwKClNvLCBk
dXJpbmcgdGhlIGJsb2cgcHVibGlzaCBzdGVwLCB3ZSBqdXN0IG5lZWQgdG8gYWRkIHRoaXMgbGl0
dGxlIHN0ZXAgdG8gdGhlIGh0bWwgZ2VuZXJhdGlvbiwgYW5kIGl0IHdpbGwgYmUgaW5jbHVkZWQg
YXMgYSBkYXRhIHVyaS4gSGVyZSBpcyB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIGRh
dGEgdXJpIGZvciB1cywgYW5kIGV4YW1wbGUgb2YgdXNpbmcgaXQ6CgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIiBkb3dubG9hZD1cInNvdXJjZS5vcmdcIj5zb3VyY2U8L2E+IiAK
ICAgKGJhc2U2NC1lbmNvZGUtc3RyaW5nIHNvdXJjZSkpKQoKKHNvdXJjZS1kYXRhLXVyaSAoYnVm
ZmVyLXN0cmluZykpCiMrRU5EX1NSQwoKCgoKCgoK" download="source.org">source</a>
#+END_HTML

Now, we integrate it into the blogofile function:

#+BEGIN_SRC emacs-lisp
(defun bf-get-post-html ()
  "Return a string containing the YAML header, the post html, my
copyright line, and a link to the org-source code."
  (interactive)
  (let ((org-source (buffer-string))
	(url-to-org (bf-get-url-to-org-source))
	(yaml (bf-get-YAML-heading))
	(body (bf-get-HTML)))

    (with-temp-buffer
      (insert yaml)
      (insert body)
      (insert
       (format "<p>Copyright (C) %s by John Kitchin. See the <a href=\"/copying.html\">License</a> for information about copying.<p>"
	       (format-time-string "%Y")))
      (insert (format "<p><a href=\"%s\">org-mode source</a><p>"
		      url-to-org))
      (insert (format "<p>Org-mode version = %s</p>" (org-version)))
      ;; this is the only new code we need to add.
      (insert (source-data-uri org-source))
      ;; return value
      (buffer-string))))
#+END_SRC

Now we need a new adaptation of the grab-org-source function. We still need a regexp search to get the source, and we still need to decode it.

#+BEGIN_SRC emacs-lisp
(defun grab-org-source (url)
  "Extract org-source from URL to a buffer named *grab-org-source*."
  (interactive "sURL: ")
  (switch-to-buffer (get-buffer-create "*grab-org-source*"))
  (erase-buffer)
  (org-mode)
  (insert
   (with-current-buffer
       (url-retrieve-synchronously url)
     (let (start)
       (re-search-forward
	"<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,\\([^\"]*\\)\\\">" nil t)
       (base64-decode-string  (match-string 1))))))
#+END_SRC

What else could we do with this? One idea would be to generate data uris for each code block that you could open in your browser. For example, here we generate a list of data uris for each code block in the buffer. We don't take care to label them or make it easy to see what they are, but if you click on one, you should see a plain text version of the block. If this is done a lot, it might even make sense to change the mime type to download the code in some native app.

#+BEGIN_SRC emacs-lisp :results html
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (src-block)
    (source-data-uri (org-element-property :value src-block))))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
(<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBMUzArIikK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIHNvdXJjZS1kYXRhLXVyaSAoc291cmNlKQogICJFbmNvZGUgdGhlIHN0cmluZyBpbiBT
T1VSQ0UgdG8gYSBkYXRhIHVyaS4iCiAgKGZvcm1hdAogICAiPGEgY2xhc3M9XCJvcmctc291cmNl
XCIgaHJlZj1cImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jhc2U2NCwlc1wiPnNv
dXJjZTwvYT4iCiAgIChiYXNlNjQtZW5jb2RlLXN0cmluZyBzb3VyY2UpKSkKCihzb3VyY2UtZGF0
YS11cmkgKGJ1ZmZlci1zdHJpbmcpKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGJmLWdldC1wb3N0LWh0bWwgKCkKICAiUmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcg
dGhlIFlBTUwgaGVhZGVyLCB0aGUgcG9zdCBodG1sLCBteQpjb3B5cmlnaHQgbGluZSwgYW5kIGEg
bGluayB0byB0aGUgb3JnLXNvdXJjZSBjb2RlLiIKICAoaW50ZXJhY3RpdmUpCiAgKGxldCAoKG9y
Zy1zb3VyY2UgKGJ1ZmZlci1zdHJpbmcpKQoJKHVybC10by1vcmcgKGJmLWdldC11cmwtdG8tb3Jn
LXNvdXJjZSkpCgkoeWFtbCAoYmYtZ2V0LVlBTUwtaGVhZGluZykpCgkoYm9keSAoYmYtZ2V0LUhU
TUwpKSkKCiAgICAod2l0aC10ZW1wLWJ1ZmZlcgogICAgICAoaW5zZXJ0IHlhbWwpCiAgICAgIChp
bnNlcnQgYm9keSkKICAgICAgKGluc2VydAogICAgICAgKGZvcm1hdCAiPHA+Q29weXJpZ2h0IChD
KSAlcyBieSBKb2huIEtpdGNoaW4uIFNlZSB0aGUgPGEgaHJlZj1cIi9jb3B5aW5nLmh0bWxcIj5M
aWNlbnNlPC9hPiBmb3IgaW5mb3JtYXRpb24gYWJvdXQgY29weWluZy48cD4iCgkgICAgICAgKGZv
cm1hdC10aW1lLXN0cmluZyAiJVkiKSkpCiAgICAgIChpbnNlcnQgKGZvcm1hdCAiPHA+PGEgaHJl
Zj1cIiVzXCI+b3JnLW1vZGUgc291cmNlPC9hPjxwPiIKCQkgICAgICB1cmwtdG8tb3JnKSkKICAg
ICAgKGluc2VydCAoZm9ybWF0ICI8cD5PcmctbW9kZSB2ZXJzaW9uID0gJXM8L3A+IiAob3JnLXZl
cnNpb24pKSkKICAgICAgOzsgdGhpcyBpcyB0aGUgb25seSBuZXcgY29kZSB3ZSBuZWVkIHRvIGFk
ZC4KICAgICAgKGluc2VydCAoc291cmNlLWRhdGEtdXJpIG9yZy1zb3VyY2UpKQogICAgICA7OyBy
ZXR1cm4gdmFsdWUKICAgICAgKGJ1ZmZlci1zdHJpbmcpKSkpCg==">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGdyYWItb3JnLXNvdXJjZSAodXJsKQogICJFeHRyYWN0IG9yZy1zb3VyY2UgZnJvbSBV
UkwgdG8gYSBidWZmZXIgbmFtZWQgKmdyYWItb3JnLXNvdXJjZSouIgogIChpbnRlcmFjdGl2ZSAi
c1VSTDogIikKICAoc3dpdGNoLXRvLWJ1ZmZlciAoZ2V0LWJ1ZmZlci1jcmVhdGUgIipncmFiLW9y
Zy1zb3VyY2UqIikpCiAgKGVyYXNlLWJ1ZmZlcikKICAob3JnLW1vZGUpCiAgKGluc2VydAogICAo
d2l0aC1jdXJyZW50LWJ1ZmZlcgogICAgICAgKHVybC1yZXRyaWV2ZS1zeW5jaHJvbm91c2x5IHVy
bCkKICAgICAobGV0IChzdGFydCkKICAgICAgIChyZS1zZWFyY2gtZm9yd2FyZAoJIjxhIGNsYXNz
PVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSTti
YXNlNjQsXFwoW15cIl0qXFwpXFxcIj4iIG5pbCB0KQogICAgICAgKGJhc2U2NC1kZWNvZGUtc3Ry
aW5nICAobWF0Y2gtc3RyaW5nIDEpKSkpKSkK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KG9yZy1lbGVtZW50LW1hcCAob3JnLWVsZW1lbnQtcGFyc2UtYnVmZmVyKSAnc3JjLWJsb2NrCiAg
KGxhbWJkYSAoc3JjLWJsb2NrKQogICAgKHNvdXJjZS1kYXRhLXVyaSAob3JnLWVsZW1lbnQtcHJv
cGVydHkgOnZhbHVlIHNyYy1ibG9jaykpKSkK">source</a>)
#+END_HTML


I am not sure if this is better or worse than the other approach. I have not tested it very thoroughly, but it seems like it should work pretty generally. I imagine you could also embed other kinds of files in the html, if for some reason you did not want to put the files on your server. Overall this seems to lack some elegance in searching for data, e.g. like [[http://en.wikipedia.org/wiki/Embedded_RDF][RDF]] or [[http://en.wikipedia.org/wiki/RDFa][RDFa]] is supposed to enable, but it might be a step in that direction, using org-mode and Emacs as the editor.


* A new annotation syntax

[@annotate :type comment :author John Kitchin :content This is great]

is matched by "\\[@annotate[^]]*\\]"

#+BEGIN_SRC emacs-lisp
(require 'ov)
(ov-set "\\[@annotate\\([^]]\\)*\\]" 'face '(:foreground "red") 'help-echo (match-string 1) 'display "comment" 'ov1 t)

(defun my-ov-evaporate-ov1 (_ov _after _beg _end &optional _length)
  (let ((inhibit-modification-hooks t))
    (if _after (ov-clear 'ov1))))

;; remove overlays if you edit one. it would be nice to do this on one, not all.
(ov-set "ov-" 'face 'warning
              'ov1 t
              'modification-hooks '(my-ov-evaporate-ov1))
;(ov-clear 'ov1)
#+END_SRC

#+RESULTS:



I don't know how to get a specific overlay, eg. the content, or to make a different overlay for different types of annotation. Also, this does not automatically update new content. [@annotate :type insert :content these words].

[@annotate :type delete :Date today]


#+BEGIN_SRC emacs-lisp
(setq ov1 (ov-set "\\[@annotate\\([^]]\\)*\\]" 'face '(:foreground "red") 'help-echo (match-string 1) 'display "comment"))
(mapcar 'ov-end ov1)
#+END_SRC
#+RESULTS:
| 996 | 933 | 894 | 201 | 129 | 97 |

#+BEGIN_SRC emacs-lisp
(defun mod-ov () (interactive)
 (let ((overlay (ov-at)))
 (message "%s" overlay)
 (ov-clear (ov-beg overlay) (ov-end overlay))))
#+END_SRC

** With fontlock


[@annotate :type delete :Date today]

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("\\[@annotate\\([^]]*\\)\\]"
    (1 'font-lock-variable-name-face))))

(font-lock-add-keywords
 'org-mode
 '("\\[@annotate\\([^]]*\\)\\]" . 'font-lock-variable-name-face))

(font-lock-add-keywords nil
  '(("foo" . (:foreground "red"))))
#+END_SRC

[@annotate :type delete]

foo  foo  foo foo  foo

foo

(defface extra-whitespace-face
  '((t (:background "pale green")))
  "Used in text-mode and friends for exactly one space after a period.")

(mapcar (lambda (mode)
	  (font-lock-add-keywords
	   mode
	   '(("FIXME" 0 'show-paren-mismatch-face)
	     ("\\.\\( \\)\\b" 1 'extra-whitespace-face))))
	'(text-mode latex-mode html-mode emacs-lisp-mode org-mode
	  texinfo-mode)) FIXME fdksaf
* Colorize comments


#+BEGIN_SRC emacs-lisp
(defvar org-comment-color "red")

(defvar org-comment-re
  "\\(\\[\\[\\)?comment:\\([^]]\\)+\\]?\\[?\\([^]]\\)*\\(\\]\\]\\)")

(defface org-comment-face2
  `((t (:inherit org-link :slant italic :foreground ,org-comment-color)))
  "Face for ref links in org-ref.")


(defun org-comment-colorize-links ()
  "Colorize org-ref links."
  (hi-lock-mode 1)
  (highlight-regexp org-comment-re 'org-comment-face2))
#+END_SRC

[[comment:test]]

[[comment:second test][Test]]


[[comment:check baby]]
* DONE Commenting in org-files
  CLOSED: [2015-04-24 Fri 12:41]
  :PROPERTIES:
  :categories: org
  :date:     2015/04/24 12:41:39
  :updated:  2015/04/24 12:41:39
  :END:
There was an interesting discussion on the org-mode mail list about putting comments in org files. Eric Fraga suggested using inline tasks, and customizing the export of them so they make a footnote, or use the todonotes package (suggested by Marcin Borkowski). Here is Eric's export. A big advantage of this is integration with the Agenda, so you can see what there is todo in your document.

#+begin_src emacs-lisp
  (setq org-inlinetask-export-templates
        '((latex "%s\\footnote{%s\\\\ %s}\\marginpar{\\fbox{\\thefootnote}}"
                 '((unless
                       (eq todo "")
                     (format "\\fbox{\\textsc{%s%s}}" todo priority))
                   heading content))))
#+end_src

Eric Abrahamsen suggested an idea to use a link syntax. I like the idea a lot, so here we develop some ideas. A link has two parts, the path, and description. A simple comment would just be a simple link, probably in double square brackets so you can have spaces in your comment. [[comment:Why do you think there are only two parts]] It might be feasible to use [[comment:Why do you quote mark?][the description to "mark text" that the comment refers to]]. The remaining question is what functionality should our link have when you click on it, and how to export it. For functionality, a click will show the comment in the minibuffer and offer to delete it. For export, for now we will make it export with todonotes in LaTeX, and as a red COMMENT with a tooltip in html. To use this, you need to have the LaTeX package todonotes included in your org file.
#+LATEX_HEADER: \usepackage{todonotes}

Here is our comment link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "comment"
 (lambda (linkstring)
   (let ((elm (org-element-context))
         (use-dialog-box nil))
     (when (y-or-n-p "Delete comment? ")
       (setf (buffer-substring
	      (org-element-property :begin elm)
	      (org-element-property :end elm))
	     (cond
	      ((org-element-property :contents-begin elm)
	       (buffer-substring
		(org-element-property :contents-begin elm)
		(org-element-property :contents-end elm)))
	      (t
	       ""))))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'html)
     (format "<font color=\"red\"><abbr title=\"%s\" color=\"red\">COMMENT</abbr></font> %s" keyword (or desc "")))
    ((eq format 'latex)
     (format "\\todo{%s}{%s}" keyword (or desc ""))))))
#+END_SRC


It would be convenient to have a quick function for adding a comment to some highlighted text.

#+BEGIN_SRC emacs-lisp
(defun add-comment (begin end)
  (interactive "r")
  (if (region-active-p)
      (let ((selected-text (buffer-substring begin end)))
	(setf (buffer-substring begin end)
	      (format "[[comment:%s][%s]]"
		      (read-input "Comment: ") selected-text)))
  (insert (format  "[[comment:%s]]" (read-input "Comment: ")))))
#+END_SRC

Test 1: [[comment:test comment]]

[[comment:You seem to have forgotten Test 2][Test 2]]

That is it. I could see a few other enhancements that might be very useful, e.g. a command to list all the comments, remove all the comments, etc... I am pretty satisfied with this for now though.

* insert code block
#+BEGIN_SRC emacs-lisp
(defun pec ()
  (interactive)
  (kill-region (region-beginning) (region-end))
  (insert "#+BEGIN_EXAMPLE\n")
  (yank)
  (insert "\n#+END_EXAMPLE")
  (previous-line 1)
  (org-edit-special)
  (fill-region (point-min) (point-max))
  (org-edit-src-exit))
#+END_SRC


* DONE Extending the org-mode link syntax with attributes
  CLOSED: [2015-04-20 Mon 12:55]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/02/05 10:06:25
  :updated:  2015/04/20 12:56:35
  :END:
I make super heavy use of links in org-mode. I use them extensively in org-ref to create functional citations. One detail that has never been very satisfactory is the need for pre/post text in citations. I don't need that capability often, but it seems important to some. I have implemented a kind of clunky solution where I use the description part of a link with the pre/post text separated by a ::. Although that works, I dislike the way it looks, the need to parse it, and that the description covers the link.

#+BEGIN_EXAMPLE
[[cite:key][pre text::post text]]
#+END_EXAMPLE

Some [[https://lists.gnu.org/archive/html/emacs-orgmode/2010-08/msg00404.html][time ago]] there was a suggestion of how to extend the link syntax, which was to my knowledge never implemented. Here is the proposed syntax:
#+BEGIN_EXAMPLE
$[link http://google.com
         :last-followed [2009-02-25 Wed 02:00]
         :label "click here for evil search engine"
         :export-label "click here for nice search engine"]
#+END_EXAMPLE

This is interesting because this syntax suggests the link has attributes which can be updated.

We will show here how to implement part of this idea with the existing link syntax. We will make a link that has attributes like that. The basic idea is to simply incorporate the attributes into the path, and use lisp to read them. We will wrap the link path in parentheses and read that as a lisp data structure. So, a link like [[link:key :pre "some pre text" :post "some post text"]] will be parsed as:

#+BEGIN_SRC emacs-lisp
(read "(key :pre \"some pre text\" :post \"some post text\")")
#+END_SRC

#+RESULTS:
| key | :pre | some pre text | :post | some post text |

The car of that list is the key, and the cdr contains the attributes. The quotes are necessary here to make sure all the text is correctly parsed as a single element for each attribute. So, here is an example link

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "slink"
 ;;  follow function
 (lambda (path)
   (let* ((data (read (format "(%s)" path)))
	  (head (car data))
	  (plist (cdr data))
	  (link (org-element-context))
	  (begin (org-element-property :begin link))
	  (end (org-element-property :end link)))
     (setq plist (plist-put plist :last-clicked (current-time-string)))
     (save-excursion
     (setf (buffer-substring begin end) "")
     (goto-char begin)
     (insert (format "[[slink:%s %s]]" head
         (substring (format "%S" plist) 1 -1))))))
 ;; format function
 (lambda (path description backend)
   (let* ((data (read (concat "(" path ")")))
	  (head (car data))
	  (plist (cdr data)))
     (format "\\%s[%s][%s]{%s}"
             (plist-get plist :type)
	     (plist-get plist :pre)
	     (plist-get plist :post)
             head))))
#+END_SRC

Now, each time I click on this link, the time stamp gets updated.

[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Mon Apr 20 12:54:40 2015"]]

#+BEGIN_EXAMPLE
[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Thu Feb  5 09:31:15 2015"]]
#+END_EXAMPLE


And, the generic export of this link is:

#+BEGIN_EXAMPLE
\cite[See for example][page 47]{kitchin-2010}
#+END_EXAMPLE

Is this a good idea? I am not using this for anything right now. Sometimes my version of org-mode has trouble recognizing that is a link. It is strange, as I am typing, sometimes it flashes in and out of being recognized as a link. Anyway, it is an interesting idea!
* equations in html

See ref:eq-1.


label:eq-1
\begin{equation}
e^x = 4
\end{equation}


* sweet new babel things

Thanks to William Henney for sharing this on the orgmode mailing list.

#+BEGIN_SRC python :results value :return mytable
NROWS, NCOLS = 6, 4
mytable = []
mytable.append(['A', 'B', 'C', 'D'])  # Table header
mytable.append(None)                  # hline
for irow in range(NROWS):
    mytable.append([icol**irow for icol in range(NCOLS)])
mytable.append(None)                  # hline
 #+END_SRC

#+RESULTS:
| A | B |  C |   D |
|---+---+----+-----|
| 1 | 1 |  1 |   1 |
| 0 | 1 |  2 |   3 |
| 0 | 1 |  4 |   9 |
| 0 | 1 |  8 |  27 |
| 0 | 1 | 16 |  81 |
| 0 | 1 | 32 | 243 |
|---+---+----+-----|



* DONE Using the Scopus api with xml output
  CLOSED: [2015-04-06 Mon 09:36]
  :PROPERTIES:
  :categories: python,xml,scopus
  :date:     2015/04/06 09:35:57
  :updated:  2015/04/06 09:35:57
  :END:
According to http://api.elsevier.com/documentation/AbstractRetrievalAPI.wadl, the native form of the Scopus abstract document is xml, and the full abstract cannot always be represented  as json. So... I am going to just bite the bullet and learn to deal with the xml. This is a companion post to http://kitchingroup.cheme.cmu.edu/blog/2015/04/04/Making-highly-linked-bibliographies-from-the-Scopus-API/. Most of the code in this post gets tangled out to scopus_xml.py. I know it is not totally robust yet, but I have been using it for a lot of analysis, and it works pretty well so far.

This is another long post, with code that probably runs off screen. You can see the end result of what we do in this post here:  http://kitchingroup.cheme.cmu.edu/publications.html.


We start with a general function to return an xml elementtree. We build in some caching to avoid downloading things we already have; this is slow, and there are limits on how many times you can download.

#+BEGIN_SRC python :tangle scopus_xml.py
import requests
import os
import xml.etree.ElementTree as ET

from my_scopus import MY_API_KEY

def get_abstract_info(EID, refresh=False):
    'Get and save the json data for EID.'
    base = 'scopus-xml/get_abstract_info'
    if not os.path.exists(base):
        os.makedirs(base)

    fname = '{0}/{1}'.format(base, EID)
    if os.path.exists(fname) and not refresh:
        with open(fname) as f:
            return ET.fromstring(f.read())

    # Otherwise retrieve and save results
    url = ("http://api.elsevier.com/content/abstract/eid/" + EID + '?view=META_ABS')
    resp = requests.get(url,
                    headers={'Accept':'application/xml',
                             'X-ELS-APIKey': MY_API_KEY})
    with open(fname, 'w') as f:
        f.write(resp.text.encode('utf-8'))

    results = ET.fromstring(resp.text.encode('utf-8'))

    return results
#+END_SRC

Next, we do some introspection to see what we have.

#+BEGIN_SRC python :results html
from scopus_xml import *
#results = get_abstract_info('2-s2.0-84896759135')
#results = get_abstract_info('2-s2.0-84924911828')
results = get_abstract_info('2-s2.0-84901638552')
for el in results:
    print el.tag
    for el1 in el:
        print '  -->',el1.tag
    print
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata
  --> {http://prismstandard.org/namespaces/basic/2.0/}url
  --> {http://purl.org/dc/elements/1.1/}identifier
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}eid
  --> {http://prismstandard.org/namespaces/basic/2.0/}doi
  --> {http://purl.org/dc/elements/1.1/}title
  --> {http://prismstandard.org/namespaces/basic/2.0/}aggregationType
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}srctype
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}citedby-count
  --> {http://prismstandard.org/namespaces/basic/2.0/}publicationName
  --> {http://purl.org/dc/elements/1.1/}publisher
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}source-id
  --> {http://prismstandard.org/namespaces/basic/2.0/}issn
  --> {http://prismstandard.org/namespaces/basic/2.0/}volume
  --> {http://prismstandard.org/namespaces/basic/2.0/}startingPage
  --> {http://prismstandard.org/namespaces/basic/2.0/}endingPage
  --> {http://prismstandard.org/namespaces/basic/2.0/}pageRange
  --> {http://prismstandard.org/namespaces/basic/2.0/}coverDate
  --> {http://purl.org/dc/elements/1.1/}creator
  --> {http://purl.org/dc/elements/1.1/}description
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link

{http://www.elsevier.com/xml/svapi/abstract/dtd}affiliation
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}affilname

{http://www.elsevier.com/xml/svapi/abstract/dtd}authors
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}author
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}author

#+END_HTML

Now, some examples for myself to see how to get things.

#+BEGIN_SRC python :results html
from scopus_xml import *

results = get_abstract_info('2-s2.0-84901638552')

coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}srctype').text
print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}source-id').text

#authors = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors')
#for author in results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors'):
#    print author.find('{http://www.elsevier.com/xml/ani/common}indexed-name').text

for creator in coredata.find('{http://purl.org/dc/elements/1.1/}creator'):
    print creator.attrib

print coredata.find('{http://purl.org/dc/elements/1.1/}title').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}publicationName').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}coverDate').text
print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}citedby-count').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi').text

for link in coredata.findall('{http://www.elsevier.com/xml/svapi/abstract/dtd}link'):
    if link.attrib['rel'] == 'scopus':
        print link.attrib['href']
    else:
        print link.attrib['href']

# alternative xpath to get the link
print coredata.find("./{http://www.elsevier.com/xml/svapi/abstract/dtd}link/[@rel='scopus']").attrib['href']
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
j
22746
{'auid': '55569461200', 'seq': '1'}
Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces
Catalysis Communications
52
60-64
2014-07-05
2
10.1016/j.catcom.2013.10.028
http://api.elsevier.com/content/abstract/scopus_id/84901638552
http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward
http://api.elsevier.com/content/search/scopus?query=refeid%282-s2.0-84901638552%29
http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward
#+END_HTML

That is basically it. In the next sections, we basically recreate the previous functions from scopus.py using the xml data.

** Authors
#+BEGIN_SRC python :tangle scopus_xml.py
def get_author_link(EID):
    results = get_abstract_info(EID)
    authors = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors')
    if authors is None:
        return 'No authors found'
    s = []

    for author in authors:
        name = author.find('{http://www.elsevier.com/xml/ani/common}indexed-name').text
        auid = author.attrib['auid']
        s += ['<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId={0}">{1}</a>'.format(auid, name)]

    return ', '.join(s)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from scopus_xml import *
print get_author_link('2-s2.0-84896759135')
print get_author_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
: <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8724572500">Thompson R.L.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=22981503200">Shi W.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6506329719">Albenze E.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23004637900">Kusuma V.A.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55676869000">Hopkinson D.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Damodaran K.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Lee A.S.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">Luebke D.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Nulwala H.</a>
: <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>

** Journal

#+BEGIN_SRC python :tangle scopus_xml.py
def get_journal_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

    journal = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}publicationName').text
    sid = coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}source-id').text
    s = '<a href="http://www.scopus.com/source/sourceInfo.url?sourceId={sid}">{journal}</a>'

    return s.format(sid=sid, journal=journal)
#+END_SRC

#+BEGIN_SRC python
from scopus_xml import *
print get_journal_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
: <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>

** DOI link

#+BEGIN_SRC python :tangle scopus_xml.py
def get_doi_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    doi = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi')
    if doi is not None: doi = doi.text
    s = '<a href="http://dx.doi.org/{doi}">doi:{doi}</a>'
    return s.format(doi=doi)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_doi_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>
#+END_HTML

** Abstract link

#+BEGIN_SRC python  :tangle scopus_xml.py
def get_abstract_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

    data = get_abstract_info(EID)

    title = coredata.find('{http://purl.org/dc/elements/1.1/}title').text.encode('utf-8')
    link = coredata.find("./{http://www.elsevier.com/xml/svapi/abstract/dtd}link/[@rel='scopus']").attrib['href'].encode('utf-8')
    s = '<a href="{link}">{title}</a>'
    return s.format(link=link, title=title)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_abstract_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a>
#+END_HTML

** Citation image

#+BEGIN_SRC python :tangle scopus_xml.py
def get_cite_img_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    doi = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi')
    if doi is not None: doi = doi.text
    s = '<img src="http://api.elsevier.com/content/abstract/citation-count?doi={doi}&httpAccept=image/jpeg&apiKey={apikey}"></img>'

    return s.format(doi=doi, apikey=MY_API_KEY, cite_link=None)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_cite_img_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

** Getting it all together

#+BEGIN_SRC python :tangle scopus_xml.py
def get_html_citation(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    s = '{authors}, <i>{title}</i>, {journal}, <b>{volume}{issue}</b>, {pages}, ({year}), {doi}, {cites}.'

    issue = ''
    if coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}issueIdentifier') is not None:
        issue = '({})'.format(    coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}issueIdentifier').text)

    volume = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume')
    if volume is not None:
        volume = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume').text
    else:
        volume = 'None'

    pages = ''
    if coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange') is not None:
        pages = 'p. ' + coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange').text
    elif coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}article-number') is not None:
        pages = coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}article-number').text
    else:
        pages = 'no pages found'


    year = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}coverDate').text

    return s.format(authors=get_author_link(EID),
                    title=get_abstract_link(EID),
                    journal=get_journal_link(EID),
                    volume=volume,
                    issue=issue,
                    pages=pages,
                    year=year,
                    doi=get_doi_link(EID),
                    cites=get_cite_img_link(EID))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus_xml import *
print '<ol>'
print '<li>',get_html_citation('2-s2.0-84896759135'),'</li>'
print
print '<li>',get_html_citation('2-s2.0-84924911828'),'</li>'
print
print '<li>',get_html_citation('2-s2.0-84901638552'),'</li>'
print '</ol>'
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<ol>
<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8724572500">Thompson R.L.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=22981503200">Shi W.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6506329719">Albenze E.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23004637900">Kusuma V.A.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55676869000">Hopkinson D.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Damodaran K.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Lee A.S.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">Luebke D.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Nulwala H.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84896759135&origin=inward">Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=21100199840">RSC Advances</a>, <b>4(25)</b>, p. 12748-12755, (2014-03-17), <a href="http://dx.doi.org/10.1039/c3ra47097k">doi:10.1039/c3ra47097k</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/c3ra47097k&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>

<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924911828&origin=inward">Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=28134">Journal of Chemical Physics</a>, <b>142(10)</b>, 104703, (2015-03-14), <a href="http://dx.doi.org/10.1063/1.4914093">doi:10.1063/1.4914093</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4914093&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>

<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>
</ol>
#+END_HTML


** Finally getting my documents

Here we get the EIDs from a search query. We use these in the next section to get a new bibliography.

#+BEGIN_SRC python :results value
import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=eid,aggregationType&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

return [[str(r['eid']), str(r['prism:aggregationType'])] for r in results['search-results']["entry"] if str(r['prism:aggregationType']) == 'Journal']
#+END_SRC


#+tblname: my-eids
| 2-s2.0-84924911828 | Journal |
| 2-s2.0-84923164062 | Journal |
| 2-s2.0-84924778427 | Journal |
| 2-s2.0-84924130725 | Journal |
| 2-s2.0-84901638552 | Journal |
| 2-s2.0-84898934670 | Journal |
| 2-s2.0-84896759135 | Journal |
| 2-s2.0-84896380535 | Journal |
| 2-s2.0-84896585411 | Journal |
| 2-s2.0-84916613197 | Journal |
| 2-s2.0-84908637059 | Journal |
| 2-s2.0-84880986072 | Journal |
| 2-s2.0-84881394200 | Journal |
| 2-s2.0-84873706643 | Journal |
| 2-s2.0-84876703352 | Journal |
| 2-s2.0-84867809683 | Journal |
| 2-s2.0-84864914806 | Journal |
| 2-s2.0-84865730756 | Journal |
| 2-s2.0-84864592302 | Journal |
| 2-s2.0-84863684845 | Journal |
| 2-s2.0-84866142469 | Journal |
| 2-s2.0-84861127526 | Journal |
| 2-s2.0-80052944171 | Journal |
| 2-s2.0-80051809046 | Journal |
| 2-s2.0-79953651013 | Journal |
| 2-s2.0-79952860396 | Journal |
| 2-s2.0-77956568341 | Journal |
| 2-s2.0-77954747189 | Journal |
| 2-s2.0-77956693843 | Journal |
| 2-s2.0-77949916234 | Journal |
| 2-s2.0-77955464573 | Journal |
| 2-s2.0-72049114200 | Journal |
| 2-s2.0-73149124752 | Journal |
| 2-s2.0-73149109096 | Journal |
| 2-s2.0-67449106405 | Journal |
| 2-s2.0-63649114440 | Journal |
| 2-s2.0-60849113132 | Journal |
| 2-s2.0-58649114498 | Journal |
| 2-s2.0-40949100780 | Journal |
| 2-s2.0-33750804660 | Journal |
| 2-s2.0-20544467859 | Journal |
| 2-s2.0-15744396507 | Journal |
| 2-s2.0-9744261716  | Journal |
| 2-s2.0-13444307808 | Journal |
| 2-s2.0-3042820285  | Journal |
| 2-s2.0-2942640180  | Journal |
| 2-s2.0-0142023762  | Journal |
| 2-s2.0-0141924604  | Journal |
| 2-s2.0-0037368024  | Journal |
| 2-s2.0-0037197884  | Journal |

** And my html bibliography
This generates my blog bibliography page..
#+BEGIN_SRC python
from scopus_xml import *

import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=eid,aggregationType&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

data = [[str(r['eid']), str(r['prism:aggregationType'])] for r in
        results['search-results']["entry"] if str(r['prism:aggregationType']) == 'Journal']


with open('../publications.html.mako', 'w') as f:
    f.write('''<%inherit file="_templates/site.mako" />
<article class="page_box">
<%self:filter chain="markdown">

<h1>Online collections of our work</h1>
Pick your favorite:
<ul>
<li><a href="http://orcid.org/0000-0003-2625-9232">orcid:0000-0003-2625-9232</a></li>

<li><a href="http://www.researcherid.com/rid/A-2363-2010">researcherid:A-2363-2010</a></li>

<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a></li>

<li><a href="https://scholar.google.com/citations?user=jD_4h7sAAAAJ">Google Scholar</a></li>

<li><a href="https://www.researchgate.net/profile/John_Kitchin">Research Gate</a></li>

<li><a href="https://www.growkudos.com/profiles/40205">Kudos</a></li>
</ul>

<h1>Publications</h1>
The authors are linked to their Scopus page, the title linked to the Scopus abstract, the journal linked to the Scopus journal page, and the DOI is linked to http://dx.doi.org which normally redirects you to the journal page.

<ol reversed="reversed">
''')

    for eid,type in data:
        f.write('<li>{}</li>'.format(get_html_citation(eid)))
    f.write('''</ol>

</%self:filter>
</article>
''')
#+END_SRC

** Summary
The XML format is not that intuitive to me. It takes some practice writing robust code, e.g. sometimes the find command does not find anything, and then there is not text attribute to get, so you should check for success on finding things. Also, some text is unicode, and you have to take care to encode it, which my library does not do uniformly. Finally, not all journals have things like volume or issue. My formatting code is not super flexible, so these bibliography entries show None in them occasionally. Still, it is not too bad, and this enables a lot of analysis of your publications, as well as displaying them in different ways. See the result of this page here: http://kitchingroup.cheme.cmu.edu/publications.html



* DONE Making highly linked bibliographies from the Scopus API
  CLOSED: [2015-04-04 Sat 11:32]
  :PROPERTIES:
  :categories: python,scopus
  :date:     2015/04/04 11:32:05
  :updated:  2015/04/04 11:32:05
  :END:

A given article entry in a bibliography might have the following kinds of links in it. I think we can generate these from a Scopus query.

- Author page: http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771
- [[https://www.scopus.com/record/display.url?eid=2-s2.0-84901638552&origin=resultslist&sort=plf-f&src=s&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a50&sot=autdocs&sdt=autdocs&sl=17&s=AU-ID%287004212771%29&relpos=4&relpos=4&citeCnt=2&searchTerm=][Document page]]
- Journal page: http://www.scopus.com/source/sourceInfo.url?sourceId=22746&origin=resultslist
- [[https://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=2-s2.0-84901638552&src=s&imp=t&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a230&sot=cite&sdt=a&sl=0&origin=resultslist&editSaveSearch=&txGid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a23][Cited by]]
- http://dx.doi.org/10.1016/j.catcom.2013.10.028
- [[https://www.scopus.com/results/citedbyresults.url?sort=r-f&src=s&mltEid=2-s2.0-84901638552&mltType=ref&mltAll=t&imp=t&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a290&sot=mlt&sdt=mlt&sl=730&s=REFEID%28%28%222-s2.0-79953651013%22%29+OR+%28%222-s2.0-84855602300%22%29+OR+%28%222-s2.0-33750453016%22%29+OR+%28%222-s2.0-33645349847%22%29+OR+%28%222-s2.0-0034814842%22%29+OR+%28%222-s2.0-77955464573%22%29+OR+%28%222-s2.0-13444307808%22%29+OR+%28%222-s2.0-53349153662%22%29+OR+%28%222-s2.0-80051809046%22%29+OR+%28%222-s2.0-84876703352%22%29+OR+%28%222-s2.0-80053316882%22%29+OR+%28%222-s2.0-83255187152%22%29+OR+%28%222-s2.0-80052944171%22%29+OR+%28%222-s2.0-84865730756%22%29+OR+%28%222-s2.0-0000778362%22%29+OR+%28%222-s2.0-60349090198%22%29+OR+%28%222-s2.0-2442537377%22%29+OR+%28%222-s2.0-0030190741%22%29+OR+%28%222-s2.0-25744460922%22%29+OR+%28%222-s2.0-0011236321%22%29+OR+%28%222-s2.0-4243943295%22%29+OR+%28%222-s2.0-4944232881%22%29+OR+%28%222-s2.0-1842816907%22%29+OR+%28%222-s2.0-33646343022%22%29+OR+%28%222-s2.0-4143079428%22%29+OR+%28%222-s2.0-77954807118%22%29+OR+%28%222-s2.0-11544320930%22%29%29+AND+NOT+EID+%282-s2.0-84901638552%29&origin=resultslist&txGid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a29][Related articles]]

We are going to look at the document above, with eid=2-s2.0-84901638552. This is another long post, so here is a teaser of what we are doing. For this eid, we want to generate an html entry where each part of the entry is clickable. Here is what we will be able to do by the end of this post:

#+BEGIN_SRC python :results html
from scopus import *

print '<ol>', get_html('2-s2.0-84901638552'), '</ol>'
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<ol> <li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>.</li> </ol>
#+END_HTML

In this post, we work out code that works for this document. This code in the form shown here might not work on all entries, e.g. for ones that are in press and are missing data, or for APS journals that have no page range. Later, I will fix those so this is more robust. To minimize repeating the code below, I create a python module here called [[./scopus.py]].  Tangle it out with elisp:org-babel-tangle. As in the last [[http://kitchingroup.cheme.cmu.edu/blog/2015/04/03/Getting-data-from-the-Scopus-API/][post]], I am not sharing my API key here, since it is not clear if that key is private or not.

I like json, so we use that data format here. XML would be more robust, as the Scopus site admits not all of the data can be turned into the json format, but for now we stick to json for its simplicity.

#+BEGIN_SRC python :tangle scopus.py
import requests
import json, os
from my_scopus import MY_API_KEY

def get_abstract_info(EID, refresh=False):
    'Get and save the json data for EID.'
    base = 'scopus-data/get_abstract_info'
    if not os.path.exists(base):
        os.makedirs(base)

    fname = '{0}/{1}'.format(base, EID)
    if os.path.exists(fname) and not refresh:
        with open(fname) as f:
            return json.loads(f.read())

    # Otherwise retrieve and save results
    url = ("http://api.elsevier.com/content/abstract/eid/" + EID)
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})
    results = json.loads(resp.text.encode('utf-8'))
    with open(fname, 'w') as f:
        f.write(json.dumps(results))

    return results
#+END_SRC

** Author pages
Here, we generate the html that will make each author a clickable link that goes to their Scopus ID author page.

#+BEGIN_SRC python :tangle scopus.py

def get_author_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    html = '<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId={0}">{1}</a>'
    authors = [html.format(auid, name) for auid, name in
               zip([x['@auid'] for x in result['authors']['author']],
                   [x['ce:indexed-name'] for x in result['authors']['author']])]

    return ','.join(authors)

#+END_SRC


#+BEGIN_SRC python :results html
from scopus import *
print get_author_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>
#+END_HTML

** Journal link
The most important pieces of information we need is the journal name and the source-id from the coredata.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']
print result['coredata']['source-id']
print result['coredata']['prism:publicationName']
#+END_SRC

#+RESULTS:
: 22746
: Catalysis Communications

#+BEGIN_SRC python :tangle scopus.py
def get_journal_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    sid = result['coredata']['source-id']
    journal = result['coredata']['prism:publicationName']
    s = '<a href="http://www.scopus.com/source/sourceInfo.url?sourceId={sid}">{journal}</a>'

    return s.format(sid=sid, journal=journal)

#+END_SRC

#+BEGIN_SRC python :results html
from scopus import *
print get_journal_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>
#+END_HTML

** DOI link
It would be helpful to have a doi link, which is actually independent of Scopus so people without Scopus access can still access information.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']
print result['coredata']['prism:doi']
#+END_SRC

#+RESULTS:
: 10.1016/j.catcom.2013.10.028

#+BEGIN_SRC python :tangle scopus.py
def get_doi_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    s = '<a href="http://dx.doi.org/{doi}">doi:{doi}</a>'
    return s.format(doi=result['coredata']['prism:doi'])
#+END_SRC


#+BEGIN_SRC python :results html
from scopus import *
print get_doi_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>
#+END_HTML

** Citation count image
It is nice to show impact of a paper by showing the citations. These change with time, so a static view is not ideal. Scopus provides a way to get an image they generate that should update when viewed. We need the doi to get that.

#+BEGIN_SRC python :tangle scopus.py
def get_cite_img_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    s = '<img src="http://api.elsevier.com/content/abstract/citation-count?doi={doi}&httpAccept=image/jpeg&apiKey={apikey}"></img>'
    return s.format(doi=result['coredata']['prism:doi'].strip(), apikey=MY_API_KEY)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus import *
print get_cite_img_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

** The document link
The document link is sort of buried in the coredata. It seems like & has been replaced by &amp; in the json data so we have to do a clunky fix here.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']

print result['coredata']['dc:title']
for ref in result['coredata']['link']:
    if ref['@rel'] == 'scopus':
        print ref['@href'].replace('&amp;', '&')
        break
#+END_SRC

#+RESULTS:
: Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces
: http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward

#+BEGIN_SRC python :tangle scopus.py
def get_abstract_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    title = result['coredata']['dc:title']
    for ref in result['coredata']['link']:
        if ref['@rel'] == 'scopus':
            link = ref['@href'].replace('&amp;', '&')

    s = '<a href="{link}">{title}</a>'
    return s.format(link=link, title=title)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus import *
print get_abstract_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a>
#+END_HTML

** Putting it all together
Our goal is ultimately an html formatted citation where nearly every piece is a hyperlink to additional information, e.g. each author is linked to their page, the title is linked to the scopus document page, the journal is linked to the scopus journal page, a DOI link, and an image of the number of citations. Here it is.

#+BEGIN_SRC python :tangle scopus.py
def get_html(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']

    s = '<li>{authors}, <i>{title}</i>, {journal}, <b>{volume}{issue}</b>, p. {pages}, ({year}), {doi}, {cites}.</li>'

    issue = ''
    if result['coredata'].get('prism:issue'):
        issue = '({})'.format(result['coredata'].get('prism:issue'))
    return s.format(authors=get_author_link(EID),
                    title=get_abstract_link(EID),
                    journal=get_journal_link(EID),
                    volume=result['coredata'].get('prism:volume'),
                    issue=issue,
                    pages=result['coredata'].get('prism:pageRange'),
                    year=result['coredata'].get('prism:coverDate'),
                    doi=get_doi_link(EID),
                    cites=get_cite_img_link(EID))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :results html
from scopus import *
print get_html('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>.</li>
#+END_HTML


Well, that is the end for now. We have a reusable function that generates a nice HTML formatted citation that links out to many different resources. Why aren't all citations on the web this helpful?
* DONE Getting data from the Scopus API
  CLOSED: [2015-04-03 Fri 15:17]
  :PROPERTIES:
  :categories: python,scopus
  :date:     2015/04/03 15:17:27
  :updated:  2015/04/03 15:19:45
  :END:

I have been exploring the Scopus API (http://dev.elsevier.com/index.html) lately. This is a RESTful API that allows you to retrieve data about publications via http requests, i.e. from a script. This service is not free; you need to be at an institution that has a Scopus license.

Scopus is very good at finding your papers, and associating them with a Scopus ID. You don't have to do anything to get one, they make it. I have a Scopus ID (http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771) that has all this data via the web, but I wanted to get this data in a tabular form I could use and analyze. Sure you can download a CSV file from that page and analyze that, but I want to script it. I am just like that ;) To use the API, you need to get an API key (http://www.developers.elsevier.com/action/devprojects). I still cannot figure out if this key is "private" so I am not going to share mine here. I have stored it in a python file called my_scopus.py, and I will import it in these examples.

The code below is "wide", so apologies in advance that some of it will run out of the usual area it belongs.

** About me from Scopus
There is an author API that provides a metrics view of a Scopus ID. Here this shows there are about 77 documents for me, cited about 3028 times. Why do I say "about"? Apparently there are two different databases that Scopus uses, one for the web, and one for this API, and they do not return the same data. It is close, but not the same. The API database includes thing that are published after 1995, and it may not be updated as quickly as the web database. For example the web page reports 79 documents and 3143 citations. In the next sections we will use the search API, which returns the same information as what is on the web. Here we just illustrate how to setup an http request in Python. I like json output, so we ask for it.

#+BEGIN_SRC python
import requests
import json
from my_scopus import MY_API_KEY

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18"
        }
    ]
}
#+end_example

** Get my documents from Scopus
To find my documents, we will use the Search API, http://api.elsevier.com/documentation/SCOPUSSearchAPI.wadl. We specify a Scopus ID, and to limit the quantity of data that comes back we specify that we want the dc:identifier field, which corresponds to the scopus id for each document. We will use that in the next section to get info for each document.

#+name: identifiers
#+BEGIN_SRC python :results value
import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=dc:identifier&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

return [[str(r['dc:identifier'])] for r in results['search-results']["entry"]]
#+END_SRC

#+RESULTS: identifiers
| SCOPUS_ID:84924911828 |
| SCOPUS_ID:84923164062 |
| SCOPUS_ID:84924778427 |
| SCOPUS_ID:84924130725 |
| SCOPUS_ID:84901638552 |
| SCOPUS_ID:84898934670 |
| SCOPUS_ID:84896759135 |
| SCOPUS_ID:84896380535 |
| SCOPUS_ID:84896585411 |
| SCOPUS_ID:84916613197 |
| SCOPUS_ID:84908637059 |
| SCOPUS_ID:84880986072 |
| SCOPUS_ID:84881394200 |
| SCOPUS_ID:84873706643 |
| SCOPUS_ID:84876703352 |
| SCOPUS_ID:84872843990 |
| SCOPUS_ID:84872872509 |
| SCOPUS_ID:84872845400 |
| SCOPUS_ID:84872841108 |
| SCOPUS_ID:84872855250 |
| SCOPUS_ID:84872864754 |
| SCOPUS_ID:84886483703 |
| SCOPUS_ID:84872854676 |
| SCOPUS_ID:84867809683 |
| SCOPUS_ID:84864914806 |
| SCOPUS_ID:84865730756 |
| SCOPUS_ID:84864592302 |
| SCOPUS_ID:84863684845 |
| SCOPUS_ID:84866142469 |
| SCOPUS_ID:84861127526 |
| SCOPUS_ID:84857224144 |
| SCOPUS_ID:84857197729 |
| SCOPUS_ID:84856818654 |
| SCOPUS_ID:80052944171 |
| SCOPUS_ID:80051860134 |
| SCOPUS_ID:80051809046 |
| SCOPUS_ID:79953651013 |
| SCOPUS_ID:79952860396 |
| SCOPUS_ID:79951537083 |
| SCOPUS_ID:79251517782 |
| SCOPUS_ID:77956568341 |
| SCOPUS_ID:77954747189 |
| SCOPUS_ID:77956693843 |
| SCOPUS_ID:77949916234 |
| SCOPUS_ID:77955464573 |
| SCOPUS_ID:72049114200 |
| SCOPUS_ID:78649528829 |
| SCOPUS_ID:78649504144 |
| SCOPUS_ID:77952266872 |
| SCOPUS_ID:73149124752 |
| SCOPUS_ID:73149109096 |
| SCOPUS_ID:67449106405 |
| SCOPUS_ID:63649114440 |
| SCOPUS_ID:60849113132 |
| SCOPUS_ID:58649114498 |
| SCOPUS_ID:79952218110 |
| SCOPUS_ID:79952292116 |
| SCOPUS_ID:78049295221 |
| SCOPUS_ID:79952296916 |
| SCOPUS_ID:79952225819 |
| SCOPUS_ID:78049231913 |
| SCOPUS_ID:79952234104 |
| SCOPUS_ID:79952301915 |
| SCOPUS_ID:45149129361 |
| SCOPUS_ID:40949100780 |
| SCOPUS_ID:37349101648 |
| SCOPUS_ID:58049109348 |
| SCOPUS_ID:33750804660 |
| SCOPUS_ID:33645645065 |
| SCOPUS_ID:20544467859 |
| SCOPUS_ID:15744396507 |
| SCOPUS_ID:9744261716  |
| SCOPUS_ID:13444307808 |
| SCOPUS_ID:3042820285  |
| SCOPUS_ID:2942640180  |
| SCOPUS_ID:0142023762  |
| SCOPUS_ID:0141924604  |
| SCOPUS_ID:0037368024  |
| SCOPUS_ID:0037197884  |


** Retrieve info for a document
Here, we work out how to retrieve data for a document. We use the Abstract API (http://api.elsevier.com/documentation/AbstractRetrievalAPI.wadl). We again use a field to limit the amount of data. Here is an example that works for an article. Scopus also lists books and conferences so, we will see how that works later. Note the unicode stuff. I was getting some errors about non-ascii characters causing the json file not to read, and then issues in constructing the string. This was only a problem for some entries.

#+BEGIN_SRC python
import requests
import json
from my_scopus import MY_API_KEY

def get_scopus_info(SCOPUS_ID):
    url = ("http://api.elsevier.com/content/abstract/scopus_id/"
          + SCOPUS_ID
          + "?field=authors,title,publicationName,volume,issueIdentifier,"
          + "prism:pageRange,coverDate,article-number,doi,citedby-count,prism:aggregationType")
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})
    results = json.loads(resp.text.encode('utf-8'))

    fstring = '{authors}, {title}, {journal}, {volume}, {articlenum}, ({date}). {doi} (cited {cites} times).\n'
    return fstring.format(authors=', '.join([au['ce:indexed-name'] for au in results['abstracts-retrieval-response']['authors']['author']]),
                          title=results['abstracts-retrieval-response']['coredata']['dc:title'].encode('utf-8'),
                          journal=results['abstracts-retrieval-response']['coredata']['prism:publicationName'].encode('utf-8'),
                          volume=results['abstracts-retrieval-response']['coredata']['prism:volume'].encode('utf-8'),
                          articlenum=(results['abstracts-retrieval-response']['coredata'].get('prism:pageRange') or
                              results['abstracts-retrieval-response']['coredata'].get('article-number')).encode('utf-8'),
                          date=results['abstracts-retrieval-response']['coredata']['prism:coverDate'].encode('utf-8'),
                          doi='doi:' + results['abstracts-retrieval-response']['coredata']['prism:doi'].encode('utf-8'),
                          cites=int(results['abstracts-retrieval-response']['coredata']['citedby-count'].encode('utf-8')))



print get_scopus_info('SCOPUS_ID:0037368024')
#+END_SRC

#+RESULTS:
: Kitchin J.R., Barteau M.A., Chen J.G., A comparison of gold and molybdenum nanoparticles on TiO2(1 1 0) 1  2 reconstructed single crystal surfaces, Surface Science, 526, 323-331, (2003-03-01). doi:10.1016/S0039-6028(02)02679-1 (cited 27 times).
:


** Get information for all documents
We will use the data we previously got in the long list of Scopus IDs. A few subtle points here are that I made that a nested list so it would print as a column, and so we will have to index each entry to get the scopus id. Also, it seems that some entries generate json that cannot be parsed by python, so we wrap this in a try block and skip those entries. We need to check for the entry being a Journal article, to avoid errors with our format string. We also need to accomodate journals that do not have page ranges, but have artice numbers instead. Finally, we will format each entry so there is some html code for it.

#+BEGIN_SRC python :var scopus_ids=identifiers :results html
import requests
import json
import textwrap
from my_scopus import MY_API_KEY

def get_scopus_info(SCOPUS_ID):
    url = ("http://api.elsevier.com/content/abstract/scopus_id/"
          + SCOPUS_ID
          + "?field=authors,title,publicationName,volume,issueIdentifier,"
          + "prism:pageRange,coverDate,article-number,doi,citedby-count,prism:aggregationType")
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

    return json.loads(resp.text.encode('utf-8'))


i = 0
for sid in scopus_ids:
    # some entries seem to have json parse errors, so we catch those
    try:
        results = get_scopus_info(sid[0])  # index 0 because the input data is a 2d array
        if results['abstracts-retrieval-response']['coredata']['prism:aggregationType'] == 'Journal':
            i += 1
            fstring = '{authors}, {title}, {journal}, {volume}, {articlenum}, ({date}). <a href="http://dx.doi.org/{doi}">{doi}</a> (cited {cites} times)\n\n'

            s = fstring.format(authors=', '.join([au['ce:indexed-name'].encode('utf-8') for au in results['abstracts-retrieval-response']['authors']['author']]),
                               title=results['abstracts-retrieval-response']['coredata']['dc:title'].encode('utf-8'),
                               journal=results['abstracts-retrieval-response']['coredata']['prism:publicationName'].encode('utf-8'),
                               volume=results['abstracts-retrieval-response']['coredata'].get('prism:volume', 'None').encode('utf-8'),
                               articlenum=str((results['abstracts-retrieval-response']['coredata'].get('prism:pageRange') or
                                           results['abstracts-retrieval-response']['coredata'].get('article-number'))).encode('utf-8'),
                               date=results['abstracts-retrieval-response']['coredata']['prism:coverDate'].encode('utf-8'),
                               doi='doi:' + results['abstracts-retrieval-response']['coredata']['prism:doi'].encode('utf-8'),
                               cites=int(results['abstracts-retrieval-response']['coredata']['citedby-count'].encode('utf-8')))
            print '{0:3d}. {1}<br>'.format(i, s)
    except:
        print '{0:3d}. {1}'.format(i, sid)
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
  1. Xu Z., Kitchin J.R., Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides, Journal of Chemical Physics, 142, 104703, (2015-03-14). <a href="http://dx.doi.org/doi:10.1063/1.4914093">doi:10.1063/1.4914093</a> (cited 0 times)

<br>
  2. Boes J.R., Gumuslu G., Miller J.B., Gellman A.J., Kitchin J.R., Estimating bulk-composition-dependent H2 adsorption energies on CuxPd1- x alloy (111) surfaces, ACS Catalysis, 5, 1020-1026, (2015-02-06). <a href="http://dx.doi.org/doi:10.1021/cs501585k">doi:10.1021/cs501585k</a> (cited 0 times)

<br>
  3. Boes J.R., Kondratyuk P., Yin C., Miller J.B., Gellman A.J., Kitchin J.R., Core level shifts in Cu-Pd alloys as a function of bulk composition and structure, Surface Science, None, None, (2015-01-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2015.02.011">doi:10.1016/j.susc.2015.02.011</a> (cited 0 times)

<br>
  4. Xu Z., Rossmeisl J., Kitchin J.R., A linear response DFT+U study of trends in the oxygen evolution activity of transition metal rutile dioxides, Journal of Physical Chemistry C, 119, 4827-4833, (2015-01-01). <a href="http://dx.doi.org/doi:10.1021/jp511426q">doi:10.1021/jp511426q</a> (cited 0 times)

<br>
  5. Xu Z., Kitchin J.R., Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces, Catalysis Communications, 52, 60-64, (2014-07-05). <a href="http://dx.doi.org/doi:10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a> (cited 2 times)

<br>
  6. Demeter E.L., Hilburg S.L., Washburn N.R., Collins T.J., Kitchin J.R., Electrocatalytic oxygen evolution with an immobilized TAML activator, Journal of the American Chemical Society, 136, 5603-5606, (2014-04-16). <a href="http://dx.doi.org/doi:10.1021/ja5015986">doi:10.1021/ja5015986</a> (cited 4 times)

<br>
  7. Thompson R.L., Shi W., Albenze E., Kusuma V.A., Hopkinson D., Damodaran K., Lee A.S., Kitchin J.R., Luebke D.R., Nulwala H., Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids, RSC Advances, 4, 12748-12755, (2014-03-17). <a href="http://dx.doi.org/doi:10.1039/c3ra47097k">doi:10.1039/c3ra47097k</a> (cited 1 times)

<br>
  8. Mehta P., Salvador P.A., Kitchin J.R., Identifying potential BO2 oxide polymorphs for epitaxial growth candidates, ACS Applied Materials and Interfaces, 6, 3630-3639, (2014-03-12). <a href="http://dx.doi.org/doi:10.1021/am4059149">doi:10.1021/am4059149</a> (cited 0 times)

<br>
  9. Miller S.D., Pushkarev V.V., Gellman A.J., Kitchin J.R., Simulating temperature programmed desorption of oxygen on Pt(111) using DFT derived coverage dependent desorption barriers, Topics in Catalysis, 57, 106-117, (2014-02-01). <a href="http://dx.doi.org/doi:10.1007/s11244-013-0166-3">doi:10.1007/s11244-013-0166-3</a> (cited 2 times)

<br>
 10. Curnan M.T., Kitchin J.R., Effects of concentration, crystal structure, magnetism, and electronic structure method on first-principles oxygen vacancy formation energy trends in perovskites, Journal of Physical Chemistry C, 118, 28776-28790, (2014-01-01). <a href="http://dx.doi.org/doi:10.1021/jp507957n">doi:10.1021/jp507957n</a> (cited 2 times)

<br>
 11. Xu Z., Kitchin J.R., Probing the coverage dependence of site and adsorbate configurational correlations on (111) surfaces of late transition metals, Journal of Physical Chemistry C, 118, 25597-25602, (2014-01-01). <a href="http://dx.doi.org/doi:10.1021/jp508805h">doi:10.1021/jp508805h</a> (cited 0 times)

<br>
 12. Lee A.S., Eslick J.C., Miller D.C., Kitchin J.R., Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach, International Journal of Greenhouse Gas Control, 18, 68-74, (2013-10-01). <a href="http://dx.doi.org/doi:10.1016/j.ijggc.2013.06.020">doi:10.1016/j.ijggc.2013.06.020</a> (cited 3 times)

<br>
 13. Hallenbeck A.P., Kitchin J.R., Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent, Industrial and Engineering Chemistry Research, 52, 10788-10794, (2013-08-07). <a href="http://dx.doi.org/doi:10.1021/ie400582a">doi:10.1021/ie400582a</a> (cited 7 times)

<br>
 13. ['SCOPUS_ID:84873706643']
 14. Calle-Vallejo F., Inoglu N.G., Su H.-Y., Martinez J.I., Man I.C., Koper M.T.M., Kitchin J.R., Rossmeisl J., Number of outer electrons as descriptor for adsorption processes on transition metals and their oxides, Chemical Science, 4, 1245-1249, (2013-03-01). <a href="http://dx.doi.org/doi:10.1039/c2sc21601a">doi:10.1039/c2sc21601a</a> (cited 16 times)

<br>
 15. Lee A.S., Kitchin J.R., Chemical and molecular descriptors for the reactivity of amines with CO
                    2 , Industrial and Engineering Chemistry Research, 51, 13609-13618, (2012-10-24). <a href="http://dx.doi.org/doi:10.1021/ie301419q">doi:10.1021/ie301419q</a> (cited 3 times)

<br>
 16. Rubin E.S., Mantripragada H., Marks A., Versteeg P., Kitchin J., The outlook for improved carbon capture technology, Progress in Energy and Combustion Science, 38, 630-671, (2012-10-01). <a href="http://dx.doi.org/doi:10.1016/j.pecs.2012.03.003">doi:10.1016/j.pecs.2012.03.003</a> (cited 91 times)

<br>
 17. Akhade S.A., Kitchin J.R., Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces, Journal of Chemical Physics, 137, 084703, (2012-08-28). <a href="http://dx.doi.org/doi:10.1063/1.4746117">doi:10.1063/1.4746117</a> (cited 8 times)

<br>
 18. Landon J., Demeter E., Inoglu N., Keturakis C., Wachs I.E., Vasic R., Frenkel A.I., Kitchin J.R., Spectroscopic characterization of mixed Fe-Ni oxide electrocatalysts for the oxygen evolution reaction in alkaline electrolytes, ACS Catalysis, 2, 1793-1801, (2012-08-03). <a href="http://dx.doi.org/doi:10.1021/cs3002644">doi:10.1021/cs3002644</a> (cited 39 times)

<br>
 19. Chao R., Munprom R., Petrova R., Gerdes K., Kitchin J.R., Salvador P.A., Structure and relative thermal stability of mesoporous (La, Sr) MnO 3powders prepared using evaporation-induced self-assembly methods, Journal of the American Ceramic Society, 95, 2339-2346, (2012-07-01). <a href="http://dx.doi.org/doi:10.1111/j.1551-2916.2012.05236.x">doi:10.1111/j.1551-2916.2012.05236.x</a> (cited 4 times)

<br>
 20. Kitchin J., Preface: Trends in computational catalysis, Topics in Catalysis, 55, 227-228, (2012-06-01). <a href="http://dx.doi.org/doi:10.1007/s11244-012-9808-0">doi:10.1007/s11244-012-9808-0</a> (cited 0 times)

<br>
 21. Alesi W.R., Kitchin J.R., Evaluation of a primary amine-functionalized ion-exchange resin for CO
                    2 capture, Industrial and Engineering Chemistry Research, 51, 6907-6915, (2012-05-16). <a href="http://dx.doi.org/doi:10.1021/ie300452c">doi:10.1021/ie300452c</a> (cited 15 times)

<br>
 22. Akhade S.A., Kitchin J.R., Effects of strain, d-band filling, and oxidation state on the bulk electronic structure of cubic 3d perovskites, Journal of Chemical Physics, 135, 104702, (2011-09-14). <a href="http://dx.doi.org/doi:10.1063/1.3631948">doi:10.1063/1.3631948</a> (cited 3 times)

<br>
 23. Man I.C., Su H.-Y., Calle-Vallejo F., Hansen H.A., Martinez J.I., Inoglu N.G., Kitchin J., Jaramillo T.F., Norskov J.K., Rossmeisl J., Universality in Oxygen Evolution Electrocatalysis on Oxide Surfaces, ChemCatChem, 3, 1159-1165, (2011-07-11). <a href="http://dx.doi.org/doi:10.1002/cctc.201000397">doi:10.1002/cctc.201000397</a> (cited 199 times)

<br>
 24. Inoglu N., Kitchin J.R., Identification of sulfur-tolerant bimetallic surfaces using dft parametrized models and atomistic thermodynamics, ACS Catalysis, 1, 399-407, (2011-04-01). <a href="http://dx.doi.org/doi:10.1021/cs200039t">doi:10.1021/cs200039t</a> (cited 9 times)

<br>
 25. Miller S.D., Inoglu N., Kitchin J.R., Configurational correlations in the coverage dependent adsorption energies of oxygen atoms on late transition metal fcc(111) surfaces, Journal of Chemical Physics, 134, 104709, (2011-03-14). <a href="http://dx.doi.org/doi:10.1063/1.3561287">doi:10.1063/1.3561287</a> (cited 16 times)

<br>
 26. Alesi Jr. W.R., Gray M., Kitchin J.R., CO2 adsorption on supported molecular amidine systems on activated carbon, ChemSusChem, 3, 948-956, (2010-08-01). <a href="http://dx.doi.org/doi:10.1002/cssc.201000056">doi:10.1002/cssc.201000056</a> (cited 18 times)

<br>
 27. Landon J., Kitchin J.R., Electrochemical concentration of carbon dioxide from an oxygen/carbon dioxide containing gas stream, Journal of the Electrochemical Society, 157, None, (2010-07-23). <a href="http://dx.doi.org/doi:10.1149/1.3432440">doi:10.1149/1.3432440</a> (cited 3 times)

<br>
 28. Inoglu N., Kitchin J.R., Simple model explaining and predicting coverage-dependent atomic adsorption energies on transition metal surfaces, Physical Review B - Condensed Matter and Materials Physics, 82, 045414, (2010-07-16). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.82.045414">doi:10.1103/PhysRevB.82.045414</a> (cited 14 times)

<br>
 29. Pennline H.W., Granite E.J., Luebke D.R., Kitchin J.R., Landon J., Weiland L.M., Separation of CO2 from flue gas using electrochemical cells, Fuel, 89, 1307-1314, (2010-06-01). <a href="http://dx.doi.org/doi:10.1016/j.fuel.2009.11.036">doi:10.1016/j.fuel.2009.11.036</a> (cited 20 times)

<br>
 30. Inoglu N., Kitchin J.R., New solid-state table: Estimating d-band characteristics for transition metal atoms, Molecular Simulation, 36, 633-638, (2010-06-01). <a href="http://dx.doi.org/doi:10.1080/08927022.2010.481794">doi:10.1080/08927022.2010.481794</a> (cited 16 times)

<br>
 31. Tierney H.L., Baber A.E., Kitchin J.R., Sykes E.C.H., Hydrogen dissociation and spillover on individual isolated palladium atoms, Physical Review Letters, 103, 246102, (2009-12-10). <a href="http://dx.doi.org/doi:10.1103/PhysRevLett.103.246102">doi:10.1103/PhysRevLett.103.246102</a> (cited 45 times)

<br>
 32. Miller S.D., Kitchin J.R., Uncertainty and figure selection for DFT based cluster expansions for oxygen adsorption on Au and Pt (111) surfaces, Molecular Simulation, 35, 920-927, (2009-09-01). <a href="http://dx.doi.org/doi:10.1080/08927020902833137">doi:10.1080/08927020902833137</a> (cited 14 times)

<br>
 33. Inolu N., Kitchin J.R., Sulphur poisoning of water-gas shift catalysts: Site blocking and electronic structure modification, Molecular Simulation, 35, 936-941, (2009-09-01). <a href="http://dx.doi.org/doi:10.1080/08927020902833129">doi:10.1080/08927020902833129</a> (cited 6 times)

<br>
 34. Kitchin J.R., Correlations in coverage-dependent atomic adsorption energies on Pd(111), Physical Review B - Condensed Matter and Materials Physics, 79, 205412, (2009-05-01). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.79.205412">doi:10.1103/PhysRevB.79.205412</a> (cited 26 times)

<br>
 35. Han J.W., Kitchin J.R., Sholl D.S., Step decoration of chiral metal surfaces, Journal of Chemical Physics, 130, 124710, (2009-04-08). <a href="http://dx.doi.org/doi:10.1063/1.3096964">doi:10.1063/1.3096964</a> (cited 11 times)

<br>
 36. Miller S.D., Kitchin J.R., Relating the coverage dependence of oxygen adsorption on Au and Pt fcc(1 1 1) surfaces through adsorbate-induced surface electronic structure effects, Surface Science, 603, 794-801, (2009-03-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2009.01.021">doi:10.1016/j.susc.2009.01.021</a> (cited 39 times)

<br>
 37. Inoglu N., Kitchin J.R., Atomistic thermodynamics study of the adsorption and the effects of water-gas shift reactants on Cu catalysts under reaction conditions, Journal of Catalysis, 261, 188-194, (2009-01-25). <a href="http://dx.doi.org/doi:10.1016/j.jcat.2008.11.020">doi:10.1016/j.jcat.2008.11.020</a> (cited 20 times)

<br>
 38. Kitchin J.R., Reuter K., Scheffler M., Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag3 Pd(111) in oxygen atmospheres, Physical Review B - Condensed Matter and Materials Physics, 77, 075437, (2008-02-29). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.77.075437">doi:10.1103/PhysRevB.77.075437</a> (cited 49 times)

<br>
 39. Norskov J.K., Bligaard T., Logadottir A., Kitchin J.R., Chen J.G., Pandelov S., Stimming U., Response to "comment on 'trends in the exchange current for hydrogen evolution' [J. Electrochem. Soc., 152, J23 (2005)]", Journal of the Electrochemical Society, 153, 054612JES, (2006-11-14). <a href="http://dx.doi.org/doi:10.1149/1.2358292">doi:10.1149/1.2358292</a> (cited 9 times)

<br>
 40. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Trends in the chemical properties of early transition metal carbide surfaces: A density functional study, Catalysis Today, 105, 66-73, (2005-07-15). <a href="http://dx.doi.org/doi:10.1016/j.cattod.2005.04.008">doi:10.1016/j.cattod.2005.04.008</a> (cited 70 times)

<br>
 41. Norskov J.K., Bligaard T., Logadottir A., Kitchin J.R., Chen J.G., Pandelov S., Stimming U., Trends in the exchange current for hydrogen evolution, Journal of the Electrochemical Society, 152, None, (2005-04-07). <a href="http://dx.doi.org/doi:10.1149/1.1856988">doi:10.1149/1.1856988</a> (cited 282 times)

<br>
 42. Norskov J.K., Rossmeisl J., Logadottir A., Lindqvist L., Kitchin J.R., Bligaard T., Jonsson H., Origin of the overpotential for oxygen reduction at a fuel-cell cathode, Journal of Physical Chemistry B, 108, 17886-17892, (2004-11-18). <a href="http://dx.doi.org/doi:10.1021/jp047349j">doi:10.1021/jp047349j</a> (cited 1055 times)

<br>
 43. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Role of strain and ligand effects in the modification of the electronic and chemical Properties of bimetallic surfaces, Physical Review Letters, 93, None, (2004-10-08). <a href="http://dx.doi.org/doi:10.1103/PhysRevLett.93.156801">doi:10.1103/PhysRevLett.93.156801</a> (cited 361 times)

<br>
 44. Mhadeshwar A.B., Kitchin J.R., Barteau M.A., Vlachos D.G., The role of adsorbate-adsorbate interactions in the rate controlling step and the most abundant reaction intermediate of NH 3 decomposition on RU, Catalysis Letters, 96, 13-22, (2004-07-01). <a href="http://dx.doi.org/doi:10.1023/B:CATL.0000029523.22277.e1">doi:10.1023/B:CATL.0000029523.22277.e1</a> (cited 45 times)

<br>
 45. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Modification of the surface electronic and chemical properties of Pt(111) by subsurface 3d transition metals, Journal of Chemical Physics, 120, 10240-10246, (2004-06-01). <a href="http://dx.doi.org/doi:10.1063/1.1737365">doi:10.1063/1.1737365</a> (cited 443 times)

<br>
 46. McCormick J.R., Kitchin J.R., Barteau M.A., Chen J.G., A four-point probe correlation of oxygen sensitivity to changes in surface resistivity of TiO2(0 0 1) and Pd-modified TiO2(0 0 1), Surface Science, 545, None, (2003-11-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2003.08.041">doi:10.1016/j.susc.2003.08.041</a> (cited 11 times)

<br>
 47. Kitchin J.R., Khan N.A., Barteau M.A., Chen J.G., Yakshinskiy B., Madey T.E., Elucidation of the active surface and origin of the weak metal-hydrogen bond on Ni/Pt(1 1 1) bimetallic surfaces: A surface science and density functional theory study, Surface Science, 544, 295-308, (2003-10-20). <a href="http://dx.doi.org/doi:10.1016/j.susc.2003.09.007">doi:10.1016/j.susc.2003.09.007</a> (cited 108 times)

<br>
 48. Kitchin J.R., Barteau M.A., Chen J.G., A comparison of gold and molybdenum nanoparticles on TiO2(1 1 0) 1  2 reconstructed single crystal surfaces, Surface Science, 526, 323-331, (2003-03-01). <a href="http://dx.doi.org/doi:10.1016/S0039-6028(02)02679-1">doi:10.1016/S0039-6028(02)02679-1</a> (cited 27 times)

<br>
 49. Song I.K., Kitchin J.R., Barteau M.A., H3PW12O40-functionalized tip for scanning tunneling microscopy, Proceedings of the National Academy of Sciences of the United States of America, 99, 6471-6475, (2002-04-30). <a href="http://dx.doi.org/doi:10.1073/pnas.072514399">doi:10.1073/pnas.072514399</a> (cited 12 times)

<br>
#+END_HTML

** Summary thoughts
I see a lot of potential here for analytics on publications, generation of bibliography files, etc... Instead of retrieving this data every time, it would make much more sense to cache it, e.g. writing each result to a file that could then be used locally, and much faster. The downside of that is, the citations would not be updated in those files. The upside is, you could fix the titles so they are properly marked up. I do not know what the issues with some of the json files was. Some of them were unicode issues. Some other day I will try to track down the other ones.

The entries could be made a lot more functional than this. Each author could be turned into a link back to the scopus author page, for example, the title could be linked to the scopus abstract page, etc... The citations could be a button that automatically updates (like the one in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/30/1000+-citations-for-fuel-cell-paper-on-the-oxygen-reduction-reaction/][post]]). That is another exercise, for another day!


* miscellaneous scopus things I have used.
** author 1 - metrics view
This seems to return a simple view with basic metrics.

http://api.elsevier.com/content/author

http://api.elsevier.com/content/author/AUTHOR_ID:7202762180?start=0&count=200&view=DOCUMENTS


#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((url-request-method "GET")
      (url-mime-accept-string "application/json")
      (url-request-extra-headers  '(("X-ELS-APIKey" . "5cd06d8a7df3de986bf3d0cd9971a47c")))
      (json-object-type 'plist)
      (json-data))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://api.elsevier.com/content/author?author_id=7102750465&view=metrics")
    (setq json-data
	  (elt (plist-get
	   (json-read-from-string
	    (buffer-substring url-http-end-of-headers (point-max)))
	   :author-retrieval-response)
	       0)))
  (list (plist-get json-data :h-index)
    (plist-get (plist-get json-data :coredata) :document-count)
    (plist-get (plist-get json-data :coredata) :citation-count)))
#+END_SRC

#+RESULTS:
| 56 | 451 | 10188 |


#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7102750465&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "270",
            "coredata": {
                "citation-count": "10009",
                "cited-by-count": "5002",
                "dc:identifier": "AUTHOR_ID:7102750465",
                "document-count": "447",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7102750465"
            },
            "h-index": "56"
        }
    ]
}
#+end_example

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18"
        }
    ]
}
#+end_example

** author - enhanced view
This provides affiliation history, and a lot more information, but interestingly not the list of published documents.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=enhanced",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "affiliation-current": {
                "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/110785688",
                "@id": "110785688"
            },
            "affiliation-history": {
                "affiliation": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60026531",
                        "@id": "60026531"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60090776",
                        "@id": "60090776"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60027757",
                        "@id": "60027757"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60008644",
                        "@id": "60008644"
                    }
                ]
            },
            "author-profile": {
                "affiliation-current": {
                    "affiliation": {
                        "@affiliation-id": "110785688",
                        "@parent": "60027950",
                        "ip-doc": {
                            "@id": "110785688",
                            "@relationship": "author",
                            "@type": "dept",
                            "address": {
                                "@country": "usa",
                                "address-part": "5000 Forbes Avenue",
                                "city": "Pittsburgh",
                                "country": "United States",
                                "postal-code": "15213",
                                "state": "PA"
                            },
                            "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                            "org-URL": "http://www.cmu.edu/index.shtml",
                            "org-domain": "cmu.edu",
                            "parent-preferred-name": "Carnegie Mellon University",
                            "preferred-name": "Department of Chemical Engineering",
                            "sort-name": "Department of Chemical Engineering"
                        }
                    }
                },
                "affiliation-history": {
                    "affiliation": [
                        {
                            "@affiliation-id": "110785688",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "110785688",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104568870",
                            "@parent": "60030926",
                            "ip-doc": {
                                "@id": "104568870",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "state": "GA"
                                },
                                "afdispname": "TECH Lab, US Dept. of Energy",
                                "parent-preferred-name": "TECH Lab",
                                "preferred-name": "US Dept. of Energy",
                                "sort-name": "US Dept. of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "60026531",
                            "ip-doc": {
                                "@id": "60026531",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "P.O. Box 880",
                                    "city": "Morgantown",
                                    "country": "United States",
                                    "postal-code": "26507-0880",
                                    "state": "WV"
                                },
                                "afdispname": "National Energy Technology Laboratory, Morgantown",
                                "afnameid": "National Energy Technology Laboratory, Morgantown#60026531",
                                "org-URL": "http://www.netl.doe.gov/",
                                "org-domain": "netl.doe.gov",
                                "preferred-name": "National Energy Technology Laboratory, Morgantown",
                                "sort-name": "National Energy Technology Laboratory, Morgantown"
                            }
                        },
                        {
                            "@affiliation-id": "60090776",
                            "ip-doc": {
                                "@id": "60090776",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "626 Cochrans Mill Road",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15236-0940",
                                    "state": "PA"
                                },
                                "afdispname": "National Energy Technology Laboratory, Pittsburgh",
                                "afnameid": "National Energy Technology Laboratory, Pittsburgh#60090776",
                                "org-URL": "http://www.netl.doe.gov/",
                                "preferred-name": "National Energy Technology Laboratory, Pittsburgh",
                                "sort-name": "National Energy Technology Laboratory, Pittsburgh"
                            }
                        },
                        {
                            "@affiliation-id": "60027757",
                            "ip-doc": {
                                "@id": "60027757",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "1000 Independence Ave., SW",
                                    "city": "Washington",
                                    "country": "United States",
                                    "postal-code": "20585",
                                    "state": "DC"
                                },
                                "afdispname": "United States Department of Energy",
                                "afnameid": "United States Department of Energy#60027757",
                                "org-URL": "http://www.energy.gov/",
                                "org-domain": "energy.gov",
                                "preferred-name": "United States Department of Energy",
                                "sort-name": "United States Department of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "109531166",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "109531166",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108790916",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108790916",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108336146",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108336146",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105243609",
                            "@parent": "60023143",
                            "ip-doc": {
                                "@id": "105243609",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Medford",
                                    "country": "United States",
                                    "postal-code": "02155",
                                    "state": "MA"
                                },
                                "afdispname": "Tufts University, Department of Chemistry",
                                "org-URL": "http://www.tufts.edu/",
                                "org-domain": "tufts.edu",
                                "parent-preferred-name": "Tufts University",
                                "preferred-name": "Department of Chemistry",
                                "sort-name": "Department of Chemistry"
                            }
                        },
                        {
                            "@affiliation-id": "104415945",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "104415945",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105144364",
                            "@parent": "60019647",
                            "ip-doc": {
                                "@id": "105144364",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "postal-code": "30332",
                                    "state": "GA"
                                },
                                "afdispname": "Georgia Institute of Technology, School of Chemical and Biomolecular Engineering",
                                "org-URL": "http://www.gatech.edu/",
                                "org-domain": "gatech.edu",
                                "parent-preferred-name": "Georgia Institute of Technology",
                                "preferred-name": "School of Chemical and Biomolecular Engineering",
                                "sort-name": "School of Chemical and Biomolecular Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "60008644",
                            "ip-doc": {
                                "@id": "60008644",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "deu",
                                    "address-part": "Faradayweg 4 - 6",
                                    "city": "Berlin",
                                    "country": "Germany",
                                    "postal-code": "14195",
                                    "state": "Berlin"
                                },
                                "afdispname": "Fritz Haber Institute of the Max Planck Society",
                                "afnameid": "Fritz Haber Institute of the Max Planck Society#60008644",
                                "org-URL": "http://www.fhi-berlin.mpg.de",
                                "org-domain": "fhi-berlin.mpg.de",
                                "preferred-name": "Fritz Haber Institute of the Max Planck Society",
                                "sort-name": "Fritz Haber Institute of the Max Planck Society"
                            }
                        },
                        {
                            "@affiliation-id": "100258138",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "100258138",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "112570754",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "112570754",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108425177",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "108425177",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104168124",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "104168124",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Materials Science and Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Materials Science and Engineering",
                                "sort-name": "Department of Materials Science and Engineering"
                            }
                        }
                    ]
                },
                "classificationgroup": {
                    "classifications": {
                        "@type": "ASJC",
                        "classification": [
                            {
                                "$": "2207",
                                "@frequency": "2"
                            },
                            {
                                "$": "2700",
                                "@frequency": "1"
                            },
                            {
                                "$": "1502",
                                "@frequency": "1"
                            },
                            {
                                "$": "3100",
                                "@frequency": "7"
                            },
                            {
                                "$": "2310",
                                "@frequency": "1"
                            },
                            {
                                "$": "1503",
                                "@frequency": "17"
                            },
                            {
                                "$": "3311",
                                "@frequency": "2"
                            },
                            {
                                "$": "2200",
                                "@frequency": "2"
                            },
                            {
                                "$": "2500",
                                "@frequency": "6"
                            },
                            {
                                "$": "1000",
                                "@frequency": "1"
                            },
                            {
                                "$": "2611",
                                "@frequency": "3"
                            },
                            {
                                "$": "1603",
                                "@frequency": "3"
                            },
                            {
                                "$": "2103",
                                "@frequency": "4"
                            },
                            {
                                "$": "3107",
                                "@frequency": "1"
                            },
                            {
                                "$": "3110",
                                "@frequency": "7"
                            },
                            {
                                "$": "1305",
                                "@frequency": "1"
                            },
                            {
                                "$": "1607",
                                "@frequency": "1"
                            },
                            {
                                "$": "2300",
                                "@frequency": "1"
                            },
                            {
                                "$": "2504",
                                "@frequency": "7"
                            },
                            {
                                "$": "1303",
                                "@frequency": "1"
                            },
                            {
                                "$": "1500",
                                "@frequency": "30"
                            },
                            {
                                "$": "2308",
                                "@frequency": "1"
                            },
                            {
                                "$": "3104",
                                "@frequency": "13"
                            },
                            {
                                "$": "2503",
                                "@frequency": "1"
                            },
                            {
                                "$": "2208",
                                "@frequency": "1"
                            },
                            {
                                "$": "2213",
                                "@frequency": "3"
                            },
                            {
                                "$": "1605",
                                "@frequency": "4"
                            },
                            {
                                "$": "1606",
                                "@frequency": "21"
                            },
                            {
                                "$": "2304",
                                "@frequency": "2"
                            },
                            {
                                "$": "1501",
                                "@frequency": "7"
                            },
                            {
                                "$": "2100",
                                "@frequency": "8"
                            },
                            {
                                "$": "2508",
                                "@frequency": "9"
                            },
                            {
                                "$": "1604",
                                "@frequency": "2"
                            },
                            {
                                "$": "1505",
                                "@frequency": "1"
                            },
                            {
                                "$": "1602",
                                "@frequency": "1"
                            },
                            {
                                "$": "2105",
                                "@frequency": "1"
                            },
                            {
                                "$": "2102",
                                "@frequency": "4"
                            },
                            {
                                "$": "1311",
                                "@frequency": "1"
                            },
                            {
                                "$": "1710",
                                "@frequency": "3"
                            },
                            {
                                "$": "2505",
                                "@frequency": "4"
                            },
                            {
                                "$": "1600",
                                "@frequency": "23"
                            },
                            {
                                "$": "1508",
                                "@frequency": "2"
                            },
                            {
                                "$": "2209",
                                "@frequency": "7"
                            }
                        ]
                    }
                },
                "date-created": {
                    "@day": "03",
                    "@month": "12",
                    "@year": "2005"
                },
                "journal-history": {
                    "@type": "author",
                    "journal": [
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00134651",
                            "sourcetitle": "Journal of the Electrochemical Society",
                            "sourcetitle-abbrev": "J Electrochem Soc"
                        },
                        {
                            "@type": "j",
                            "issn": "1864564X",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "00162361",
                            "sourcetitle": "Fuel",
                            "sourcetitle-abbrev": "Fuel"
                        },
                        {
                            "@type": "j",
                            "issn": "15667367",
                            "sourcetitle": "Catalysis Communications",
                            "sourcetitle-abbrev": "Catal. Commun."
                        },
                        {
                            "@type": "j",
                            "issn": "17505836",
                            "sourcetitle": "International Journal of Greenhouse Gas Control",
                            "sourcetitle-abbrev": "Int. J. Greenh. Gas Control"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE Annu. Meet. Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "10526102",
                            "sourcetitle": "Proceedings of the Air and Waste Management Association's Annual Conference and Exhibition, AWMA",
                            "sourcetitle-abbrev": "Proc. Air Waste Manage. Assoc. Annu. Conf. Exhib. AWMA"
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10225528",
                            "sourcetitle": "Topics in Catalysis",
                            "sourcetitle-abbrev": "Top. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "00027820",
                            "sourcetitle": "Journal of the American Ceramic Society",
                            "sourcetitle-abbrev": "J Am Ceram Soc"
                        },
                        {
                            "@type": "k",
                            "issn": "01400568",
                            "sourcetitle": "Catalysis",
                            "sourcetitle-abbrev": "Catal."
                        },
                        {
                            "@type": "p",
                            "issn": "00657727",
                            "sourcetitle": "ACS National Meeting Book of Abstracts",
                            "sourcetitle-abbrev": "ACS Natl. Meet. Book Abstr."
                        },
                        {
                            "@type": "j",
                            "issn": "00222860",
                            "sourcetitle": "Journal of Molecular Structure",
                            "sourcetitle-abbrev": "J. Mol. Struct."
                        },
                        {
                            "@type": "j",
                            "issn": "20462069",
                            "sourcetitle": "RSC Advances",
                            "sourcetitle-abbrev": "RSC Adv."
                        },
                        {
                            "@type": "j",
                            "issn": "20416520",
                            "sourcetitle": "Chemical Science",
                            "sourcetitle-abbrev": "Chem. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J Phys Chem B"
                        },
                        {
                            "@type": "j",
                            "issn": "03601285",
                            "sourcetitle": "Progress in Energy and Combustion Science",
                            "sourcetitle-abbrev": "Prog. Energy Combust. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal. Lett."
                        },
                        {
                            "@type": "j",
                            "issn": "00319007",
                            "sourcetitle": "Physical Review Letters",
                            "sourcetitle-abbrev": "Phys Rev Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10897690",
                            "sourcetitle": "The Journal of chemical physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "issn": "0277786X",
                            "sourcetitle": "Proceedings of SPIE - The International Society for Optical Engineering",
                            "sourcetitle-abbrev": "Proc SPIE Int Soc Opt Eng"
                        },
                        {
                            "@type": "j",
                            "issn": "08927022",
                            "sourcetitle": "Molecular Simulation",
                            "sourcetitle-abbrev": "Mol Simul"
                        },
                        {
                            "@type": "j",
                            "issn": "19327455",
                            "sourcetitle": "Journal of Physical Chemistry C",
                            "sourcetitle-abbrev": "J. Phys. Chem. C"
                        },
                        {
                            "@type": "j",
                            "issn": "21555435",
                            "sourcetitle": "ACS Catalysis",
                            "sourcetitle-abbrev": "ACS Catal."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "10AIChE - 2010 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "19385862",
                            "sourcetitle": "ECS Transactions",
                            "sourcetitle-abbrev": "ECS Transactions"
                        },
                        {
                            "@type": "j",
                            "issn": "00396028",
                            "sourcetitle": "Surface Science",
                            "sourcetitle-abbrev": "Surf Sci"
                        },
                        {
                            "@type": "j",
                            "issn": "00219517",
                            "sourcetitle": "Journal of Catalysis",
                            "sourcetitle-abbrev": "J. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "19448252",
                            "sourcetitle": "ACS Applied Materials and Interfaces",
                            "sourcetitle-abbrev": "ACS Appl. Mater. Interfaces"
                        },
                        {
                            "@type": "j",
                            "issn": "09205861",
                            "sourcetitle": "Catalysis Today",
                            "sourcetitle-abbrev": "Catal Today"
                        },
                        {
                            "@type": "j",
                            "issn": "00219606",
                            "sourcetitle": "Journal of Chemical Physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "Conference Proceedings - 2009 AIChE Spring National Meeting and 5th Global Congress on Process Safety",
                            "sourcetitle-abbrev": "Conf. Proc. - AIChE Spring Natl. Meet. Global Congr. Process Saf."
                        },
                        {
                            "@type": "j",
                            "issn": "18645631",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "18673880",
                            "sourcetitle": "ChemCatChem",
                            "sourcetitle-abbrev": "ChemCatChem"
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J. Phys. Chem. B"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 100 - 2008 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00278424",
                            "sourcetitle": "Proceedings of the National Academy of Sciences of the United States of America",
                            "sourcetitle-abbrev": "Proc. Natl. Acad. Sci. U. S. A."
                        },
                        {
                            "@type": "j",
                            "issn": "10980121",
                            "sourcetitle": "Physical Review B - Condensed Matter and Materials Physics",
                            "sourcetitle-abbrev": "Phys. Rev. B Condens. Matter Mater. Phys."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "2007 AIChE Annual Meeting",
                            "sourcetitle-abbrev": "AIChE Ann. Meet."
                        },
                        {
                            "@type": "j",
                            "issn": "08885885",
                            "sourcetitle": "Industrial and Engineering Chemistry Research",
                            "sourcetitle-abbrev": "Ind. Eng. Chem. Res."
                        },
                        {
                            "@type": "j",
                            "issn": "15205126",
                            "sourcetitle": "Journal of the American Chemical Society",
                            "sourcetitle-abbrev": "J. Am. Chem. Soc."
                        }
                    ]
                },
                "name-variant": [
                    {
                        "given-name": null,
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John",
                        "indexed-name": "Kitchin J.",
                        "initials": "J.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John R",
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    }
                ],
                "preferred-name": {
                    "given-name": "John R.",
                    "indexed-name": "Kitchin J.",
                    "initials": "J.R.",
                    "surname": "Kitchin"
                },
                "publication-range": {
                    "@end": "2015",
                    "@start": "2002"
                },
                "status": "update"
            },
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "eid": "9-s2.0-7004212771",
                "link": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=refauid%287004212771%29",
                        "@rel": "scopus-citedby"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://www.scopus.com/authid/detail.url?partnerID=HzOxMe3b&authorId=7004212771&origin=inward",
                        "@rel": "scopus-author"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/author/author_id/7004212771",
                        "@rel": "self"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=au-id%287004212771%29",
                        "@rel": "search"
                    },
                    {
                        "@href": "http://api.elsevier.com/content/search/author?co-author=7004212771",
                        "@rel": "coauthor-search"
                    }
                ],
                "orcid": "0000-0003-2625-9232",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18",
            "subject-areas": {
                "subject-area": [
                    {
                        "$": "Control and Systems Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2207"
                    },
                    {
                        "$": "Medicine (all)",
                        "@_fa": "true",
                        "@abbrev": "MEDI",
                        "@code": "2700"
                    },
                    {
                        "$": "Bioengineering",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1502"
                    },
                    {
                        "$": "Physics and Astronomy (all)",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3100"
                    },
                    {
                        "$": "Pollution",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2310"
                    },
                    {
                        "$": "Catalysis",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1503"
                    },
                    {
                        "$": "Safety Research",
                        "@_fa": "true",
                        "@abbrev": "SOCI",
                        "@code": "3311"
                    },
                    {
                        "$": "Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2200"
                    },
                    {
                        "$": "Materials Science (all)",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2500"
                    },
                    {
                        "$": "Multidisciplinary",
                        "@_fa": "true",
                        "@abbrev": "MULT",
                        "@code": "1000"
                    },
                    {
                        "$": "Modeling and Simulation",
                        "@_fa": "true",
                        "@abbrev": "MATH",
                        "@code": "2611"
                    },
                    {
                        "$": "Electrochemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1603"
                    },
                    {
                        "$": "Fuel Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2103"
                    },
                    {
                        "$": "Atomic and Molecular Physics, and Optics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3107"
                    },
                    {
                        "$": "Surfaces and Interfaces",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3110"
                    },
                    {
                        "$": "Biotechnology",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1305"
                    },
                    {
                        "$": "Spectroscopy",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1607"
                    },
                    {
                        "$": "Environmental Science (all)",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2300"
                    },
                    {
                        "$": "Electronic, Optical and Magnetic Materials",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2504"
                    },
                    {
                        "$": "Biochemistry",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1303"
                    },
                    {
                        "$": "Chemical Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1500"
                    },
                    {
                        "$": "Management, Monitoring, Policy and Law",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2308"
                    },
                    {
                        "$": "Condensed Matter Physics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3104"
                    },
                    {
                        "$": "Ceramics and Composites",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2503"
                    },
                    {
                        "$": "Electrical and Electronic Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2208"
                    },
                    {
                        "$": "Safety, Risk, Reliability and Quality",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2213"
                    },
                    {
                        "$": "Organic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1605"
                    },
                    {
                        "$": "Physical and Theoretical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1606"
                    },
                    {
                        "$": "Environmental Chemistry",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2304"
                    },
                    {
                        "$": "Chemical Engineering (miscellaneous)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1501"
                    },
                    {
                        "$": "Energy (all)",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2100"
                    },
                    {
                        "$": "Surfaces, Coatings and Films",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2508"
                    },
                    {
                        "$": "Inorganic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1604"
                    },
                    {
                        "$": "Colloid and Surface Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1505"
                    },
                    {
                        "$": "Analytical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1602"
                    },
                    {
                        "$": "Renewable Energy, Sustainability and the Environment",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2105"
                    },
                    {
                        "$": "Energy Engineering and Power Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2102"
                    },
                    {
                        "$": "Genetics",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1311"
                    },
                    {
                        "$": "Information Systems",
                        "@_fa": "true",
                        "@abbrev": "COMP",
                        "@code": "1710"
                    },
                    {
                        "$": "Materials Chemistry",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2505"
                    },
                    {
                        "$": "Chemistry (all)",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1600"
                    },
                    {
                        "$": "Process Chemistry and Technology",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1508"
                    },
                    {
                        "$": "Industrial and Manufacturing Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2209"
                    }
                ]
            }
        }
    ]
}
#+end_example

** Author retrieval 2
This seems to be almost the same as the enhanced view
#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author/author_id/7004212771",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "affiliation-current": {
                "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/110785688",
                "@id": "110785688"
            },
            "affiliation-history": {
                "affiliation": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60026531",
                        "@id": "60026531"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60090776",
                        "@id": "60090776"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60027757",
                        "@id": "60027757"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60008644",
                        "@id": "60008644"
                    }
                ]
            },
            "author-profile": {
                "affiliation-current": {
                    "affiliation": {
                        "@affiliation-id": "110785688",
                        "@parent": "60027950",
                        "ip-doc": {
                            "@id": "110785688",
                            "@relationship": "author",
                            "@type": "dept",
                            "address": {
                                "@country": "usa",
                                "address-part": "5000 Forbes Avenue",
                                "city": "Pittsburgh",
                                "country": "United States",
                                "postal-code": "15213",
                                "state": "PA"
                            },
                            "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                            "org-URL": "http://www.cmu.edu/index.shtml",
                            "org-domain": "cmu.edu",
                            "parent-preferred-name": "Carnegie Mellon University",
                            "preferred-name": "Department of Chemical Engineering",
                            "sort-name": "Department of Chemical Engineering"
                        }
                    }
                },
                "affiliation-history": {
                    "affiliation": [
                        {
                            "@affiliation-id": "110785688",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "110785688",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104568870",
                            "@parent": "60030926",
                            "ip-doc": {
                                "@id": "104568870",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "state": "GA"
                                },
                                "afdispname": "TECH Lab, US Dept. of Energy",
                                "parent-preferred-name": "TECH Lab",
                                "preferred-name": "US Dept. of Energy",
                                "sort-name": "US Dept. of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "60026531",
                            "ip-doc": {
                                "@id": "60026531",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "P.O. Box 880",
                                    "city": "Morgantown",
                                    "country": "United States",
                                    "postal-code": "26507-0880",
                                    "state": "WV"
                                },
                                "afdispname": "National Energy Technology Laboratory, Morgantown",
                                "afnameid": "National Energy Technology Laboratory, Morgantown#60026531",
                                "org-URL": "http://www.netl.doe.gov/",
                                "org-domain": "netl.doe.gov",
                                "preferred-name": "National Energy Technology Laboratory, Morgantown",
                                "sort-name": "National Energy Technology Laboratory, Morgantown"
                            }
                        },
                        {
                            "@affiliation-id": "60090776",
                            "ip-doc": {
                                "@id": "60090776",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "626 Cochrans Mill Road",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15236-0940",
                                    "state": "PA"
                                },
                                "afdispname": "National Energy Technology Laboratory, Pittsburgh",
                                "afnameid": "National Energy Technology Laboratory, Pittsburgh#60090776",
                                "org-URL": "http://www.netl.doe.gov/",
                                "preferred-name": "National Energy Technology Laboratory, Pittsburgh",
                                "sort-name": "National Energy Technology Laboratory, Pittsburgh"
                            }
                        },
                        {
                            "@affiliation-id": "60027757",
                            "ip-doc": {
                                "@id": "60027757",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "1000 Independence Ave., SW",
                                    "city": "Washington",
                                    "country": "United States",
                                    "postal-code": "20585",
                                    "state": "DC"
                                },
                                "afdispname": "United States Department of Energy",
                                "afnameid": "United States Department of Energy#60027757",
                                "org-URL": "http://www.energy.gov/",
                                "org-domain": "energy.gov",
                                "preferred-name": "United States Department of Energy",
                                "sort-name": "United States Department of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "109531166",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "109531166",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108790916",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108790916",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108336146",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108336146",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105243609",
                            "@parent": "60023143",
                            "ip-doc": {
                                "@id": "105243609",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Medford",
                                    "country": "United States",
                                    "postal-code": "02155",
                                    "state": "MA"
                                },
                                "afdispname": "Tufts University, Department of Chemistry",
                                "org-URL": "http://www.tufts.edu/",
                                "org-domain": "tufts.edu",
                                "parent-preferred-name": "Tufts University",
                                "preferred-name": "Department of Chemistry",
                                "sort-name": "Department of Chemistry"
                            }
                        },
                        {
                            "@affiliation-id": "104415945",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "104415945",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105144364",
                            "@parent": "60019647",
                            "ip-doc": {
                                "@id": "105144364",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "postal-code": "30332",
                                    "state": "GA"
                                },
                                "afdispname": "Georgia Institute of Technology, School of Chemical and Biomolecular Engineering",
                                "org-URL": "http://www.gatech.edu/",
                                "org-domain": "gatech.edu",
                                "parent-preferred-name": "Georgia Institute of Technology",
                                "preferred-name": "School of Chemical and Biomolecular Engineering",
                                "sort-name": "School of Chemical and Biomolecular Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "60008644",
                            "ip-doc": {
                                "@id": "60008644",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "deu",
                                    "address-part": "Faradayweg 4 - 6",
                                    "city": "Berlin",
                                    "country": "Germany",
                                    "postal-code": "14195",
                                    "state": "Berlin"
                                },
                                "afdispname": "Fritz Haber Institute of the Max Planck Society",
                                "afnameid": "Fritz Haber Institute of the Max Planck Society#60008644",
                                "org-URL": "http://www.fhi-berlin.mpg.de",
                                "org-domain": "fhi-berlin.mpg.de",
                                "preferred-name": "Fritz Haber Institute of the Max Planck Society",
                                "sort-name": "Fritz Haber Institute of the Max Planck Society"
                            }
                        },
                        {
                            "@affiliation-id": "100258138",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "100258138",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "112570754",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "112570754",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108425177",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "108425177",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104168124",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "104168124",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Materials Science and Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Materials Science and Engineering",
                                "sort-name": "Department of Materials Science and Engineering"
                            }
                        }
                    ]
                },
                "classificationgroup": {
                    "classifications": {
                        "@type": "ASJC",
                        "classification": [
                            {
                                "$": "2207",
                                "@frequency": "2"
                            },
                            {
                                "$": "2700",
                                "@frequency": "1"
                            },
                            {
                                "$": "1502",
                                "@frequency": "1"
                            },
                            {
                                "$": "3100",
                                "@frequency": "7"
                            },
                            {
                                "$": "2310",
                                "@frequency": "1"
                            },
                            {
                                "$": "1503",
                                "@frequency": "17"
                            },
                            {
                                "$": "3311",
                                "@frequency": "2"
                            },
                            {
                                "$": "2200",
                                "@frequency": "2"
                            },
                            {
                                "$": "2500",
                                "@frequency": "6"
                            },
                            {
                                "$": "1000",
                                "@frequency": "1"
                            },
                            {
                                "$": "2611",
                                "@frequency": "3"
                            },
                            {
                                "$": "1603",
                                "@frequency": "3"
                            },
                            {
                                "$": "2103",
                                "@frequency": "4"
                            },
                            {
                                "$": "3107",
                                "@frequency": "1"
                            },
                            {
                                "$": "3110",
                                "@frequency": "7"
                            },
                            {
                                "$": "1305",
                                "@frequency": "1"
                            },
                            {
                                "$": "1607",
                                "@frequency": "1"
                            },
                            {
                                "$": "2300",
                                "@frequency": "1"
                            },
                            {
                                "$": "2504",
                                "@frequency": "7"
                            },
                            {
                                "$": "1303",
                                "@frequency": "1"
                            },
                            {
                                "$": "1500",
                                "@frequency": "30"
                            },
                            {
                                "$": "2308",
                                "@frequency": "1"
                            },
                            {
                                "$": "3104",
                                "@frequency": "13"
                            },
                            {
                                "$": "2503",
                                "@frequency": "1"
                            },
                            {
                                "$": "2208",
                                "@frequency": "1"
                            },
                            {
                                "$": "2213",
                                "@frequency": "3"
                            },
                            {
                                "$": "1605",
                                "@frequency": "4"
                            },
                            {
                                "$": "1606",
                                "@frequency": "21"
                            },
                            {
                                "$": "2304",
                                "@frequency": "2"
                            },
                            {
                                "$": "1501",
                                "@frequency": "7"
                            },
                            {
                                "$": "2100",
                                "@frequency": "8"
                            },
                            {
                                "$": "2508",
                                "@frequency": "9"
                            },
                            {
                                "$": "1604",
                                "@frequency": "2"
                            },
                            {
                                "$": "1505",
                                "@frequency": "1"
                            },
                            {
                                "$": "1602",
                                "@frequency": "1"
                            },
                            {
                                "$": "2105",
                                "@frequency": "1"
                            },
                            {
                                "$": "2102",
                                "@frequency": "4"
                            },
                            {
                                "$": "1311",
                                "@frequency": "1"
                            },
                            {
                                "$": "1710",
                                "@frequency": "3"
                            },
                            {
                                "$": "2505",
                                "@frequency": "4"
                            },
                            {
                                "$": "1600",
                                "@frequency": "23"
                            },
                            {
                                "$": "1508",
                                "@frequency": "2"
                            },
                            {
                                "$": "2209",
                                "@frequency": "7"
                            }
                        ]
                    }
                },
                "date-created": {
                    "@day": "03",
                    "@month": "12",
                    "@year": "2005"
                },
                "journal-history": {
                    "@type": "author",
                    "journal": [
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00134651",
                            "sourcetitle": "Journal of the Electrochemical Society",
                            "sourcetitle-abbrev": "J Electrochem Soc"
                        },
                        {
                            "@type": "j",
                            "issn": "1864564X",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "00162361",
                            "sourcetitle": "Fuel",
                            "sourcetitle-abbrev": "Fuel"
                        },
                        {
                            "@type": "j",
                            "issn": "15667367",
                            "sourcetitle": "Catalysis Communications",
                            "sourcetitle-abbrev": "Catal. Commun."
                        },
                        {
                            "@type": "j",
                            "issn": "17505836",
                            "sourcetitle": "International Journal of Greenhouse Gas Control",
                            "sourcetitle-abbrev": "Int. J. Greenh. Gas Control"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE Annu. Meet. Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "10526102",
                            "sourcetitle": "Proceedings of the Air and Waste Management Association's Annual Conference and Exhibition, AWMA",
                            "sourcetitle-abbrev": "Proc. Air Waste Manage. Assoc. Annu. Conf. Exhib. AWMA"
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10225528",
                            "sourcetitle": "Topics in Catalysis",
                            "sourcetitle-abbrev": "Top. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "00027820",
                            "sourcetitle": "Journal of the American Ceramic Society",
                            "sourcetitle-abbrev": "J Am Ceram Soc"
                        },
                        {
                            "@type": "k",
                            "issn": "01400568",
                            "sourcetitle": "Catalysis",
                            "sourcetitle-abbrev": "Catal."
                        },
                        {
                            "@type": "p",
                            "issn": "00657727",
                            "sourcetitle": "ACS National Meeting Book of Abstracts",
                            "sourcetitle-abbrev": "ACS Natl. Meet. Book Abstr."
                        },
                        {
                            "@type": "j",
                            "issn": "00222860",
                            "sourcetitle": "Journal of Molecular Structure",
                            "sourcetitle-abbrev": "J. Mol. Struct."
                        },
                        {
                            "@type": "j",
                            "issn": "20462069",
                            "sourcetitle": "RSC Advances",
                            "sourcetitle-abbrev": "RSC Adv."
                        },
                        {
                            "@type": "j",
                            "issn": "20416520",
                            "sourcetitle": "Chemical Science",
                            "sourcetitle-abbrev": "Chem. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J Phys Chem B"
                        },
                        {
                            "@type": "j",
                            "issn": "03601285",
                            "sourcetitle": "Progress in Energy and Combustion Science",
                            "sourcetitle-abbrev": "Prog. Energy Combust. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal. Lett."
                        },
                        {
                            "@type": "j",
                            "issn": "00319007",
                            "sourcetitle": "Physical Review Letters",
                            "sourcetitle-abbrev": "Phys Rev Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10897690",
                            "sourcetitle": "The Journal of chemical physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "issn": "0277786X",
                            "sourcetitle": "Proceedings of SPIE - The International Society for Optical Engineering",
                            "sourcetitle-abbrev": "Proc SPIE Int Soc Opt Eng"
                        },
                        {
                            "@type": "j",
                            "issn": "08927022",
                            "sourcetitle": "Molecular Simulation",
                            "sourcetitle-abbrev": "Mol Simul"
                        },
                        {
                            "@type": "j",
                            "issn": "19327455",
                            "sourcetitle": "Journal of Physical Chemistry C",
                            "sourcetitle-abbrev": "J. Phys. Chem. C"
                        },
                        {
                            "@type": "j",
                            "issn": "21555435",
                            "sourcetitle": "ACS Catalysis",
                            "sourcetitle-abbrev": "ACS Catal."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "10AIChE - 2010 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "19385862",
                            "sourcetitle": "ECS Transactions",
                            "sourcetitle-abbrev": "ECS Transactions"
                        },
                        {
                            "@type": "j",
                            "issn": "00396028",
                            "sourcetitle": "Surface Science",
                            "sourcetitle-abbrev": "Surf Sci"
                        },
                        {
                            "@type": "j",
                            "issn": "00219517",
                            "sourcetitle": "Journal of Catalysis",
                            "sourcetitle-abbrev": "J. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "19448252",
                            "sourcetitle": "ACS Applied Materials and Interfaces",
                            "sourcetitle-abbrev": "ACS Appl. Mater. Interfaces"
                        },
                        {
                            "@type": "j",
                            "issn": "09205861",
                            "sourcetitle": "Catalysis Today",
                            "sourcetitle-abbrev": "Catal Today"
                        },
                        {
                            "@type": "j",
                            "issn": "00219606",
                            "sourcetitle": "Journal of Chemical Physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "Conference Proceedings - 2009 AIChE Spring National Meeting and 5th Global Congress on Process Safety",
                            "sourcetitle-abbrev": "Conf. Proc. - AIChE Spring Natl. Meet. Global Congr. Process Saf."
                        },
                        {
                            "@type": "j",
                            "issn": "18645631",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "18673880",
                            "sourcetitle": "ChemCatChem",
                            "sourcetitle-abbrev": "ChemCatChem"
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J. Phys. Chem. B"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 100 - 2008 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00278424",
                            "sourcetitle": "Proceedings of the National Academy of Sciences of the United States of America",
                            "sourcetitle-abbrev": "Proc. Natl. Acad. Sci. U. S. A."
                        },
                        {
                            "@type": "j",
                            "issn": "10980121",
                            "sourcetitle": "Physical Review B - Condensed Matter and Materials Physics",
                            "sourcetitle-abbrev": "Phys. Rev. B Condens. Matter Mater. Phys."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "2007 AIChE Annual Meeting",
                            "sourcetitle-abbrev": "AIChE Ann. Meet."
                        },
                        {
                            "@type": "j",
                            "issn": "08885885",
                            "sourcetitle": "Industrial and Engineering Chemistry Research",
                            "sourcetitle-abbrev": "Ind. Eng. Chem. Res."
                        },
                        {
                            "@type": "j",
                            "issn": "15205126",
                            "sourcetitle": "Journal of the American Chemical Society",
                            "sourcetitle-abbrev": "J. Am. Chem. Soc."
                        }
                    ]
                },
                "name-variant": [
                    {
                        "given-name": null,
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John",
                        "indexed-name": "Kitchin J.",
                        "initials": "J.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John R",
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    }
                ],
                "preferred-name": {
                    "given-name": "John R.",
                    "indexed-name": "Kitchin J.",
                    "initials": "J.R.",
                    "surname": "Kitchin"
                },
                "publication-range": {
                    "@end": "2015",
                    "@start": "2002"
                },
                "status": "update"
            },
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "eid": "9-s2.0-7004212771",
                "link": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=refauid%287004212771%29",
                        "@rel": "scopus-citedby"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://www.scopus.com/authid/detail.url?partnerID=HzOxMe3b&authorId=7004212771&origin=inward",
                        "@rel": "scopus-author"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/author/author_id/7004212771",
                        "@rel": "self"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=au-id%287004212771%29",
                        "@rel": "search"
                    }
                ],
                "orcid": "0000-0003-2625-9232",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "subject-areas": {
                "subject-area": [
                    {
                        "$": "Control and Systems Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2207"
                    },
                    {
                        "$": "Medicine (all)",
                        "@_fa": "true",
                        "@abbrev": "MEDI",
                        "@code": "2700"
                    },
                    {
                        "$": "Bioengineering",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1502"
                    },
                    {
                        "$": "Physics and Astronomy (all)",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3100"
                    },
                    {
                        "$": "Pollution",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2310"
                    },
                    {
                        "$": "Catalysis",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1503"
                    },
                    {
                        "$": "Safety Research",
                        "@_fa": "true",
                        "@abbrev": "SOCI",
                        "@code": "3311"
                    },
                    {
                        "$": "Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2200"
                    },
                    {
                        "$": "Materials Science (all)",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2500"
                    },
                    {
                        "$": "Multidisciplinary",
                        "@_fa": "true",
                        "@abbrev": "MULT",
                        "@code": "1000"
                    },
                    {
                        "$": "Modeling and Simulation",
                        "@_fa": "true",
                        "@abbrev": "MATH",
                        "@code": "2611"
                    },
                    {
                        "$": "Electrochemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1603"
                    },
                    {
                        "$": "Fuel Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2103"
                    },
                    {
                        "$": "Atomic and Molecular Physics, and Optics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3107"
                    },
                    {
                        "$": "Surfaces and Interfaces",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3110"
                    },
                    {
                        "$": "Biotechnology",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1305"
                    },
                    {
                        "$": "Spectroscopy",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1607"
                    },
                    {
                        "$": "Environmental Science (all)",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2300"
                    },
                    {
                        "$": "Electronic, Optical and Magnetic Materials",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2504"
                    },
                    {
                        "$": "Biochemistry",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1303"
                    },
                    {
                        "$": "Chemical Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1500"
                    },
                    {
                        "$": "Management, Monitoring, Policy and Law",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2308"
                    },
                    {
                        "$": "Condensed Matter Physics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3104"
                    },
                    {
                        "$": "Ceramics and Composites",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2503"
                    },
                    {
                        "$": "Electrical and Electronic Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2208"
                    },
                    {
                        "$": "Safety, Risk, Reliability and Quality",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2213"
                    },
                    {
                        "$": "Organic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1605"
                    },
                    {
                        "$": "Physical and Theoretical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1606"
                    },
                    {
                        "$": "Environmental Chemistry",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2304"
                    },
                    {
                        "$": "Chemical Engineering (miscellaneous)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1501"
                    },
                    {
                        "$": "Energy (all)",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2100"
                    },
                    {
                        "$": "Surfaces, Coatings and Films",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2508"
                    },
                    {
                        "$": "Inorganic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1604"
                    },
                    {
                        "$": "Colloid and Surface Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1505"
                    },
                    {
                        "$": "Analytical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1602"
                    },
                    {
                        "$": "Renewable Energy, Sustainability and the Environment",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2105"
                    },
                    {
                        "$": "Energy Engineering and Power Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2102"
                    },
                    {
                        "$": "Genetics",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1311"
                    },
                    {
                        "$": "Information Systems",
                        "@_fa": "true",
                        "@abbrev": "COMP",
                        "@code": "1710"
                    },
                    {
                        "$": "Materials Chemistry",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2505"
                    },
                    {
                        "$": "Chemistry (all)",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1600"
                    },
                    {
                        "$": "Process Chemistry and Technology",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1508"
                    },
                    {
                        "$": "Industrial and Manufacturing Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2209"
                    }
                ]
            }
        }
    ]
}
#+end_example

** Citation retrieval
Retrieves citation data for a DOI.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/search/index:SCOPUS?query=DOI(10.1021/jp047349j)&field=citedby-count",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))

#+END_SRC

#+RESULTS:
#+begin_example
{
    "search-results": {
        "entry": [
            {
                "@_fa": "true",
                "citedby-count": "1050",
                "prism:url": "http://api.elsevier.com/content/abstract/scopus_id:9744261716"
            }
        ],
        "link": [
            {
                "@_fa": "true",
                "@href": "http://api.elsevier.com:80/content/search/index:scopus?start=0&count=25&query=DOI%2810.1021%2Fjp047349j%29&field=citedby-count",
                "@ref": "self",
                "@type": "application/json"
            },
            {
                "@_fa": "true",
                "@href": "http://api.elsevier.com:80/content/search/index:scopus?start=0&count=25&query=DOI%2810.1021%2Fjp047349j%29&field=citedby-count",
                "@ref": "first",
                "@type": "application/json"
            }
        ],
        "opensearch:Query": {
            "@role": "request",
            "@searchTerms": "DOI%2810.1021%2Fjp047349j%29",
            "@startPage": "0"
        },
        "opensearch:itemsPerPage": "1",
        "opensearch:startIndex": "0",
        "opensearch:totalResults": "1"
    }
}
#+end_example

requests.el [[http://tkf.github.io/emacs-request/][Request.el  Easy HTTP request for Emacs Lisp  Request.el 0.2.0 documentation]]

* Kitchingroup products
** Youtube videos
https://www.youtube.com/analytics?o=U

#+BEGIN_HTML
<script src="https://apis.google.com/js/platform.js"></script>

<div class="g-ytsubscribe" data-channelid="UCQp2VLAOlvq142YN3JO3y8w" data-layout="full" data-count="default"></div>
#+END_HTML
- Reproducible Research at Scipy 2013
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/1-dUkyn_fZA" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- org-mode is awesome
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/fgizHHd7nOo" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- A Success Story in Using Python in a Graduate Chemical Engineering Course at Scipy 2014
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/IsSMs-4GlT8" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- Teaching with Emacs + org-mode
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/cRUCiF2MwP4" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- The org-ref show
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/JyvpSVl4_dg" frameborder="0" allowfullscreen></iframe>
#+END_HTML
* Scientific writing


cite:whitesides-2004-whites-group

cite:powell-2010-public

https://medium.com/@write4research/why-do-academics-and-phders-carefully-choose-useless-titles-for-articles-and-chapters-518f02a2ecbb


http://pubs.acs.org/isbn/9780841239999

cite:2006-acs-style-guide
* DONE 1000+ citations for fuel cell paper on the oxygen reduction reaction!
  CLOSED: [2015-03-30 Mon 20:02]
  :PROPERTIES:
  :categories: news
  :date:     2015/03/30 20:02:58
  :updated:  2015/03/30 20:11:41
  :END:

This landmark paper cite:norskov-2004-origin recently hit 1000+ citations! In this paper we lay out a framework using density functional theory to calculate the stabilities of intermediates in electrochemical processes such as fuel cells and electrolyzers. This was a very early use of electrochemical atomistic thermodynamics in which the electric potential and pH were both accounted for in the electrochemical reaction energies. We showed how the volcano plots frequently observed arise from trends in adsorption energies that are easily calculated. This paper also shows one of the earliest scaling relations between O and OH adsorption energies!

This paper came out shortly after I spent three months at DTU with Jens Nrskov when I was a PhD student. I still remember talking to him about the work that led to this paper one day at their regular afternoon department tea time. He suggested some DFT calculations that I knew how to do, and I went back to the office and worked on them the rest of the night. He wrote this amazing paper afterwards that has been cited over and over. Congratulations Jens! I am proud to have had a part in it.

#+BEGIN_SRC bibtex
@article{norskov-2004-origin,
  author =	 {N{\o}rskov, J. K. and Rossmeisl, J. and Logadottir, A. and
                  Lindqvist, L. and Kitchin, J. R. and Bligaard, T. and J{\'o}nsson,
                  H.},
  title =	 {Origin of the overpotential for oxygen reduction at a
                  fuel-cell cathode},
  journal =	 {Journal of Physical Chemistry B},
  year =	 2004,
  volume =	 108,
  pages =	 {17886-17892},
  number =	 46,
  doi =		 {10.1021/jp047349j},
  url = {http://dx.doi.org/10.1021/jp047349j},
  issn =	 {1520-6106},
  type =	 {Journal Article},
}
#+END_SRC


#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp047349j &httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

bibliography:../../Dropbox/bibliography/references.bib



* Filtering subsets of a bibtex file

I guess this is basically what bibtex-map-entries does.
#+BEGIN_SRC emacs-lisp :results output
(defun filter-bibtex (bibfile &rest keys)
  "keys are pairs of :field regexp"
  (set-buffer (find-file-noselect bibfile))
  (goto-char (point-min))
  (let ((results '()))
    (bibtex-map-entries
     (lambda (key start end)
       (let ((entry (bibtex-parse-entry))
	     (temp-keys keys))
	 (when
	     (catch 'nomatch
	       (while temp-keys
		 (let ((field (replace-regexp-in-string "^:" "" (symbol-name (car temp-keys))))
		       (regex (cadr temp-keys)))
		   (setq temp-keys (cddr temp-keys))
		   (unless (string-match-p
			    (format "%s" regex) ; use format to get a string
			    (org-ref-reftex-get-bib-field field entry))
		     (throw 'nomatch nil))))
	       t)
	   (add-to-list 'results key)))))
    results))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(filter-bibtex "../../Dropbox/bibliography/references.bib" :author "gellman" :year 2014)
#+END_SRC

#+RESULTS:
| miller-2014-simul-temper |









* Scientific researcher IDs

** ORCID
"ORCID provides a persistent digital identifier that distinguishes you from every other researcher and, through integration in key research workflows such as manuscript and grant submission, supports automated linkages between you and your professional activities ensuring that your work is recognized."

orcid:0000-0003-2625-9232

** Researcher ID
"ResearcherID provides a solution to the author ambiguity problem within the scholarly research community. Each member is assigned a unique identifier to enable researchers to manage their publication lists, track their times cited counts and h-index, identify potential collaborators and avoid author misidentification. In addition, your ResearcherID information integrates with the Web of Science and is ORCID compliant, allowing you to claim and showcase your publications from a single one account."

researcherid:A-2363-2010

One thing I like about ResearcherID is they provide some HTML to give you a dynamic "badge":

#+BEGIN_HTML
<span id='badgeCont777711' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont777711&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span>
#+END_HTML

You also get interesting things like my [[http://labs.researcherid.com/mashlets/rid/mashletsServer.jsp?rid%3DA-2363-2010&mid%3DCollaborationNetwork&cat%3DMap][collaboration map]], and a map of who [[http://labs.researcherid.com/mashlets/rid/mashletsServer.jsp?rid=A-2363-2010&mid=CitationDistribution&cat=Map][cites my work]].

** Scopus ID
I really like Scopus. It does a remarkable job identifying your papers and giving you a Scopus ID. Here is mine: scopusid:7004212771. While it is at it, you can see citation information, h-index, and other things.

** Google Scholar
Who knows who long this will be around (e.g. Google reader, Google Code, Google+, ...). It is pretty easy to use, but it tends to over citations, and to make correspondingly higher h-index (mine is 20 in Google Scholar).

https://scholar.google.com/citations?user=jD_4h7sAAAAJ

** ResearchGate
One nice feature of ResearchGate is it provides a way to serve full text versions of your papers.
https://www.researchgate.net/profile/John_Kitchin


* DONE The orcid api and generating a bibtex file from it
  CLOSED: [2015-03-28 Sat 14:22]
  :PROPERTIES:
  :categories: python,orcid
  :date:     2015/03/28 14:21:59
  :updated:  2015/03/28 14:21:59
  :END:

I found this interesting package [[https://pypi.python.org/pypi/orcid-python][orcid-python 0.1 : Python Package Index]]. Unfortunately, it seems to have some issues and it did not work for me. But, the idea is pretty simple, there is a restful API (see http://members.orcid.org/api/tutorial-retrieve-data-public-api-curl-12-and-earlier) that we can use to retrieve data. We explore that a bit here.

I have an orcid:0000-0003-2625-9232 which contains my data. First, we just retrieve some basic information using Python.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232",
                    headers={'Accept':'application/orcid+json'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC
#+RESULTS:
#+begin_example
{
    "message-version": "1.1",
    "orcid-profile": {
        "client-type": null,
        "group-type": null,
        "orcid": null,
        "orcid-activities": {
            "affiliations": null
        },
        "orcid-bio": {
            "applications": null,
            "contact-details": {
                "address": {
                    "country": {
                        "value": "US",
                        "visibility": null
                    }
                },
                "email": []
            },
            "delegation": null,
            "external-identifiers": {
                "external-identifier": [
                    {
                        "external-id-common-name": {
                            "value": "ResearcherID"
                        },
                        "external-id-orcid": {
                            "host": "orcid.org",
                            "path": "0000-0001-7707-4137",
                            "uri": "http://orcid.org/0000-0001-7707-4137",
                            "value": null
                        },
                        "external-id-reference": {
                            "value": "A-2363-2010"
                        },
                        "external-id-url": {
                            "value": "http://www.researcherid.com/rid/A-2363-2010"
                        }
                    },
                    {
                        "external-id-common-name": {
                            "value": "Scopus Author ID"
                        },
                        "external-id-orcid": {
                            "host": "orcid.org",
                            "path": "0000-0002-5982-8983",
                            "uri": "http://orcid.org/0000-0002-5982-8983",
                            "value": null
                        },
                        "external-id-reference": {
                            "value": "7004212771"
                        },
                        "external-id-url": {
                            "value": "http://www.scopus.com/inward/authorDetails.url?authorID=7004212771&partnerID=MN8TOARS"
                        }
                    }
                ],
                "visibility": null
            },
            "keywords": {
                "keyword": [
                    {
                        "value": "Computational catalysis, electrochemistry, CO2 capture"
                    }
                ],
                "visibility": null
            },
            "personal-details": {
                "family-name": {
                    "value": "Kitchin"
                },
                "given-names": {
                    "value": "John"
                }
            },
            "researcher-urls": {
                "researcher-url": [
                    {
                        "url": {
                            "value": "http://kitchingroup.cheme.cmu.edu"
                        },
                        "url-name": {
                            "value": "Research website"
                        }
                    }
                ],
                "visibility": null
            },
            "scope": null
        },
        "orcid-history": {
            "claimed": {
                "value": true
            },
            "completion-date": {
                "value": 1376581428004
            },
            "creation-method": "WEBSITE",
            "last-modified-date": {
                "value": 1427557747595
            },
            "source": null,
            "submission-date": {
                "value": 1376581211104
            },
            "visibility": null
        },
        "orcid-identifier": {
            "host": "orcid.org",
            "path": "0000-0003-2625-9232",
            "uri": "http://orcid.org/0000-0003-2625-9232",
            "value": null
        },
        "orcid-preferences": {
            "locale": "EN"
        },
        "type": "USER"
    }
}
#+end_example

That information is not too interesting, but it would allow you to scrape out my website, scopus id, and researcher id. Next, we look at the publications orcid knows about for me. These are integrated from a few sources, notably my researcherid:A-2363-2010, scopusid:7004212771, and http://crossref.org.  The next code block prints the bibtex entry for the first few entries. The bibtex entries are not too well formed, and would need some cleaning, but it is a pretty good start.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})

results = resp.json()
for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    print result['work-citation']['citation'].encode('utf-8') + '\n'
    if i == 2:
        break
#+END_SRC

#+RESULTS:
: @article{Xu_2015,doi = {10.1021/jp511426q},url = {http://dx.doi.org/10.1021/jp511426q},year = 2015,month = {mar},publisher = {American Chemical Society ({ACS})},volume = {119},number = {9},pages = {4827--4833},author = {Zhongnan Xu and Jan Rossmeisl and John R. Kitchin},title = { A Linear Response {DFT}$\mathplus$ U Study of Trends in the Oxygen Evolution Activity of Transition Metal Rutile Dioxides },journal = {J. Phys. Chem. C}}
:
: @article{Xu_2015,doi = {10.1063/1.4914093},url = {http://dx.doi.org/10.1063/1.4914093},year = 2015,month = {mar},publisher = {{AIP} Publishing},volume = {142},number = {10},pages = {104703},author = {Zhongnan Xu and John R. Kitchin},title = {Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides},journal = {J. Chem. Phys.}}
:
: @article{Boes_2015,doi = {10.1016/j.susc.2015.02.011},url = {http://dx.doi.org/10.1016/j.susc.2015.02.011},year = 2015,month = {mar},publisher = {Elsevier {BV}},author = {Jacob Boes and Peter Kondratyuk and Chunrong Yin and James B. Miller and Andrew J. Gellman and John R. Kitchin},title = {Core level shifts in Cu{\textendash}Pd alloys as a function of bulk composition and structure},journal = {Surface Science}}
:

Let us look at a tabular form of that data so it is sortable. We attempt to remove some duplicates based on the title and doi. The duplicates come about because there is more than one source where this data is pulled from. This is a little tricky, we do a case insensitive title comparison, but that still fails if the titles have different white space in them, e.g. "111" vs "1 1 1", and different sources do that. Also, the DOIs are sometimes missing, and sometimes have different cases, and sometimes are not correct. This code tries to fix most of those issues.

#+BEGIN_SRC python :results org
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})
results = resp.json()

data = []
TITLES, DOIs = [], []

for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    title = str(result['work-title']['title']['value'].encode('utf-8'))
    doi = 'None'

    for x in result.get('work-external-identifiers', []):
        for eid in result['work-external-identifiers']['work-external-identifier']:
            if eid['work-external-identifier-type'] == 'DOI':
                doi = str(eid['work-external-identifier-id']['value'].encode('utf-8'))

    # AIP journals tend to have a \n in the DOI, and the doi is the second line. we get
    # that here.
    if len(doi.split('\n')) == 2:
        doi = doi.split('\n')[1]

    pub_date = result.get('publication-date', None)
    if pub_date:
        year = pub_date.get('year', None).get('value').encode('utf-8')
    else:
        year = 'Unknown'

    # Try to minimize duplicate entries that are found
    dup = False
    if title.lower() in TITLES:
        dup = True
    if (doi != 'None'
        and doi.lower() in DOIs):
        dup = True

    if not dup:
        # truncate title to first 50 characters
        print('| {3} | {0}  | {1} | [[doi:{2}]]|'.format(title[0:50], year, doi, result['work-type']))

    TITLES.append(title.lower())
    DOIs.append(doi.lower())
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
| JOURNAL_ARTICLE  | A Linear Response DFT+ U Study of Trends in the Ox | 2015 | [[doi:10.1021/jp511426q]]                                |
| JOURNAL_ARTICLE  | Relationships between the surface electronic and c | 2015 | [[doi:10.1063/1.4914093]]                                |
| JOURNAL_ARTICLE  | Core level shifts in CuPd alloys as a function    | 2015 | [[doi:10.1016/j.susc.2015.02.011]]                       |
| JOURNAL_ARTICLE  | Estimating bulk-composition-dependent H2 adsorptio | 2015 | [[doi:10.1021/cs501585k]]                                |
| JOURNAL_ARTICLE  | Probing the Coverage Dependence of Site and Adsorb | 2014 | [[doi:10.1021/jp508805h]]                                |
| JOURNAL_ARTICLE  | Relating the electronic structure and reactivity o | 2014 | [[doi:10.1016/j.catcom.2013.10.028]]                     |
| JOURNAL_ARTICLE  | Electrocatalytic Oxygen Evolution with an Immobili | 2014 | [[doi:10.1021/ja5015986]]                                |
| JOURNAL_ARTICLE  | Identifying Potential BO 2 Oxide Polymorphs for Ep | 2014 | [[doi:10.1021/am4059149]]                                |
| JOURNAL_ARTICLE  | Simulating temperature programmed desorption of ox | 2014 | [[doi:10.1007/s11244-013-0166-3]]                        |
| JOURNAL_ARTICLE  | Probing the effect of electron donation on CO2 abs | 2014 | [[doi:10.1039/c3ra47097k]]                               |
| JOURNAL_ARTICLE  | Effects of concentration, crystal structure, magne | 2014 | [[doi:10.1021/jp507957n]]                                |
| JOURNAL_ARTICLE  | Effects of O 2 and SO 2 on the Capture Capacity of | 2013 | [[doi:10.1021/ie400582a]]                                |
| JOURNAL_ARTICLE  | Number of outer electrons as descriptor for adsorp | 2013 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Interactions in 1-ethyl-3-methyl imidazolium tetra | 2013 | [[doi:http://dx.doi.org/10.1016/j.molstruc.2013.01.046]] |
| JOURNAL_ARTICLE  | Comparisons of amine solvents for post-combustion  | 2013 | [[doi:http://dx.doi.org/10.1016/j.ijggc.2013.06.020]]    |
| JOURNAL_ARTICLE  | Chemical and Molecular Descriptors for the Reactiv | 2012 | [[doi:10.1021/ie301419q]]                                |
| JOURNAL_ARTICLE  | Spectroscopic Characterization of Mixed FeNi Ox   | 2012 | [[doi:10.1021/cs3002644]]                                |
| REPORT           | Modeling Coverage Dependence in Surface Reaction N | 2012 | [[doi:10.2172/1149701]]                                  |
| CONFERENCE_PAPER | Vibrational spectroscopy characterization of CO2-i | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | The role of electrolytes in the oxygen evolution r | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | The outlook for improved carbon capture technology | 2012 | [[doi:10.1016/j.pecs.2012.03.003]]                       |
| JOURNAL_ARTICLE  | Structure and Relative Thermal Stability of Mesopo | 2012 | [[doi:10.1111/j.1551-2916.2012.05236.x]]                 |
| JOURNAL_ARTICLE  | Preface: Trends in computational catalysis         | 2012 | [[doi:10.1007/s11244-012-9808-0]]                        |
| CONFERENCE_PAPER | Exergetic analysis of chemical looping reforming   | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Evaluation of a Primary Amine-Functionalized Ion-E | 2012 | [[doi:10.1021/ie300452c]]                                |
| CONFERENCE_PAPER | Electrocatalytic water oxidation using iron-center | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Effects of strain, d-band filling, and oxidation s | 2012 | [[doi:10.1063/1.4746117]]                                |
| BOOK             | Coverage dependent adsorption properties of atomic | 2012 | [[doi:10.1039/9781849734776-00083]]                      |
| CONFERENCE_PAPER | Comparisons of solvents for post-combustion CO2 ca | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Characterization of an ion exchange resin for CO2  | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Assessing the ability of using first principles to | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Universality in Oxygen Evolution Electrocatalysis  | 2011 | [[doi:10.1002/cctc.201000397]]                           |
| CONFERENCE_PAPER | The effect of CO 2 partial pressure on capture wit | 2011 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Preparation of Mesoporous La 0.8Sr 0.2MnO 3 infilt | 2011 | [[doi:10.1149/1.3570235]]                                |
| JOURNAL_ARTICLE  | Identification of sulfur-tolerant bimetallic surfa | 2011 | [[doi:10.1021/cs200039t]]                                |
| JOURNAL_ARTICLE  | Effects of strain, d-band filling, and oxidation s | 2011 | [[doi:10.1063/1.3631948]]                                |
| CONFERENCE_PAPER | Determining the conditions necessary for optimal C | 2011 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Configurational correlations in the coverage depen | 2011 | [[doi:10.1063/1.3561287]]                                |
| CONFERENCE_PAPER | An electronic structure based understanding of ami | 2011 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | CO2 Adsorption on Supported Molecular Amidine Syst | 2010 | [[doi:10.1002/cssc.201000056]]                           |
| JOURNAL_ARTICLE  | Separation of CO2 from flue gas using electrochemi | 2010 | [[doi:10.1016/j.fuel.2009.11.036]]                       |
| JOURNAL_ARTICLE  | New solid-state table: estimating d-band character | 2010 | [[doi:10.1080/08927022.2010.481794]]                     |
| JOURNAL_ARTICLE  | Simple model explaining and predicting coverage-de | 2010 | [[doi:10.1103/PhysRevB.82.045414]]                       |
| CONFERENCE_PAPER | Intrinsic and extrinsic factors associated with CO | 2010 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Electrochemical concentration of carbon dioxide fr | 2010 | [[doi:10.1149/1.3432440]]                                |
| CONFERENCE_PAPER | Catalyzing the catalyst: Hydrogen dissociation and | 2010 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Uncertainty and figure selection for DFT based clu | 2009 | [[doi:10.1080/08927020902833137]]                        |
| JOURNAL_ARTICLE  | Sulphur poisoning of water-gas shift catalysts: Si | 2009 | [[doi:10.1080/08927020902833129]]                        |
| JOURNAL_ARTICLE  | Step decoration of chiral metal surfaces           | 2009 | [[doi:10.1063/1.3096964]]                                |
| JOURNAL_ARTICLE  | Relating the coverage dependence of oxygen adsorpt | 2009 | [[doi:10.1016/j.susc.2009.01.021]]                       |
| JOURNAL_ARTICLE  | Hydrogen Dissociation and Spillover on Individual  | 2009 | [[doi:10.1103/PhysRevLett.103.246102]]                   |
| JOURNAL_ARTICLE  | Correlations in coverage-dependent atomic adsorpti | 2009 | [[doi:10.1103/PhysRevB.79.205412]]                       |
| CONFERENCE_PAPER | Catalyzing the catalyst: Novel pathways to hydroge | 2009 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Atomistic thermodynamics study of the adsorption a | 2009 | [[doi:10.1016/j.jcat.2008.11.020]]                       |
| CONFERENCE_PAPER | Ancillary oxygen-fired combustion using electroche | 2009 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Adsorbate Cu interactions and catalyst morphologie | 2009 | [[doi:None]]                                             |
| CONFERENCE_PAPER | <title>Rotational isomeric state theory applied to | 2008 | [[doi:10.1117/12.776303]]                                |
| CONFERENCE_PAPER | The effect of hydration on the adsorption of carbo | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt-decorated electrocatalysts for direct alcohol f | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | PEM-based electrochemical separation of gases      | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | First principles, atomistic thermodynamics for sul | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Evaluating uncertainty in Ab initio phase diagrams | 2008 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | ENVR 1-Basic research needs to assure a secure ene | 2008 | [[doi:None]]                                             |
| OTHER            | Density functional theory studies of alloys in het | 2008 | [[doi:10.1039/b608782p]]                                 |
| JOURNAL_ARTICLE  | Alloy surface segregation in reactive environments | 2008 | [[doi:10.1103/PhysRevB.77.075437]]                       |
| CONFERENCE_PAPER | A first principles evaluation of the role of subst | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt nanoparticle electrocatalyst synthesis for dire | 2007 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt nanoparticle anode electrocatalysts for direct  | 2007 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Response to &quot;comment on 'Trends in the exchan | 2006 | [[doi:10.1149/1.2358292]]                                |
| JOURNAL_ARTICLE  | Trends in the exchange current for hydrogen evolut | 2005 | [[doi:10.1149/1.1856988]]                                |
| JOURNAL_ARTICLE  | Trends in the chemical properties of early transit | 2005 | [[doi:10.1016/j.cattod.2005.04.008]]                     |
| CONFERENCE_PAPER | Alloy surface segregation in reactive environments | 2005 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | The role of adsorbate-adsorbate interactions in th | 2004 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Role of strain and ligand effects in the modificat | 2004 | [[doi:10.1103/PhysRevLett.93.156801]]                    |
| JOURNAL_ARTICLE  | Origin of the overpotential for oxygen reduction a | 2004 | [[doi:10.1021/jp047349j]]                                |
| JOURNAL_ARTICLE  | Modification of the surface electronic and chemica | 2004 | [[doi:10.1063/1.1737365]]                                |
| JOURNAL_ARTICLE  | Elucidation of the active surface and origin of th | 2003 | [[doi:10.1016/j.susc.2003.09.007]]                       |
| JOURNAL_ARTICLE  | A four-point probe correlation of oxygen sensitivi | 2003 | [[doi:10.1016/j.susc.2003.08.041]]                       |
| JOURNAL_ARTICLE  | A comparison of gold and molybdenum nanoparticles  | 2003 | [[doi:10.1016/s0039-6028(02)02679-1]]                    |
| JOURNAL_ARTICLE  | H3PW12O40-functionalized tip for scanning tunnelin | 2002 | [[doi:10.1073/pnas.072514399]]                           |
| JOURNAL_ARTICLE  | Preparation of paramagnetic ligands for coordinati | 1997 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Preparation and Characterization of a Bis-Semiquin | 1995 | [[doi:10.1021/jo00117a004]]                              |
| JOURNAL_ARTICLE  | SYNTHESIS AND CHARACTERIZATION OF TRISEMIQUINONE L | 1995 | [[doi:None]]                                             |
#+END_SRC

Not too bad. Clearly we could do a lot more work to fine tune exactly what data we retrieve, and then what to do with it. The tools are all here to do that.

* debugging outshine issue

#+BEGIN_SRC emacs-lisp
outline-regexp
#+END_SRC

#+RESULTS:
: \*+

#+BEGIN_SRC emacs-lisp
(require 'outshine)
#+END_SRC

#+RESULTS:
: outshine

#+BEGIN_SRC emacs-lisp
outline-regexp
#+END_SRC

#+RESULTS:
: \*+


* bibdesk links
We guess that this base64 encoded, so we decode it (M-x base64-decode-region) This then gives us a binary plist (it starts with bplist) which we can turn into a readable form with M-: plutil -convert xml1 -o - - RET

#+BEGIN_SRC emacs-lisp
(defun convert-bindata (beg end)
  (interactive "r")
  (let ((content (buffer-substring beg end)))
    (with-temp-buffer
      (insert
       (with-temp-buffer
	 (insert content)
	 (base64-decode-region (point-min) (point-max))
	 (shell-command-on-region (point-min) (point-max) "plutil -convert xml1 -o - -")
	 (set-buffer "*Shell Command Output*")
	 (buffer-string)))
      (message "%s"(xml-parse-region (point-min) (point-max))))))
#+END_SRC

#+RESULTS:
: convert-bindata

YnBsaXN0MDDUAQIDBAUGJCVYJHZlcnNpb25YJG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGGoKgHCBMUFRYaIVUkbnVsbNMJCgsMDxJXTlMua2V5c1pOUy5vYmplY3RzViRjbGFzc6INDoACgAOiEBGABIAFgAdccmVsYXRpdmVQYXRoWWFsaWFzRGF0YV8QLi4uLy4uLy4uLy4uLy4uL0RvY3VtZW50cy9QYXBlcnMvQWxiaW4vMjAwNi5wZGbSFwsYGVdOUy5kYXRhTxEBigAAAAABigACAAAMTWFjaW50b3NoIEhEAAAAAAAAAAAAAAAAAAAAzJJLUEgrAAAJ9GrLCDIwMDYucGRmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAn0a4DQ8zSXAAAAAAAAAAAABQAEAAAJIAAAAAAAAAAAAAAAAAAAAAVBbGJpbgAAEAAIAADMkq3AAAAAEQAIAADQ86UXAAAAAQAUCfRqywDX3BkABcoiAAXKIQACEEoAAgA/TWFjaW50b3NoIEhEOlVzZXJzOgBzdGFudG9uOgBEb2N1bWVudHM6AFBhcGVyczoAQWxiaW46ADIwMDYucGRmAAAOABIACAAyADAAMAA2AC4AcABkAGYADwAaAAwATQBhAGMAaQBuAHQAbwBzAGgAIABIAEQAEgAtVXNlcnMvc3RhbnRvbi9Eb2N1bWVudHMvUGFwZXJzL0FsYmluLzIwMDYucGRmAAATAAEvAAAVAAIADv//AACABtIbHB0eWiRjbGFzc25hbWVYJGNsYXNzZXNdTlNNdXRhYmxlRGF0YaMdHyBWTlNEYXRhWE5TT2JqZWN00hscIiNcTlNEaWN0aW9uYXJ5oiIgXxAPTlNLZXllZEFyY2hpdmVy0SYnVHJvb3SAAQAIABEAGgAjAC0AMgA3AEAARgBNAFUAYABnAGoAbABuAHEAcwB1AHcAhACOAL8AxADMAloCXAJhAmwCdQKDAocCjgKXApwCqQKsAr4CwQLGAAAAAAAAAgEAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAsg=

../../../../../Documents/Papers/Albin/2006.pdf

bplist00$%X$versionX$objectsY$archiverT$top !U$null
WNS.keysZNS.objectsV$class\relativePathYaliasData_.../../../../../Documents/Papers/Albin/2006.pdfWNS.dataO       Macintosh HD               KPH+  	j2006.pdf                                                       	k4            	                Albin               	j  " ! J  ?Macintosh HD:Users: stanton: Documents: Papers: Albin: 2006.pdf     2 0 0 6 . p d f    M a c i n t o s h   H D  -Users/stanton/Documents/Papers/Albin/2006.pdf   /      Z$classnameX$classes]NSMutableData VNSDataXNSObject"#\NSDictionary" _NSKeyedArchiver&'Troot    # - 2 7 @ F M U ` g j l n q s u w     Z\alu             (              

* Finding and handling duplicate bibtex entries
Duplicate bibtex entries in your bibtex file is a problem. Finding them is tricky because minor spelling differences, differences in capitalization, etc... make it difficult to use code to find duplicates. I find it good practice to keep your bibtex file sorted, so that duplicates tend to be near each other, and hence easier to spot. But with a large number of entries, this is still tedious to do.

I have been trying to learn more about the bibtex.el library, so I am going to use this opportunity to write some code for duplicate detection. The idea is to go through each entry, generate a key for it, and see if the key has already been generated. bibtex comes with bibtex-generate-autokey for generating keys automatically.

Here is my bibtex autokey setup. This is a reasonable balance (for me) of almost always generating new keys that are not too long, and with enough information to often tell which reference it is. Every once in a while there are title/author/year combinations that are close enough that the same key is generated, but it is not too frequent.

#+BEGIN_SRC emacs-lisp
;; variables that control bibtex key format for auto-generation
;; I want firstauthor-year-title-words
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

So, we will just map over our entries looking for places where the same key is generated. We will save markers to these, and generate a clickable link to jump to the places where we suspect duplicates. We will temporarily redefine the key algorithm to make longer, less likely to be the same, keys.

#+BEGIN_SRC emacs-lisp :results output org raw
(let ((bibtex-autokey-year-length 4)
      (bibtex-autokey-names nil)
      (bibtex-autokey-name-year-separator "-")
      (bibtex-autokey-year-title-separator "-")
      (bibtex-autokey-titleword-separator "-")
      (bibtex-autokey-titlewords nil)
      (bibtex-autokey-titlewords-stretch nil)
      (bibtex-autokey-titleword-length nil))
  (dolist (pd (with-current-buffer (find-file-noselect  "~/Dropbox/bibliography/references.bib")
		(let ((possible-duplicates '())
		      (found '()))
		  (bibtex-map-entries
		   (lambda (key start end)
		     (let ((akey (bibtex-generate-autokey)))
                       (unless (not (string= "" akey)) (setq akey key))
		       (if (assoc akey found)
			   (add-to-list
			    'possible-duplicates
			    (list (cons akey (cdr (assoc akey found)))
				  (cons akey (point-marker))))
			 (add-to-list 'found (cons akey (point-marker)))))))
		  possible-duplicates)))
    (princ (format "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][1. %S]] [[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][%S]]\n"
		   (marker-buffer (cdr (nth 0 pd)))
		   (marker-position (cdr (nth 0 pd)))
		   (car (nth 0 pd))
		   (marker-buffer (cdr (nth 1 pd)))
		   (marker-position (cdr (nth 1 pd)))
		   (car (nth 1 pd))))))
#+END_SRC

#+RESULTS:
[[elisp:(progn (switch-to-buffer "references.bib")(goto-char 627548))][1. "university-2012-factbook"]] [[elisp:(progn (switch-to-buffer "references.bib")(goto-char 627752))]["university-2012-factbook"]]



* A new approach to extracting bibtex file from org

org-ref has a function org-ref-extract-bibtex-entries that uses reftex to build a bibliography from an exported LaTeX file. I have learned a lot since I wrote that code, and in this post illustrate how to avoid the lengthy export process, and use mostly org-mode and built in bibtex functions to extract a bibtex file from org-ref citations.

This paragraph contains a single citation cite:goedecker-2004-minim. A
multicitation cite:kitchin-2002-molyb,kitchin-2004-tunin-the and some articles
cite:xu-2015-linear-respon,boes-2015-estim-bulk-si.

To extract the bibtex entries, we get all the unique keys in the buffer that we have cited.

#+BEGIN_SRC emacs-lisp
(defun get-cite-keys ()
  "Return list of cite keys in current buffer."
  (let ((all-keys '()))
    (org-element-map (org-element-parse-buffer) 'link
      (lambda (link)
	(when (-contains?
	       org-ref-cite-types
	       (org-element-property :type link))
	  (let* ((path (org-element-property :path link))
		 (keys (split-string path ",")))
	    (mapc (lambda (key) (add-to-list 'all-keys key)) keys)))))
    all-keys))

(get-cite-keys)
#+END_SRC
#+RESULTS:
| boes-2015-estim-bulk-si | xu-2015-linear-respon | kitchin-2004-tunin-the | kitchin-2002-molyb | goedecker-2004-minim |

Next we get data structures for each entry in the bibtex files. We will use this to construct the new bibtex file. Here is an example of an a-list we can use. Note, we use add-to-list here, so duplicate keys will be problematic; the second entry will not be included. Since you don't have duplicate entries (right ;) this won't be a big problem.

#+BEGIN_SRC emacs-lisp
(defun get-bibtex-entry-a-list ()
  "Return a-list of (key . entry-string) from files from
`org-ref-find-bibliography'."
  (let ((entries '()))
     (loop for bib-file in (org-ref-find-bibliography)
	   do
	   (with-current-buffer
	     (find-file-noselect bib-file)
	     (bibtex-map-entries
	      (lambda (key start end)
		(add-to-list 'entries (cons key (buffer-substring start end)))))))
     entries))

(cdr (assoc "boes-2015-estim-bulk-si" (get-bibtex-entry-a-list)))
#+END_SRC

#+RESULTS:
#+begin_example
@article{boes-2015-estim-bulk-si,
  author =	 {Jacob R. Boes and Gamze Gumuslu and James B. Miller and Andrew
                  J. Gellman and John R. Kitchin},
  title =	 {Supporting Information: Estimating Bulk-Composition-Dependent
                  \ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
                  Surfaces},
  keywords =	 {orgmode},
  journal =	 {ACS Catalysis},
  volume =	 5,
  pages =	 {1020-1026},
  year =	 2015,
  doi =		 {10.1021/cs501585k},
  url =
                  {http://pubs.acs.org/doi/suppl/10.1021/cs501585k/suppl_file/cs501585k_si_001.pdf},
}
#+end_example

Now, we just put these together to get an entry for each key in the current file:

#+BEGIN_SRC emacs-lisp
(let ((entries (get-bibtex-entry-a-list)))
  (mapconcat
   'identity
   (mapcar
    (lambda (key)
      (cdr (assoc key entries)))
    (get-cite-keys))
   "\n\n"))
#+END_SRC

#+RESULTS:
#+begin_example
@article{boes-2015-estim-bulk-si,
  author =	 {Jacob R. Boes and Gamze Gumuslu and James B. Miller and Andrew
                  J. Gellman and John R. Kitchin},
  title =	 {Supporting Information: Estimating Bulk-Composition-Dependent
                  \ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
                  Surfaces},
  keywords =	 {orgmode},
  journal =	 {ACS Catalysis},
  volume =	 5,
  pages =	 {1020-1026},
  year =	 2015,
  doi =		 {10.1021/cs501585k},
  url =
                  {http://pubs.acs.org/doi/suppl/10.1021/cs501585k/suppl_file/cs501585k_si_001.pdf},
}

@article{xu-2015-linear-respon,
  author =	 {Xu, Zhongnan and Rossmeisl, Jan and Kitchin, John R.},
  title =	 {A Linear Response {DFT}+{U} Study of Trends in the Oxygen
                  Evolution Activity of Transition Metal Rutile Dioxides},
  keywords =	 {DESC0004031, early-career, orgmode, },
  journal =	 {The Journal of Physical Chemistry C},
  volume =	 119,
  number =	 9,
  pages =	 {4827-4833},
  year =	 2015,
  doi =		 {10.1021/jp511426q},
  url =		 { http://dx.doi.org/10.1021/jp511426q },
  eprint =	 { http://dx.doi.org/10.1021/jp511426q },
}

@phdthesis{kitchin-2004-tunin-the,
  Author =	 {John R. Kitchin},
  Title =	 {Tuning the electronic and chemical properties
of metals: bimetallics and transition metal
carbides},
  School =	 {University of Delaware},
  Year =	 2004}

@MastersThesis{kitchin-2002-molyb,
  author =	 {John R. Kitchin},
  title =	 {Molybdenum nanoclusters on titanium dioxide single crystal surfaces},
  school =	 {University of Delaware},
  year =	 2002}

@article{goedecker-2004-minim,
  author =	 {Stefan Goedecker},
  title =	 {Minima Hopping: An Efficient Search Method for the Global
                  Minimum of the Potential Energy Surface of Complex Molecular
                  Systems},
  journal =	 {J. Chem. Phys.},
  volume =	 120,
  number =	 21,
  pages =	 9911,
  year =	 2004,
  doi =		 {10.1063/1.1724816},
  url =		 {http://dx.doi.org/10.1063/1.1724816},
  date_added =	 {Sat Mar 21 09:58:27 2015},
}
#+end_example

Well, that looks like it. All that is left is writing that string to a file.

#+BEGIN_SRC emacs-lisp
(defun org-ref-create-bib-file-from-org (bib-file)
  "Copy cited references to BIB-FILE."
  (interactive (list (ido-read-file-name "Bib file: " "." nil nil "references.bib")))
  (let ((all-entries (get-bibtex-entry-a-list))
	(content))
    (setq content
	  (mapconcat
	   'identity
	   (mapcar
	    (lambda (key)
	      (cdr (assoc key all-entries)))
	    (get-cite-keys))
	   "\n\n"))
    (with-temp-file bib-file
      (insert content)))
  (find-file bib-file))
#+END_SRC
#+RESULTS:
: org-ref-create-bib-file-from-org



* filename or file object

#+BEGIN_SRC python
with open('test.py', 'w') as fd:
    print fd.name
    print isinstance(fd, file)
#+END_SRC

#+RESULTS:
: test.py
: True


* Clickable org-contacts in Emacs

In exploring dynamic clickable text in Emacs, it occurred to me it might be interesting if your org-contact headings were clickable links.

#+BEGIN_SRC emacs-lisp :results silent
(require 'button-lock)
(global-button-lock-mode)

(setq org-contacts-cons
      (mapcar (lambda (entry)
		(let ((contact (with-temp-buffer
				 (insert (car entry))
				 (buffer-substring-no-properties
				  (point-min) (point-max)))))
		  (cons (s-trim contact) contact)))
	      (org-contacts-db)))


(setq org-contacts-regex (mapconcat 'identity
	   (mapcar 'car org-contacts-cons)
	   "\\|"))

(button-lock-set-button
 org-contacts-regex
 (lambda ()
   (interactive)
   ;; move point back to a non-matched link, based on face property
   (while (equal
	   (car (get-text-property (point) 'face))
	   'org-link)
     (backward-char))
   ;; search forward to find the match
   (re-search-forward org-contacts-regex)
   (let* ((contact-string (cdr (assoc (match-string 0) org-contacts-cons)))
	  (contact (assoc contact-string (org-contacts-db)))
	  (marker (elt contact 1)))
     (switch-to-buffer (marker-buffer marker))
     (goto-char (marker-position marker))))
 :face (list 'org-link))
#+END_SRC

  @johnkitchin

  Billy Bardin

* DONE Restarting org-babel sessions in org-mode more effectively
  CLOSED: [2015-03-19 Thu 18:53]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/03/19 18:53:18
  :updated:  2015/03/19 18:53:18
  :END:

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/12/Making-org-mode-Python-sessions-look-better/][post]] I eliminated one annoying problem with sessions, which was getting rid of extraneous Python interpreter characters in the output. Another thing that has bothered me is when you close Emacs, or even the session buffer, the session is, of course, lost. That means when you reopen the file, you have to run each block in order to continue your work. There does not seem to be a selective way to do this in org. So, in this post, we consider a simple approach to automate that. We want a function that will run all the blocks in a current session that are above the current point.


The idea is we will go to the beginning of the buffer, find all blocks that match the language of the block we are in, and in the session, and execute them. We can tell if a block is in a session by looking at the :parameters property of the block. Interestingly, if a block is not in a session, then session will be "none", if it is in an unnamed session, session will be nil, and otherwise, session will be the session name.

| scenario        | :session value |
|-----------------+----------------|
| no session      | "none"         |
| unnamed session | nil            |
| named session   | "name"         |

Here is a function for testing if a block is in a session.

#+BEGIN_SRC emacs-lisp
(defun src-block-in-session-p (&optional name)
  "Return if src-block is in a session of NAME.
NAME may be nil for unnamed sessions."
  (let* ((info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (body (nth 1 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))

    (cond
     ;; unnamed session, both name and session are nil
     ((and (null session)
	   (null name))
      t)
     ;; Matching name and session
     ((and
       (stringp name)
       (stringp session)
       (string= name session))
      t)
     ;; no match
     (t nil))))
#+END_SRC

Now, we need to get some information about the current point and block. We will want to run blocks that start before the current point, but not after. We will use org-element-map to find code blocks, and when the language and session of a code block matches the current block, and the block starts at a point earlier than the current point, then we will go to that block, and run it. Here is that code.

#+BEGIN_SRC emacs-lisp
(defun org-babel-restart-session-to-point (&optional arg)
  "Restart session up to the src-block in the current point.
Goes to beginning of buffer and executes each code block with
`org-babel-execute-src-block' that has the same language and
session as the current block. ARG has same meaning as in
`org-babel-execute-src-block'."
  (interactive "P")
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (let* ((current-point (point-marker))
	 (info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
	;; goto start of block
        (goto-char (match-beginning 0))
	(let* ((this-info (org-babel-get-src-block-info))
	       (this-lang (nth 0 this-info))
	       (this-params (nth 2 this-info))
	       (this-session (cdr (assoc :session this-params))))
	    (when
		(and
		 (< (point) (marker-position current-point))
		 (string= lang this-lang)
		 (src-block-in-session-p session))
	      (org-babel-execute-src-block arg)))
	;; move forward so we can find the next block
	(forward-line)))))
#+END_SRC


In the course of testing this, I found this function a little helpful to kill the current session so we start fresh.

#+BEGIN_SRC emacs-lisp
(defun org-babel-kill-session ()
  "Kill session for current code block."
  (interactive)
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (save-window-excursion
    (org-babel-switch-to-session)
    (kill-buffer)))
#+END_SRC

And also this one to remove all results in the buffer. This not at all selective, it removes results for session and non-session blocks.

#+BEGIN_SRC emacs-lisp
(defun org-babel-remove-result-buffer ()
  "Remove results from every code block in buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward org-babel-src-block-regexp nil t)
      (org-babel-remove-result))))
#+END_SRC

Ok, now for some testing. The rest of this post is pretty boring, just some blocks of mixed session and non-session to see if they get run. Skip to the [[*Summary]].

#+BEGIN_SRC python :session test  :var d=4
def f(x):
    y = 4 * x
    return y

print(f(d))
#+END_SRC

#+RESULTS:
: 16

Let us put a non-session block in this buffer for testing.

#+BEGIN_SRC python
a = 5
print(a)
#+END_SRC

Now, some more named session blocks.
#+BEGIN_SRC python :session test
print f(5)
#+END_SRC

#+RESULTS:
: 20

#+BEGIN_SRC python :session test
print 'ok'
#+END_SRC

#+RESULTS:
: ok

#+BEGIN_SRC python :session test
print 2
#+END_SRC

#+RESULTS:
: 2

An unnamed session that should not get run in restarting the named test session.

#+BEGIN_SRC python :session
print 886
#+END_SRC


#+BEGIN_SRC python :session test
print f(6)
#+END_SRC

#+RESULTS:
: 24

** Summary
This works pretty well so far.  It would be nice to consider making C-c C-c do this automatically, if the session does not exist, and maybe to take a prefix arg that would restart the session. Maybe on another day ;)

* DONE Clickable links for Twitter handles in Emacs
  CLOSED: [2015-03-18 Wed 12:20]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/03/18 12:20:18
  :updated:  2015/03/18 12:21:53
  :END:

Org-mode has clickable links, and they are awesome. You can make your own links, for example here is a link for twitter handles that opens a browser to the handle, and exports as an html link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type "twitter"
 (lambda (handle)
   (browse-url (concat "http://twitter.com/" handle)))
 (lambda (path desc backend)
   (format "<a href=\"http://twitter.com/%s\">%s</a>" path path)))
#+END_SRC

Check it out here: twitter:johnkitchin.

There is another alternative to make clickable text, and that is the button-lock package. You define a regular expression for the text you want to be clickable, and a function to run when it is clicked. Here is an example.

#+BEGIN_SRC emacs-lisp :results silent
(require 'button-lock)
(global-button-lock-mode)

(button-lock-set-button
 "@\\([-a-zA-Z0-9_:]*\\)"
 (lambda ()
   (interactive)
   (re-search-backward "@")
   (re-search-forward  "@\\([a-zA-Z0-9_]*\\)")
   (let* ((handle (match-string-no-properties 1)))
     (browse-url (concat "http://twitter.com/" handle))))
 :face '(:foreground "red"  :underline t))
#+END_SRC

Check it out: @johnkitchin. Of course, you can make your clicking function more sophisticated, e.g. to give you a [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/22/org-mode-links-meet-hydra/][menu of options]], e.g. to send a tweet to someone, or open the web page, or look them up in your org-contacts. The differences between this and an org-mode link are that this works in any mode, and it has no export in org-mode, so it will go as plain text. Since this is just a feature for Emacs though, that should be fine.


* font-locking to make clickable links for pandoc citations

Org-mode has clickable links, and they are awesome. There is a new citation syntax being discussed, and these too will be clickable. Here we just explore a little approach to make clickable text using the button-lock package. We will use it to make pandoc citations clickable in Emacs. A pandoc citation looks like [@dominik-2010-org-mode].

This code makes pandoc citation links clickable, as you type them in.

#+BEGIN_SRC emacs-lisp :results silent
(require 'button-lock)
(global-button-lock-mode)

(button-lock-set-button
 "@\\([-a-zA-Z0-9_:]*\\)"
 (lambda ()
   (interactive)
   (re-search-backward "@")
   (re-search-forward  "@\\([-a-zA-Z0-9_:]*\\)")
   (let* ((key (match-string-no-properties 1))
	  (bibfile (cdr (org-ref-get-bibtex-key-and-file key))))
     (if bibfile
	(save-excursion
	  (with-temp-buffer
	    (insert-file-contents bibfile)
	    (bibtex-search-entry key)
	    (message (org-ref-bib-citation))))
       (message "No entry found"))))
 :face (list 'org-link))
#+END_SRC

* DONE Update on org-ref - it is now all emacs-lisp
  CLOSED: [2015-03-16 Mon 08:51]
  :PROPERTIES:
  :categories: emacs,orgmode,orgref
  :date:     2015/03/16 08:51:50
  :updated:  2015/03/16 08:51:50
  :END:

The [[https://github.com/jkitchin/org-ref][org-ref]] code is finally all in emacs-lisp! This should make it much easier to install, and is another step closer to getting org-ref into MELPA. Previously, I had written the most significant code in org-mode source blocks that were intended to be tangled out. I found this was not really portable, because what gets tangled depends on your org-mode setup. I had to specifically set example blocks to not tangle, or org-ref would not work for other people, and if I forgot to set a block to tangle, it also would not work for others. That should not happen again now, since there is no more tangling.


There are some relatively new features in org-ref:
1. New colored org-ref links to differentiate them from other
   org-links. Citations are greenish, refs and labels are maroonish.
2. Context messages about links. With your cursor on a cite, ref or label link
   you will get a context message, e.g. a formatted citation, some context about
   the label a ref refers to, or a count of the labels in the mini-buffer.
3. There is now an org-ref menu in the Org menu.
4. There is a new org-ref-help function that opens an org-file of org-ref
   documentation.
5. Pretty thorough integration of helm throughout org-ref, and some integration
   of hydra.
6. A few utility libraries: doi-utils, isbn, wos, pubmed, arxiv, jmax-bibtex, sci-id,
   x2bib. Not all these are new, but if you didn't know about them, check them out.
7. Cask integration. This mostly provides access to testing and dependencies
   right now. org-ref is also now tested continuously at
   https://travis-ci.org/jkitchin/org-ref.

org-ref is basically feature complete I think (which is to say that once again, I do not have any big ideas for new features ;). There are some places where it could be refactored a little, e.g. there are some bibtex only functions in org-ref.el that really should go into jmax-bibtex.el (which also could be renamed). This is a very low priority though, because things are working fine as far as I can tell.

What does it need before going into MELPA? Probably some tests would be a good idea. On Travis, all that is really tested is that it loads with no errors. I would like to see some stability on my end, e.g. at least a week where no commits get made, and no errors are reported. And finally, I would like to make sure I have some time to handle issues that come up when a broader audience is trying it out.

My target date to get this in MELPA is June 1, 2015. Try out the new org-ref, and let me know how it goes!
* PDFsync for org files


\(e^x = 3.14\)

First, we need a way to check if the current buffer has changed since the last time we built so we can avoid unnecessary builds. We can use an md5 sum for this. We will just store the md5 sum in a global variable, so we can compare it at any point in time.

#+BEGIN_SRC emacs-lisp
(md5 (current-buffer))
#+END_SRC

#+RESULTS:
: 62126c8993a8caa7541c42a907660b08

We want our build to happen asynchronously, so we can continue typing. First, we develop the build function.

#+BEGIN_SRC emacs-lisp
(defvar *last-md5* nil "md5 of current buffer")
(defvar *async-building* nil "is a build happening")

(defun async-build ()
  (interactive)
  (cond
   (*async-building*
    (message "Build in progress"))
   ((equal *last-md5* (md5 (current-buffer)))
    (message "No change to build"))
   (t
    (message "building")
    (setq *last-md5* (md5 (current-buffer)))
    (setq *async-building* t)
    (save-buffer)
    (org-latex-export-to-pdf t))))
#+END_SRC
#+RESULTS:
: async-build

That last function will launch an asynchronous build process. We can see the contents and progress of this in this variable.

#+BEGIN_SRC emacs-lisp
org-export-stack-contents
#+END_SRC
#+RESULTS:
| *Org Export Process*                                         | nil   | org-export-process    |
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.pdf | latex | (21752 50592 42735 0) |
| #<killed buffer>                                             | nil   | org-export-process    |


When the export is done,
#+BEGIN_SRC emacs-lisp
org-export-stack-contents
#+END_SRC
#+RESULTS:
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.pdf | latex | (21752 51636 244054 0) |
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.tex | latex | (21752 51630 69022 0)  |
| #<killed buffer>                                             | nil   | org-export-process<10> |
| #<killed buffer>                                             | nil   | org-export-process<9>  |
| #<killed buffer>                                             | nil   | org-export-process<8>  |
| #<killed buffer>                                             | nil   | org-export-process<7>  |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process<6>  |
| #<killed buffer>                                             | nil   | org-export-process<5>  |
| #<killed buffer>                                             | nil   | org-export-process<4>  |
| #<killed buffer>                                             | nil   | org-export-process<3>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process<2>  |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process<4>  |
| #<killed buffer>                                             | nil   | org-export-process<3>  |
| #<killed buffer>                                             | nil   | org-export-process<2>  |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |


We can view the result here in docview.
#+BEGIN_SRC emacs-lisp
(find-file-other-window (caar org-export-stack-contents))
#+END_SRC
#+RESULTS:
: #<buffer blog.pdf>

The last little idea is to create an idle timer to launch the build whenever we are idle. There are some tricks we want to use. First, we need to save the timer so we can cancel it later. Second, we need two timers, one to start the build, and one to check when it is done.

#+BEGIN_SRC emacs-lisp
(defvar async-message-timer1 nil
  "Variable to store the timer in.")

(defvar async-message-timer2 nil
  "Variable to store the timer in.")

;; timer that starts builds when we are idle
(setq async-message-timer1 (run-with-idle-timer 0.5 t 'async-build))

(setq async-message-timer2
      (run-with-idle-timer
       0.5 t
       (lambda ()
	 (when (and (stringp (caar org-export-stack-contents))
		    (file-exists-p (caar org-export-stack-contents))
                    (string= "pdf" (f-ext (caar org-export-stack-contents))))
	   (setq *async-building* nil)
	   (find-file-other-window (caar org-export-stack-contents))))))
#+END_SRC

#+RESULTS:
: [nil 0 0 500000 t (lambda nil (when (and (stringp (caar org-export-stack-contents)) (file-exists-p (caar org-export-stack-contents)) (string= "pdf" (f-ext (caar org-export-stack-contents)))) (setq *async-building* nil) (find-file-other-window (caar org-export-stack-contents)))) nil idle 0]

#+BEGIN_SRC emacs-lisp
(cancel-timer async-message-timer1)
(cancel-timer async-message-timer2)
#+END_SRC
#+RESULTS:


* Writing emacs-lisp code with lentic
  :PROPERTIES:
  :categories: emacs
  :END:
org-mode provides a way to do literate programming where you can intermingle code and narrative text. The code can be "tangled" out to the real executable code file. I mostly love this capability, and have used it to write several packages in [[https://github.com/jkitchin/org-ref][jkitchin/org-ref]]. There are some things that are tricky though. I find I have to manage carefully which blocks get tangled explicitly because different setups might have different default tangle behavior. This does allow me to intermingle code, example usage, and even tests in one document.  After it has been tangled, all the narrative text is gone, and separated from what I consider to be the "source". Not everyone is fluent in using org to automatically load code from an org file. Finally, it is not currently possible to distribute org-ref through MELPA or to include it in org because the code is in org-format. I could have some kind of release tool, perhaps a Makefile that tangles the file to make an elisp file, and ideally run some tests on it. I want to avoid this redirection, and keep the source as close to what I use as possible, ideally the same as what I use.

Here we consider [[https://github.com/phillord/lentic][phillord/lentic]], which is an alternative point of view to literate programming. In lentic, you have a source file that is in its native language, e.g. emacs-lisp, but you can create a view of the file as if it was an org-mode file. You can edit either view, and both views are automatically updated in the proper format, i.e. narrative text in org appears as comments in emacs-lisp, and code in emacs-lisp appears in a source block in org. There is only one permanent file, and the views exist temporarily.

Is this useful? The code in the end is functionally equivalent, and a user would never know the difference. It is useful then, if it helps the author write better code, or a maintainer to maintain it. Being both of those for some packages, hopefully this will be useful!

So, lentic works by having some minor markup in the emacs-lisp code that enables it to transform the elisp to an org-file. For example consider this example from the lentic package:
#+BEGIN_SRC emacs-lisp
;;; orgel-org.el --- A test file -*- lexical-binding: t -*-

;; Author: Phillip Lord

;;; Commentary:

;; This is an "orgel" file. That is a valid emacs lisp file with comments in
;; org-mode. The header comments are translated into header one in org mode.


;; #+BEGIN_SRC emacs-lisp
(defun orgel-function ())
;; #+END_SRC

;; And we finish off with the local variables declaration.

;; # Local Variables:
;; # lentic-init: lentic-orgel-org-init
;; # End:
#+END_SRC

There is mostly the usual header section, but the code is wrapped in comments that resemble the org-mode code-block. There is also a local variable that is defined when the file is opened. There is a small amount of boiler-plate stuff here, namely the top line and the local variables. I should note that lentic provides a function to insert the local variables for you, and it is bound to "C-c , f", and it even has completion. It is important that the lentic-init variable be defined before you can create a lentic view. This makes for a minor dilemma in starting a new file you want to edit with lentic. When you first create the file you need to create the file and either manually set this variable, or open it and close it. You need this file because it might be possible you prefer a LaTeX file instead of an org-file, or in the future perhaps some other kind of markup like markdown, etc... Maybe the file wouldn't even be emacs-lisp, it could be clojure, or one might hope Python in the future.

Anyway, this brings me to the point of this post, which is to write a little function that generates this boilerplate stuff and creates a lentic view for a new file, or that opens an existing file in my preferred view.

#+BEGIN_SRC emacs-lisp
(defun lentic-open-orgel (base-name)
 "Create a new lentic el file if base-name.el does not exist, or open it if it does.
Create a lentic view with org-file on the right."
 (interactive "sBase name (no extension): ")
 (delete-other-windows)
 (unless (file-exists-p (concat base-name ".el"))
   (with-temp-file (concat base-name ".el")
     (insert
      (format ";;; %s.el ---    -*- lexical-binding: t -*-
;;; Header:

;;; Commentary:

;;; Reminders about lentic:
;; Lentic key binding reminders
;; C-c , h  Move here in other view
;; C-c , s  Swap windows
;; [[elisp:lentic-mode-split-window-right]]  C-c o to open this link and make the view

;;; Code:

;;; %s.el ends here

;; # Local Variables:
;; # lentic-init: lentic-orgel-org-init
;; # End:" base-name base-name))))
 (find-file (concat base-name ".el"))
 (lentic-mode-split-window-right))
#+END_SRC
#+RESULTS:
: lentic-open-orgel

#+BEGIN_SRC emacs-lisp
(lentic-open-orgel "test-orgel")
#+END_SRC

Time will tell if I use this often. Maybe there are other simpler ways to do this that bypass the local variables. The lentic source uses a directory variable, but that is nearly the same except that it might have less impact on the distributed code. In any case, I really like this idea.

* Exceptions on entering a context manager

#+BEGIN_SRC python
class WithContext(object):
    def __init(self, context):
        print('within context init({0})'.format(context))

    def __enter__(self):
        print('Entering')

        try:
            raise Exception('NotImplemented')
        except:
            self.__exit__('exception in enter')
            raise

    def __exit__(self, *args):
        print('Exiting with {0}'.format(args))
        return False

with WithContext() as c:
    print("running context test")
#+END_SRC

#+RESULTS:

* Find value in column 2 corresponding to maximum of column 4

#+tblname: tab-data
| Menge (x) | P(x) |   E(x) |   K(x) |  Gewinn |
|-----------+------+--------+--------+---------|
|         0 |   20 |   0.00 | 140.00 | -140.00 |
|        10 |   18 | 180.00 | 180.00 |    0.00 |
|        20 |   16 | 320.00 | 220.00 |  100.00 |
|        30 |   14 | 420.00 | 260.00 |  160.00 |
|        40 |   12 |    100 |    158 |      50 |



#+BEGIN_SRC emacs-lisp :var data=tab-data :results code
(let ((c4 (mapcar (lambda (x) (nth 4 x)) data))
      (c2 (mapcar (lambda (x) (nth 2 x)) data)))
   (nth (-elem-index (-max c4) c4) c2))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
420.0
#+END_SRC


org-table-get-field
(org-table-next-row)
(org-table-goto-column
(org-table-current-column)

#+BEGIN_SRC emacs-lisp
(defun jt ()
 "find max in column, message the corresponding value in column 3."
 (interactive)
 (let ((max (string-to-number (org-table-get-field)))
       (row (org-table-current-line)))
   (while (org-table-next-row)
     (when (>  (string-to-number (org-table-get-field)) max)
       (setq max (string-to-number (org-table-get-field))
	     ind (org-table-current-line))))
   (org-table-goto-line ind)
   ; columns start at 1?
   (org-table-goto-column 3)
   (message-box "%s" (org-table-get-field))))
#+END_SRC

#+RESULTS:
: jt

* Wrapping selected text into an org-block
** Wrap selected text in an org block
:PROPERTIES:
:EXPORT_TITLE: An Interesting Article
:EXPORT_AUTHOR: Simon Jones
:EXPORT_FILE_NAME: an-interesting-article
:EXPORT_DATE: 2015-02-16
:END:


#+BEGIN_SRC emacs-lisp
(defun export-subtree ()
 (interactive)
 (let ((fname  (concat (org-entry-get (point) "EXPORT_FILE_NAME") ".org"))
       (author (org-entry-get (point) "EXPORT_AUTHOR"))
       (title (org-entry-get (point) "EXPORT_TITLE"))
       (date (org-entry-get (point) "EXPORT_DATE"))
       (content (progn (set-buffer (org-org-export-as-org nil t t))
                   (buffer-string))))
   ;; warning you can delete something unintentionally
   (when (file-exists-p fname) (delete-file fname))
   (find-file fname)
   (insert "#+TITLE: " title "\n")
   (insert "#+AUTHOR: " author "\n")
   (insert "#+DATE: " date "\n")
   (insert "\n" content)
   ;; remove properties drawer. Kind of hacky.
   (goto-char (point-min))
   (re-search-forward ":PROPERTIES:")
   (setf (buffer-substring
	  (org-element-property :begin (org-element-context))
	  (org-element-property :end (org-element-context)))
           "")
   (save-buffer)))

(export-subtree)
#+END_SRC

#+RESULTS:



#+BEGIN_SRC emacs-lisp
(defun wrap-text-in-org-block (start end)
  (interactive "r")
  (goto-char end)
  (insert "\n#+END_QUOTE\n")
  (goto-char start)
  (insert "\n#+BEGIN_QUOTE:\n"))
#+END_SRC


#+BEGIN_QUOTE:
TEstesat
#+END_QUOTE

* Command line export of a section in an org-file
#+LATEX_CLASS: article
#+BEGIN_SRC emacs-lisp :tangle export-org-section :shebang #!/bin/sh
:;exec emacs -batch  -l ~/Dropbox/kitchingroup/jmax/init.el -l "$0" "$@"

;; usage: export-org-section section-id org-file

;; now goto, narrow and export the section
(let ((section-id (pop command-line-args-left))
      (org-file (pop command-line-args-left)))
  (print (format "Opened %s" org-file))
  (find-file (expand-file-name org-file))
  (org-open-link-from-string (format "[[#%s]]" section-id))
  (org-narrow-to-subtree)
  (org-latex-export-to-pdf)
)
#+END_SRC


#+BEGIN_SRC sh :results silent
rm -f blog.pdf
./export-org-section sec-2 blog.org
open blog.pdf
#+END_SRC

** Test section 1
   :PROPERTIES:
   :CUSTOM_ID: sec-1
   :END:

Some words and an equation \(e^x-1=0\).


** Test section 2
   :PROPERTIES:
   :CUSTOM_ID: sec-2
   :END:

Some words and a table:

| a | b |
|---+---|
| 9 | 8 |
| 8 | 8 |


#+BEGIN_SRC emacs-lisp :tangle test2 :shebang #!/bin/sh
#!/bin/sh
":"; exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(defun main ()
  (print (version))
  (print (format "I did it. you passed in %s" command-line-args-left)))

(main)
;; Local Variables:
;; mode: emacs-lisp
;; End:
#+END_SRC


#+BEGIN_SRC sh
./test2 arg1 arg2 arg3
#+END_SRC
#+RESULTS:
:
: "GNU Emacs 25.0.50.1 (x86_64-apple-darwin13.4.0, NS appkit-1265.21 Version 10.9.5 (Build 13F34))
:  of 2015-01-18 on vpn-128-237-146-193.library.vpn.cmu.edu"
:
: "I did it. you passed in (arg1 arg2 arg3)"
* test Rasmus link code
from [[mu4e:msgid:87bnlcdj7d.fsf@gmx.us][Re: {O} Citations, continued]]

#+BEGIN_SRC emacs-lisp

(with-eval-after-load 'org
  (require 'reftex-cite)

  (defmacro rasmus/org-bib-add-type (type)
    ;; TODO: maybe this can be made more effective?
    ;; Seems to work OK...
    `(org-add-link-type
      ,type
      'rasmus/org-bib-follow
      ,(lambda (path description backend)
	 (funcall 'rasmus/org-bib-format path description backend
                  ;; cite defaults to textcite
		  (if (equal type "cite") "textcite" type)))))

  (mapc (lambda (type) (funcall 'rasmus/org-bib-add-type type))
        '("cite" "textcite" "parentcite" "citeyear" "citeauthor"))

  (defun rasmus/org-bib-follow (path)
    "Find the pdf version of citation."
    (let* ((stream (read (format "(%s)" path))))
      (rasmus/find-lit (car head))))

  (defun rasmus/find-lit (key)
    "Open pdf file associated with KEY from `reftex-default-bibliography'."
    (let* ((bib (file-name-directory (car reftex-default-bibliography)))
           (file (concat bib path (concat "/" key ".pdf"))))
      (when (file-exists-p file) (find-file file))))

  (defun rasmus/org-bib-format (path description backend &optional type*)
    "Format a org-link citation.

 Support links of the type

 [[type*:key :pre PRE :post POST :type TYPE**]]

 Or

 [[Key*:key][POST;PRE]]

Based on John K's great post here:
    http://permalink.gmane.org/gmane.emacs.orgmode/94575"
    (let* ((key
            ;; key is a single symbol by assumption
            (and (string-match "\\` *\\([^ ]+\\) *" path)
                 (prog1 (match-string 1 path)
                   (setq path (replace-match "" nil nil path)))))
           ;; generate plist
           (data (read (format "(%s)"
                               (replace-regexp-in-string
                                "\\(:\\w+\\) \\([^:]+\\) ?" "\\1 \"\\2\" "
                                path))))
           (type (or (plist-get data :type) type* "textcite"))
           (pre  (org-trim (or (plist-get data :pre)
			       ;; support my "old" syntax
			       (and description
				    (cadr (split-string description ";"))) "")))
	   (post (org-trim
		  (or (funcall (lambda (txt)
				 (and txt
				      (let ((res (string-to-number txt)))
					(if (zerop res) txt
					  (concat (if (> (length txt) 1)  "pp." "p.") " " txt)))))
			       (plist-get data :post))
		      (and description
			   (car (split-string description ";")))
		      "")))
	   (entry (or (save-window-excursion
                        (bibtex-search-entry key t 0)
                        (bibtex-parse-entry))
                      (error (format "unknown key: %s" key))))
           (author (or (reftex-format-citation entry "%2a") ""))
           (year (or  (reftex-format-citation entry "%y") "")))
      (if (org-export-derived-backend-p backend 'latex)
          (format "\\%s[%s][%s]{%s}" type pre post key)
        ;; TODO: This should probably be wrapped in <cite>.</cite> with html...
        (cl-case (intern type)
          (parencite
           (format "(%s %s %s %s)"
                   pre author
                   (or (and (org-string-nw-p year) (concat year ", ")) "")
                   post))
          (citeyear
           (format "%s %s %s" pre year post))
          (citeauthor
           (format "%s %s %s" pre author post))
          (fullcite
           (reftex-format-citation entry reftex-cite-view-format))
          (t ;; textcite
           (format "%s (%s%s%s)"
                   author
                   (and (org-string-nw-p pre) (concat pre " "))
                   year
                   (and (org-string-nw-p post) (concat ", " post)))))))))


#+END_SRC


* About face

You have probably wondered why some words are colored in Emacs and wondered how some text behaves like a link. That happens from font locking. Here we look at some ways you can modify this behavior too.

Following and lightly adapting the example here [[info:emacs#Font%20Lock][info:emacs#Font Lock]], we can add some keywords that get highlighted for us like this:

#+BEGIN_SRC emacs-lisp :results silent
(font-lock-add-keywords
 nil  ;; mode, nil for current buffer
 '(("FIXME"  ; regexp with group you want to match
    'font-lock-warning-face	; the face to use
)))
#+END_SRC

FIXME some text. FIXME again. It works!

How do you know what faces are available? M-x list-faces-display will give you a nice buffer of face names you can choose from. Let's do one better though, and create our own face.

#+BEGIN_SRC emacs-lisp
(defface my-face
  '((t		; display type
     (:background "yellow" :foreground "black")))
     "My custom face.")

(font-lock-add-keywords
 'org-mode  ;; mode, nil for current buffer
 '(("BROKEN"  ; regexp with group you want to match
    0
    'my-face	; the face to use
)))
#+END_SRC

#+RESULTS:


 BROKEN  fdsafdFIXME




* Count headlines in current level


#+BEGIN_SRC emacs-lisp
(save-restriction
  (org-narrow-to-subtree)
  (1- (length
   (org-element-map
       (org-element-parse-buffer)
       'headline
     (lambda (x) 1)))))
#+END_SRC

#+RESULTS:
: 5

** one
** two
*** three
**** four
** five

* org-element-explorer
  :PROPERTIES:
  :CATEGORY: emacs
  :END:

#+OPTIONS: toc:nil ^:{}

#+TITLE: org-element-explorer

#+caption: some table.
| 2 | 4 |
| e | r |
| 5 | 6 |

cite:shi-2007-first-au

#+caption: image caption
#+label: citations
[[./images/2014-citations.png]]


\( sin(x) = 5\)

#+BEGIN_EXAMPLE
example
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defvar org-ref-last-mouse-pos nil
 "Stores last mouse position for use in `org-ref-mouse-message'.")

(defun can-move-p ()
  "See if a character is under the mouse. If so return the position for `goto-char'."
  (let* ((line (cddr org-ref-last-mouse-pos))
	 (col  (cadr org-ref-last-mouse-pos)))
    (save-excursion
      (goto-char (window-start))
      (forward-line line)
      (if
	  (> (- (line-end-position) (line-beginning-position)) col)
	  (progn  (forward-char col) (point))
	nil))))

(defun org-element-explorer ()
  "Display buffer with org-element context under mouse cursor."
  (interactive)

        (let ((context (org-element-context))
              (cb (current-buffer)))
	  (switch-to-buffer "*org-element*")
	  (erase-buffer)
	  (emacs-lisp-mode)
	  (insert (format "%s"  context))
	  (goto-char (point-min))
	  (while (re-search-forward ":" nil t)
	    (backward-char)
	    (insert "\n")
	    (forward-char))
	  (goto-char (point-min))
	  (special-lispy-multiline)
	  (switch-to-buffer cb)
          ))

(add-hook 'post-command-hook 'org-element-explorer nil t)
;(remove-hook 'post-command-hook 'org-element-explorer)
#+END_SRC

#+RESULTS:
| org-element-explorer | whitespace-post-command-hook | t | flyspell-post-command-hook |

** TODO a subheading
   SCHEDULED: <2015-01-28 Wed> DEADLINE: <2015-01-29 Thu>

* Getting messages about the link under the mouse cursor
Now that I have set up org-ref to give minibuffer messages when the cursor is on a link, I thought, why can't this happen when I mouse over a link. I am likely to just mouse over links while reading them, and not necessarily have the cursor moving. Well, here is the idea. We can get the mouse position, which is approximately the number of lines from the top of the frame, and a number of characters from the beginning of a line. A trick is that there may not be a character at that position, if the line is shorter than those characters. So, we will have to calculate from the mouse position whether there is a character where the mouse is.

Another trick is we don't want to remessage our selves constantly, so we will store the last mouse position, and not do anything unless it changes.

An idle timer does not do what we want here. Apparently, idle refers to the cursor, not the mouse. I use a regular timer here, and run it every 1/2 second. I don't notice any performance issues with this.

#+BEGIN_SRC emacs-lisp
efvar org-ref-last-mouse-pos nil
 "Stores last mouse position for use in `org-ref-mouse-message'.")

(defun can-move-p ()
  "See if a character is under the mouse. If so return the position for `goto-char'."
  (let* ((line (cddr org-ref-last-mouse-pos))
	 (col  (cadr org-ref-last-mouse-pos)))
    (save-excursion
      (goto-char (window-start))
      (forward-line line)
      (if
	  (> (- (line-end-position) (line-beginning-position)) col)
	  (progn  (forward-char col) (point))
	nil))))

(defun org-ref-mouse-message ()
  "Display message for link under mouse cursor"
  (interactive)
  (when (not (equal (mouse-position) org-ref-last-mouse-pos))
    (setq org-ref-last-mouse-pos (mouse-position))
    (when (can-move-p)
      (save-excursion
	(goto-char (can-move-p))
	(org-ref-link-message)))))


(setq org-ref-message-timer-mouse
       (run-at-time "0.5 sec" 0.5 'org-ref-mouse-message))

;(cancel-timer org-ref-message-timer-mouse)
#+END_SRC

#+RESULTS:
: [nil 21706 25351 779030 0.5 org-ref-mouse-message nil nil 0]

Ok, that is the code. Here are some links to test it out.

ref:icon


label:icon


cite:shi-2007-first-au

cite:needs-1989-calcul,jarvi-2008-devel-reaxf

It looks like it worked pretty well for me!




* org to org


http://google.com

mailto:jkitchin@andrew.cmu.edu



one citation cite:shi-2007-first-au


multi-citation cite:shi-2007-first-au,jarvi-2008-devel-reaxf,kondratyuk-2013


pre and post text  [[cite:grimme-2006-semiem-gga][See::page 34]]


Just pre text [[cite:marjolin-2015-therm-descr][See also]]

#+BEGIN_SRC emacs-lisp
(defun pandoc-cite-format (link contents info)
  (if (-contains? org-ref-cite-types  (org-element-property :type link))
      (cond
       ;; link with description
       ((org-element-property :contents-begin link)
	(let* ((contents (buffer-substring
			  (org-element-property :contents-begin link)
			  (org-element-property :contents-end link)))
	       (split (split-string contents "::"))
	       (pre-text (nth 0 split))
	       (post-text (nth 1 split)))
	  (concat
	   "[@" (org-element-property :path link)
	   (when pre-text (concat ", " pre-text))
	   (when post-text (concat ", " post-text))
	   "]"
	   )
	  ))
       ;; plain citations
       (t
	(concat "["
	      (mapconcat (lambda (key) (concat "@" key))
			 (split-string (org-element-property :path link) ",")
			 "; ")
	      "]")))
    ;; not a cite link. just return the original link
    (org-org-identity link contents info)))

(org-export-define-derived-backend 'pandoc-org 'org
  :translate-alist '((link . pandoc-cite-format)))

(find-file (org-export-to-file 'pandoc-org "org-to-org.org"))
#+END_SRC

#+RESULTS:





* exploring Zotero sqlite

#+BEGIN_SRC sh
cp /Users/jkitchin/Library/Application\ Support/Zotero/Profiles/hiro2nsy.default/zotero/zotero.sqlite .
#+END_SRC

#+RESULTS:

What tables do we have?
#+BEGIN_SRC sqlite :db zotero.sqlite :list
.tables
#+END_SRC

#+RESULTS:
#+begin_example
annotations                itemNotes
baseFieldMappings          itemSeeAlso
baseFieldMappingsCombined  itemTags
charsets                   itemTypeCreatorTypes
collectionItems            itemTypeFields
collections                itemTypeFieldsCombined
creatorData                itemTypes
creatorTypes               itemTypesCombined
creators                   items
customBaseFieldMappings    libraries
customFields               proxies
customItemTypeFields       proxyHosts
customItemTypes            relations
deletedItems               savedSearchConditions
fieldFormats               savedSearches
fields                     settings
fieldsCombined             storageDeleteLog
fileTypeMimeTypes          syncDeleteLog
fileTypes                  syncObjectTypes
fulltextItemWords          syncedSettings
fulltextItems              tags
fulltextWords              transactionLog
groupItems                 transactionSets
groups                     transactions
highlights                 translatorCache
itemAttachments            users
itemCreators               version
itemData                   zoteroDummyTable
itemDataValues
#+end_example

Best I can tell, items contains a list of our items. Although, this db should have 4 items. presumably it kept some things I deleted.

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select itemID,key from items;
#+END_SRC
#+RESULTS:
: 1|ABCD2345
: 2|ABCD3456
: 3|95VXFTCD
: 4|TKAZVJDH
: 5|NMW5IEF2
: 6|EU3FEG47

This lists the fields defined in item 3, itemid, fieldid, valueid

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select itemData.itemID, fields.fieldName, itemDataValues.value from itemData
inner join ItemDataValues
on itemData.valueID == itemDataValues.valueID
inner join fields
on fields.fieldID == itemData.fieldID
where itemData.itemID==3;
#+END_SRC
#+RESULTS:
#+begin_example
3|url|http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5756277
3|volume|13
3|issue|3
3|pages|66-73
3|publicationTitle|Computing in Science & Engineering
3|ISSN|1521-9615
3|date|2011-05-00 05/2011
3|DOI|10.1109/MCSE.2011.41
3|accessDate|2015-01-27 23:27:14
3|libraryCatalog|CrossRef
3|title|Active Documents with Org-Mode
#+end_example

To get the authors:

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select firstName, lastName from creatorData
inner join itemCreators
on itemCreators.creatorID == creatorData.creatorDataID
where itemCreators.itemID==3;
#+END_SRC

#+RESULTS:
: Eric|Schulte
: Dan|Davison

* test links

#+caption: some text label:test3  cite:needs-1989-cal
| a | b |
| 1 | 3 |

 citenum:needs-1989-calcu

#+BEGIN_SRC emacs-lisp :results code
(org-element-map (org-element-parse-buffer) 'link
  (lambda (link)
    (cons
     (org-element-property :path link)
     (if (not (org-element-secondary-p link))
	 (org-element-property :begin link)
       "Secondary link")))
  nil nil nil t)
#+END_SRC
#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("test3" . 11)
 ("needs-1989-cal" . 24)
 ("needs-1989-calcu" . 91))
#+END_SRC

(goto-char 11) This goes into the headline

(goto-char 24) This goes to the : in the caption

(goto-char 91)  This goes exactly where I expect

#+BEGIN_SRC emacs-lisp :results code
(org-element-map (org-element-parse-buffer) 'link
  (lambda (link)
    (cons
     (org-element-property :path link)
     (org-element-property :parent link)))
  nil nil nil t)
#+END_SRC


(org-version)
* Revisiting tooltips on cite links
This is not going to work permanently. maybe i could map over the links and put some proprties on though.

(insert (propertize "cite:kondratyuk-2013"
                          'help-echo "testing"))cite:kondratyuk-2013

cite:

cite:kondratyuk-2013

These links work in the code block, but not in org.

#+BEGIN_SRC emacs-lisp
(insert (concat "cite:"
(mapconcat
(lambda (key)
 (propertize key 'help-echo (org-ref-get-bibtex-entry-citation key)))
'("kondratyuk-2013" "paier-2006-errat" "marjolin-2015-therm-descr")
",")))cite:kondratyuk-2013,paier-2006-errat,marjolin-2015-therm-descr

#+END_SRC

#+RESULTS:
:


cite:kondratyuk-2013,paier-2006-errat,marjolin-2015-therm-descr

(setq tooltip-use-echo-area nil)
cite:kondratyuk-2013,paier-2006-errat,marjolin-2015-therm-descr


#+BEGIN_SRC emacs-lisp
(defun org-ref-cite-link-p () (interactive)
       (let* ((object (org-element-context))
	      (type (org-element-property :type object)))
	 ;;   We only want this to work on citation links
	 (when (-contains? org-ref-cite-types type)
	   (message (org-ref-get-citation-string-at-point)))))

(add-hook 'post-command-hook 'cite-link-p)
;(remove-hook 'post-command-hook 'cite-link-p)
#+END_SRC

#+RESULTS:
| cite-link-p | matlab-start-block-highlight-timer |


* Helm source for headings with TODO


For a helm source we need a list of cons cells that have a car of a selection, and a cdr that corresponds to that selection.

#+BEGIN_SRC emacs-lisp :results raw
(defun helm-todo-candidates ()
  (let ((results '()))
    (org-map-entries
     (lambda ()
       (add-to-list 'results
		    (cons
		     (concat (make-string (nth 1 (org-heading-components)) ?*)
			     " TODO "
			     (nth 4 (org-heading-components)))
		     (point-marker))))
     "TODO=\"TODO\"")
    results))

(helm-todo-candidates)
#+END_SRC

#+RESULTS:
((** post it . #<marker at 977 in blog.org>) (** work it out . #<marker at 941 in blog.org>))

Now to run helm, there is a subtle point. We need to map the current buffer /before/ running helm, otherwise we will map an empty helm buffer.

#+BEGIN_SRC emacs-lisp
(defun helm-todo ()
  "Helm interface to headlines with TODO status in current buffer."
  (interactive)
  (let ((candidates (helm-todo-candidates)))
    (setq helm-todo-source '((name . "TODO headlines")
			     (candidates . candidates)
			     (action . (("open" . goto-char)))))
    (helm :sources '(helm-todo-source))))

(helm-todo)
#+END_SRC

#+RESULTS:

Now, let us expand the idea to a helm-agenda. We want a function that prompts for a match criteria, then presents a helm buffer to select matching entries in your agenda files.

#+BEGIN_SRC emacs-lisp
(defun helm-agenda-candidates (query)
  (let ((results '()))
    (mapc (lambda (f)
      (with-current-buffer (find-file-noselect f)
	(org-map-entries
	 (lambda ()
	   (add-to-list 'results
			(cons
			 (concat
			  (file-name-nondirectory f) " | "
			  (make-string (nth 1 (org-heading-components)) ?*)
			  " "
			  (org-get-heading))
			 (point-marker))))
	 query))) (org-agenda-files))
    results))


(defun helm-query-agenda (query)
  "Helm interface to headlines with TODO status in current buffer."
  (interactive "sQuery: ")
  (let ((candidates (helm-agenda-candidates query)))
    (helm :sources '(((name . "TODO headlines")
		      (candidates . candidates)
		      (action . (("open" . (lambda (m)
					     (switch-to-buffer (marker-buffer m))
					     (goto-char m)
					     (show-children))))))))))
#+END_SRC

#+RESULTS:

** TODO work it out
** DONE test it
** TODO post it



* Copy the bibtex entry for a link to a new file
Sometimes I am reading a document with citations from org-ref in it, and I want to copy the bibtex entry for that link from the file it is in to a new file. Right now, I have to click on the link, open the entry, copy the file, open the new file, and paste it. Here we develop a function that does all that.

Some functions will help us with this. First, org-ref-open-citation-at-point will open the bibtex file with the point in the entry. Second, bibtex-copy-entry-as-kill will copy the entry to the bibtex-entry-kill-ring. Finally bibtex-yank will put the entry in the new file we select. We should try not to add entries if there is already a key present in the file.

A subtlety is the function should not take an argument, so it can work in our cite menu, but it needs an interactive file selection to say where the entry is copied to.

#+BEGIN_SRC emacs-lisp
(defun org-ref-copy-entry-at-point-to-file ()
  "Copy the bibtex entry for the citation at point to NEW-FILE.
Prompt for NEW-FILE includes bib files in org-ref-default-bibliography, and bib files in current working directory. You can also specify a new file."
  (interactive)
  (let ((new-file (ido-completing-read
		   "Copy to bibfile: "
		   (append org-ref-default-bibliography
			   (f-entries "." (lambda (f) (f-ext? f "bib"))))))
	(key (org-ref-get-bibtex-key-under-cursor)))
    (save-window-excursion
      (org-ref-open-citation-at-point)
      (bibtex-copy-entry-as-kill))

    (let ((bibtex-files (list (file-truename new-file))))
      (if (assoc key (bibtex-global-key-alist))
	  (message "That key already exists in %s" new-file)
	;; add to file
	(save-window-excursion
	  (find-file new-file)
	  (goto-char (point-max))
          ;; make sure we are at the beginning of a line.
	  (unless (looking-at "^") (insert "\n\n"))
	  (bibtex-yank)
	  (save-buffer))))))
#+END_SRC

#+RESULTS:
: #<marker at 1038 in blog.org>

#+BEGIN_SRC emacs-lisp
(add-to-list
'org-ref-user-cite-menu-funcs
       '("y" "Copy entry to file" org-ref-copy-entry-at-point-to-file) t)
#+END_SRC

We might also want to copy a short summary to the clipboard, so we could readily paste it somewhere. Here is one way to do it. You might prefer (bibtex-copy-summary-as-kill) instead.

#+BEGIN_SRC emacs-lisp
(defun org-ref-copy-entry-as-summary ()
  "Copy the bibtex entry for the citation at point as a summary."
  (interactive)
    (save-window-excursion
      (org-ref-open-citation-at-point)
      (kill-new (org-ref-bib-citation))))
#+END_SRC
#+RESULTS:
: org-ref-copy-entry-as-summary

#+BEGIN_SRC emacs-lisp
(add-to-list
'org-ref-user-cite-menu-funcs
       '("s" "Copy summary" org-ref-copy-entry-as-summary) t)
#+END_SRC

Here is a citation to test these out on cite:mehta-2014-ident-poten.

They seem to work! These are built in to org-ref now, so if you update to the latest version they should work for you too.

* A voting system for org-mode headlines

Over on [[http://stackoverflow.com/questions/27937446/how-to-vote-for-a-heading-in-org-mode][Stack Overflow]] someone wanted a system to "vote" for headlines. Basically they have a lot of headlines, and they want a +1 feature that will set a VOTES property on a headline. Then, they could filter the headlines by some voting criteria. Org-mode is made for that kind of thing, but we have to implement it ourselves. We just need to define a function that sets the property. The only subtle points in this are that properties are defined as strings, and we have to put a string in the property. That means we have to convert the string to a number, increment it, and convert it back to a string. We also add an org-mode speed command to + so when our cursor is at the beginning of the headline, we just press + to increment the VOTES property.

#+BEGIN_SRC emacs-lisp
(defun plusone ()
  "Increase the VOTES property in an org-heading by one. Create
the property if needed."
  (interactive)
  (org-entry-put
   (point)
   "VOTES"
   (format "%s" (+ 1 (string-to-number
		      (or
		       (org-entry-get (point) "VOTES")
		       "0"))))))

(add-to-list 'org-speed-commands-user '("+" . (plusone)))
#+END_SRC

#+RESULTS:
| + | quote | plusone |

Now some test headlines. We can use the agenda to filter headlines. Here is the agenda command that is equivalent to the key sequence "C-c a < m". Type in VOTES>2, for example, to see headlines that have more than two votes.

#+BEGIN_SRC emacs-lisp
(org-agenda nil "m" "<")
#+END_SRC

** heading 1
   :PROPERTIES:
   :VOTES:    2
   :END:
** heading 2
   :PROPERTIES:
   :VOTES:    5
   :END:
** heading 3
   :PROPERTIES:
   :VOTES:    1
   :END:




* vtk

#+BEGIN_SRC python
import vtk
from ase.cluster.icosahedron import Icosahedron
from ase.io import write
from ase.visualize import view

# With almost everything else ready, its time to initialize the renderer and window, as well as creating a method for exiting the application
renderer = vtk.vtkRenderer()
renderWin = vtk.vtkRenderWindow()
renderWin.AddRenderer(renderer)
renderInteractor = vtk.vtkRenderWindowInteractor()
renderInteractor.SetRenderWindow(renderWin)



atoms = Icosahedron('Au', noshells=3)

from ase.visualize.vtk.atoms import vtkAtoms

va = vtkAtoms(atoms)
va.add_actors_to_renderer(renderer)


renderInteractor.Initialize()
# Because nothing will be rendered without any input, we order the first render manually before control is handed over to the main-loop.
renderWin.Render()
renderInteractor.Start()
#+END_SRC

#+RESULTS:


* bullet

notes about this mail: [[mu4e:msgid:CANniJEwZu8UcvbB6G%2B0Q%2Be_ZYQNFUsw9DJxxVg9cfKvSnoSQOw@mail.gmail.com][{O} Getting beginning postiion of a description list]]

- foo :: bar    (goto-char (org-element-property :contents-begin (org-element-at-point)))
-     baz :: goo
- 1 egg
- 0.5 cups
- :punc

#+BEGIN_SRC emacs-lisp
(defun gg ()
 (interactive)
 (beginning-of-line)
 (forward-word)
 (backward-word)
 (while (not (looking-at " "))
   (backward-char)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
; display element at point as a message.
(defun eap ()
  (interactive)
  (message "%s" (org-element-at-point)))


(defun gg ()
(interactive)
(when (eq (car (org-element-at-point)) 'item)
(message-box "on item")
(goto-char (org-element-property :end (org-element-at-point)))))

(add-hook 'post-command-hook 'eap)
(remove-hook 'post-command-hook 'eap)
#+END_SRC

#+RESULTS:
| eap |

* wok3
from https://github.com/mstrupler/WOS3/blob/master/wok3.py

#+BEGIN_SRC python :tangle wok3.py
# -*- coding: utf-8 -*-
"""
Created on Wed Aug 27 10:12:00 2014

@author: mathiasstrupler
"""


import sys
import re
import datetime

#try:
#    import urllib2
#except ImportError:
#    print('We need urllib2, sorry...')
#    sys.exit(1)

try:
    from suds.client import Client
except ImportError:
    print('We need suds.client, sorry...')
    sys.exit(1)

try:
    import xml.etree.ElementTree as ET
except ImportError:
    print('We need xml.etree.ElementTree, sorry...')
    sys.exit(1)

class Error(Exception):
    """Base class for any wok3 error."""

class SearchQueryError(Error):
    """You need to set a user query"""

class Edition(object):
    """
    This class is only used to let you know easily all the databases
    that can be searched in World of sciences
    example : wokSearch.setEdition(Edition.SCI)
    """
    SCI   = {'collection' : 'WOS', 'edition' : 'SCI'}    #Science Citation Index Expanded
    SSCI  = {'collection' : 'WOS', 'edition' : 'SSCI'}   #Social Sciences Citation Index
    AHCI  = {'collection' : 'WOS', 'edition' : 'AHCI'}   #Arts & Humanities Citation Index
    ISTP  = {'collection' : 'WOS', 'edition' : 'ISTP'}   #Conference Proceedings Citation Index - Science
    ISSHP = {'collection' : 'WOS', 'edition' : 'ISSHP'}  #Conference Proceedings Citation Index - Social Sciences
    IC    = {'collection' : 'WOS', 'edition' : 'IC'}     #Index Chemicus
    CCR   = {'collection' : 'WOS', 'edition' : 'CCR'}    #Current Chemical Reactions
    BSCI  = {'collection' : 'WOS', 'edition' : 'BSCI'}   #Book Citation Index - Science
    BHCI  = {'collection' : 'WOS', 'edition' : 'BHCI'}   #Book Citation Index - Social Sciences and Humanities


class SearchRespAnalyzer(object):
    """
    This class is used to parse the soap answer received
    after a search request
    """
    def __init__(self,searchResp):
        self._searchResp = searchResp

    def toDict(self):
        """
        This method parse the answer into a dictonnary
        It does not retreive all the information that gives WOS
        It looks for the following info:
            UID : WOS identifier
            title : Title of the document
            journal : Name of the journal
            year : Year of publication
            volume : Volume
            issue : Issue
            page : page [begin, end]
            authors : list of author dict {name, dais_id, affiliations list}
            language : primary language of the document
            docType : document type (article, review, book,...)
            publisher : name of the publisher
        """

        ans = {'records' : [] }
        records = re.sub(' xmlns="http://scientific.thomsonreuters.com/schema/wok5.4/public/FullRecord"', '', self._searchResp.records, count=1)
        #records = re.sub(' r_id_disclaimer="ResearcherID data provided by Thomson Reuters"', '', resp.records, count=resp.recordsFound)
        recordsTree = ET.fromstring( records)
        for rec in recordsTree.iter('REC'):
            #retreive UID
            record = {'UID' : rec.find('UID').text}
            #retreive title and journal name
            record['title'] = None
            record['journal'] = None
            for title in rec.findall('static_data/summary/titles/title'):
                if title.attrib['type'] == 'item':
                    record['title'] = title.text
                if title.attrib['type'] == 'source':
                    record['journal'] = title.text
            #retreive publication information
            pubinfo = rec.find('static_data/summary/pub_info').attrib
            record['year'] = pubinfo['pubyear']
            record['volume'] = pubinfo['vol']
            if 'issue' in  pubinfo:
                record['issue'] = pubinfo['issue']
            else:
                record['issue'] = ''
            page = rec.find('static_data/summary/pub_info/page').attrib
            if 'begin' in  page:
                record['page'] = [page['begin'],page['end']]
            else:
                record['page'] = []
            #retreive author list
            record['authors'] = []
            for name in rec.findall('static_data/summary/names/name'):
                if name.attrib['role']=='author':
                    author = {'name' : ''}
                    if name.find('wos_standard') is not None:
                        author['name'] = name.find('wos_standard').text
                    elif name.find('display_name') is not None:
                        author['name'] = name.find('display_name').text
                    elif name.find('full_name') is not None:
                        author['name'] = name.find('full_name').text
                    if 'dais_id' in name.attrib:
                        author['dais_id'] = name.attrib['dais_id']
                    author['affiliation']=[]
                    record['authors'].append(author)
            #retrieve publication language
            record['language'] = None
            for language in rec.findall('static_data/fullrecord_metadata/languages/language'):
                if language.attrib['type']=='primary':
                    record['language'] = language.text
            #retrieve adressess
            affiliations = []
            for adresses in rec.findall('static_data/fullrecord_metadata/addresses/address_name'):
                affiliations.append({'nb' : adresses.find('address_spec').attrib['addr_no'],'add' : adresses.find('address_spec/full_address').text})
            record['affiliations'] = affiliations
            if len(affiliations)==1:
                for author in record['authors']:
                    author['affiliation']=[affiliations[0]['add']]
            if len(affiliations)>=1:
                aff_names = rec.findall('static_data/fullrecord_metadata/addresses/address_name/names/name')
                aff_names_list = []
                for aff_name in aff_names:
                    tmp = {'nb' : aff_name.attrib['addr_no'], 'name' : aff_name.find('wos_standard').text}
                    aff_names_list.append(tmp)
                for author in record['authors']:
                    for name in aff_names_list:
                        if author['name'] == name['name']:
                            author['affiliation'].append(name['nb'])

            #retrieve doctype
            record['docType'] = []
            for docType in rec.findall('static_data/fullrecord_metadata/normalized_doctypes/doctype'):
                record['docType'].append(docType.text)
            #retrieve publisher
            record['publisher'] = rec.find('static_data/summary/publishers/publisher/names/name/full_name').text

            #append record to answer
            ans['records'].append(record)
        return ans

    def saveAsJSON(self,directory):
        """
        This method save as a JSON file
        the dictionnary produced by the toDict() method
        """
        try:
            import json
        except ImportError:
            print('We need JSON, sorry...')
            sys.exit(1)

        searchRespDict = self.toDict()
        with open(directory, 'wb') as fp:
            json.dump(searchRespDict , fp, sort_keys=True, indent=4, separators=(',', ': '))

    def saveRawAsXML(self,directory):
        """
        This method save as a XML file the raw records
        returned by the WOS search
        It only adds identations to make it more pretty
        """
        from xml.dom import minidom
        records = re.sub(' xmlns="http://scientific.thomsonreuters.com/schema/wok5.4/public/FullRecord"', '', self._searchResp.records, count=1)
        #records = re.sub(' r_id_disclaimer="ResearcherID data provided by Thomson Reuters"', '', resp.records, count=resp.recordsFound)
        recordsTree = ET.fromstring( records)
        rough_string = ET.tostring(recordsTree, 'utf-8')
        reparsed = minidom.parseString(rough_string)
        with open(directory, 'wb') as fp:
            reparsed.writexml(fp, indent="", addindent="\t", newl="\n")

    def saveAsBibtex(self,directory):
        """
        This method save as a bibtex files all the records
        It should be rewritten better handle different document types
        """
        searchRespDict = self.toDict()
        with open(directory, 'w') as fp:
            for rec in searchRespDict['records']:
                if rec['docType'][0]=='Article' or rec['docType'][0]=='Review' or rec['docType'][0]=='Letter':
                    bibtexentry = '@article{'
                elif rec['docType'][0]=='Proceedings Paper' or rec['docType'][0]=='Meeting':
                    bibtexentry = '@proceedings{'
                elif rec['docType'][0]=='Book':
                    bibtexentry = '@book{'
                elif rec['docType'][0]=='Book Chapter':
                    bibtexentry = '@inbook{'
                else:
                    bibtexentry = '@misc{'
                bibtexentry = bibtexentry + rec['UID'] + ',\n'
                bibtexentry = bibtexentry + '  title={' + rec['title'] + '},\n'

                authors = ''
                authorlist = rec['authors']
                firstauthor = authorlist.pop(0)
                authors = firstauthor['name']
                for author in authorlist:
                    authors = authors + ' and ' + author['name']

                bibtexentry = bibtexentry + '  author={' + authors + '},\n'
                bibtexentry = bibtexentry + '  journal={' + rec['journal'] + '},\n'
                if not(rec['volume']==''):
                    bibtexentry = bibtexentry + '  volume={' + rec['volume'] + '},\n'
                if not(rec['issue']==''):
                    bibtexentry = bibtexentry + '  number={' + rec['issue'] + '},\n'
                if rec['page']:
                    bibtexentry = bibtexentry + '  pages={'  + rec['page'][0] + '--' + rec['page'][1] + '},\n'
                if not(rec['year']==''):
                    bibtexentry = bibtexentry + '  year={' + rec['year'] + '},\n'
                if not(rec['publisher']==''):
                    bibtexentry = bibtexentry + '  publisher={' + rec['publisher'] + '},\n'
                bibtexentry = bibtexentry  + '}\n'
                fp.write(bibtexentry)





class WokSearch(object):
    """
    This class is used
        - to define the query parameters of a WOK search
        - open a session on WOK
        - send requests
        - close the session

    """
    AUTH_URL = 'http://search.webofknowledge.com/esti/wokmws/ws/WOKMWSAuthenticate?wsdl'
    SEARCH_URL = 'http://search.webofknowledge.com/esti/wokmws/ws/WokSearch?wsdl'
    def __init__(self):
        #initialization
        self._queryLanguage = 'en'
        self._databaseId = 'WOS'
        self._timeSpanStart = None
        self._timeSpanEnd = None
        self._edition = None
        self._query = None
        self._resultsRetrieved = 0
        self._resultsPerRequest = 100

    def setQuery(self, query):
        self._query = query

    def setEdition(self, edition):
        self._edition = edition

    def setTimeSpanStart(self, date):
        self._timeSpanStart = date

    def setTimeSpanEnd(self, date):
        self._timeSpanEnd = date

    def clearEdition(self):
        self._edition = None

    def clearSpanTime(self):
        self._timeSpanStart = None
        self._timeSpanEnd = None

    def queryToSOAP(self):
        if self._query is not None:
            soap =  {'databaseId' : self._databaseId, 'userQuery' : self._query, 'queryLanguage': self._queryLanguage}
            if self._edition is not None:
                soap['editions'] = self._edition
            soaptime = {}
            if self._timeSpanStart is not None:
                soaptime['begin'] = self._timeSpanStart.isoformat()
            if self._timeSpanEnd is not None:
                soaptime['end'] = self._timeSpanEnd.isoformat()
            if soaptime :
                soap['timeSpan'] = soaptime
            return soap
        else:
            raise SearchQueryError

    def retrieveParamToSOAP(self):
        soap = {'firstRecord' : self._resultsRetrieved+1, 'count' : self._resultsPerRequest}
        return soap

    def openSOAPsession(self):
        self._authClient = Client(self.AUTH_URL)
        self._sid = self._authClient.service.authenticate()
        headers = { 'Cookie': 'SID='+self._sid}
        self._authClient.set_options(soapheaders=headers)
        self._searchClient = Client(self.SEARCH_URL, headers= { 'Cookie': 'SID='+self._sid})

    def closeSOAPsession(self):
        self._authClient.service.closeSession()

    def sendSearchRequest(self):
        resp = self._searchClient.factory.create('searchResponse')
        resp = self._searchClient.service.search(self.queryToSOAP(),self.retrieveParamToSOAP())
        return resp



def main():
    wokSearch = WokSearch()

    wokSearch.setQuery('TS = Optical Coherence Tomography')

    #wokSearch.setEdition(Edition.SCI)
    wokSearch.setTimeSpanEnd(datetime.date(2014,01,01))
    wokSearch.setTimeSpanStart(datetime.date(2003,01,01))
    print wokSearch.queryToSOAP()
    print wokSearch.retrieveParamToSOAP()

    wokSearch.openSOAPsession()
    resp = wokSearch.sendSearchRequest()
    aResp = SearchRespAnalyzer(resp)
    aResp.saveRawAsXML('/Users/mathiasstrupler/WOS3/OCT2003_2010.xml')
    aResp.saveAsJSON('/Users/mathiasstrupler/WOS3/OCT2003_2010.JSON')
    aResp.saveAsBibtex('/Users/mathiasstrupler/WOS3/OCT2003_2010.bib')
    wokSearch.closeSOAPsession()

if __name__ == "__main__":
    sys.exit(main())

#+END_SRC

#+BEGIN_SRC python
from wok3 import *
wokSearch = WokSearch()

wokSearch.setQuery('TS = Optical Coherence Tomography')

wokSearch.setEdition(Edition.SCI)
wokSearch.setTimeSpanEnd(datetime.date(2014,01,01))
wokSearch.setTimeSpanStart(datetime.date(2003,01,01))
print wokSearch.queryToSOAP()
print wokSearch.retrieveParamToSOAP()

wokSearch.openSOAPsession()
resp = wokSearch.sendSearchRequest()
#aResp = SearchRespAnalyzer(resp)
#aResp.saveRawAsXML('OCT2003_2010.xml')
#aResp.saveAsJSON('/Users/mathiasstrupler/WOS3/OCT2003_2010.JSON')
#aResp.saveAsBibtex('OCT2003_2010.bib')

#wokSearch.closeSOAPsession()
#+END_SRC

#+RESULTS:
#+begin_example
{'editions': {'edition': 'SCI', 'collection': 'WOS'}, 'databaseId': 'WOS', 'timeSpan': {'begin': '2003-01-01', 'end': '2014-01-01'}, 'userQuery': 'TS = Optical Coherence Tomography', 'queryLanguage': 'en'}
{'count': 100, 'firstRecord': 1}
No handlers could be found for logger "suds.client"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "wok3.py", line 309, in sendSearchRequest
    resp = self._searchClient.service.search(self.queryToSOAP(),self.retrieveParamToSOAP())
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 542, in __call__
    return client.invoke(args, kwargs)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 602, in invoke
    result = self.send(soapenv)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 649, in send
    result = self.failed(binding, e)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 702, in failed
    r, p = binding.get_fault(reply)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/bindings/binding.py", line 265, in get_fault
    raise WebFault(p, faultroot)
suds.WebFault: Server raised fault: 'User has no entitlement for this service level - WOKSearchPremium'

#+end_example

#+BEGIN_SRC bibtex

#+END_SRC

* completing in python


#+BEGIN_SRC python

def completer(text, state):
    options = [i for i in commands if i.startswith(text)]
    if state < len(options):
        return options[state]
    else:
        return None

print completer('os.', 0)
#+END_SRC

#+RESULTS:
:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 2, in completer
: NameError: global name 'commands' is not defined
:

#+BEGIN_SRC python
import rlcompleter
completer = rlcompleter.Completer()

print completer.complete("sy", 1)

#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/Applications/Canopy.app/appdata/canopy-1.5.1.2730.macosx-x86_64/Canopy.app/Contents/lib/python2.7/rlcompleter.py", line 87, in complete
:     return self.matches[state]
: AttributeError: Completer instance has no attribute 'matches'
:

#+BEGIN_SRC python

import pip
installed_packages = pip.get_installed_distributions()
installed_packages_list = sorted(["%s" % (i.key)
     for i in installed_packages])
print(installed_packages_list)
#+END_SRC

#+RESULTS:
:
: ['appinst', 'apptools', 'astroid', 'atom', 'backports.ssl-match-hostname', 'basemap', 'biopython', 'bitarray', 'blist', 'blockcanvas', 'blogofile', 'blogofile-blog', 'boto', 'bsdiff4', 'casuarius', 'chaco', 'cloud', 'codetools', 'configobj', 'curl', 'cython', 'doclinks', 'elpy', 'enable', 'enaml', 'encore', 'enstaller', 'envisage', 'epc', 'epydoc', 'ets', 'etsdevtools', 'etsproxy', 'examples', 'fiona', 'flake8', 'flask', 'foolscap', 'freetype', 'fwrap', 'gdal', 'graphcanvas', 'grin', 'h5py', 'hdf5', 'html5lib', 'idle', 'ipython', 'itsdangerous', 'jedi', 'jinja2', 'kernmagic', 'kiwisolver', 'lib-netcdf4', 'libgdal', 'libjpeg', 'libpng', 'libxml2', 'libxslt', 'logilab-common', 'lxml', 'mako', 'markdown', 'markupsafe', 'matplotlib', 'mayavi', 'mccabe', 'mdp', 'netcdf4', 'networkx', 'nltk', 'nose', 'numba', 'numexpr', 'numpy', 'openpyxl', 'pandas', 'pandasql', 'paramiko', 'patsy', 'pep8', 'pil', 'pint', 'ply', 'pychecker', 'pycluster', 'pycrypto', 'pycse', 'pydot', 'pyephem', 'pyface', 'pyfits', 'pyflakes', 'pygarrayimage', 'pyglet', 'pygments', 'pyhdf', 'pylint', 'pymacs', 'pymc', 'pyodbc', 'pyopengl', 'pyopenssl', 'pyparsing', 'pyproj', 'pysal', 'pyserial', 'pyshp', 'pytables', 'python-dateutil', 'pythondoc', 'pytz', 'pyyaml', 'pyzmq', 'quantities', 'readline', 'reportlab', 'requests', 'rope', 'scikit-learn', 'scikits.image', 'scikits.timeseries', 'scimath', 'scipy', 'scons', 'sexpdata', 'shapely', 'simpy', 'six', 'sphinx', 'sqlalchemy', 'sqlparse', 'statsmodels', 'suds', 'swig', 'sympy', 'textile', 'tornado', 'traits', 'traits-enaml', 'traitsui', 'twisted', 'uncertainties', 'unidecode', 'virtualenv', 'vtk', 'werkzeug', 'wxpython', 'xlrd', 'xlwt', 'zope.interface']
:

* Possibilities for pydoc completion

#+BEGIN_SRC python
import rlcompleter as rl
import sys
C = rl.Completer(namespace=globals())
matched = True
i = 0
matches = []
while matched:
    m = C.complete("sys.", i)
    if m:
        matches += [m]
        i +=1
    else:
        matched = False

print matches
#+END_SRC

#+RESULTS:
: ['sys.__displayhook__(', 'sys.__doc__', 'sys.__egginsert', 'sys.__excepthook__(', 'sys.__name__', 'sys.__package__', 'sys.__plen', 'sys.__stderr__', 'sys.__stdin__', 'sys.__stdout__', 'sys._clear_type_cache(', 'sys._current_frames(', 'sys._executable', 'sys._getframe(', 'sys._home', 'sys._mercurial', 'sys.api_version', 'sys.argv', 'sys.base_exec_prefix', 'sys.base_prefix', 'sys.builtin_module_names', 'sys.byteorder', 'sys.call_tracing(', 'sys.callstats(', 'sys.copyright', 'sys.displayhook(', 'sys.dont_write_bytecode', 'sys.exc_clear(', 'sys.exc_info(', 'sys.exc_type', 'sys.excepthook(', 'sys.exec_prefix', 'sys.executable', 'sys.exit(', 'sys.flags', 'sys.float_info', 'sys.float_repr_style', 'sys.getcheckinterval(', 'sys.getdefaultencoding(', 'sys.getdlopenflags(', 'sys.getfilesystemencoding(', 'sys.getprofile(', 'sys.getrecursionlimit(', 'sys.getrefcount(', 'sys.getsizeof(', 'sys.gettrace(', 'sys.hexversion', 'sys.long_info', 'sys.maxint', 'sys.maxsize', 'sys.maxunicode', 'sys.meta_path', 'sys.modules', 'sys.path', 'sys.path_hooks', 'sys.path_importer_cache', 'sys.platform', 'sys.prefix', 'sys.py3kwarning', 'sys.setcheckinterval(', 'sys.setdlopenflags(', 'sys.setprofile(', 'sys.setrecursionlimit(', 'sys.settrace(', 'sys.stderr', 'sys.stdin', 'sys.stdout', 'sys.subversion', 'sys.version', 'sys.version_info', 'sys.warnoptions', 'sys.__class__(', 'sys.__class__(', 'sys.__delattr__(', 'sys.__dict__', 'sys.__doc__', 'sys.__format__(', 'sys.__getattribute__(', 'sys.__hash__(', 'sys.__init__(', 'sys.__new__(', 'sys.__reduce__(', 'sys.__reduce_ex__(', 'sys.__repr__(', 'sys.__setattr__(', 'sys.__sizeof__(', 'sys.__str__(', 'sys.__subclasshook__(', 'sys.__class__(', 'sys.__delattr__(', 'sys.__doc__', 'sys.__format__(', 'sys.__getattribute__(', 'sys.__hash__(', 'sys.__init__(', 'sys.__new__(', 'sys.__reduce__(', 'sys.__reduce_ex__(', 'sys.__repr__(', 'sys.__setattr__(', 'sys.__sizeof__(', 'sys.__str__(', 'sys.__subclasshook__(']

* pydoc apropos

see https://github.com/philippp/apropos.py

This needs to be done asynchronously
#+BEGIN_SRC emacs-lisp
(defun pydoc-apropos (name)
  (interactive)
  (switch-to-buffer-other-window "*pydoc-apropos*")
  (erase-buffer)
  (insert (shell-command-to-string (format "python -c \"import pydoc; pydoc.apropos('%s')\"" "zip")))
  (goto-char (point-min)))

(pydoc-apropos "zip")
#+END_SRC

#+RESULTS:
: 1


* Convert word at point to internal link
must have been some org-mode list question

#+BEGIN_SRC emacs-lisp
(defun word-to-link ()
  (interactive)
  (save-excursion
    (let (start end word)
      (backward-word)
      (setq start (point))
      (forward-word)
      (setq end (point))
      (setq word (buffer-substring start end))
      (setf (buffer-substring start end)
	    (format "[[%s]]" word)))))
#+END_SRC

#+RESULTS:
: word-to-link

Test [[some]] word


* Quick access to your own cheat sheets
There are a lot of 1-2 page cheat sheets available on the Internet. In emacs It should be easy to make your own cheat sheets (in org-mode of course), and to access them from a command with completion. Here we explore a way to get that with a helm interface.

The idea is to keep an org-file with headings in it for each cheat sheet. I put mine here: file:cheat-sheets.org.

We don't even have to work very hard here, helm already has a slick function to give you quick searching of the headlines. We just open our file, and run the helm command.

#+BEGIN_SRC emacs-lisp
(defun cheatsheet ()
  (interactive)
  (find-file "cheat-sheets.org")
  (helm-org-headlines))
#+END_SRC

#+RESULTS:
: cheatsheet


* Automating version control on org files
  I came across this [[http://erikclarke.net/2014/10/21/keeping-a-lab-notebook-with-org-mode-git-papers-and-pandoc-part-ii/][post]] on keeping a lab notebook in org-mode and git. One interesting feature in the post is a lab-notebook minor mode that automates version control by adding a function to the after-save-hook. I am testing it out here.

#+BEGIN_SRC emacs-lisp
(defun ensure-in-vc-or-checkin ()
  (interactive)
  (if (file-exists-p (format "%s" (buffer-file-name)))
      (progn (vc-next-action nil) (message "Committed"))
    (ding) (message "File not checked in.")))

;; i set this to nil at some point for performance reasons
(setq vc-handled-backends '(Git))

(add-hook 'after-save-hook 'ensure-in-vc-or-checkin nil 'make-it-local)
#+END_SRC

#+RESULTS:
| ensure-in-vc-or-checkin | t |

#+BEGIN_SRC emacs-lisp
(remove-hook 'after-save-hook 'ensure-in-vc-or-checkin)
#+END_SRC

#+RESULTS:

Now, when I save this file, I am prompted for a commit message, then I press C-c C-c to commit it.

If we make a new file: file:new-file.org I do not get quite what I would have expected. The file is added, but not committed. The second save prompts for a commit message.

So, what should happen? I think you should only be prompted for a commit message when you want one. I often save to avoid losing work, but I wouldn't always want to write a commit message for that. Also, if the file is new, I want it added /and/ committed. Probably, you should commit when a buffer is killed.

It turns out there are a lot of helpful vc commands built into Emacs.

| C-x v l | Show log            |                          |
| C-x v i | add file            | vc-register              |
| C-x v = | diff current file   |                          |
| C-x v G | ignore file         | vc-ignore                |
| C-x v v | next logical action | (vc-next-action VERBOSE) |
|         |                     | vc-create-repo           |
|         |                     | vc-git-grep              |
|         |                     |                          |

vc-dir

vc-diff

We can get some idea of the state of the vc directory like this
#+BEGIN_SRC emacs-lisp
(vc-deduce-fileset nil t 'state-model-only-files)
#+END_SRC

#+RESULTS:
| Git | (/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | (/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | edited | implicit |

Checking if the current buffer is under vc:
#+BEGIN_SRC emacs-lisp
(vc-registered (buffer-file-name)) ;; return non-nil if file is registered
#+END_SRC

#+RESULTS:
: t




* Storing data files in a Word document


You probably know that the modern office documents are just thinly wrapped zip files full of other files. For example, this Word document file:kitchin_cv.docx opens as a Word document, but we can use Python and zipfile to examine the contents.

#+BEGIN_SRC python
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx') as myzip:
    print myzip.printdir()
#+END_SRC
#+RESULTS:
#+begin_example
File Name                                             Modified             Size
[Content_Types].xml                            1980-01-01 00:00:00         2125
_rels/.rels                                    1980-01-01 00:00:00          590
word/_rels/document.xml.rels                   1980-01-01 00:00:00        14241
word/document.xml                              1980-01-01 00:00:00       524045
word/footer1.xml                               1980-01-01 00:00:00         4036
word/header1.xml                               1980-01-01 00:00:00         1706
word/endnotes.xml                              1980-01-01 00:00:00         1629
word/footnotes.xml                             1980-01-01 00:00:00         3117
word/theme/theme1.xml                          1980-01-01 00:00:00         7076
word/media/image1.tmp                          1980-01-01 00:00:00        99449
word/media/image2.tmp                          1980-01-01 00:00:00        85976
word/media/image3.tmp                          1980-01-01 00:00:00        61281
word/settings.xml                              1980-01-01 00:00:00        29812
word/fontTable.xml                             1980-01-01 00:00:00         3887
word/styles.xml                                1980-01-01 00:00:00        36430
word/stylesWithEffects.xml                     1980-01-01 00:00:00        37296
docProps/app.xml                               1980-01-01 00:00:00        21158
docProps/core.xml                              1980-01-01 00:00:00          748
word/webSettings.xml                           1980-01-01 00:00:00         2484
word/numbering.xml                             1980-01-01 00:00:00        82725
None
#+end_example

You can see many of the files are xml files. In this post, I want to explore putting an arbitrary data file in the Word document, and then extracting it later. This is similar to the way we use LaTeX and attachfile to store data files in PDFs for supporting information files.

So first, lets create a simple json file.

#+BEGIN_SRC python :results silent
import json
with open('some-data.json', 'w') as f:
    f.write(json.dumps({'a': 1,
                        'b': 2}))
#+END_SRC

Here are the contents of our new file.
#+BEGIN_SRC sh
cat some-data.json
#+END_SRC

#+RESULTS:
: {"a": 1, "b": 2}

Now, we will add the file to the docx file. We just open the ZipFile in append mode, and write a new file to it.

#+BEGIN_SRC python
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx', 'a') as myzip:
    print myzip.write('some-data.json')
    print myzip.printdir()
#+END_SRC

#+RESULTS:
#+begin_example
None
File Name                                             Modified             Size
[Content_Types].xml                            1980-01-01 00:00:00         2125
_rels/.rels                                    1980-01-01 00:00:00          590
word/_rels/document.xml.rels                   1980-01-01 00:00:00        14241
word/document.xml                              1980-01-01 00:00:00       524045
word/footer1.xml                               1980-01-01 00:00:00         4036
word/header1.xml                               1980-01-01 00:00:00         1706
word/endnotes.xml                              1980-01-01 00:00:00         1629
word/footnotes.xml                             1980-01-01 00:00:00         3117
word/theme/theme1.xml                          1980-01-01 00:00:00         7076
word/media/image1.tmp                          1980-01-01 00:00:00        99449
word/media/image2.tmp                          1980-01-01 00:00:00        85976
word/media/image3.tmp                          1980-01-01 00:00:00        61281
word/settings.xml                              1980-01-01 00:00:00        29812
word/fontTable.xml                             1980-01-01 00:00:00         3887
word/styles.xml                                1980-01-01 00:00:00        36430
word/stylesWithEffects.xml                     1980-01-01 00:00:00        37296
docProps/app.xml                               1980-01-01 00:00:00        21158
docProps/core.xml                              1980-01-01 00:00:00          748
word/webSettings.xml                           1980-01-01 00:00:00         2484
word/numbering.xml                             1980-01-01 00:00:00        82725
some-data.json                                 2014-12-14 12:08:56           16
None
#+end_example

Sure enough, there is a new entry in there! Finally, we show that the contents of this file can be read in. We simply have to know what the file to read is, and we can get the contents.

#+BEGIN_SRC python
import json
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx', 'r') as myzip:
    contents = myzip.read('some-data.json')
    data = json.loads(contents)
    print data
#+END_SRC
#+RESULTS:

Unfortunately, this corrupts the Word file so it does not immediately open. Word is able to recover it and get it open. And, after it is open, the some-data.json entry is gone.

#+BEGIN_SRC python
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx', 'a') as myzip:
    print myzip.printdir()
#+END_SRC
#+RESULTS:
#+begin_example
File Name                                             Modified             Size
[Content_Types].xml                            1980-01-01 00:00:00         2125
_rels/.rels                                    1980-01-01 00:00:00          590
word/_rels/document.xml.rels                   1980-01-01 00:00:00        14241
word/document.xml                              1980-01-01 00:00:00       524305
word/footer1.xml                               1980-01-01 00:00:00         4037
word/header1.xml                               1980-01-01 00:00:00         1706
word/endnotes.xml                              1980-01-01 00:00:00         1629
word/footnotes.xml                             1980-01-01 00:00:00         3117
word/theme/theme1.xml                          1980-01-01 00:00:00         7076
word/media/image1.tmp                          1980-01-01 00:00:00        99449
word/media/image2.tmp                          1980-01-01 00:00:00        85976
word/media/image3.tmp                          1980-01-01 00:00:00        61281
word/settings.xml                              1980-01-01 00:00:00        29890
word/fontTable.xml                             1980-01-01 00:00:00         3887
word/styles.xml                                1980-01-01 00:00:00        36430
word/stylesWithEffects.xml                     1980-01-01 00:00:00        37296
docProps/app.xml                               1980-01-01 00:00:00        21158
docProps/core.xml                              1980-01-01 00:00:00          748
word/webSettings.xml                           1980-01-01 00:00:00         2484
word/numbering.xml                             1980-01-01 00:00:00        82725
None
#+end_example

So, it appears this is not a good way to store data inside a Word document.

* Filtering an org-mode table

Suppose I have this table, and I want to filter it for all entries having a topic of 1. Of course you can sort the table by topic and find the group. I want something like Excel has where you filter and make the other rows disappear.

First, let's take a look at some org-table functions that will be useful. Let us assume our filtering command is run interactively in a table. We need to know what column we are in, which we can get with =org-table-current-column=. We then might go to the beginning of the table. WE can find that with =org-table-begin=. Then, we iterate through the rows with =org-table-next-row=, and check the value of a field in the desired column with =org-table-get-field=.

#+BEGIN_SRC emacs-lisp
(defun filter-message ()
  (interactive)
  (let* ((current-column (org-table-current-column))
	 (current-value (org-table-get-field))
	 (filtered-lines  '()))
    (goto-char (org-table-begin))
    ;(message-box "%s" (org-table-current-dline))
    (while (org-table-p)
      (forward-line)
      (message "%s" (org-table-get-field current-column))
      (if (not
	   (string= current-value (org-table-get-field current-column)))
	  (add-to-list 'filtered-lines nil)
	(add-to-list 'filtered-lines t)))
    (message-box "%s" filtered-lines    )
    ))
#+END_SRC

#+RESULTS:
: filter-message




maybe see https://gist.github.com/doitian/1571162 for a folding way

#+tblname: my-data
| name | topic |
|------+-------|
| a    |     1 |
| v    |     1 |
| c    |     2 |
| d    |     3 |
| e    |     2 |
| f    |     1 |

First, we try making a row invisible.

(remove-from-invisibility-spec '(org-table-filter))
#+BEGIN_SRC emacs-lisp :results silent
(re-search-backward "#\\+tblname: my-data")
(re-search-forward "| v")
(beginning-of-line)
(let ((beg (point))
      (end)(ov))

  (end-of-line)
  (setq end (point))
  (setq ov (make-overlay beg end))
  (message-box "%s" (buffer-substring beg end))
  ;(overlay-put (make-overlay beg end) 'invisible 'org-table-filter))
  (overlay-put ov 'display '(height 0)))

(add-to-invisibility-spec '(org-table-filter))
#+END_SRC


see http://www.gnu.org/software/emacs/manual/html_node/elisp/Pixel-Specification.html#Pixel-Specification

maybe we can make lines on pixel high

* Indirect buffer in another mode

#+BEGIN_SRC emacs-lisp
(defun dwiw-indirect ()
  (if (org-in-block-p '("src"))
    (let* ((temp (org-edit-src-find-region-and-lang))
	   (beg (nth 0 temp))
	   (end (nth 1 temp))
	   (lang (nth 2 temp)))
      (message "in block: %s" lang)
      (pop-to-buffer (or
		      (get-buffer "*indirect*")
		      (make-indirect-buffer (current-buffer) "*indirect*")))
      (narrow-to-region beg end)
      ;; set mode(major-mode)
      (funcall (intern (concat lang "-mode"))))

    (when (eq major-mode 'org-mode)
      (when (get-buffer "*indirect*")
	(kill-buffer (get-buffer "*indirect*")))
      (font-lock-fontify-buffer))))


(add-hook 'post-command-hook 'dwiw-indirect)
;(remove-hook 'post-command-hook 'dwiw-indirect)
#+END_SRC




* toggle images in section

#+BEGIN_SRC emacs-lisp
(defun show-images-subtree ()
 (interactive)
(save-restriction
  (org-narrow-to-subtree)
  (org-display-inline-images nil t (point-min) (point-max))))
#+END_SRC
** section 1

[[./images/eos.png]]



** section 1

[[./images/eos.png]]

* get a count of unique elements

  ;; we need counts for each atom type. eventually we need to make sure the POTCAR file is written consistently with the order here. This is the clumsiest part of VASP, and the reason for the complex sorting done in ase. Some effort is made to group the atoms together so there is only one copy of each POTCAR.
  (insert "\n")
  (let* ((all-symbols (loop for atom in (oref atoms atoms)
			    collect (oref atom symbol)))
	 (unique-syms (-uniq all-symbols))
	 (counts (loop for usym in unique-syms
		       collect (cl-count usym all-symbols))))

    (dolist (c counts)
      (insert (format "%d " c))))

* OOP in emacs-lisp

#+BEGIN_SRC emacs-lisp
(defclass student ()
  ((first-name :initarg :first-name
	       :documentation "First name")
   (last-name :initarg :last-name
	      :documentation "Last name")
   (email :initarg :email
	  :documentation "Email address")))

(defmethod email-student ((rec student))
  "send email to student stored in REC."
  (message "sending email to %s"
	   (oref rec email)))

(setq s1 (student "s1" :first-name "John"
		 :last-name "Kitchin"
		 :email "jkitchin@andrew.cmu.edu"))

(email-student s1)
#+END_SRC

#+RESULTS:
: sending email to jkitchin@andrew.cmu.edu

* Getting items done today

** DONE item 1
   CLOSED: [2014-11-26 Wed 13:09] DEADLINE: <2014-11-26 Wed>



** DONE item 2
   CLOSED: [2014-11-25 Tue 13:09] DEADLINE: <2014-11-26 Wed>


** Mapping entries to find what closed today.

First, we look at a timestamp comparison function.
#+BEGIN_SRC emacs-lisp
(org-time= "<2014-11-26 Wed>" "<2014-11-26 Wed>")
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
(org-map-entries
  (lambda ()
    (let* ((closed (org-entry-get (point) "CLOSED"))
           (today (format-time-string "<%Y-%m-%d>")))
      (when closed
	(when
	    (org-time=
	     today
	     (let ((parts (org-parse-time-string closed)))
	       (format "<%s-%s-%s>"
		       (nth 5 parts) ; year
		       (nth 4 parts) ; month
		       (nth 3 parts) ; day
		       )))
	  (message-box "Found a closed task: %s"
		       (org-heading-components)))))))

#+END_SRC

#+RESULTS:
| nil | Found a closed task: (2 2 DONE nil item 1 nil) | nil | nil |

* A new data structure for me in emacs-lisp

I am examining the struct data type in emacs-lisp today. This creates something like an object with fields of data that are accessed by name. We will create a student object that contains first name, last name and an email address.

#+BEGIN_SRC emacs-lisp
(defstruct student first-name last-name email)
#+END_SRC

#+RESULTS:
: student

Let us make a student now, and assign it to a variable.
#+BEGIN_SRC emacs-lisp
(setq s1
      (make-student :first-name "John"
		    :last-name "Kitchin"
		    :email "jkitchin@andrew.cmu.edu"))
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@andrew.cmu.edu"]

The defstruct macro automatically creates accessor functions with names of NAME-SLOT. NAME in this case is student, and SLOT is one of the words we defined in the defstruct call. We access data from the student like this.

#+BEGIN_SRC emacs-lisp
(list
 (student-first-name s1)
 (student-last-name s1)
 (student-email s1))
#+END_SRC

#+RESULTS:
| John | Kitchin | jkitchin@andrew.cmu.edu |

Now, let us print the object.
#+BEGIN_SRC emacs-lisp
(princ s1)
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@andrew.cmu.edu"]

We can use generalized setf to change the values in the object.

#+BEGIN_SRC emacs-lisp
(setf (student-email s1) "jkitchin@cmu.edu")
(princ s1)
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@cmu.edu"]

Finally, the defstruct macro also defines a function to test if a variable is one of these objects. We can confirm a variable is a student object like this:
#+BEGIN_SRC emacs-lisp
(student-p s1)
#+END_SRC

#+RESULTS:
: t

This looks like a relatively handy way to encapsulate data in emacs-lisp, and accessing the data seems more readable than using any combination of car, cdr, elt and nth.


* A custom block in orgmode

#+BEGIN_EXAMPLE
Example text in a block to make sure it gets handled
#+END_EXAMPLE

Some instructions for the quiz.

#+ATTR_quiz: :points 5 :correct-answer A
#+BEGIN_quiz
test quiz
- [ ] answer A
- [ ] answer B
#+END_quiz


#+BEGIN_SRC emacs-lisp :exports none
(defun my-org-html-export-block (export-block contents info)
  "Transcode a EXPORT-BLOCK element from Org to HTML.
CONTENTS is nil.  INFO is a plist used as a communication
channel. QUIZ blocks are handled separately."

  (cond
   ;; handle our special quiz block
   ((string= (org-element-property :type export-block) "QUIZ")

    (format
     "<b>got it:</b> %s points, correct answer = %s
<br>
You would have to parse the body to generate your html here.
<br>
<pre>%s</pre>"
     (plist-get
      (read (format "%s" (org-element-property :attr_quiz export-block)))
     :points)
     (plist-get
      (read (format "%s" (org-element-property :attr_quiz export-block)))
     :correct-answer)
     (org-element-property :value export-block)
     ))
   ;; handle every other kind of block
   (t
    (org-html-export-block (export-block contents info)))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((export-block . my-org-html-export-block))
  ;; quiz blocks will not be parsed, they are handled directly in org-html-export-block.
  :export-block "quiz"
)


(browse-url (org-export-to-file 'my-html "custom-element.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-element.html>


* Helm notes

from [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.helm.user#loom.20140114T194900-298@post.gmane.org][Email from Tom: Making google suggest even mor]]
#+BEGIN_SRC emacs-lisp
(setq helm-source-google-suggest
  '((name . "Google Suggest")
    (candidates . (lambda ()
                    (funcall helm-google-suggest-default-function)))
    (action . (("Google Search" . helm-google-suggest-action)
               ("Wikipedia" . (lambda (candidate)
                     (browse-url
                      (concat "https://en.wikipedia.org/wiki/Special:Search?search="
                              (url-hexify-string candidate)))))
               ("Youtube" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.youtube.com/results?aq=f&search_query="
                              (url-hexify-string candidate)))))
               ("IMDb" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.imdb.com/find?s=all&q="
                              (url-hexify-string candidate)))))
               ("Google Maps" . (lambda (candidate)
                     (browse-url
                      (concat "http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q="
                              (url-hexify-string candidate)))))
               ("Google News" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.google.com/search?hl=en&safe=off&prmd=nvlifd&source=lnms&tbs=nws:1&q="
                              (url-hexify-string candidate)))))
               ))
    (volatile)
    (requires-pattern . 3)))

(helm :sources 'helm-source-google-suggest)
#+END_SRC

#+RESULTS:
: #<process open http://www.imdb.com/find?s=all&q=kitchen%20cabinets>


https://github.com/krisajenkins/helm-spotify/blob/master/helm-spotify.el

(require 'multi)

** dictionary
[[https://raw.githubusercontent.com/emacs-helm/helm-dictionary/master/helm-dictionary.el]]

#+BEGIN_SRC emacs-lisp
;;; helm-dictionary.el --- Helm source for looking up dictionaries

;; Copyright 2013 Titus von der Malsburg <malsburg@posteo.de>

;; Author: Titus von der Malsburg <malsburg@posteo.de>
;;         Michael Heerdegen <michael_heerdegen@web.de>
;; Maintainer: Titus von der Malsburg <malsburg@posteo.de>
;; URL: https://github.com/emacs-helm/helm-dictionary
;; Version: 1.0.0
;; Package-Requires: ((helm "1.5.5"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This helm source can be used to look up words in local (offline)
;; dictionaries.  It also provides short-cuts for various online
;; dictionaries, which is useful in situations where the local
;; dictionary doesn't have an entry for a word.
;;
;; Dictionaries are available for a variety of language pairs.  See
;; the project page for an incomplete list:
;;
;;     https://github.com/emacs-helm/helm-dictionary

;;; Install:

;; Put this file on your Emacs-Lisp load path and add the following in
;; your Emacs startup file:
;;
;;     (require 'helm-dictionary)
;;
;; Alternatively, you can use autoload:
;;
;;     (autoload 'helm-dictionary "helm-dictionary" "" t)
;;
;; In order to specify a dictionary set the variable
;; `helm-dictionary-database' to the filename of that dictionary.
;;
;; A dictionary for German and English can be found in the Debian
;; package trans-de-en.  This package is also available in many
;; distributions derived from Debian such as Ubuntu.  Alternatively,
;; this dictionary can also be downloaded here:
;;
;;   http://www-user.tu-chemnitz.de/~fri/ding/
;;
;; A dictionary for German and Spanish can be found here:
;;
;;   https://savannah.nongnu.org/projects/ding-es-de
;;
;; A variety of dictionaries with English as the source or target
;; language can be found here:
;;
;;   https://en.wiktionary.org/wiki/User:Matthias_Buchmeier
;;
;; These dictionaries were automatically created from the Wiktionary
;; database.  Their size and quality may vary.  Also generated from
;; Wiktionary are the following dictionaries with Russian as the
;; source or target language:
;;
;;   http://wiktionary-export.nataraj.su/en/
;;
;; If the local dictionary doesn't have an entry for a word, it can be
;; useful to try online dictionaries available on the
;; web.  Helm-dictionary has a dummy source that provides shortcuts
;; for looking up the currently entered string in these online
;; dictionaries.  The variable `helm-dictionary-online-dicts'
;; specifies which online dictionaries should be listed.  The value of
;; that variable is a list conses.  The first element of each cons
;; specifies the name of an online dictionary for display during
;; searches.  The second element is the URL used for retrieving search
;; results from the respective dictionary.  This URL has to contain a
;; "%s" at the position where the search term should be inserted.
;;

;; The browser specified in `helm-dictionary-browser-function' will be
;; used to show results from online dictionaries.  If this variable is
;; nil (default), the value of the variable
;; `browse-url-browser-function' will be used (the currently
;; configured Emacs-wide default browser).  If that variable is also
;; nil, helm uses the first available browser in
;; `helm-browse-url-default-browser-alist'.

;;; Usage:

;; Use the command `helm-dictionary' to start a new search.  As usual,
;; a search is case-insensitive unless the expression contains capital
;; letters.  Regular expressions can also be used as search
;; terms.  During a search, you can use `M-n` to search for the word
;; at which you called `helm-dictionary`.

;; There are two actions available: insert the currently selected term
;; in the source language (left) or in the target language (right) at
;; point, i.e., the cursor position at which `helm-dictionary' was
;; called.

;; In the section "Look up online", you can choose among several online
;; dictionaries.  If you select one of the entries listed in this
;; section, a browser will be used to display search results from the
;; respective dictionary.

;;; Code:

(require 'cl-lib)
(require 'helm)
(require 'helm-net)
(require 'helm-plugin)

(defgroup helm-dictionary nil
  "Helm plugin for looking up a dictionary."
  :group 'helm)

(defcustom helm-dictionary-database "/usr/share/trans/de-en"
  "The file containing the dictionary."
  :group 'helm-dictionary
  :type  'file)

(defcustom helm-dictionary-online-dicts
  '(("translate.reference.com de->eng" .
     "http://translate.reference.com/translate?query=%s&src=de&dst=en")
    ("translate.reference.com eng->de" .
     "http://translate.reference.com/translate?query=%s&src=en&dst=de")
    ("leo eng<->de" .
     "http://dict.leo.org/ende?lp=ende&lang=de&search=%s")
    ("en.wiktionary.org" . "http://en.wiktionary.org/wiki/%s")
    ("de.wiktionary.org" . "http://de.wiktionary.org/wiki/%s")
    ("linguee-eng<->de" . "http://www.linguee.de/deutsch-englisch/search\
?sourceoverride=none&source=auto&query=%s"))
  "Alist of online dictionaries.  The key of each entry is the
name of the online dictionary.  The value is the URL used for
retrieving results.  This URL must contain a %s at the position
where the search term should be inserted.")

(defcustom helm-dictionary-browser-function nil
  "The browser that is used to access online dictionaries.  If
nil (default), the value of `browse-url-browser-function' is
used.  If that value is nil, Helm uses the first available
browser in `helm-browse-url-default-browser-alist'"
  :group 'helm-dictionary
  :type '(choice
          (const         :tag "Default" :value nil)
          (function-item :tag "Emacs interface to w3m" :value w3m-browse-url)
          (function-item :tag "Emacs W3" :value  browse-url-w3)
          (function-item :tag "W3 in another Emacs via `gnudoit'"
                         :value  browse-url-w3-gnudoit)
          (function-item :tag "Mozilla" :value  browse-url-mozilla)
          (function-item :tag "Firefox" :value browse-url-firefox)
          (function-item :tag "Chromium" :value browse-url-chromium)
          (function-item :tag "Galeon" :value  browse-url-galeon)
          (function-item :tag "Epiphany" :value  browse-url-epiphany)
          (function-item :tag "Netscape" :value  browse-url-netscape)
          (function-item :tag "eww" :value  eww-browse-url)
          (function-item :tag "Mosaic" :value  browse-url-mosaic)
          (function-item :tag "Mosaic using CCI" :value  browse-url-cci)
          (function-item :tag "Text browser in an xterm window"
                         :value browse-url-text-xterm)
          (function-item :tag "Text browser in an Emacs window"
                         :value browse-url-text-emacs)
          (function-item :tag "KDE" :value browse-url-kde)
          (function-item :tag "Elinks" :value browse-url-elinks)
          (function-item :tag "Specified by `Browse Url Generic Program'"
                         :value browse-url-generic)
          (function-item :tag "Default Windows browser"
                         :value browse-url-default-windows-browser)
          (function-item :tag "Default Mac OS X browser"
                         :value browse-url-default-macosx-browser)
          (function-item :tag "GNOME invoking Mozilla"
                         :value browse-url-gnome-moz)
          (function-item :tag "Default browser"
                         :value browse-url-default-browser)
          (function      :tag "Your own function")
          (alist         :tag "Regexp/function association list"
                         :key-type regexp :value-type function)))

(easy-menu-add-item nil '("Tools" "Helm" "Tools") ["Dictionary" helm-dictionary t])


(defun helm-dictionary-transformer (candidates)
  "Formats entries retrieved from the data base."
  (cl-loop for i in candidates
           with entry and l1terms and l2terms
           and width = (with-helm-window (window-width))
           unless (or (string-match "\\`#" i)
                      (not (string-match " :: ?" i)))
           do (progn (setq entry (split-string i " :: ?"))
                     (setq l1terms (split-string (car entry) " | "))
                     (setq l2terms (split-string (cadr entry) " | ")))
           and append
           (cl-loop for l1term in l1terms
                    for l2term in l2terms
                    if (or (string-match helm-pattern l1term)
                           (string-match helm-pattern l2term))
                    collect
                    (cons
                     (concat
                      (truncate-string-to-width l1term (- (/ width 2) 1) 0 ?\s)
                      " "
                      (truncate-string-to-width l2term (- (/ width 2) 1) 0 ?\s))
                     (cons l1term l2term)))))


(defun helm-dictionary-insert-l1term (entry)
  (insert
    (replace-regexp-in-string
      " *{.+}\\| *\\[.+\\]" "" (car entry))))

(defun helm-dictionary-insert-l2term (entry)
  (insert
    (replace-regexp-in-string
      " *{.+}\\| *\\[.+\\]" "" (cdr entry))))


(defvar helm-source-dictionary
  '((name . "Search dictionary")
    (candidates-file . helm-dictionary-database)
    (candidate-transformer . helm-dictionary-transformer)
    (action . (("Insert source language term" . helm-dictionary-insert-l1term)
               ("Insert target language term" . helm-dictionary-insert-l2term)))))

(defvar helm-source-dictionary-online
  '((name . "Look up online")
    (match (lambda (_candidate) t))
    (candidates . helm-dictionary-online-dicts)
    (no-matchplugin)
    (nohighlight)
    (action
     . (lambda (cand)
         (let ((browse-url-browser-function
                (or helm-dictionary-browser-function
                    browse-url-browser-function)))
           (helm-browse-url (format cand (url-hexify-string helm-pattern)))))))
  "Source for online look-up.")

;;;###autoload
(defun helm-dictionary ()
  (interactive)
  (helm :sources '(helm-source-dictionary helm-source-dictionary-online)
        :full-frame t
        :candidate-number-limit 500
        :buffer "*helm dictionary*"))

(provide 'helm-dictionary)

;; Local Variables:
;; byte-compile-warnings: (not cl-functions obsolete)
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:

;;; helm-dictionary.el ends here
#+END_SRC

#+RESULTS:
: helm-dictionary


** mail list
[[gnus:nntp%2Bnews.gmane.org:gmane.emacs.helm.user#87eh8mpakg.fsf@gmail.com][Email from Thierry Volpiatto: Re: Get the full path to the c]]

helm-describe-helm-attribute

* Using filters to get pdf images into html export

#+BEGIN_SRC python
import matplotlib.pyplot as plt

plt.plot([1, 2, 4, 8])
plt.savefig('im.pdf')
#+END_SRC

Here is our inline image as a pdf file. We would like it to be converted to a png, and rendered in an html export. This is most easily done with a derived backend.

[[./im.pdf]]


#+BEGIN_SRC emacs-lisp
(defun my-link-format (link contents info)
  (let ((type (org-element-property :type link))
	(path (org-element-property :path link)))
    (cond
     ((and
       (string= type "file")
       (string-match "\.pdf" path))
      (shell-command
       (format
	"convert %s %s"
	path
	(replace-regexp-in-string "\.pdf" ".png" path)))
      (format "<img src=\"%s\">" (replace-regexp-in-string "\.pdf" ".png" path)))
     ;; anything else, we just do the regular thing
     (t
      (org-html-link link contents info)))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((link . my-link-format)))


(browse-url (org-export-to-file 'my-html "custom-link.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-link.html>




* A helm interface to org-contacts

#+BEGIN_SRC emacs-lisp
(defun oc-email (_)
 (interactive)
 (message-box "%s"
	      (mapconcat
	       (lambda (x)
		 (cdr (assoc "EMAIL" (elt x 1))))
	       (helm-marked-candidates :with-wildcard t)
	       ",")))


(defun oc-open-entry (selection)
 (let ((mark (car selection)))
   (switch-to-buffer (marker-buffer mark))
   (goto-char (marker-position mark))
   (show-subtree)))


(defun oc-open-url (selection)
  (let ((url (cdr (assoc "URL" (elt selection 1)))))
    (when url
      (browse-url url))))


(defvar helm-source-org-contacts
  '((name                            . "Contacts")
    (candidates                      . org-contaqcts-db)
    (action . (("Email"              . oc-email)
	       ("web"                . oc-open-url)
               ("Show entry"         . oc-open-entry))))
  "Source for searching in org-contacts.")

(defun helm-org-contacts ()
  "Search BibTeX entries."
  (interactive)
  (helm :sources '(helm-source-org-contacts)
        :candidate-number-limit 500))
#+END_SRC

#+RESULTS:
: helm-org-contacts

* org-ref-helm
Inspired by [[https://github.com/tmalsburg/helm-bibtex][helm-bibtex]], here I explore a way to insert citations using some helm-bibtex machinery. The gist of helm-bibtex is it scans your bib files, offers spectacular search and select capability, and then your choice of actions on those. The default action is to open the pdf, but I want the default action to be to insert a link.

#+BEGIN_SRC emacs-lisp
(require 'helm-bibtex)

(defun helm-bibtex-format-org-ref (keys)
  "insert selected KEYS as cite link. Append KEYS if you are on a link."
  (let ((el (org-element-context)))
    (message "%s" el)
    (if (eq 'link (car el))
	(progn
	  (goto-char (org-element-property :end el))
	  (concat "," (s-join "," keys)))
      (concat "cite:" (s-join "," keys)))))

(setq helm-bibtex-format-citation-functions
      '((org-mode . helm-bibtex-format-org-ref)))


(defvar org-ref-helm-source-bibtex
  '((name                                      . "BibTeX entries")
    (init                                      . helm-bibtex-init)
    (candidates                                . helm-bibtex-candidates)
    (filtered-candidate-transformer            . helm-bibtex-candidates-formatter)
    (action . (("Insert citation"              . helm-bibtex-insert-citation)
	       ("Open PDF file (if present)"   . helm-bibtex-open-pdf)
               ("Open URL or DOI in browser"   . helm-bibtex-open-url-or-doi)
               ("Insert reference"             . helm-bibtex-insert-reference)
               ("Insert BibTeX key"            . helm-bibtex-insert-key)
               ("Insert BibTeX entry"          . helm-bibtex-insert-bibtex)
               ("Attach PDF to email"          . helm-bibtex-add-PDF-attachment)
               ("Edit notes"                   . helm-bibtex-edit-notes)
               ("Show entry"                   . helm-bibtex-show-entry))))
  "Source for searching in BibTeX files.")

;;;###autoload
(defun org-ref-helm-bibtex ()
  "Search BibTeX entries."
  (interactive)
  (helm :sources '(org-ref-helm-source-bibtex helm-source-fallback-options)
        :full-frame t
        :candidate-number-limit 500))
#+END_SRC

#+RESULTS:
: org-ref-helm-bibtex



* A simple helm menu

Helm is an interesting way to interactively select something, and perform an action on it.
here is an example where I tried to get all the words in the buffer, select one from helm, and then search the word.

The setup is not intuitive yet. You need to provide some sources that helm will use to create the matching buffer. This is usually done in a variable that is a list of cons cells. The source provides "candidates", and "actions". After that


#+BEGIN_SRC emacs-lisp
(defun helm-words-google (word)
  "Google the WORD."
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s" word)))

(defun helm-words-twitter (word)
  "Search twitter for WORD."
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s" word)))


(defvar helm-source-words
 '()
  "Source for helm-words")

(setq helm-source-words
      '((name . "Words entries")
	(candidates . (lambda nil (with-current-buffer
				    cb
				    (split-string (buffer-string)))))
	(action . (("google" . helm-words-google)
		   ("twitter" . helm-words-twitter)))))

(defun helm-words ()
  "helm a word"
  (interactive)
  ;; we have to save the buffer we are in before we go to the helm buffer
  ;; so that we can get the words there.
  (let ((cb (current-buffer)))
    (helm :sources '(helm-source-words)
	  :buffer "*helm-words*")))

#+END_SRC

#+RESULTS:
: helm-words

#+BEGIN_SRC emacs-lisp :results code
(helm-bibtex-candidates)
#+END_SRC

#+RESULTS:


The candidates must be a list of items, and the car of the list is what gets listed in the helm selection buffer. The cdr of the list gets passed to the action functions. Here we hard code some candidates to make it more clear. We see the car in the helm buffer, and get the cdr passed to our action functions.

#+BEGIN_SRC emacs-lisp
(defun helm-words-google (word)
  "Google the WORD."
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s"
    (if (listp word)
	(mapconcat 'identity word " and ")
      word))))

(defun helm-words-twitter (word)
  "Search twitter for WORD."
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s"
    (if (listp word)
	(mapconcat 'identity word " and ")
      word))))

(defvar helm-source-words
 '()
  "Source for helm-words")

(setq helm-source-words
      '((name . "Words entries")
	(candidates . (lambda nil '(("a" . ("apple" "apricot"))
				    ("b" . "bear")
				    ("c" . "cat"))))
	(action . (("google" . helm-words-google)
		   ("twitter" . helm-words-twitter)))))

(defun helm-words ()
  "helm a word"
  (interactive)

  (let ((cb (current-buffer)))
    (helm :sources '(helm-source-words)
	  :buffer "*helm-words*")))

#+END_SRC

#+RESULTS:
: helm-words


* Find org-files that mention a citation




I want to find all my org-files in some tree that cite this paper cite:kitchin-2004-role.

#+BEGIN_SRC emacs-lisp
(rgrep "kitchin-2004-role\\(;\\|:\\|.\\|,\\| \\)" "*.org" "~/Dropbox/CMU/manuscripts")
#+END_SRC

#+RESULTS:

kitchin-2004-role-strain



#+BEGIN_SRC emacs-lisp
(switch-to-buffer (grep-find "find ~/Dropbox/CMU/manuscripts -type f -name \"*.org\" -exec grep -nH -e  \"kresse-1996-effic\\(;\\|:\\|.\\|,\\| \\)\" {} +"))
#+END_SRC
#+RESULTS:
: #<buffer *grep*>

cite:kresse-1996-effic


#+BEGIN_SRC emacs-lisp
(switch-to-buffer (grep-find "find ~/Dropbox/CMU/manuscripts -type f -name \"*.org\" -exec grep -nH -e  \"kitchin-\" {} +"))
#+END_SRC
#+RESULTS:
: #<buffer *grep*>

From techela
#+BEGIN_SRC emacs-lisp
(multi-occur (mapcar 'find-file-noselect
		     (-filter
		      'file-exists-p
		      (files-in-below-directory
		       "~/Dropbox/CMU/manuscripts")))
	     "kitchin-2004-strain")
#+END_SRC
#+RESULTS:
: t

This returns t, it does not work!
#+BEGIN_SRC emacs-lisp
(multi-occur (mapcar 'find-file-noselect
		     (f-entries "~/Dropbox/CMU/manuscripts"
				(lambda (f) (string= (f-filename f) "manuscript.org")) t))
	     "kitchin-2004-strain")
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
(helm-multi-occur (mapcar 'find-file-noselect
		     (f-entries "~/Dropbox/CMU/manuscripts"
				(lambda (f) (string= (f-filename f) "manuscript.org")) t)))
#+END_SRC


* make any org link a menu link

It seems like it should be possible to make org links have variable behavior. For example, if one action is defined, it should be done. If more than one action is defined, you should get a menu. One way to achieve this is to hijack the org-link functions, or in cases where lambda functions are used, we have to redefine them. The follow functions are defined in org-link-protocols.

#+BEGIN_SRC emacs-lisp :results code
org-link-protocols
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("google"
  (lambda
    (link-string)
    (browse-url
     (format "http://www.google.com/search?q=%s"
	     (url-hexify-string link-string))))
  nil)
 ("ResearcherID"
  (lambda
    (link-string)
    (browse-url
     (format "http://www.researcherid.com/rid/%s" link-string)))
  nil)
 ("orcid"
  (lambda
    (link-string)
    (browse-url
     (format "http://orcid.org/%s" link-string)))
  nil)
 ("message" org-mac-message-open nil)
 ("mac-outlook" org-mac-outlook-message-open nil)
 ("skim" org-mac-skim-open nil)
 ("addressbook" org-mac-addressbook-item-open nil)
 ("x-together-item" org-mac-together-item-open nil)
 ("rmail" org-rmail-open nil)
 ("mhe" org-mhe-open nil)
 ("irc" org-irc-visit nil)
 ("info" org-info-open nil)
 ("gnus" org-gnus-open nil)
 ("docview" org-docview-open org-docview-export)
 ("bibtex" org-bibtex-open nil)
 ("bbdb" org-bbdb-open org-bbdb-export)
 ("ans"
  (lambda
    (path)
    (let*
	((fields
	  (split-string path "::"))
	 (label
	  (nth 0 fields))
	 (data
	  (nth 1 fields))
	 (data-file
	  (format "%s-%s.dat" tq-userid label)))
      (let
	  ((temp-file data-file)
	   (temp-buffer
	    (get-buffer-create
	     (generate-new-buffer-name " *temp file*"))))
	(unwind-protect
	    (prog1
		(save-current-buffer
		  (set-buffer temp-buffer)
		  (insert data))
	      (save-current-buffer
		(set-buffer temp-buffer)
		(write-region nil nil temp-file nil 0)))
	  (and
	   (buffer-name temp-buffer)
	   (kill-buffer temp-buffer))))
      (mygit
       (format "git add %s" data-file))
      (mygit
       (format "git commit -m \"%s\"" data-file))
      (mygit "git push origin master")))
  nil)
 ("exercise"
  (lambda
    (arg)
    (tq-check-internet)
    (tq-get-assignment arg))
  nil)
 ("solution"
  (lambda
    (label)
    (tq-check-internet)
    (let
	((default-directory
	   (file-name-as-directory
	    (expand-file-name tq-root-directory))))
      (if
	  (file-exists-p "solutions")
	  nil
	(make-directory "solutions"))
      (let
	  ((default-directory
	     (file-name-as-directory
	      (expand-file-name "solutions"))))
	(if
	    (file-exists-p label)
	    (progn
	      (find-file
	       (concat label "/" label ".org"))
	      (tq-update))
	  (mygit
	   (format "git clone %s@%s:solutions/%s" tq-current-course tq-git-server label))
	  (find-file
	   (concat label "/" label ".org"))))))
  nil)
 ("assignment"
  (lambda
    (arg)
    (tq-check-internet)
    (tq-get-assignment arg))
  nil)
 ("doi" doi-link-menu nil)
 ("bibentry" org-ref-cite-onclick-minibuffer-menu org-ref-format-bibentry)
 ("Autocites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocites)
 ("autocites" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocites)
 ("supercites" org-ref-cite-onclick-minibuffer-menu org-ref-format-supercites)
 ("Textcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Textcites)
 ("textcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-textcites)
 ("Smartcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Smartcites)
 ("smartcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-smartcites)
 ("footcitetexts" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcitetexts)
 ("footcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcites)
 ("Parencites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Parencites)
 ("parencites" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencites)
 ("Cites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Cites)
 ("cites" org-ref-cite-onclick-minibuffer-menu org-ref-format-cites)
 ("fnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-fnotecite)
 ("Pnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Pnotecite)
 ("pnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-pnotecite)
 ("Notecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Notecite)
 ("notecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-notecite)
 ("footfullcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-footfullcite)
 ("fullcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-fullcite)
 ("citeurl" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeurl)
 ("citedate*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citedate*)
 ("citedate" org-ref-cite-onclick-minibuffer-menu org-ref-format-citedate)
 ("citetitle*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetitle*)
 ("citetitle" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetitle)
 ("Citeauthor*" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citeauthor*)
 ("Autocite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocite*)
 ("autocite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocite*)
 ("Autocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocite)
 ("autocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocite)
 ("supercite" org-ref-cite-onclick-minibuffer-menu org-ref-format-supercite)
 ("parencite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencite*)
 ("cite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-cite*)
 ("Smartcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Smartcite)
 ("smartcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-smartcite)
 ("Textcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Textcite)
 ("textcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-textcite)
 ("footcitetext" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcitetext)
 ("footcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcite)
 ("Parencite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Parencite)
 ("parencite" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencite)
 ("Cite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Cite)
 ("Citeauthor" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citeauthor)
 ("Citealp" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citealp)
 ("Citealt" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citealt)
 ("Citep" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citep)
 ("Citet" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citet)
 ("citeyear*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeyear*)
 ("citeyear" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeyear)
 ("citeauthor*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeauthor*)
 ("citeauthor" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeauthor)
 ("citetext" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetext)
 ("citenum" org-ref-cite-onclick-minibuffer-menu org-ref-format-citenum)
 ("citealp*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealp*)
 ("citealp" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealp)
 ("citealt*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealt*)
 ("citealt" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealt)
 ("citep*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citep*)
 ("citep" org-ref-cite-onclick-minibuffer-menu org-ref-format-citep)
 ("citet*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citet*)
 ("citet" org-ref-cite-onclick-minibuffer-menu org-ref-format-citet)
 ("nocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-nocite)
 ("cite" org-ref-cite-onclick-minibuffer-menu org-ref-format-cite)
 ("eqref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (goto-char
     (point-min))
    (if
	(or
	 (re-search-forward
	  (format "label:%s" label)
	  nil t)
	 (re-search-forward
	  (format "\\label{%s}" label)
	  nil t)
	 (re-search-forward
	  (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	  nil t))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<eqref>%s</eqref>)" path))
     ((eq format 'latex)
      (format "\\eqref{%s}" keyword)))))
 ("nameref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<nameref>%s</nameref>)" path))
     ((eq format 'latex)
      (format "\\nameref{%s}" keyword)))))
 ("pageref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "label:%s\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<pageref>%s</pageref>)" path))
     ((eq format 'latex)
      (format "\\pageref{%s}" keyword)))))
 ("ref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "label:%s\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (org-show-entry)
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<ref>%s</ref>)" path))
     ((eq format 'latex)
      (format "\\ref{%s}" keyword)))))
 ("label"
  (lambda
    (label)
    "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
    (message
     (format "%s occurences"
	     (+
	      (count-matches
	       (format "label:%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "^#\\+tblname:\\s-*%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "\\label{%s}\\b" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "^#\\+label:\\s-*%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)))))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<label>%s</label>)" path))
     ((eq format 'latex)
      (format "\\label{%s}" keyword)))))
 ("list-of-tables" org-ref-list-of-tables
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\listoftables")))))
 ("list-of-figures" org-ref-list-of-figures
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\listoffigures")))))
 ("addbibresource"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-addbibresource)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format ""))
     ((eq format 'latex)
      (format "\\addbibresource{%s}" keyword)))))
 ("bibliographystyle"
  (lambda
    (arg)
    (message "Nothing implemented for clicking here."))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\bibliographystyle{%s}" keyword)))))
 ("printbibliography"
  (lambda
    (arg)
    (message "Nothing implemented for clicking here."))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      "\\printbibliography"))))
 ("nobibliography"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-bibliography)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'ascii)
      (org-ref-get-ascii-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      (format "\\nobibliography{%s}"
	      (replace-regexp-in-string "\\.bib" ""
					(mapconcat 'identity
						   (mapcar 'expand-file-name
							   (split-string keyword ","))
						   ",")))))))
 ("bibliography"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-bibliography)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'ascii)
      (org-ref-get-ascii-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      (format "\\bibliography{%s}"
	      (replace-regexp-in-string "\\.bib" ""
					(mapconcat 'identity
						   (mapcar 'expand-file-name
							   (split-string keyword ","))
						   ",")))))))
 ("pydoc"
  (lambda
    (link-string)
    (shell-command
     (format "python -m pydoc %s" link-string)))
  nil)
 ("index"
  (lambda
    (path)
    (tq-index)
    (occur path))
  nil)
 ("attachfile"
  (lambda
    (link-string)
    (org-open-file link-string))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format ""))
     ((eq format 'latex)
      (format "\\attachfile{%s}" keyword)))))
 ("msx" org-msx-open nil)
 ("id" org-id-open nil)
 ("file+emacs" org-open-file-with-emacs nil)
 ("file+sys" org-open-file-with-system nil))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results code
(car org-link-protocols)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("google"
 (lambda
   (link-string)
   (browse-url
    (format "http://www.google.com/search?q=%s"
	    (url-hexify-string link-string))))
 nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setf (cadr (assoc "google" org-link-protocols))
  (lambda (x) (message "You googled %s good" x)))
#+END_SRC

#+RESULTS:
| lambda | (x) | (message You googled %s good x) |

#+BEGIN_SRC emacs-lisp :results code
(car org-link-protocols)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("google"
 (lambda
   (x)
   (message "You googled %s good" x))
 nil)
#+END_SRC

google:test

This way you can make the function do what ever you want, without digging into the source code, advising functions etc...

#+BEGIN_SRC emacs-lisp
(assoc "file" org-link-protocols)
#+END_SRC

#+RESULTS:
skim:ts
* Unlinkify an org link

cnn

a f test.regfdsa


#+BEGIN_SRC emacs-lisp
(defun unlinkify ()
  "replace an org-link with the path, or description."
  (interactive)
  (let ((eop (org-element-context)))
    (when (eq 'link (car eop))
(message "%s" eop)
      (let* ((start (org-element-property :begin eop))
	     (end (org-element-property :end eop))
	     (contents-begin (org-element-property :contents-begin eop))
	     (contents-end (org-element-property :contents-end eop))
	     (path (org-element-property :path eop))
	     (desc (and contents-begin
			contents-end
			(buffer-substring contents-begin contents-end))))
	(setf (buffer-substring start end) (or desc path))))))
#+END_SRC

#+RESULTS:
: unlinkify

* retired wos python code

Get this here: https://gist.github.com/domoritz/2012629
#+BEGIN_SRC python :tangle wos.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from suds.client import Client
from suds.transport.http import HttpTransport
import urllib2

class HTTPSudsPreprocessor(urllib2.BaseHandler):
    def __init__(self, SID):
        self.SID = SID

    def http_request(self, req):
        req.add_header('cookie', 'SID="'+self.SID+'"')
        return req

    https_request = http_request


class WokmwsSoapClient():
    """
    main steps you have to do:
        soap = WokmwsSoapClient()
        results = soap.search(...)
    """
    def __init__(self):
        self.url = self.client = {}
        self.SID = ''

        self.url['auth'] = 'http://search.isiknowledge.com/esti/wokmws/ws/WOKMWSAuthenticate?wsdl'
        self.url['search'] = 'http://search.isiknowledge.com/esti/wokmws/ws/WokSearchLite?wsdl'

        self.prepare()

    def __del__(self):
        self.close()

    def prepare(self):
        """does all the initialization we need for a request"""
        self.initAuthClient()
        self.authenticate()
        self.initSearchClient()

    def initAuthClient(self):
        self.client['auth'] = Client(self.url['auth'])

    def initSearchClient(self):
        http = HttpTransport()
        opener = urllib2.build_opener(HTTPSudsPreprocessor(self.SID))
        http.urlopener = opener
        self.client['search'] = Client(self.url['search'], transport = http)

    def authenticate(self):
        self.SID = self.client['auth'].service.authenticate()

    def close(self):
        self.client['auth'].service.closeSession()

    def search(self, query):
        qparams = {
            'databaseID' : 'WOS',
            'userQuery' : query,
            'queryLanguage' : 'en',
            'editions' : [{
                'collection' : 'WOS',
                'edition' : 'SCI',
            },{
                'collection' : 'WOS',
                'edition' : 'SSCI',
            }]
        }

        rparams = {
            'count' : 5, # 1-100
            'firstRecord' : 1,
            'fields' : [{
                'name' : 'Relevance',
                'sort' : 'D',
            }],
        }

        return self.client['search'].service.search(qparams, rparams)
#+END_SRC

#+BEGIN_SRC sh
pip install suds
#+END_SRC

#+BEGIN_SRC python
from wos import *
soap = WokmwsSoapClient()
results = soap.search('AU=kitchin')
print results
#+END_SRC

#+RESULTS:

suds.WebFault: Server raised fault: 'The Web Service (version 2.0) has been retired permanently. Please contact Thomson Reuters IP and Science Technical Support http://ip-science.thomsonreuters.com/techsupport/ for information on how to obtain a new version of our Web Service.'
* Spelling and grammar checking in emacs with a web API

After the deadline (http://www.afterthedeadline.com/api.slp) has an API for checking spelling, grammar, statistics and style. You post to their server, and they send back some xml. Here is a minimal example in emacs.

#+BEGIN_SRC emacs-lisp
(let ((url-request-method "POST")
      (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not"))))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://service.afterthedeadline.com/checkDocument")
    (buffer-substring url-http-end-of-headers (point-max))))
#+END_SRC

#+RESULTS:
#+begin_example

<results>
  <error>
    <string>spel</string>
    <description>Spelling</description>
    <precontext>be</precontext>
    <suggestions>
        <option>spell</option>
        <option>spelt</option>
        <option>sped</option>
        <option>spec</option>
        <option>spew</option>
    </suggestions>
    <type>spelling</type>

  </error>
  <error>
    <string>gud</string>
    <description>Spelling</description>
    <precontext>spel</precontext>
    <suggestions>
        <option>gd</option>
        <option>gu</option>
        <option>gcd</option>
        <option>gad</option>
        <option>guid</option>
    </suggestions>
    <type>spelling</type>

  </error>
  <error>
    <string>weather</string>
    <description>Did you mean...</description>
    <precontext>gud</precontext>
    <suggestions>
        <option>whether</option>
    </suggestions>
    <type>spelling</type>
    <url>http://service.afterthedeadline.com/info.slp?text=weather&amp;tags=NN&amp;engine=0</url>

  </error>
  <error>
    <string>to be</string>
    <description>Passive voice</description>
    <precontext>want</precontext>

    <type>grammar</type>
    <url>http://service.afterthedeadline.com/info.slp?text=to+be&amp;tags=TO%2FVB&amp;engine=3</url>

  </error>
</results>
#+end_example

It finds two spelling errors, and a probable other kind of error (whether/weather), and a grammar issue. It would be nice to parse this into something more helpful. Emacs has come xml parsing [[http://www.emacswiki.org/emacs/XmlParserExamples][capabilities]], which we consider next.

#+BEGIN_SRC emacs-lisp
(describe-function 'xml-get-children)
#+END_SRC

#+RESULTS:
: xml-get-children is a compiled Lisp function in `xml.el'.
:
: (xml-get-children NODE CHILD-NAME)
:
: Return the children of NODE whose tag is CHILD-NAME.
: CHILD-NAME should match the value returned by `xml-node-name'.

#+BEGIN_SRC emacs-lisp
(describe-function 'xml-node-children)
#+END_SRC

#+RESULTS:
: xml-node-children is a compiled Lisp function in `xml.el'.
:
: (xml-node-children NODE)
:
: Return the list of children of NODE.
: This is a list of nodes, and it can be nil.

#+BEGIN_SRC emacs-lisp :results drawer
(let* ((url-request-method "POST")
       (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not")))
       (xml  (with-current-buffer
		 (url-retrieve-synchronously
		  "http://service.afterthedeadline.com/checkDocument")
	       (xml-parse-region url-http-end-of-headers (point-max)))))
  xml)
#+END_SRC

#+RESULTS:
:RESULTS:
((results nil
   (error nil
     (string nil spel)
     (description nil Spelling)
     (precontext nil be)
     (suggestions nil
         (option nil spell)
         (option nil spelt)
         (option nil sped)
         (option nil spec)
         (option nil spew)
    )
     (type nil spelling)

  )
   (error nil
     (string nil gud)
     (description nil Spelling)
     (precontext nil spel)
     (suggestions nil
         (option nil gd)
         (option nil gu)
         (option nil gcd)
         (option nil gad)
         (option nil guid)
    )
     (type nil spelling)

  )
   (error nil
     (string nil weather)
     (description nil Did you mean...)
     (precontext nil gud)
     (suggestions nil
         (option nil whether)
    )
     (type nil spelling)
     (url nil http://service.afterthedeadline.com/info.slp?text=weather&tags=NN&engine=0)

  )
   (error nil
     (string nil to be)
     (description nil Passive voice)
     (precontext nil want)

     (type nil grammar)
     (url nil http://service.afterthedeadline.com/info.slp?text=to+be&tags=TO%2FVB&engine=3)

  )
))
:END:

Here, we have some code that parses that xml into some more readable text. It took a while to work this out, and it still doesn't seem very beautiful.

#+BEGIN_SRC emacs-lisp :results output
(let* ((url-request-method "POST")
       (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not")))
       (xml  (with-current-buffer
		 (url-retrieve-synchronously
		  "http://service.afterthedeadline.com/checkDocument")
	       (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (errors (xml-get-children results 'error)))
  (dolist (err errors)
    (let* ((children (xml-node-children err))
	   ;; for some reason I could not get the string out, and had to do this.
	   (s (car (last (nth 1 children))))
	   ;; the last/car stuff doesn't seem right. there is probably
	   ;; a more idiomatic way to get this
           (desc (last (car (xml-get-children children 'description))))
	   (type (last (car (xml-get-children children 'type))))
	   (suggestions (xml-get-children children 'suggestions))
	   (options (xml-get-children (xml-node-name suggestions) 'option))
	   (opt-string  (mapconcat
		 (lambda (el)
		   (when (listp el)
		     (car (last el))))
		 options
		 " "))
	  )
      (princ (format "** %s ** %s
Description: %s
Suggestions: %s

" s type desc opt-string)))))
#+END_SRC

#+RESULTS:
#+begin_example
** spel ** (spelling)
Description: (Spelling)
Suggestions: spell spelt sped spec spew

** gud ** (spelling)
Description: (Spelling)
Suggestions: gd gu gcd gad guid

** weather ** (spelling)
Description: (Did you mean...)
Suggestions: whether

** to be ** (grammar)
Description: (Passive voice)
Suggestions:

#+end_example

Still, from here we could make some org links to go to different places in the buffer for editing.

** python approach

Basically, you post a request to the website, and you get an xml response back. I adapted this code from https://bitbucket.org/miguelventura/after_the_deadline/wiki/Home to do a simple spell check. The idea is to build this up to an emacs lisp library that does this from a command.

#+BEGIN_SRC python
import requests
import urllib

payload = urllib.urlencode({'key': None,
                            'data': 'I spel gud'})

url = "http://service.afterthedeadline.com/checkDocument"

r = requests.post(url, data=payload)

from xml.etree import ElementTree
e = ElementTree.fromstring(r.text)

errs = e.findall('message')
if len(errs) > 0:
    raise Exception('Server returned an error: %s' % errs[0].text)

for err in e.findall('error'):
    if err[1].text == 'Spelling':
        print '\n**{}** mispelled\nSuggestions:'.format(err[0].text)
        for opt in err.findall('suggestions/option'):
            print '  {}'.format(opt.text)
#+END_SRC

#+RESULTS:
#+begin_example

**spel** mispelled
Suggestions:
  sped
  spell
  spelt
  spec
  spew

**gud** mispelled
Suggestions:
  guy
  god
  gun
  gum
  gut
#+end_example



* More doi utility functions

#+BEGIN_SRC emacs-lisp
(defun doi-utils-google-scholar (doi)
 "DOI can be any query."
 (interactive "sDOI: ")
 (browse-url (format "http://scholar.google.com/scholar?hl=en&q=%s" (url-hexify-string doi))))

(doi-utils-google-scholar "10.1021/jp047349j")
#+END_SRC

#+RESULTS:
: #<process open http://scholar.google.com/scholar?hl=en&q=10.1021%2Fjp047349j>

#+BEGIN_SRC emacs-lisp
(defun doi-utils-crossref (doi)
 (interactive "sDOI: ")
 (browse-url (format "http://search.crossref.org/?q=%s" (url-hexify-string doi))))

(doi-utils-crossref "10.1021/jp047349j")
#+END_SRC

#+RESULTS:
: #<process open http://search.crossref.org/?q=10.1021%2Fjp047349j>

http://wokinfo.com/products_tools/products/related/webservices/

I requested access for this ip address: 128.2.54.215
[[google:my ip address]]

soap
http://search.isiknowledge.com/esti/wokmws/ws/


#+BEGIN_SRC emacs-lisp
(defun doi-utils-ads (query)
 "run QUERY in the Harvard abstract simple search."
 (interactive "sQuery: ")
 (browse-url (format "http://adsabs.harvard.edu/cgi-bin/nph-basic_connect?qsearch=%s&version=1" (url-hexify-string doi))))

(doi-utils-ads "kitchin and barteau")
#+END_SRC

#+RESULTS:
: #<process open http://adsabs.harvard.edu/cgi-bin/nph-basic_connect?qsearch=kitchin%20and%20barteau&version=1>

* crossref + doi

[[http://www.crossref.org/][crossref.org]]

#+BEGIN_SRC emacs-lisp
(let ((url-request-method "GET")
      (json-object-type 'plist)
      (json-data))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://search.crossref.org/dois?q=john+kitchin+catalysis&&rows=3")
      (setq json-data (buffer-substring url-http-end-of-headers (point-max)))
      (json-read-from-string json-data)))
#+END_SRC
#+RESULTS:
: [(:year "2012" :coins "ctx_ver=Z39.88-2004&amp;rft_id=info%3Adoi%2Fhttp%3A%2F%2Fdx.doi.org%2F10.1007%2Fs11244-012-9808-0&amp;rfr_id=info%3Asid%2Fcrossref.org%3Asearch&amp;rft.atitle=Preface%3A+Trends+in+Computational+Catalysis&amp;rft.jtitle=Topics+in+Catalysis&amp;rft.date=2012&amp;rft.volume=55&amp;rft.issue=5-6&amp;rft.spage=227&amp;rft.epage=228&amp;rft.aufirst=John&amp;rft.aulast=Kitchin&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.au=John+Kitchin" :fullCitation "John Kitchin, 2012, 'Preface: Trends in Computational Catalysis', <i>Topics in Catalysis</i>, vol. 55, no. 5-6, pp. 227-228" :title "Preface: Trends in Computational Catalysis" :normalizedScore 100 :score 3.5252514 :doi "http://dx.doi.org/10.1007/s11244-012-9808-0") (:year "2012" :coins "ctx_ver=Z39.88-2004&amp;rft_id=info%3Adoi%2Fhttp%3A%2F%2Fdx.doi.org%2F10.1039%2F9781849734776-00083&amp;rfr_id=info%3Asid%2Fcrossref.org%3Asearch&amp;rft.atitle=Coverage+dependent+adsorption+properties+of+atomic+adsorbates+on+late+transition+metal+surfaces&amp;rft.jtitle=Catalysis&amp;rft.date=2012&amp;rft.spage=83&amp;rft.epage=115&amp;rft.aufirst=Spencer&amp;rft.aulast=Miller&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=bookitem&amp;rft.au=Spencer+Miller&amp;rft.au=+Carmeline+Dsilva&amp;rft.au=+John+R.+Kitchin" :fullCitation "Spencer Miller, Carmeline Dsilva, John R. Kitchin, 2012, 'Coverage dependent adsorption properties of atomic adsorbates on late transition metal surfaces', <i>Catalysis</i>, pp. 83-115" :title "Coverage dependent adsorption properties of atomic adsorbates on late transition metal surfaces" :normalizedScore 85 :score 3.021644 :doi "http://dx.doi.org/10.1039/9781849734776-00083") (:year "2014" :coins "ctx_ver=Z39.88-2004&amp;rft_id=info%3Adoi%2Fhttp%3A%2F%2Fdx.doi.org%2F10.1016%2Fj.catcom.2013.10.028&amp;rfr_id=info%3Asid%2Fcrossref.org%3Asearch&amp;rft.atitle=Relating+the+electronic+structure+and+reactivity+of+the+3d+transition+metal+monoxide+surfaces&amp;rft.jtitle=Catalysis+Communications&amp;rft.date=2014&amp;rft.volume=52&amp;rft.spage=60&amp;rft.epage=64&amp;rft.aufirst=Zhongnan&amp;rft.aulast=Xu&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Ajournal&amp;rft.genre=article&amp;rft.au=Zhongnan+Xu&amp;rft.au=+John+R.+Kitchin" :fullCitation "Zhongnan Xu, John R. Kitchin, 2014, 'Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces', <i>Catalysis Communications</i>, vol. 52, pp. 60-64" :title "Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces" :normalizedScore 85 :score 3.021644 :doi "http://dx.doi.org/10.1016/j.catcom.2013.10.028")]

#+BEGIN_SRC emacs-lisp
(url-hexify-string "10.1016/j.catcom.2013.10.028")
#+END_SRC
#+RESULTS:
: 10.1016%2Fj.catcom.2013.10.028

#+BEGIN_SRC emacs-lisp
(url-unhex-string "10.1016%2Fj.catcom.2013.10.028")
#+END_SRC
#+RESULTS:
: 10.1016/j.catcom.2013.10.028

#+BEGIN_SRC emacs-lisp
(defun cross-ref-search ()
  (interactive)
  (browse-url
   (format
    "http://search.crossref.org/?q=%s"
    (if (use-region-p)
	(url-hexify-string (buffer-substring
			    (region-beginning)
			    (region-end)))
      (read-string "string: ")))))
#+END_SRC

* Capturing stderr and stdout in org-mode

It looks like you have to send these to files, and then read them.

If we run this in org-mode, there is no message about stderr.
#+BEGIN_SRC python :tangle peo.py
import sys

print >>sys.stdout, "on stdout"
print >>sys.stderr, "on stderr"
#+END_SRC

#+RESULTS:
: on stdout

elisp:org-babel-tangle

Interestingly, we get stderr here...
#+BEGIN_SRC emacs-lisp
(shell-command-to-string "python peo.py")
#+END_SRC
#+RESULTS:
: on stderr
: on stdout



* TODO Saving state data to a file in Emacs
  :PROPERTIES:
  :categories: emacs,lisp
  :END:

I want to be able to save state data to a file from Emacs, and read it in later, possible after Emacs has been closed and re-opened. Here we document how to save the results to a file, and then later read them in. First, say we have a list containing a string, and we want to write it to disk. We will use the print function [[elisp:(describe-function 'print)]] for this. The basic strategy is to print the variable to a buffer that is written to file. Later, we can read the data in.

#+BEGIN_SRC emacs-lisp
(setq assignments '("one"))
(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| one |

Now, to read it back, we will load the file in a buffer, and then use the [[elisp:(describe-function 'read)]].

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
 (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

We can add to the list, and update the file easy enough.

#+BEGIN_SRC emacs-lisp
(add-to-list 'assignments "two")

(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

And, checking the results:

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
  (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

In the next sections, we consider saving more complex data structures.

** Saving an alist

We can save an alist

#+BEGIN_SRC emacs-lisp :results raw
(with-temp-file "state-alist.el"
  (print '(("title" . "the title")
           ("author" . "John Kitchin")
           ("email" . "jkitchin@cmu.edu"))
	 (current-buffer)))
#+END_SRC

#+RESULTS:
((title . the title) (author . John Kitchin) (email . jkitchin@cmu.edu))

And, then read it in and access data from it.

#+BEGIN_SRC emacs-lisp
(cdr (assoc "email"
	 (with-temp-buffer (insert-file-contents "state-alist.el")
	   (read (current-buffer)))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Writing and reading a plist

The print function can handle a plist.

#+BEGIN_SRC emacs-lisp
(with-temp-file "state-plist.el"
  (print '(:title   "the title"
		    :author  "John Kitchin"
		    :email   "jkitchin@cmu.edu")
	 (current-buffer)))
#+END_SRC

#+RESULTS:
| :title | the title | :author | John Kitchin | :email | jkitchin@cmu.edu |

#+BEGIN_SRC emacs-lisp
(plist-get (with-temp-buffer
	       (insert-file-contents "state-plist.el")
	     (read (current-buffer))) :author)
#+END_SRC

#+RESULTS:
: John Kitchin

** Writing and reading a hash table
We can save a hash table.

#+BEGIN_SRC emacs-lisp
(setq my-hash (make-hash-table :test 'equal))

(puthash "title" "the title" my-hash)
(puthash "author" "John Kitchin" my-hash)
(puthash "email" "jkitchin@cmu.edu" my-hash)

(with-temp-file "state-hash.el"
  (print my-hash (current-buffer)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data ("title" "the title" "author" "John Kitchin" "email" "jkitchin@cmu.edu"))

#+BEGIN_SRC emacs-lisp
(gethash "email"
	 (with-temp-buffer (insert-file-contents "state-hash.el")
	   (read (current-buffer))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Totally different approach using json
I like the symmetry of code and data in Emacs-lisp. There might be some advantages to using a structured data format other than Emacs Lisp data/code. One of them is interoperability with other programs. If there are subprograms that need to analyze the data in Python, for example. Here we consider json as a data format. We can write the data like this.

#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "this.json"
  (let ((data   '(:title   "the title"
			   :author  "John Kitchin"
			   :email   "jkitchin@cmu.edu")))
    (insert (json-encode-plist data))))
#+END_SRC

#+RESULTS:

It is simple enough to read the json data back in. Note, this reads in as an a-list by default.

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdr (assoc 'email (json-read-file "this.json")))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

To get the json read in another form, we have to temporarily define the json-object-type variable.

#+BEGIN_SRC emacs-lisp
(require 'json)
(let ((json-object-type 'plist))
  (plist-get (json-read-file "this.json") :email))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** COMMENT Saving several things in a file
I have some time to kill in an airport, so I am going to explore saving a few variable to file.

#+BEGIN_SRC emacs-lisp
(let ((x 1)
      (y 2))
  (with-temp-file "multi-values.el"
    (print x (current-buffer))
    (print y (current-buffer))))
#+END_SRC

#+RESULTS:
: 2

Now, I presume we have to do two reads to get those values back.

#+BEGIN_SRC emacs-lisp
(let (a b)
  (with-temp-buffer
    (insert-file-contents "multi-values.el")
    (setq a (read (current-buffer)))
    (setq b (read (current-buffer))))
(list a b))
#+END_SRC

#+RESULTS:
| 1 | 2 |

Indeed. That is exactly what we do. The downside of this is you must know in advance the data structure, and read it in the same way. That is reminiscent of binary data structures from Fortran or C. That probably is not too flexible to changes in data structure. For example, you can only add data to the end of the structure if you need to maintain backward compatibility.

** Summary
There are a few options for saving and reading data in different structures and formats. I did not explore very complex data structures here, e.g. deeply nested data, or different types of data within one structure. I still have not completely internalized best practices in writing/reading data. There are several approaches that all involve getting the data into a buffer. That can be done with find-file, or find-file-noselect, or with temp-buffers and insert-file-contents. I do not know which of these approaches are the best. Apparently find-file affects other things such as recent-files, and the buffer list, which may be undesirable. Emacs treats this very differently than Python, where you can simply open a file, and read it to get a string (the closest Python has to a buffer concept are related to StringIO). Interestingly, the json-read-file function uses a temp-buffer, inserts the file contents, and then reads the data. The code resembles this block:

#+BEGIN_SRC emacs-lisp
(defun read-file (file)
  "Read contents of a FILE into a string"
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-string)))

(read-file "state-alist.el")
#+END_SRC
#+RESULTS:
:
: (("title" . "the title") ("author" . "John Kitchin") ("email" . "jkitchin@cmu.edu"))



* "live" graphics in org-mode

#+tblname: tbldata
|   x |   y |
|-----+-----|
|   1 |   1 |
|   1 |   0 |
|   2 |   4 |
|   3 |   5 |
| 0.2 | 0.3 |


#+RESULTS: make-table-graph
#+BEGIN_SRC org
[[1, 1], [1, 0], [2, 4], [3, 5], [0.2, 0.3]]
[[./live-chart.png]]
#+END_SRC

** Code

#+NAME: make-table-graph
#+BEGIN_SRC python :var data=tbldata :results org
import matplotlib.pyplot as plt
plt.plot([x[0] for x in data], [x[1] for x in data])
plt.savefig('live-chart.png')
print data
print '[[./live-chart.png]]'
#+END_SRC

Now, for the elisp part.

#+BEGIN_SRC emacs-lisp
(defun update-graph ()
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "#\\+NAME: make-table-graph")
    (forward-line 2)
    (org-babel-execute-src-block)))

(defvar my-timer nil)

(setq my-timer (run-with-idle-timer
		5 ; idle for this many seconds
		t ; repeat indefinitely
		'update-graph))
#+END_SRC

#+RESULTS:
: [nil 0 5 0 t update-graph nil idle 0]

#+BEGIN_SRC emacs-lisp
(cancel-timer my-timer)
#+END_SRC
* An experiment of integrating git with save
  :PROPERTIES:
  :categories: git
  :END:
This is a little experiment to integrate saving a file with git. The idea is that every time we save, we also commit the changes. That way later we can undo changes, even after the file is closed and undo history is lost.

#+BEGIN_SRC emacs-lisp
(defun git-save-commit ()
  "Save buffer and commit it to the git repo."
  (interactive)
  (when
      (shell-command "git rev-parse --is-inside-work-tree")
    (save-buffer)

    ;; I am not sure if this works on a file nested in the repo
    (let ((f (file-relative-name
	      (buffer-file-name)
	      default-directory)))
      (shell-command (format "git add %s" f))
      (shell-command (format "git commit %s -m \"save\"" f)))))

(add-hook 'after-save-hook 'git-save-commit)

;; this runs just before autosave
(add-hook 'auto-save-hook 'git-save-commit)
#+END_SRC

#+RESULTS:
| git-save-commit | tramp-set-auto-save-file-modes |

#+BEGIN_SRC sh
git hist -n 10
#+END_SRC

* archived introspection work
some hints to get started

http://stackoverflow.com/questions/605785/how-do-i-get-a-list-of-emacs-lisp-non-interactive-functions

related code that might allow us to find all functions defined in a file with some filtering, if we find where the functions are from.

#+BEGIN_SRC emacs-lisp
(find-lisp-object-file-name 'jmax-stringify-journal-name  'defun)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(flet ((first-line (text)
         (if text
             (substring text 0 (string-match "\n" text))
           "")))
  (mapatoms
   (lambda (x)
     (and (fboundp x)                          ; does x name a function?
          (not (commandp (symbol-function x))) ; is it non-interactive?
          (subrp (symbol-function x))          ; is it built-in?
          (insert (symbol-name x) " - " (first-line (documentation x)) "\n")))))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results drawer
(let ((r '()))
      (mapatoms
       (lambda (x)
	 (add-to-list 'r
		      (find-lisp-object-file-name x 'defun)))))
#+END_SRC

#+RESULTS:
:RESULTS:
nil
:END:

(documentation 'jmax-stringify-journal-name)

(describe-key)
(describe-function)



#+BEGIN_SRC emacs-lisp
(require 'bibtools)
(let ((funclist ()))
  (mapatoms
   (lambda (x)
     (when (and (fboundp x)                     ; does x name a function?
                (let ((f (symbol-file x)))
                  (and f (string= (file-name-base f) "jmax-bibtex"))))
       (push x funclist))))
  funclist)
#+END_SRC

#+RESULTS:
| jmax-replace-nonascii | jmax-stringify-journal-name | jmax-bibtex-next-entry | jmax-title-case-article | jmax-bibtex-generate-shorttitles | jmax-bibtex-mode-keys | jmax-bibtex-generate-longtitles | jmax-bibtex-previous-entry | jmax-sentence-case-article |


#+BEGIN_SRC emacs-lisp :results code
((find-file  "../../Dropbox/kitchingroup/jmax/jmax-bibtex.el")
(imenu-default-create-index-function))
;; (imenu-choose-buffer-index))
#+END_SRC

#+RESULTS:


http://stackoverflow.com/questions/26330363/how-do-i-get-a-list-of-functions-defined-in-an-emacs-lisp-file/26360946?iemail=1&noredirect=1#26360946

#+BEGIN_SRC emacs-lisp
(cdr (assoc "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el" load-history ))
#+END_SRC

#+RESULTS:
| jmax-bibtex-journal-abbreviations | (defun . jmax-bibtex-generate-longtitles) | (defun . jmax-bibtex-generate-shorttitles) | (defun . jmax-stringify-journal-name) | (defun . jmax-set-journal-string) | jmax-nonascii-latex-replacements | (defun . jmax-replace-nonascii) | jmax-lower-case-words | (defun . jmax-title-case-article) | (defun . jmax-sentence-case-article) | (defun . jmax-bibtex-next-entry) | (defun . jmax-bibtex-previous-entry) | (defun . jmax-bibtex-mode-keys) | (provide . jmax-bibtex) |
* cycle src blocks

#+BEGIN_SRC emacs-lisp
(save-restriction
  (org-narrow-to-subtree)
  (goto-char (point-min))
  (let ((case-fold-search t))
    (while (re-search-forward "#\\+BEGIN_SRC" nil t)
      (org-cycle))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(save-excursion
  (save-restriction
    (org-narrow-to-subtree)
    (goto-char (point-min))
    (org-element-map
	(org-element-parse-buffer)
	'src-block
      (lambda (element)
	(goto-char (org-element-property :begin element))
	(org-cycle)))))
#+END_SRC

#+RESULTS:


(remove-hook 'org-cycle-hook 'org-hide-block-all)


#+BEGIN_SRC emacs-lisp
(defun my-hide (state)
  (message "%s" state)
  (if (or (eq state 'children)
	  (eq state 'subtree))
      (save-restriction
	(org-narrow-to-subtree)
	(org-hide-block-all))))

(add-hook 'org-cycle-hook 'my-hide)
#+END_SRC

#+RESULTS:
| my-hide | org-cycle-hide-archived-subtrees | org-cycle-hide-drawers | org-cycle-hide-inline-tasks | org-cycle-show-empty-lines | org-optimize-window-after-visibility-change |

** code blocks

#+BEGIN_SRC python
print 'hello'
#+END_SRC

#+BEGIN_SRC sh
echo hello
#+END_SRC

#+BEGIN_SRC emacs-lisp
(format "hello")
#+END_SRC
#+RESULTS:

** another heading
with test

* Using filters to redefine output

I have written about filters before, but admittedly, I have never fully grasped how to get all the information you need. For example, in [[http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][this post]] I came up with a convoluted method to preprocess an org-file to get a list of link properties, and then keep a running counter to access the nth property. Recently I saw this [[http://lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html][post]] on the org-mode mail list that made me think I have totally missed the boat on how to do this!

Here is the key point I have missed all along. You can apparently get the element associated with the text, and from that you can get any property of the element. Apparently, you find the next property change, and then get them. The element is stored sometimes as a text property.

file:bib1.bib

[[file:bib1.bib]]

[[./bib1.bib][bibliography]]


#+BEGIN_SRC emacs-lisp :results output
(defun ox-mrkup-filter-link (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (link (if beg (get-text-property beg :parent text))))
    (cond
     (link
      (princ (format "%s: %s\n\n\n" beg link (org-element-property :type link))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))
;; >     (cond ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "bib"))
;; >            (format "\\cite{%s}" (org-element-property :path link)))
;; >           ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "file")
;; >                 (string= (org-element-property :path link) "~/.bib.bib"))
;; >            (format "\\cite{%s}" (org-element-property :search-option link)))
;; >           (t text))))
(let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-html-export-as-html))
#+END_SRC


#+tblname: my-table
| 1 | 3 |
| 3 | 4 |

#+BEGIN_SRC emacs-lisp :results output
(defun ox-mrkup-filter-table (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (table (if beg (get-text-property beg :parent text))))
    (cond
     (table
      (princ (format "%s: %s\n\n\n" beg table (org-element-property :name table))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table)))
    (org-html-export-as-html))
#+END_SRC

#+RESULTS:
#+begin_example
198: (table-cell (:begin 2020 :end 2024 :contents-begin 2021 :contents-end 2022 :post-blank 0 :parent (table-row (:type standard :begin 2019 :end 2029 :contents-begin 2020 :contents-end 2028 :post-blank 0 :parent (table (:begin 1999 :end 2040 :type org :tblfm nil :contents-begin 2019 :contents-end 2039 :value nil :post-blank 1 :post-affiliated 2019 :name my-table :parent (section (:begin 38 :end 2530 :contents-begin 38 :contents-end 2523 :post-blank 7 :parent (headline (:raw-value Using filters to redefine output :begin 2 :end 2530 :pre-blank 1 :hiddenp nil :contents-begin 38 :contents-end 2523 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 7 :footnote-section-p nil :archivedp nil :commentedp nil :quotedp nil :CATEGORY blog :title (Using filters to redefine output) :parent (org-data nil #8)) #6)) (paragraph (:begin 38 :end 639 :contents-begin 38 :contents-end 638 :post-blank 1 :post-affiliated 38 :parent #6) I have written about filters before, but admittedly, I have never fully grasped how to get all the information you need. For example, in  (link (:type http :path //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ :raw-link http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ :application nil :search-option nil :begin 175 :end 288 :contents-begin 276 :contents-end 285 :post-blank 1 :parent #7) this post) I came up with a convoluted method to preprocess an org-file to get a list of link properties, and then keep a running counter to access the nth property. Recently I saw this  (link (:type http :path //lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html :raw-link http://lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html :application nil :search-option nil :begin 463 :end 543 :contents-begin 536 :contents-end 540 :post-blank 1 :parent #7) post) on the org-mode mail list that made me think I have totally missed the boat on how to do this!
) (paragraph (:begin 639 :end 895 :contents-begin 639 :contents-end 894 :post-blank 1 :post-affiliated 639 :parent #6) Here is the key point I have missed all along. You can apparently get the element associated with the text, and from that you can get any property of the element. Apparently, you find the next property change, and then get them. The element is stored in
) (paragraph (:begin 895 :end 910 :contents-begin 895 :contents-end 909 :post-blank 1 :post-affiliated 895 :parent #6) (link (:type file :path bib1.bib :raw-link file:bib1.bib :application nil :search-option nil :begin 895 :end 908 :contents-begin nil :contents-end nil :post-blank 0 :parent #7))
) (paragraph (:begin 910 :end 929 :contents-begin 910 :contents-end 928 :post-blank 1 :post-affiliated 910 :parent #6) (link (:type file :path bib1.bib :raw-link file:bib1.bib :application nil :search-option nil :begin 910 :end 927 :contents-begin nil :contents-end nil :post-blank 0 :parent #7))
) (paragraph (:begin 929 :end 960 :contents-begin 929 :contents-end 958 :post-blank 2 :post-affiliated 929 :parent #6) (link (:type file :path ./bib1.bib :raw-link ./bib1.bib :application nil :search-option nil :begin 929 :end 957 :contents-begin 943 :contents-end 955 :post-blank 0 :parent #7) bibliography)
) (src-block (:language emacs-lisp :switches nil :parameters nil :begin 960 :end 1999 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (defun ox-mrkup-filter-link (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (link (if beg (get-text-property beg :parent text))))
    (cond
     (link
      (princ (format "%s: %s\n\n\n" beg link (org-element-property :type link))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))
;; >     (cond ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "bib"))
;; >            (format "\\cite{%s}" (org-element-property :path link)))
;; >           ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "file")
;; >                 (string= (org-element-property :path link) "~/.bib.bib"))
;; >            (format "\\cite{%s}" (org-element-property :search-option link)))
;; >           (t text))))
(let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-html-export-as-html))
 :post-blank 2 :post-affiliated 960 :parent #6)) #4 (src-block (:language emacs-lisp :switches nil :parameters nil :begin 2040 :end 2495 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (defun ox-mrkup-filter-table (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (table (if beg (get-text-property beg :parent text))))
    (cond
     (table
      (princ (format "%s: %s\n\n\n" beg table (org-element-property :name table))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table)))
    (org-html-export-as-html))
 :post-blank 1 :post-affiliated 2040 :parent #6)) (fixed-width (:begin 2495 :end 2523 :value 198: nil


 :post-blank 0 :post-affiliated 2506 :results () :parent #6)))) #2 (table-row (:type standard :begin 2029 :end 2039 :contents-begin 2030 :contents-end 2038 :post-blank 0 :parent #4) (table-cell (:begin 2030 :end 2034 :contents-begin 2031 :contents-end 2032 :post-blank 0 :parent #5) 3) (table-cell (:begin 2034 :end 2038 :contents-begin 2035 :contents-end 2036 :post-blank 0 :parent #5) 4)))) #0 (table-cell (:begin 2024 :end 2028 :contents-begin 2025 :contents-end 2026 :post-blank 0 :parent #2) 3))) 1)


#+end_example








* redefining how images are displayed

#+BEGIN_SRC emacs-lisp
(defun org-display-inline-images (&optional include-linked refresh beg end)
  "Display inline images.
Normally only links without a description part are inlined, because this
is how it will work for export.  When INCLUDE-LINKED is set, also links
with a description part will be inlined.  This can be nice for a quick
look at those images, but it does not reflect what exported files will look
like.
When REFRESH is set, refresh existing images between BEG and END.
This will create new image displays only if necessary.
BEG and END default to the buffer boundaries."
  (interactive "P")
  (when (display-graphic-p)
    (unless refresh
      (org-remove-inline-images)
      (if (fboundp 'clear-image-cache) (clear-image-cache)))
    (save-excursion
      (save-restriction
	(widen)
	(setq beg (or beg (point-min)) end (or end (point-max)))
	(goto-char beg)
	(let ((re (concat "\\[\\[\\(\\(file:\\)\\|\\([./~]\\)\\)\\([^]\n]+?"
			  (substring (org-image-file-name-regexp) 0 -2)
			  "\\)\\]" (if include-linked "" "\\]")))
	      (case-fold-search t)
	      old file ov img type attrwidth width)
	  (while (re-search-forward re end t)
	    (setq old (get-char-property-and-overlay (match-beginning 1)
						     'org-image-overlay)
		  file (expand-file-name
			(concat (or (match-string 3) "") (match-string 4))))
	    (when (image-type-available-p 'imagemagick)
	      (setq attrwidth (if (or (listp org-image-actual-width)
				      (null org-image-actual-width))
				  (save-excursion
				    (save-match-data
				      (when (re-search-backward
;; I modified this regexp
					     "#\\+attr.*:width[ \t]+\\([0-9]+\\)\\(in\\|px\\|cm\\)"
					     (save-excursion
					       (re-search-backward "^[ \t]*$\\|\\`" nil t)) t)
;; and here, if we catch units, we fall back on org-image-actual-width
;; by setting attrwidth to nil
					(if (match-string 2) nil
					  (string-to-number (match-string 1)))))))
		    width (cond ((eq org-image-actual-width t) nil)
				((null org-image-actual-width) attrwidth)
				((numberp org-image-actual-width)
				 org-image-actual-width)
				((listp org-image-actual-width)
				 (or attrwidth (car org-image-actual-width))))
		    type (if width 'imagemagick)))
	    (when (file-exists-p file)
	      (if (and (car-safe old) refresh)
		  (image-refresh (overlay-get (cdr old) 'display))
		(setq img (save-match-data (create-image file type nil :width width)))
		(when img
		  (setq ov (make-overlay (match-beginning 0) (match-end 0)))
		  (overlay-put ov 'display img)
		  (overlay-put ov 'face 'default)
		  (overlay-put ov 'org-image-overlay t)
		  (overlay-put ov 'modification-hooks
			       (list 'org-display-inline-remove-overlay))
		  (push ov org-inline-image-overlays))))))))))
#+END_SRC

#+RESULTS:
: org-display-inline-images
:

#+attr_latex: :width 4in :placement [H]
#+ATTR_org: :width 200
[[./images/batch-multiple.png]]

elisp:org-display-inline-images
* org-mode and Perl

https://metacpan.org/pod/GD::Graph#EXAMPLES

#+BEGIN_SRC perl
load GD::Graph;
@data = (
  ["1st","2nd","3rd","4th","5th","6th","7th", "8th", "9th"],
  [    1,    2,    5,    6,    3,  1.5,    1,     3,     4],
  [ sort { $a <=> $b } (1, 2, 5, 6, 3, 1.5, 1, 3, 4) ]
);

my $graph = GD::Graph::chart->new(400, 300);

$graph->set(
    x_label           => 'X Label',
    y_label           => 'Y label',
    title             => 'Some simple graph',
    y_max_value       => 8,
    y_tick_number     => 8,
    y_label_skip      => 2
) or die $graph->error;

my $gd = $graph->plot(\@data) or die $graph->error;
#+END_SRC

#+RESULTS:
* Scripting git
I am running a project where I need to script git to "do the right thing" non-interactively. The project involves students creating assignments, and then turning them in. They create the assignments in Emacs+org-mode, and then "turn in" the assignment by running a menu command that commits their work to a git repository, and then pushes it to my server. Some emacs-lisp code does all this magic. Most of the time.

Occasionally, students have had trouble when it comes time to update their graded assignments. These assignments have been pulled from the server by me, graded, and pushed back. I did not anticipate that students would continue changing their local repos after turning the work in, and this causes issues when they try to pull the results back.

Here I document how to make this process a bit more robust. Basically, we need to make sure the local repo is clean before we pull, then we need to check if there were merge conflicts. Since the conflicts are probably notes the students took, we will be conservative and just accept the merge markers in the text so they do not lose their notes.

What we need to do is check the output of "git status --porcelain" and do an appropriate action for each file. The output of this command is one line per file that requires some action. Basically we can have untracked files, which should just be added and committed. The reason for this is that if I create a file with the same name, it will be a conflict for git to overwrite their existing file. There could be added or modified files, renamed files, deleted files  updated but unmerged, and some other possibilities too.

The "git status --porcelain" command gives a two letter status code for each file that is not "clean". The first letter is the status of the index, and the second letter is the status of the work-tree, unless there is a merge conflict, and then they are the status of the file on each side of the merge.

#+BEGIN_EXAMPLE
       o   ' ' = unmodified

       o    M = modified

       o    A = added

       o    D = deleted

       o    R = renamed

       o    C = copied

       o    U = updated but unmerged

       Ignored files are not listed, unless --ignored option is in effect, in
       which case XY are !!.

           X          Y     Meaning
           -------------------------------------------------
                     [MD]   not updated
           M        [ MD]   updated in index
           A        [ MD]   added to index
           D         [ M]   deleted from index
           R        [ MD]   renamed in index
           C        [ MD]   copied in index
           [MARC]           index and work tree matches
           [ MARC]     M    work tree changed since index
           [ MARC]     D    deleted in work tree
           -------------------------------------------------
           D           D    unmerged, both deleted
           A           U    unmerged, added by us
           U           D    unmerged, deleted by them
           U           A    unmerged, added by them
           D           U    unmerged, deleted by us
           A           A    unmerged, both added
           U           U    unmerged, both modified
           -------------------------------------------------
           ?           ?    untracked
           !           !    ignored
           -------------------------------------------------
#+END_EXAMPLE

The man page recommends we use the -z option for parsing which ends strings with a null character.
#+BEGIN_SRC sh :dir ~/Desktop/A
git status --porcelain
#+END_SRC

#+RESULTS:
: R  f1 -> f1-rname
:  D f2
: ?? f2-rname


It seems like we need to parse the porcelain command, get X, and Y, and depending on what those are, we have a set of cond statements to act appropriately.


Here is a function to parse a line of porcelain output.
#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results raw
(defun parse-line (line)
  (let* ((X (substring line 0 1))
	 (Y (substring line 1 2))
	 (PATHS (split-string (substring line 3)))
	 (PATH1 (nth 0 PATHS))
         ; for a rename there will be PATH1 -> PATH2
	 (PATH2 (if (= 3 (length PATHS)) (nth 2 PATHS) nil)))
    (list X Y PATH1 PATH2 line)))

(defun parse-git-status ()
 (interactive)
(loop for line in (split-string
		  (shell-command-to-string "git status --porcelain") "\n")
      when (not (string= "" line)) collect (parse-line line)))
#+END_SRC

Now we check out the results.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| R |   | f1       | f1-rname | R  f1 -> f1-rname |
|   | D | f2       | nil      | D f2              |
| ? | ? | f2-rname | nil      | ?? f2-rname       |

That function gives us a list of X, Y, FROM, and TO, and the original string.

Now, we can start building the logic to handle these. The goal of this block as after running, the repo is clean, and you can then pull into it.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results output
(let ((merge-p nil))
  (loop for (X Y FROM TO LINE) in (parse-git-status)
	do
	(cond
	 ;; untracked files get added and committed.
	 ((and (string= X "?")
	       (string= Y "?"))
	  (shell-command (format "git add %s" FROM))
	  (shell-command
	   (format "git commit %s \"adding %s.\""
		   FROM FROM)))

	 ;; user rename
	 ((and (string= X "R")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO)))

	 ;; rename and modify
	 ((and (string= X "R")
	       (string= Y "M"))
	  ;; commit the rename
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO))
	  (shell-command (format "git commit %s -m \"changes in %s\"" TO TO)))

	 ;; added file
	 ((and (string= X "A")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m  \"Adding %s\"" FROM FROM)))

	 ;; deleted file
	 ((and (string= X " ")
	       (string= Y "D"))
	  (shell-command (format "git commit %s -m \"Deleting %s\"" FROM FROM)))

	 ;; modified file
	 ((or (string= X "M")
	      (string= Y "M"))
          (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"changes in %s\"" FROM FROM)))

	 ;; merge conflict, we just add the file
	 ;; we do not commit here because you cannot partially commit.
	 ;; after the loop, we do the commit if merge-p is t
	 ((or (string= X "U")
	      (string= Y "U"))
	  (setq merge-p t)
	  (shell-command (format "git add %s" FROM)))

	 ;; catch everything else
	 (t
	  (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"%s\"" FROM LINE))
	  (message "%s not handled gracefully\n" LINE))))
  ;;
  (when merge-p
    (shell-command "git commit -m \"accepting merge\"")))
#+END_SRC
#+RESULTS:


#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| M |   | empty | nil | M  empty |




* Showing that Emacs is working


#+name: my-code
#+BEGIN_SRC python
import numpy
print 5
#+END_SRC

#+RESULTS: my-code
: 5

#+RESULTS:
: 5

This does not work, because there is no way to update the reporter while the code block is running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (let ((pr (make-progress-reporter "Running")))
    ad-do-it
    (progress-reporter-done pr)))
#+END_SRC


Here we create a buffer that indicates what is running
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((code-block (org-element-property :name (org-element-at-point)))
        (LN (line-number-at-pos)))

    (split-window-below)
    (other-window 1)
    (switch-to-buffer "*My Babel*")
    (if code-block
	(insert (format "Running %s\n" code-block))
      (insert (format "Running block at line %s\n" LN)))
    (insert "Started at: " (current-time-string) "\n")
    (other-window 1)
    ad-do-it
    (kill-buffer "*My Babel*")
    (delete-other-windows)))
#+END_SRC

#+BEGIN_SRC python
import time
time.sleep(5)
print 5
#+END_SRC

#+RESULTS:
: 5



Here we change the color of the codeblocks when they are running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (set-face-attribute 'org-block-background nil :background "LightSteelBlue")
  ad-do-it
  (set-face-attribute 'org-block-background nil :background "gray")
(message "Done with code block"))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

Try using an overlay
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((ol (make-overlay (org-element-property :begin (org-element-at-point))
			  (org-element-property :end (org-element-at-point)))))

    (overlay-put ol 'face '(foreground-color . "blue"))

    ad-do-it

    (delete-overlay ol)))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

* Checking if processes are done

#+BEGIN_SRC emacs-lisp
(setq my-process (start-process-shell-command "slp" "*sleep*" "sleep 30"))
#+END_SRC

#+RESULTS:
: #<process slp>

#+BEGIN_SRC emacs-lisp
(process-live-p my-process)
#+END_SRC

#+RESULTS:


Now we try for a set of processes.

#+BEGIN_SRC emacs-lisp
(setq my-processes
      (mapcar
       (lambda (x)
	 (start-process-shell-command "slp" "*sleep*"
				      (format "sleep %s" (random 10))))
       '(1 2)))
#+END_SRC

#+RESULTS:
| slp | slp<1> |

And now check if they are all done.

#+BEGIN_SRC emacs-lisp :results raw
(mapcar (lambda (process) (process-live-p process)) my-processes)
#+END_SRC

#+RESULTS:
((run open listen connect stop) (run open listen connect stop))

This will tell us if any process is still alive.

#+BEGIN_SRC emacs-lisp :results raw
(-any-p 'process-live-p  my-processes))
#+END_SRC

#+RESULTS:
nil
nil
t
t


* Insert a timestamp that is one week older than the last timestamp found
Someone on the maillist asked how to insert a new timestamp that is one week newer than the last timestamp found in the buffer. Here is an exploration of doing that.
** week 1 (<2014-08-25 Mon>)

** week 2 (<2014-09-01 Mon 13:00>)

** Getting the last timestamp

Here we assume that the last element from org-element-map is the last timestamp found. We get the raw value of that timestamp, insert it, and then use interactive commands to change the timestamp.
#+BEGIN_SRC emacs-lisp
(defun insert-ts+1w ()
  "Insert a timestamp at point that is one week later than the
last timestamp found in the buffer."
  (interactive)
  (let ((last-ts (car (last (org-element-map (org-element-parse-buffer) 'timestamp
			      (lambda (timestamp)
				(org-element-property :raw-value timestamp)))))))
    (insert last-ts)
    (backward-char 2)
    (org-timestamp-change +7 'day)
    ))
#+END_SRC


This is the result I got from running the command I wrote above. <2014-09-08 Mon 13:00>. It worked!
* insert pages in org-ref

if you use C-c C-l, you can use completion to enter the bibtex key, and then type the page in the description. That is handy if you do not need to search for the entry.

#+BEGIN_SRC emacs-lisp
(defun cite-with-pages (key page)
  (interactive
   (list
    (car (reftex-citation t))
    (read-from-minibuffer "page: ")))
  (insert (format "[[cite:%s][page %s]]" key page)))
#+END_SRC

[[cite:armiento-2014-high][page 34]]


bibliography:../../bibliography/references.bib

* Insert formatted text
We can insert propertized strings, e.g. with different colors like this.
#+BEGIN_SRC emacs-lisp

(with-temp-buffer
  (rename-buffer "test")
  (insert "a "
	  (propertize "mail client"
		      'font-lock-face
		      '(:foreground "blue" :background "white" :underline t))
	  " b "
	  (propertize "smtp" 'font-lock-face '(:foreground "red"))
	  " "
	  (propertize "smtp" 'font-lock-face '(:foreground "forestgreen")))
  (goto-char (point-min))
  (display-buffer (current-buffer))
  (org-mode)
  ;; this just pauses long enough to see the results
  (completing-read "what? " '(1 2 3)))
#+END_SRC

#+RESULTS:
: 1

* Selectively writing out code blocks in org-mode

I have a set of notes for two software packages that contain code examples for each package. I want to selectively extract the code blocks. This post examines a way I could do that. I am going to "tag" each code block with a header. Apparently this is ok, and org-mode ignores the unknown header argument!

#+BEGIN_SRC python :tag package1
print "For use with package1"
#+END_SRC

#+RESULTS:
: For use with package1

#+BEGIN_SRC python :tag package2
print "For use with package2"
#+END_SRC

#+RESULTS:
: For use with package2

Apparently, the :tag header argument is stored in the :parameters property as a string.

#+BEGIN_SRC emacs-lisp :results raw
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element) (org-element-property :parameters element)))
#+END_SRC
#+RESULTS:
(:tag package1 :tag package2 :results raw)

So, we just need to map the source blocks, and perform some action on the ones matching the block we want. Here is one example.

#+BEGIN_SRC emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element)
    (let ((tag (org-element-property :parameters element)))
      (cond
       ((null tag) "no parameters")
       ((string-match ":tag\\s-*package1" tag)
	(format "match p1. code:\n%s" (org-element-property :value element)))
       ((string-match ":tag\\s-*package2" tag)
	(format "match p2. code:\n%s" (org-element-property :value element)))
       (t (format "\"%s\"" tag))))))
#+END_SRC

#+RESULTS:
| match p1. code:\nprint "For use with package1"\n | match p2. code:\nprint "For use with package2"\n | ":results raw" | no parameters |


* Do you have an ssh pubkey?

#+BEGIN_SRC emacs-lisp
(file-exists-p (expand-file-name "~/.ssh/id_rsa.pub"))
#+END_SRC

#+RESULTS:
: t

Make a key with no password in test.pub
#+BEGIN_SRC sh
ssh-keygen -f test -N ""
#+END_SRC

* Write and read json in emacs

If you know your data type, you can get a json representation like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/06-364.log"))))
  (json-encode-alist data))
#+END_SRC

#+RESULTS:
: {"org-course":"c:\/Users\/jkitchin\/Dropbox\/blogofile-jkitchin.github.com\/_blog\/06-364.log"}

You write a file like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "data.json"
  (let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")
		("06625" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com"))))
    (insert (json-encode-alist data))))
#+END_SRC

#+RESULTS:

Now to read it:

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdar (json-read-file "data.json"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com

We also need to conveniently set and change data. We can use setf for this. setf is a generalized version of setq that can take a "place" to set a value to. A "place" can be defined by a cdr, or car, for example. Here is a working example.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((data '(("org-course" . (("userid" . "jkitchin")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")))
	      ("06625" . (("userid" . "somestudent")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com")))))
      (course))
  (setq course (cdr (assoc "org-course" data))) ;; settings for a course

  (setf (cdr (assoc "root" course)) "blog")
data)

#+END_SRC

#+RESULTS:
((org-course (userid . jkitchin) (root . blog)) (06625 (userid . somestudent) (root . c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com)))



* automatic inlining a plot in org-mode with python

It has always bothered me that I have to manually put links to figures in after my code blocks, or I have to custom print org syntax. here is a way to get org to do it.
#+BEGIN_SRC python :file test.png
import matplotlib.pyplot as plt
plt.plot([1,2,3,4])
plt.savefig('silly-plot.png')

import os
os.system('cat silly-plot.png')
#+END_SRC

#+RESULTS:
[[file:test.png]]

It is not better if you have add the code at the end to output the image.


* org-rubric functions

prototype idea to create a rubric function

#+BEGIN_SRC emacs-lisp
(defun ta-rubric-hwk (technical-grade presentation-grade typography-grade)
  (interactive "nTechnical Grade: \nnPresentation Grade: \nnTypography Grade: ")
  (let
      ((t-weight 0.7) ; weight of technical grade
       (p-weight 0.2) ; weight of presentation grade
       (y-weight 0.1) ; weight of typography grade
       (grade))
    (setq grade (+
		 (* t-weight technical-grade)
		 (* p-weight presentation-grade)
		 (* y-weight typography-grade)))
    (end-of-buffer)
    (insert "\n"
	    (format "#+TECHNICAL_GRADE: %s\n" technical-grade)
	    (format "#+PRESENTATION_GRADE: %s\n" presentation-grade)
	    (format "#+TYPOGRAPHY_GRADE: %s\n" typography-grade)
	    (format "#+GRADE: %s" grade))))
#+END_SRC

#+RESULTS:
: ta-rubric-hwk

Maybe I can add a rubric keyword to assignments so that the right rubric function is called.
* Use org-agenda to select multiple items

This is a hacky way to use the org-contacts agenda to get multiple email addresses from a selection. We remap the return key function to call our function that maps over the selected list and gets the emails from it, and finally undoes the remapping before quitting the agenda. It feels a little hacky because you have to communicate through global variable, and the agenda call is not blocking, so the code carries on. I am not sure how to fix that.

#+BEGIN_SRC emacs-lisp
(defun get-marked ()
 (interactive)
 (setq *marked-entries*
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries)
       *done* t)
 ;; remap key
 (define-key org-agenda-mode-map [remap org-agenda-switch-to] nil)
 (org-agenda-quit))

(defun doit ()
  (interactive)
  (setq *marked-entries* nil
        *done* nil) ; make sure this is empty
  ;;remap so return exits and runs our function above
  (define-key org-agenda-mode-map [remap org-agenda-switch-to] 'get-marked)
  (org-contacts "kit")

  *marked-entries*)
#+END_SRC

This works ok. You can define a function that acts upon the marked entries.
#+BEGIN_SRC emacs-lisp
(defun email-marked ()
 (setq *marked-entries*
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries))
  (compose-mail)
  (message-goto-to)
  (insert (mapconcat 'identity *marked-entries* ",")))

  (org-contacts "kit")
#+END_SRC

* Completion in emacs commands using ido

These are some examples of using ido to provide completion in interactive commands. You just need a list of options, which can be calculated if desired, and the ido-completing-read function. You use these in the interactive function.

** string completion

#+BEGIN_SRC emacs-lisp
(defun email-1 (address)
  (interactive
   (list
    (ido-completing-read
     "Email: "     ; prompt
     '("em1" "em2" "em3") ; choices
     nil ; predicate; ignored, here for compatibility with completing-read
     t ; require match
     )))
  (message "you picked %s" address))
#+END_SRC

#+RESULTS:
: email-1

It is pretty easy to get two arguments.
#+BEGIN_SRC emacs-lisp
(defun email-2 (address label)
  (interactive (list (ido-completing-read "Email: " '("em1" "em2" "em3"))
		     (ido-completing-read "label: " '("important" "easy"))))
  (message "you picked %s with a label of %s" address label))
#+END_SRC

#+RESULTS:
: email-2

** select directories

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun pick-dir (dir)
  (interactive
   (list
    (ido-completing-read
     "Dir: "
     (remove-if-not
      'file-directory-p
      ;; list directories, except for . and ..
      (directory-files default-directory nil "[^.{1,2}]")))))
 (message "you picked this dir: %s" dir))

#+END_SRC

#+RESULTS:
: pick-dir




* put properties on strings

(put-text-property


#+BEGIN_SRC emacs-lisp
   (let ((s "Alex"))
      (put-text-property 0 (length s) 'font-lock-face '(:foreground "blue" :background "white" :underline t) s)
      (message-box s))
#+END_SRC

#+RESULTS:
: Alex

   (let ((s "Alex"))
      (put-text-property 0 (length s) 'face 'diary s)
      (insert s))Alex

finish
#+BEGIN_SRC emacs-lisp
(defun func (a b)
 (interactive (list '("a" "b") '(1 2)))
 (message "%s %s" a b))

#+END_SRC
* TODO get sha1 of a file

use this to make reproducible temp images for org-show.

(secure-hash 'sha1 (with-temp-buffer (insert-file-contents "tst.png") (buffer-string)))


* Running commands in emacs and showing what they do

I sometimes need to script shell commands into emacs functions. Recently, I needed to see the output, to see what was going wrong. This code sort of does that.

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "git status")
(eshell-send-input)
#+END_SRC

#+RESULTS:
: #<marker at 361206 in blog.org>

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "ls")
(eshell-send-input)
(insert "echo $?")
(eshell-send-input)
#+END_SRC

#+RESULTS:

* Running git commands that are interactive

** commands that freeze emacs because of ssh
Vanilla git calls vanilla ssh, which appears to hang anytime you get prompted for /anything/. The following all seems to hang, and you have to kill the ssh process to get control back.
#+BEGIN_SRC emacs-lisp
(shell-command "git clone bad@techela.cheme.cmu.edu:none")
#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(shell-command "git --no-pager clone bad@techela.cheme.cmu.edu:none")
#+END_SRC

#+RESULTS:
: 128

#+BEGIN_SRC emacs-lisp

(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none")

#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(with-timeout (1)
(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none"))

#+END_SRC


Let's try that in Python. This also freezes
#+BEGIN_SRC python
import subprocess
print subprocess.call(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], shell=True)
#+END_SRC

#+RESULTS:
: 128

** Solution, is ssh batch mode
The key is modifying the ssh command so that it runs in batch mode. You have to create a custom shell script that runs ssh in batch mode, then set GIT_SSH as an environment variable to use it.

Here is the working script.
#+BEGIN_SRC sh :tangle techela_ssh
#!/bin/sh
exec ssh -o "BatchMode yes" "$@"
#end
#+END_SRC

This will not hang.
#+BEGIN_SRC sh
./techela_ssh bad@techela.cheme.cmu.edu
#+END_SRC

#+RESULTS:

Running in sh
#+BEGIN_SRC sh
rm -fr none # rm old dir
GIT_SSH='c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh' git clone bad@techela.cheme.cmu.edu:none
#+END_SRC

#+RESULTS:


Running in Python
#+BEGIN_SRC python
import subprocess, os
my_env = os.environ.copy()
my_env['GIT_SSH'] = 'c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh'
p = subprocess.Popen(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], env=my_env)
print p.communicate()
#+END_SRC

#+RESULTS:
: (None, None)


And finally, running in emacs-lisp
#+BEGIN_SRC emacs-lisp
(let ((process-environment (cons "GIT_SSH=c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh" process-environment)))
  (shell-command-to-string "git clone bad@techela.cheme.cmu.edu:none"))
#+END_SRC

#+RESULTS:
: Cloning into 'none'...
: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
: fatal: Could not read from remote repository.
:
: Please make sure you have the correct access rights
: and the repository exists.

Finally, it appears I have a solution for this.





* Running the whole course through emacs and org-mode

I can write a command that retrieves a repo and opens it. and submits it to the server.

M-x oc-get label
This will check for label, and clone it if needed

#+BEGIN_SRC emacs-lisp
(defun oc-get (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
    (format "git clone gitolite@git-it.cheme.cmu.edu:%s" repo))))

(oc-get "hwk1")
#+END_SRC

#+RESULTS:
: git clone gitolite@git-it.cheme.cmu.edu:06-625-jkitchin-hwk1

We need to be able to update a repo. This will be tricky I think, because if students have made changes, this will not work without merges. It may be possible to commit their changes first, and then just deal with merges, but I think that will be confusing.

#+BEGIN_SRC emacs-lisp
(defun oc-update (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
   (oc-get label)) ;; first get it.

 (let (default-directory repo)
   (format "git pull"))))

#+END_SRC

M-x oc-turn-in

add everything in the directory,  commit it, and push the repo. It looks something like this:

#+BEGIN_SRC emacs-lisp
(defun oc-turn-in ()
  "Run this with the assignment open or in assignment directory"
  (interactive)
  ;; should check that we are in a git repo.

  (shell-command "git add *")
  (shell-command "git commit -am \"done\"")
  (shell-command "git push"))
#+END_SRC

What happens if students delete files?

see http://stackoverflow.com/questions/3258243/git-check-if-pull-needed for some ways to test if pull is needed.

* Getting system information and storing it in an org-mode Drawer



#+BEGIN_SRC emacs-lisp
(system-name)
#+END_SRC

#+RESULTS:
: KITCHINX61TABLE

#+BEGIN_SRC emacs-lisp
(princ system-configuration)
#+END_SRC

#+RESULTS:
: i386-mingw-nt6.1.7601


#+BEGIN_SRC emacs-lisp
(princ system-type)
#+END_SRC

#+RESULTS:
: windows-nt


#+BEGIN_SRC emacs-lisp
(shell-command-to-string ifconfig-program)
#+END_SRC

#+RESULTS:
#+begin_example

Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
#+end_example

System info function
#+BEGIN_SRC emacs-lisp
(defun insert-system-info-drawer ()
 (interactive)
 (end-of-buffer)
 (insert "\n\n")
 (org-insert-drawer nil "LOGBOOK")
 (insert (format "Name: %s\n" user-full-name))
 (insert (format "Email: %s\n" user-mail-address))
 (insert "System name: " (system-name))
 (insert (format "\n%s" system-type))
 (insert (shell-command-to-string ifconfig-program)))
#+END_SRC

#+RESULTS:
: insert-system-info-drawer
:

cite:armiento-2014-high

:LOGBOOK:
John Kitchin
jkitchin@andrew.cmu.edu
System name: KITCHINX61TABLEwindows-nt
Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

:END:

* Making a bunch of words invisible

(org-map-entries (lambda ()
                   (let ((level (org-entry-get (point) "level"))
                          (symbol-level))
                     (when level
                       (setq symbol-level (intern level))
                       (org-mark-subtree)
                       (overlay-put (make-overlay (point) (mark))
                                    'invisible
                                    symbol-level)
                       ;; make regions with symbol-level invisible
                       (add-to-invisibility-spec `(,symbol-level))))))
#+BEGIN_SRC emacs-lisp
(while (re-search-forward ":slide:" nil t)
(overlay-put (make-overlay (match-beginning 0) (match-end 0))
                                    'invisible
                                    'slide))

(add-to-invisibility-spec 'slide)
#+END_SRC
 :slide: in the text


Later when you want them back,

#+BEGIN_SRC emacs-lisp :results silent
(remove-from-invisibility-spec 'slide)
#+END_SRC

We also may want to have slide numbers, and an ability to jump to a slide.

Let us start by getting a list of slides. Our list will be cons cells with a slide number and marker. That will give us the

#+BEGIN_SRC emacs-lisp
(let ((slides '()) (n 0))
  (org-map-entries
   (lambda ()
     (when (string-match-p ":slide:" (or (nth 5 (org-heading-components)) ""))
       (setq n (+ n 1))
       (add-to-list 'slides (cons n (set-marker (make-marker) (point))) t))))
(goto-char (cdr (assoc 2 slides)))
slides)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1580 in blog.org>) | (2 . #<marker at 1603 in blog.org>) |

** subheading :slide:

** next one :slide:


* Inherited properties
example of getting an inherited property, in this case an email address
** student 1
   :PROPERTIES:
   :END:
*** lesson 1
    :PROPERTIES:
    :SENT-ON:  Sun Jun  8 20:43:16 2014
    :TO:       John Kitchin <jkitchin@andrew.cmu.edu>
    :END:
we just turn on inheritance in the property get function.
#+BEGIN_SRC emacs-lisp
(org-entry-get (point) "TO" t)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1693 in blog.org>) | (2 . #<marker at 1716 in blog.org>) |

check out https://github.com/jwiegley/emacs-async/blob/master/async.el
for asynchronous things.

* Setting up gnus for email
I have used gmail for a long time. There is a lot I like about it. Email for me is information that comes to me that I need to read, handle in some way, and then move on to the next thing. I do not store things in email, and I do not file or tag emails; I rely on gmail's search ability to find email if I ever need to (which I find is very rare). I aim for a zero-inbox with email, because that means there is nothing there I need to handle.

My typical workflow is to open my inbox, and read the new mails. If I can delete them immediately, I do that. If I can respond immediately, I do that and archive the email. If I need some time to reply, I store a link to the email in my todo list with a deadline (in org-mode, of course), and archive the email. If it will only be a day or so until I can reply, I sometimes leave it in my inbox and reply later. This works pretty well, and I usually have less than one screen of emails at any given time.

I have wanted to read email in emacs for a long time, because it would streamline the storing of links to emails, and I would not have to switch between firefox and emacs to do that. It would also make writing emails simpler for me. I already use gnus to read some newsgroups, so I want to also start reading email in it. gnus has some different ideas about mail, so I am trying to learn how to make it do what I want. By default, gnus only shows unread messages. I need it to show me all the messages in the inbox.

I also want some communication between gnus and gmail. If I delete a mail in gnus, I want it deleted in gmail. If I archive it in gnus, I want it archived in gmail. And, I want the send+archive behavior I like in gmail to work in gnus.

| open email               | RET     |
| reply                    |         |
| reply-all                |         |
| forward                  |         |
| send                     | C-c C-c |
| send and archive         |         |
| delete mail              |         |
| archive mail             |         |
| mark unread              | M-u     |
| capture mail in org-mode | C-c c e |


** Sending email

[[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-send-and-exit%20(&optional%20arg)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-send-and-exit (&optional arg)]]

It looks like you can define these actions
message-exit-actions [[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defvar%20message-exit-actions%20nil][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defvar message-exit-actions nil]]

(defvar message-exit-actions nil
  "A list of actions to be performed upon exiting after sending a message.")

This looks like a list of functions that are called with no argument after the message is sent. see [[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-do-actions%20(actions)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-do-actions (actions)]]

see [[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/simple.el::(defun%20compose-mail%20(&optional%20to%20subject%20other-headers%20continue][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/simple.el::(defun compose-mail (&optional to subject other-headers continue]] to see how to specify actions from compose-mail.

maybe it is possible to temporarily define a function to run. see http://www.gnu.org/software/emacs/manual/html_node/message/Message-Actions.html

[[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-add-action%20(action%20&rest%20types)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-add-action (action &rest types)]]
[[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-delete-action%20(action%20&rest%20types)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-delete-action (action &rest types)]]
we need a temporary action! something like: http://www.chemie.fu-berlin.de/chemnet/use/info/elisp/elisp_13.html

  (apply 'message-add-action 'gt (list 'exit))
#+BEGIN_SRC emacs-lisp
(defmacro with-temp-message-action (action types &rest body)
  "temporarily have action for a message.
action is the same as the message-add-action definition
types is a list of 'exit 'postpone 'kill
body is the code to use in the temporary definition.
"
  (apply 'message-add-action action types)
  ,@body
  (apply 'message-delete action types))

(with-temp-message-action 'gt '(list 'exit)
			  (message "we workd"))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun gt () (message "whoo"))
(add-to-list 'message-exit-actions 'gt)

(compose-mail "jkitchin@cmu.edu" "test")
#+END_SRC

#+RESULTS:
: t

we also have message-sent-hookand message-send-hook

let us try a variation with that:

#+BEGIN_SRC emacs-lisp
(defun org-contacts-gnus-article-to-get-marker ()
  "Return a marker for a contact based on From."
  (let* ((address (mail-extract-address-components
         (or (mail-fetch-field "To") "")))
         (name (car address))
         (email (cadr address)))
    (when email
    (cadar (or (org-contacts-filter
                nil
		nil
                (cons org-contacts-email-property (concat "\\b" (regexp-quote email) "\\b")))
               (when name
                 (org-contacts-filter
                  (concat "^" name "$"))))))))


(defun org-contacts-gnus-store-last-sent-mail ()
  "Store a link between mails and contacts.

This function should be called from `message-send-hook'."
(interactive)
  (let ((marker (org-contacts-gnus-article-to-get-marker)))
    (when marker
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
	  (org-set-property "LAST_SENT_MAIL" (current-time-string)))))))

(add-hook 'message-send-hook 'org-contacts-gnus-store-last-sent-mail)
#+END_SRC

#+RESULTS:
| org-contacts-gnus-store-last-sent-mail |

* extracting an org-contact from a gnus message
** getting it in the From field

try to get name from mail
#+BEGIN_SRC emacs-lisp
(defun gne ()
  (interactive)
  (if (org-contacts-gnus-article-from-get-marker)
      (message "you have that contact")
    (message "%s" (org-contacts-gnus-get-name-email))))
#+END_SRC

#+RESULTS:
: gne

try sticking entry in. you run this from a gnus article. should this happen automatically? we should
#+BEGIN_SRC emacs-lisp
(defun hare ()
  (interactive)
(let ((org-contacts-files '("test-contacts.org")))

  (let* ((r (org-contacts-gnus-get-name-email))
	 (name (nth 0 r))
	 (email (nth 1 r)))
    (find-file "test-contacts.org")
    (end-of-buffer)
    (insert (format "\n* %s" name))
    (org-entry-put (point) "EMAIL" email)
    (org-entry-put (point) "CREATED" (current-time-string))
    (save-buffer))))
#+END_SRC

#+RESULTS:
: hare

#+BEGIN_SRC emacs-lisp

#+END_SRC

* getting emails in org-contacts by tags
#+BEGIN_SRC emacs-lisp
(find-file "contacts-bbdb.org")
(let ((todo-only nil))
  (org-scan-tags
   (lambda ()
     (org-entry-get (point) "EMAIL")) ; action
  (cdr (org-make-tags-matcher "group-ms")) ; matcher
nil))
#+END_SRC

#+RESULTS:
| jboes@cmu.edu | mehakc@andrew.cmu.edu | mcurnan@andrew.cmu.edu | qingqif@andrew.cmu.edu | ahallenb@andrew.cmu.edu | jdmichae@andrew.cmu.edu | zhongnanxu@cmu.edu |


#+BEGIN_SRC emacs-lisp :results raw
(find-file "contacts-bbdb.org")
(let ((todo-only nil))
   (cdr (org-make-tags-matcher "group-phd")))
#+END_SRC

#+RESULTS:
(and (progn (setq org-cached-props nil) (and (not (member phd tags-list)) (member group tags-list))) t)


#+BEGIN_SRC emacs-lisp
(defun insert-emails-from-tags (tags)
  (interactive "sTags: ")
  (insert
   (save-window-excursion
     (find-file "contacts-bbdb.org")
     (mapconcat
      'identity
      (let ((todo-only nil))
	(org-scan-tags
	 (lambda ()
	   (org-entry-get (point) "EMAIL")) ; action
	 (cdr (org-make-tags-matcher tags)) ; matcher
	 nil)) ", "))))
#+END_SRC

#+RESULTS:
: add-emails-from-tags

ngovinda@andrew.cmu.edu,meihengl@andrew.cmu.edu,wenqiny@andrew.cmu.edu

#+BEGIN_SRC emacs-lisp
(insert-emails-from-tags "{^co.*}") ;no return
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(insert-emails-from-tags "FIRSTNAME=\"John\"") ; no matches
#+END_SRC

#+RESULTS:


* Calculating months since a date

To calculate the number of months between two dates, we parse the dates to get the year for each date, and the month for each date. Then we calculate the number of months as:

\[12 * (year2 - year1) + (month2 - month1)\]

To get the year,

#+BEGIN_SRC emacs-lisp
(nth 5 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 2014

Now the month:
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 5

Note this subtlety
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat>")))
#+END_SRC

#+RESULTS:
: 2

It appears that since no time is specified, this gets parsed as the 28th of Feb? Maybe that is a limitation of the date format in Emacs?
#+BEGIN_SRC emacs-lisp
(decode-time (date-to-time "<2014-03-01 Sat>"))
#+END_SRC

#+RESULTS:
| 0 | 0 | 19 | 28 | 2 | 2014 | 5 | nil | -18000 |

We get the right value if we specify the time.

#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat 00:01>")))
#+END_SRC

#+RESULTS:
: 3

And now for the number of months between two times

#+BEGIN_SRC emacs-lisp
(let* ((d1  (decode-time (date-to-time "2014-03-01 00:01")))
       (d2 (decode-time (date-to-time "2014-05-31  00:01")))
       (y1 (nth 5 d1))
       (y2 (nth 5 d2))
       (m1 (nth 4 d1))
       (m2 (nth 4 d2)))
  (+ (* 12 (- y2 y1)) (- m2  m1)))
#+END_SRC

#+RESULTS:
: 2


* Converting bbdb to org-contacts

#+BEGIN_SRC emacs-lisp :results output
(let ((b (find-file "../../kitchingroup/jmax/user/bbdb"))
      (count 0) (entry)(fname)(lname)(email))
  (find-file "contacts-bbdb.org")
  (erase-buffer)
  (insert "* setup")
  (while (and (< count 5) (setq entry (read b)))
    (setq fname (elt entry 0)
	  lname (elt entry 1)
	  email (car (elt entry 7)))
    (org-insert-heading-after-current)
    (insert (format "%s, %s\n" lname fname))
    (org-entry-put (point) "FIRSTNAME" fname)
    (org-entry-put (point) "LASTNAME" lname)
    (org-entry-put (point) "EMAIL" email))
  (save-buffer))
#+END_SRC

#+RESULTS:
#+begin_example
[Sarah Abdullah nil nil nil nil nil (sarah@cmu.edu) ((creation-date . 2014-03-17 01:00:18 +0000) (timestamp . 2014-03-17 01:00:18 +0000)) nil]
Sarah
Abdullah
sarah@cmu.edu
[Abdulwahab A. Abdulwahab nil nil nil nil nil (aabdulwa@andrew.cmu.edu) ((creation-date . 2014-03-17 00:54:29 +0000) (timestamp . 2014-03-17 00:54:29 +0000)) nil]
Abdulwahab A.
Abdulwahab
aabdulwa@andrew.cmu.edu
[Tanima Abedin nil nil nil nil nil (t.j.abedin@gmail.com) ((creation-date . 2014-03-17 01:00:19 +0000) (timestamp . 2014-03-17 01:00:19 +0000)) nil]
Tanima
Abedin
t.j.abedin@gmail.com
[Frank Abild-Pedersen nil nil nil nil nil (abild@slac.stanford.edu) ((creation-date . 2014-03-17 01:00:13 +0000) (timestamp . 2014-03-17 01:00:13 +0000)) nil]
Frank
Abild-Pedersen
abild@slac.stanford.edu
[Natalie Day Abrams nil nil nil nil nil (nda@andrew.cmu.edu) ((creation-date . 2014-03-17 01:00:16 +0000) (timestamp . 2014-03-17 01:00:16 +0000)) nil]
Natalie Day
Abrams
nda@andrew.cmu.edu
#+end_example


* a simple logging library for emacs
python has a great logging module. I would like this kind of capability.

(log-info "something %s" variable)
(log-debug "something %s" variable)

you set a =*log-level*= somewhere in your code to determine which messages get logged. Each log function has a corresponding trigger level, and if your =*log-level*= is greater than or equal to the trigger it will log to Messages.

#+BEGIN_SRC emacs-lisp
(setq *log-level* 10
      ,*log-info* 10
      ,*log-debug* 50)

(defun log-info (message &rest args)
  "print message formatted with args"
  (when (>= *log-level* *log-info*) ; *log-level* greater than this level print
    (message "log-info: %s" (apply #'format message args))))

(log-info "test %s %s" 5 "done")
#+END_SRC

#+RESULTS:
: log-info: test 5 done

this is not that sophisticated, it might be nice to have introspection, line numbers, functions, etc...

* Updating a bibtex entry using its doi
  :PROPERTIES:
  :categories: bibtex
  :END:
The next step is to use this to update an entry. Presumably ASAP articles will have their metadata updated in the future. It would be great to be able to run a command on an entry and update it. To do that, we need a convenient function to set a bibtex field. There is a function to get a field, but not to set a field. This next block is the closest thing I have come up with that sets a field

#+BEGIN_SRC emacs-lisp
(defun bibtex-set-field (field value)
  "set field to value in bibtex file. create field if it does not exist"
  (interactive "sfield: \nsvalue: ")
  (bibtex-beginning-of-entry)
  (let ((found))
    (if (setq found (bibtex-search-forward-field field t))
	;; we found a field
	(progn
	  (goto-char (car (cdr found)))
	  (when value
	    (bibtex-kill-field)
	    (bibtex-make-field field)
	    (backward-char)
	    (insert value)))
      ;; make a new field
      (message "new field being made")
      (bibtex-beginning-of-entry)
      (forward-line) (beginning-of-line)
      (bibtex-next-field nil)
      (forward-char)
      (bibtex-make-field field)
      (backward-char)
      (insert value))))
#+END_SRC

#+RESULTS:
: bibtex-set-field

Now, we want a function to update a bibtex entry. The function will get the doi from the entry, then retrieve the json data, and then update each field. We need to get the keys in the json results, and then map each key to a field in a bibtex entry. Here we go.

#+BEGIN_SRC emacs-lisp
(require 'json)

;; adapted from https://github.com/mon-key/mon-systems-cl/blob/master/plist.lisp
(defun plist-get-keys (plist)
   "return keys in a plist"
  (loop
   for key in results by #'cddr collect key))

(defun update-bibtex-entry-from-doi (doi)
  "update fields in a bibtex entry from the doi."
  (interactive (list (or (bibtex-autokey-get-field "doi") (read-string "DOI: "))))
  (let* ((url-request-method "GET")
	(url-mime-accept-string "application/citeproc+json")
	(json-object-type 'plist)
	(results (with-current-buffer
		    (url-retrieve-synchronously
		     (concat "http://dx.doi.org/" doi))
		  (json-read-from-string
		   (buffer-substring url-http-end-of-headers (point-max)))))
	(type (plist-get results :type))
	(author (mapconcat
		(lambda (x) (concat (plist-get x :given)
				    " " (plist-get x :family)))
		(plist-get results :author) " and "))
	(title (plist-get results :title))
	(journal (plist-get results :container-title))
	(year (format "%s"
		       (elt
			(elt
			 (plist-get
			  (plist-get results :issued) :date-parts) 0) 0)))

	(volume (plist-get results :volume))
	(number (or (plist-get results :issue) ""))
	(pages (or (plist-get results :page) ""))
	(month (format "%s"
			(elt
			 (elt
			  (plist-get
			   (plist-get results :issued) :date-parts) 0) 1)))
	(url (or (plist-get results :URL) ""))
	(doi (plist-get results :DOI))
	(annote (format "%s" results)))

    ;; map the json fields to bibtex fields
    (setq mapping '((:author . (bibtex-set-field "author" author))
		    (:title . (bibtex-set-field "title" title))
		    (:container-title . (bibtex-set-field "journal" journal))
		    (:issued . (progn
				 (bibtex-set-field "year" year)
				 (bibtex-set-field "month" month)))
		    (:volume . (bibtex-set-field "volume" volume))
		    (:issue . (bibtex-set-field "issue" issue))
		    (:page . (bibtex-set-field "pages" pages))
		    (:DOI . (bibtex-set-field "doi" doi))
		    (:URL . (bibtex-set-field "url" url))))

    ;; now we have code to run for each entry. we map over them and evaluate the code
    (mapcar
     (lambda (key)
       (eval (cdr (assoc key mapping))))
     (plist-get-keys results)))

  ; reclean entry, but keep existing key. check if it exists
  (if (bibtex-key-in-head)
      (org-ref-clean-bibtex-entry t)
    (org-ref-clean-bibtex-entry)))
#+END_SRC

#+RESULTS:
: update-bibtex-entry-from-doi


* Formatting citation links

#+BEGIN_SRC emacs-lisp
(setq s "pre text::post text")
(cond
  ((string-match "::" s)
   (format "[%s][%s]" (car (setq results (split-string s "::"))) (cadr results)))
  (t (format "[%s]" s)))

#+END_SRC

#+RESULTS:
: [pre text][:post text]

#+BEGIN_SRC emacs-lisp
(defun org-ref-cite-link-format (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite" (when desc (format "[%s]" desc)) "{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}"))))

(org-ref-cite-link-format "cite" "pre text::post text" 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text::post text]{cite}


* Functional definition of functions
In org-ref, I have a need to define a lot of link types that are all variations of the same kind, but with different names. I do not want to make a unique function for each link, because that involves a lot of cut and paste code.

I want to use something like mapcar on a list to define these links.

#+BEGIN_SRC emacs-lisp
(setq links '("test1" "test2"))

(defun define-link (link)
  (interactive)
  (eval-expression `(org-add-link-type ,link
 (lambda (x) (message "you clicked on %s" x))
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<",link">%s</",link">)" path))
    ((eq format 'latex)
     (concat "\\" ,link "{" keyword "}")))))))

(mapcar 'define-link links)
#+END_SRC

#+RESULTS:
| (test1 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test1 >%s</ test1 >) path)) ((eq format (quote latex)) (concat \ test1 { keyword }))))) | (citetext nil (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citetext{ path })))))                                             | (nocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \nocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeyear org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeyear{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citep* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))         | (citep org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citet* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citet org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citealp org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<citealp>%s</citealp>) path)) ((eq format (quote latex)) (concat \citealp{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (autocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<autocite>%s</autocite>) path)) ((eq format (quote latex)) (concat \autocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (cite org-ref-cite-onclick-minibuffer-menu org-ref-cite-link-format)                                                                                                                                                                                                                            | (eqref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (goto-char (point-min)) (if (or (re-search-forward (format label:%s label) nil t) (re-search-forward (format \label{%s} label) nil t) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<eqref>%s</eqref>) path)) ((eq format (quote latex)) (format \eqref{%s} keyword))))) | (ref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (if (or (progn (goto-char (point-min)) (re-search-forward (format label:%s\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format \label{%s} label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+tblname:\s-*\(%s\)\b label) nil t))) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<ref>%s</ref>) path)) ((eq format (quote latex)) (format \ref{%s} keyword))))) | (label (lambda (label) on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels! (message (format %s occurences (+ (count-matches (format label:%s\b label) (point-min) (point-max) t) (count-matches (format \label{%s}\b label) (point-min) (point-max) t) (count-matches (format #\+label:%s\b label) (point-min) (point-max) t))))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<label>%s</label>) path)) ((eq format (quote latex)) (format \label{%s} keyword)))))                                                                                                                                                                                         | (list-of-tables org-ref-list-of-tables (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoftables)))))                                                                                                                                                                                                                                                                                                                                                                                                                          | (list-of-figures org-ref-list-of-figures (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoffigures))))) | (addbibresource (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-addbibresource)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for addbibresource bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \addbibresource{%s} (replace-regexp-in-string \.bib  keyword)))))) | (bibliographystyle (lambda (arg) (message Nothing implemented for clicking here.)) (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \bibliographystyle{%s} keyword)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | (bibliography (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-bibliography)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for bibliography bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \bibliography{%s} (replace-regexp-in-string \.bib  keyword)))))) | (rmail org-rmail-open nil)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | (mhe org-mhe-open nil)     | (irc org-irc-visit nil) | (info org-info-open nil) | (gnus org-gnus-open nil) | (docview org-docview-open org-docview-export) | (bibtex org-bibtex-open nil)                  | (bbdb org-bbdb-open org-bbdb-export) | (index (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format %s \index{%s} keyword keyword))))) | (attachfile (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \attachfile{%s} keyword)))))  | (file+emacs org-open-file-with-emacs nil)                                                                                                                                                               | (file+sys org-open-file-with-system nil)  |                                          |
| (test2 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test2 >%s</ test2 >) path)) ((eq format (quote latex)) (concat \ test2 { keyword }))))) | (test1 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test1 >%s</ test1 >) path)) ((eq format (quote latex)) (concat \ test1 { keyword }))))) | (citetext nil (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citetext{ path })))))                                                                                                              | (nocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \nocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))     | (citeyear org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeyear{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))       | (citeauthor* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citep* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citep org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citet* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citet org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))           | (citealp org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<citealp>%s</citealp>) path)) ((eq format (quote latex)) (concat \citealp{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))     | (autocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<autocite>%s</autocite>) path)) ((eq format (quote latex)) (concat \autocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (cite org-ref-cite-onclick-minibuffer-menu org-ref-cite-link-format)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | (eqref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (goto-char (point-min)) (if (or (re-search-forward (format label:%s label) nil t) (re-search-forward (format \label{%s} label) nil t) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<eqref>%s</eqref>) path)) ((eq format (quote latex)) (format \eqref{%s} keyword)))))                                                                                                                                                                     | (ref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (if (or (progn (goto-char (point-min)) (re-search-forward (format label:%s\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format \label{%s} label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+tblname:\s-*\(%s\)\b label) nil t))) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<ref>%s</ref>) path)) ((eq format (quote latex)) (format \ref{%s} keyword))))) | (label (lambda (label) on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels! (message (format %s occurences (+ (count-matches (format label:%s\b label) (point-min) (point-max) t) (count-matches (format \label{%s}\b label) (point-min) (point-max) t) (count-matches (format #\+label:%s\b label) (point-min) (point-max) t))))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<label>%s</label>) path)) ((eq format (quote latex)) (format \label{%s} keyword))))) | (list-of-tables org-ref-list-of-tables (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoftables)))))    | (list-of-figures org-ref-list-of-figures (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoffigures)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | (addbibresource (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-addbibresource)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for addbibresource bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \addbibresource{%s} (replace-regexp-in-string \.bib  keyword)))))) | (bibliographystyle (lambda (arg) (message Nothing implemented for clicking here.)) (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \bibliographystyle{%s} keyword)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | (bibliography (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-bibliography)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for bibliography bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \bibliography{%s} (replace-regexp-in-string \.bib  keyword)))))) | (rmail org-rmail-open nil) | (mhe org-mhe-open nil)  | (irc org-irc-visit nil)  | (info org-info-open nil) | (gnus org-gnus-open nil)                      | (docview org-docview-open org-docview-export) | (bibtex org-bibtex-open nil)         | (bbdb org-bbdb-open org-bbdb-export)                                                                                                                                                                     | (index (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format %s \index{%s} keyword keyword))))) | (attachfile (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \attachfile{%s} keyword))))) | (file+emacs org-open-file-with-emacs nil) | (file+sys org-open-file-with-system nil) |



test1:wat

test2:yes



#+LATEX_CLASS: article
#+OPTIONS: author:nil toc:nil
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{subfigure}

* Side by side figures in org-mode

adapted from http://www.johndcook.com/blog/2009/01/14/how-to-display-side-by-side-figurs-in-latex/


Now you can reference Figure \ref{fig12}, or Figure ref:fig:a or Figure ref:fig:b.

#+caption: Left graph \label{fig:a}
[[./images/cos-plot.png]]





\begin{figure}
  \subfigure[Left graph \label{fig:a}]
    {\includegraphics[width=3in]{images/cos-plot.png}}
\enskip % horizontal spacking. tex.stackexchange.com/questions/41476/lengths-and-when-to-use-them
  \subfigure[Right graph. \label{fig:b}]
    {\includegraphics[width=3in]{images/eos-uncertainty.png}}
\caption{Text pertaining to both graphs,\ref{fig:a}and \ref{fig:b}. \label{fig12}}
\end{figure}

* Sorting the fields of a bibtex entry with emacs-lisp

We need two lists. The list that defines the order I want, and the rest of them.

#+BEGIN_SRC emacs-lisp :results value
(find-file "sort.bib")
(goto-char (point-min))

(defun org-ref-sort-bibtex-entry ()
  "sort fields of entry in standard order and downcase them"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((master '("author" "title" "journal" "volume" "issue" "pages" "year" "doi" "url"))
	 (entry (bibtex-parse-entry))
	 (entry-fields)
	 (other-fields)
	 (type (cdr (assoc "=type=" entry)))
	 (key (cdr (assoc "=key=" entry))))

    ;; these are the fields we want to order that are in this entry
    (setq entry-fields (mapcar (lambda (x) (car x)) entry))
    ;; we do not want to reenter these fields
    (setq entry-fields (remove "=key=" entry-fields))
    (setq entry-fields (remove "=type=" entry-fields))

    ;;these are the other fields in the entry
    (setq other-fields (remove-if-not (lambda(x) (not (member x master))) entry-fields))

    (cond
     ;; right now we only resort articles
     ((string= type "article")
      (bibtex-kill-entry)
      (insert
       (concat "@article{" key ",\n"
	       (mapconcat
		(lambda (field)
		  (when (member field entry-fields)
		    (format "%s = %s," (downcase field) (cdr (assoc field entry))))) master "\n")
	       (mapconcat
		(lambda (field)
		  (format "%s = %s," (downcase field) (cdr (assoc field entry)))) other-fields "\n")
	       "\n}"))
      (bibtex-clean-entry)
       ))))

(org-ref-sort-bibtex-entry)
#+END_SRC

#+RESULTS:
#+begin_example
@article{conesa-2010-relev-disper,
author = {Conesa, Jose\'{e} C.},
title = {The Relevance of Dispersion Interactions for the
                  Stability of Oxide Phases},
journal = {The Journal of Physical Chemistry C},
volume = 114,

pages = {22718-22726},
year = 2010,

pdf = {[[file:bibtex-pdfs/conesa-2010-relev-disper.pdf]]},
org-notes = {[[file:~/Dropbox/bibliography/notes.org::conesa-2010-relev-disper]]},
number = 51,
doi = {10.1021/jp109105g},
url = {http://pubs.acs.org/doi/abs/10.1021/jp109105g},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/jp109105g},
}
#+end_example




* Cleaning a bibtex entry

#+BEGIN_SRC emacs-lisp
(defun org-ref-clean-bibtex-entry()
  "clean and replace the key in a bibtex function"
  (interactive)
  (bibtex-beginning-of-entry)

  ;; check for empty pages, and put eid or article id in its place
  (let ((entry (bibtex-parse-entry))
	(pages (bibtex-autokey-get-field "pages"))
	(eid (bibtex-autokey-get-field "eid")))

    ;; fix pages if they are empty
    (cond
     ((string= "-" pages)
      (when eid
	(bibtex-beginning-of-entry)
	;; this seems like a clunky way to set the pages field.But I
	;; cannot find a better way.
	(goto-char (car (cdr (bibtex-search-forward-field "pages" t))))
	(bibtex-kill-field)
	(bibtex-make-field "pages")
	(backward-char)
	(insert eid))))

    ;; generate a key, and if it duplicates an existing key, edit it.
    (let ((key (bibtex-generate-autokey)))

      ;; first we delete the existing key
      (bibtex-beginning-of-entry)
      (re-search-forward bibtex-entry-maybe-empty-head)
      (if (match-beginning bibtex-key-in-head)
	  (delete-region (match-beginning bibtex-key-in-head)
			 (match-end bibtex-key-in-head)))
      ;; check if the key is in the buffer
      (when (save-excursion
	      (bibtex-search-entry key))
	  (setq key (bibtex-read-key "Duplicate Key found, edit: " key)))

      (insert key)
      (kill-new key)) ;; save key for pasting

    (bibtex-fill-entry)  ; this realigns the entry
    (bibtex-clean-entry) ; we do not replace our key

    ;; check for non-ascii characters
    (occur "[^[:ascii:]]")

    ;; one day reorder and downcase the fields
    ;; I can get all the fields like this
    ;; (bibtex-parse-entry t)
    ))
#+END_SRC

cite:daza-2014-carbon-dioxid

* Querying the ase-db
  :PROPERTIES:
  :categories: ase, database
  :date:     2014/04/24 09:33:44
  :updated:  2014/04/24 09:33:44
  :END:
I am examining how to query the ase-db, and this post looks at how to find results that do not contain a particular atom. The solution is based on a email from the mailing list (http://listserv.fysik.dtu.dk/pipermail/ase-developers/2014-April/002097.html).

We begin by making a test database. This will only contain some atoms objects with different stoichiometries. We also add keywords for the stoichiometry, because the queries will be developed directly in SQL, which cannot read the numpy arrays stored in the tables.

#+BEGIN_SRC python
import os
if os.path.exists('abc.db'): os.unlink('abc.db')

from ase import Atoms
from ase.db import connect
c = connect('abc.db')

c.write(Atoms('Fe'), ['Fe'])
c.write(Atoms('Al'), ['Al'])
c.write(Atoms('Ni'), ['Ni'])
c.write(Atoms('FeNi'), ['FeNi'])
c.write(Atoms('FeAl'), ['FeAl'])
c.write(Atoms('NiAl'), ['NiAl'])
c.write(Atoms('FeNiAl'), ['FeNiAl'])
#+END_SRC
#+RESULTS:

Now, let us see the contents to be sure what is in there.

#+BEGIN_SRC sh
ase-db abc.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|pbc|keywords|   mass
:  1|19s|jkitchin|Fe     |000|Fe      | 55.847
:  2|19s|jkitchin|Al     |000|Al      | 26.982
:  3|19s|jkitchin|Ni     |000|Ni      | 58.693
:  4|19s|jkitchin|FeNi   |000|FeNi    |114.540
:  5|19s|jkitchin|AlFe   |000|FeAl    | 82.829
:  6|19s|jkitchin|AlNi   |000|NiAl    | 85.675
:  7|19s|jkitchin|AlFeNi |000|FeNiAl  |141.522


Now, suppose I want to find entries that do not contain Ni. We can find the entries that do contain Ni like this.

#+begin_src sqlite :db abc.db :list
SELECT systems.data, species.id FROM species
inner join systems
on systems.id = species.id WHERE species.Z == 28;
#+end_src

#+RESULTS:
: {"keywords": ["Ni"], "data": {}, "key_value_pairs": {}}|3
: {"keywords": ["FeNi"], "data": {}, "key_value_pairs": {}}|4
: {"keywords": ["NiAl"], "data": {}, "key_value_pairs": {}}|6
: {"keywords": ["FeNiAl"], "data": {}, "key_value_pairs": {}}|7

You can see there is a Ni in each found entry. Now, we select the ids from the systems table that do not exist in that list.

#+begin_src sqlite :db abc.db :list
select id, data from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28);
#+end_src

#+RESULTS:
: 1|{"keywords": ["Fe"], "data": {}, "key_value_pairs": {}}
: 2|{"keywords": ["Al"], "data": {}, "key_value_pairs": {}}
: 5|{"keywords": ["FeAl"], "data": {}, "key_value_pairs": {}}

And you can see none of these entries contain Ni.


#+BEGIN_SRC python
from ase.db import connect
from ase.db.core import dict2atoms

c = connect('abc.db')
con = c._connect()
cur = con.cursor()
for row in  cur.execute('''select * from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28)'''):
    print dict2atoms(c.row_to_dict(row))
#+END_SRC
#+RESULTS:
: Atoms(symbols='Fe', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
: Atoms(symbols='Al', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
: Atoms(symbols='FeAl', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])

[[./O_sv]]

[[./O_sv][test dir]]



* latex snippets

Sometimes you just need raw latex inline. Here is a chemical formula @@latex:\ce{ABO_{3-\delta}}@@ that is inline.


* Using Matlab in org-mode
  :PROPERTIES:
  :categories: matlab
  :END:
Most of my work in org-mode uses python, or emacs-lisp. One thing that would make org-mode more readily adopted is if we could use Matlab too. Unfortunately, this is not currently possible on Windows. We need a tty shell.

#+BEGIN_SRC matlab :results value
u = cmu.units;

5*u.kg % a mass
5*u.lb % another mass
6*u.m/u.s  % a velocity

ans = 1*u.m + 10*u.cm % this is ok, 1.1 m
% 1*u.m + 1*u.s  % this is not ok
#+END_SRC

#+RESULTS:

* Parsing a bibtex file into a data structure

I need to parse a bibtex file and get a data structure I can use later. I want an a-list of (key . plist), where the plist will contain data about each bibtex entry, such as the file the key is in, and the entry string.

The idea is to do this once, to avoid re-searching a file all the time. Here is how I would use this idea.

#+BEGIN_SRC emacs-lisp
(setq results '())

(defun parse-bibtex-file (file)
  "parse bibtex file and add to data structure"
  (with-temp-buffer
    (insert-file-contents file)
    (bibtex-map-entries
     (lambda (key start end)
       (add-to-list 'results
		    `(,key . (:entry ,(buffer-substring start end)
				     :file ,file))
		    t) ;; this appends to the end
     ))))

(let ((bibfiles '("../../bibliography/references.bib" "../../bibliography/kitchin.bib")))
  (mapcar 'parse-bibtex-file bibfiles))



;; now see what we got
(plist-get
  (cdr (assoc  "mehta-2014-ident-poten" results))
  ':entry)

(plist-get
  (cdr (assoc  "mehta-2014-ident-poten" results))
  ':file)
#+END_SRC

#+RESULTS:
: ../../bibliography/references.bib




* set UUID in heading
  :PROPERTIES:
  :UUID:     ff7c16e8-a5b0-49da-a239-8cf7c6a2a211
  :END:

#+BEGIN_SRC emacs-lisp
(require 'org-id)

(add-hook 'org-insert-heading-hook
	  #'(lambda ()
	      (org-entry-put (point) "UUID" (org-id-uuid))))
#+END_SRC

#+RESULTS:





* An org-table rubric
I had an idea to insert a table that represents a rubric into an org-file

The table would compute the overall grade.

|              | weight | Emerging (1,2) | Developing (3,4)   | Mastery (5,6)      | grade |
|--------------+--------+----------------+--------------------+--------------------+-------|
| content      |    0.1 | Text rambles   | articulate ideas   | clear and concise  |     1 |
| organization |    0.2 | unorganized    | not well organized | logical            |     2 |
| mechanics    |    0.3 | many errors    | a few per page     | no errors          |     4 |
| figures      |    0.1 | inappropriate  | flawed             | proper             |     5 |
| style        |    0.2 | inappropriate  | informal, jargon   | neat               |     6 |
| format       |    0.2 | not followed   | somewhat followed  | conforms to format |     7 |
|--------------+--------+----------------+--------------------+--------------------+-------|
|              |      0 |                |                    | Total              |       |
#+TBLFM: B2=vsum(@1..@5)


You would create the table in advance as a snippet, and you could insert it. Maybe the table would have a name.

* A pyparsing example
#+BEGIN_SRC python
#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolXXX class instances, which can then
# later be evaluated for their boolean value.
#
# Copyright 2006, by Paul McGuire
# Updated 2013-Sep-14 - improved Python 2/3 cross-compatibility
#
from pyparsing import operatorPrecedence, opAssoc, Keyword, Word, alphas

# define classes to be built at parse time, as each matching
# expression type is parsed
class BoolOperand(object):
    def __init__(self,t):
        self.label = t[0]
        self.value = eval(t[0])
    def __bool__(self):
        return self.value
    def __str__(self):
        return self.label
    __repr__ = __str__
    __nonzero__ = __bool__

class BoolBinOp(object):
    def __init__(self,t):
        self.args = t[0][0::2]
    def __str__(self):
        sep = " %s " % self.reprsymbol
        return "(" + sep.join(map(str,self.args)) + ")"
    def __bool__(self):
        return self.evalop(bool(a) for a in self.args)
    __nonzero__ = __bool__
    __repr__ = __str__

class BoolAnd(BoolBinOp):
    reprsymbol = '&'
    evalop = all

class BoolOr(BoolBinOp):
    reprsymbol = '|'
    evalop = any

class BoolNot(object):
    def __init__(self,t):
        self.arg = t[0][1]
    def __bool__(self):
        v = bool(self.arg)
        return not v
    def __str__(self):
        return "~" + str(self.arg)
    __repr__ = __str__
    __nonzero__ = __bool__

TRUE = Keyword("True")
FALSE = Keyword("False")
boolOperand = TRUE | FALSE | Word(alphas,max=1)
boolOperand.setParseAction(BoolOperand)

# define expression, based on expression operand and
# list of operations in precedence order
boolExpr = operatorPrecedence( boolOperand,
    [
    ("not", 1, opAssoc.RIGHT, BoolNot),
    ("and", 2, opAssoc.LEFT,  BoolAnd),
    ("or",  2, opAssoc.LEFT,  BoolOr),
    ])


if __name__ == "__main__":
    p = True
    q = False
    r = True
    tests = [("p", True),
             ("q", False),
             ("p and q", False),
             ("p and not q", True),
             ("not not p", True),
             ("not(p and q)", True),
             ("q or not p and r", False),
             ("q or not p or not r", False),
             ("q or not (p and r)", False),
             ("p or q or r", True),
             ("p or q or r and False", True),
             ("(p or q or r) and False", False),
            ]

    print("p =", p)
    print("q =", q)
    print("r =", r)
    print()
    for t,expected in tests:
        res = boolExpr.parseString(t)[0]
        success = "PASS" if bool(res) == expected else "FAIL"
        print (t,'\n', res, '=', bool(res),'\n', success, '\n')



#+END_SRC
#+RESULTS:
#+begin_example
('p =', True)
('q =', False)
('r =', True)
()
('p', '\n', p, '=', True, '\n', 'PASS', '\n')
('q', '\n', q, '=', False, '\n', 'PASS', '\n')
('p and q', '\n', (p & q), '=', False, '\n', 'PASS', '\n')
('p and not q', '\n', (p & ~q), '=', True, '\n', 'PASS', '\n')
('not not p', '\n', ~~p, '=', True, '\n', 'PASS', '\n')
('not(p and q)', '\n', ~(p & q), '=', True, '\n', 'PASS', '\n')
('q or not p and r', '\n', (q | (~p & r)), '=', False, '\n', 'PASS', '\n')
('q or not p or not r', '\n', (q | ~p | ~r), '=', False, '\n', 'PASS', '\n')
('q or not (p and r)', '\n', (q | ~(p & r)), '=', False, '\n', 'PASS', '\n')
('p or q or r', '\n', (p | q | r), '=', True, '\n', 'PASS', '\n')
('p or q or r and False', '\n', (p | q | (r & False)), '=', True, '\n', 'PASS', '\n')
('(p or q or r) and False', '\n', ((p | q | r) & False), '=', False, '\n', 'PASS', '\n')
#+end_example

* Importing google contacts into bbdb

I am giving bbdb a try in emacs. I installed it from ELPA, and I am not sure if it is version 2 or 3, but it seems to work ok. The main reason I want it is so I can use email address completion in emails from Emacs.

The first thing I had to do was add this to my init files. Apparently the icicle-bbdb-complete-name function is not defined, so this takes care of that.
#+BEGIN_SRC emacs-lisp
;; This is not defined in my bbdb/icicles installation. This lets me use tab-completion.
(defalias 'icicle-bbdb-complete-name 'bbdb-complete-mail)
#+END_SRC

Next, I wanted to get my google contacts into bbdb. I am only going to do this once, to get most of what I need in. In the future, I suppose I will just add new contacts manually.  So, first, I exported my google contacts to a csv file. Google does some crazy scraping, so there were nearly 4000 contacts in that list. Not all of them were emails. I used this little python script to write out the first 5 columns of that file to a new file, as long as there was something in the first column.

#+BEGIN_SRC python
import csv

with open('contacts.csv', 'rb') as csvfile:
    spamreader = csv.reader(csvfile, delimiter=',')

    with open('new-contacts.csv', 'w') as f:
        for row in spamreader:
            if row[0]:
                f.write(','.join(row[0:5])+'\n')
                print ','.join(row[0:5])
#+END_SRC

Then, I manually went through the file deleting many obviously bad entries. It was just shy of interesting to see what was in there. I renamed the first line to have heading names with no spaces in them. So, the csv file eventually looked like this:

#+BEGIN_EXAMPLE
fname,mname,lname,email1,email2
Jennifer,,blahlan,fda@andrew.cmu.edu,
#+END_EXAMPLE


From there, I found a csv elisp file (http://ulf.epplejasper.de/EmacsGeneralPurpose.html) that can import a csv file to a lisp data structure. So, I read in the csv file, and then applied a function to each entry that created a bbdb entry with the information in the csv entry like this:

#+BEGIN_SRC emacs-lisp
#+BEGIN_SRC emacs-lisp
(let* ((b (find-file "new-contacts.csv"))
       (bbdb-allow-duplicates t)
       (contents (csv-parse-buffer t b)))
  (mapcar (lambda (x)
	    (let* ((fname (cdr (nth 0 x)))
		   (mname (cdr (nth 1 x)))
		   (lname (cdr (nth 2 x)))
		   (email1 (cdr (nth 3 x)))
		   (name (format "%s %s %s" fname mname lname)))
	      (bbdb-create-internal name nil nil nil email1))) contents))
#+END_SRC

Setting =(bbdb-allow-duplicates t)= was probably a mistake, it would have been better to leave this a false, catch the errors, and continue. But, it is easy to find duplicates in bbdb, and then manually delete them. In the end, I have 2648 "contacts" in my bbdb

* Sending email in emacs
  :PROPERTIES:
  :categories: emacs,email
  :END:

I would like to be able to regularly send email from emacs (one day I would like to read it too). The reason for this is simply that I have a lot of information stored in files I often read in Emacs, and I want to be able to select that information and quickly email it to someone. I need this to work smoothly on Windows and Linux.

There are numerous blog posts on how to set this up, but many are out of date, or work on Linux only.  Here I am documenting what seems to work for me. In my emacs init files, I have this:


#+BEGIN_SRC text :tangle ~/.authinfo
machine smtp.andrew.cmu.edu login jkitchin port 587 password blahbity-blah
#+END_SRC

Note that this file has my actual password in it.

Now, I can type C-x m to start an email, or use one my functions to email a selection or org-heading, and the emails get sent.
- [X] home office
- [ ] home tablet
- [ ] office slate
- [ ] office linux
- [ ] office laptop

** take 1

Here I am following this post http://wideaperture.net/blog/?p=3343

#+BEGIN_SRC emacs-lisp
;;Configure Outbound Mail

;;Tell the program who you are

(setq user-full-name "John Kitchin")
(setq user-mail-address "johnrkitchin@gmail.com")

;;Tell Emacs to use GNUTLS instead of STARTTLS
;;to authenticate when sending mail.

(setq starttls-use-gnutls t)

;;Tell Emacs about your mail server and credentials

(setq send-mail-function 'smtpmail-send-it
      message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials
      '(("smtp.gmail.com" 587 nil nil))

      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      smtpmail-debug-info t)
(require 'smtpmail)
#+END_SRC

(require 'gnutls)
(open-gnutls-stream "tls" "tls-buffer" "imap.aim.com" "imaps")

ftp://ftp.gnutls.org/gcrypt/gnutls/w32/

this needs a .authinfo file. it works on home-office computer, but not on home tablet.

#+BEGIN_SRC text
machine smtp.andrew.cmu.edu login jkitchin port 587 password jfkdlajfdkl;
machine cyrus.andrew.cmu.edu login jkitchin password fjdkslafjsdkals

#+END_SRC

** Using msmtp
this worked on my home tablet

http://www.emacswiki.org/emacs/GnusMSMTP

#+BEGIN_SRC emacs-lisp
;; This is needed to allow msmtp to do its magic:
(setq message-sendmail-f-is-evil 't)

;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("--read-envelope-from"))

;; with Emacs 23.1, you have to set this explicitly (in MS Windows)
;; otherwise it tries to send through OS associated mail client
(setq message-send-mail-function 'message-send-mail-with-sendmail)
;; we substitute sendmail with msmtp
(setq sendmail-program "c:/Users/jkitchin/Desktop/GetGnuWin32/bin/msmtp.exe")
;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("-a" "gmail"))
;; you might want to set the following too
(setq mail-host-address "gmail.com")
(setq user-full-name "John Kitchin")
(setq user-mail-address "johnrkitchin@gmail.com")
#+END_SRC
#+RESULTS:
: johnrkitchin@gmail.com


It appears we have an msmtp installed from our git installation.


#+BEGIN_SRC sh
which msmtp
#+END_SRC

#+RESULTS:
: C:\Program Files (x86)\Git\bin\msmtp.EXE

We can check the version like this.

#+BEGIN_SRC sh
msmtp --version
#+END_SRC

#+RESULTS:
#+begin_example
msmtp version 1.4.17
TLS/SSL library: OpenSSL
Authentication library: GNU SASL
Supported authentication methods:
plain cram-md5 digest-md5 external login
IDN support: disabled
NLS: disabled
Keyring support: none
System configuration file name: C:\ProgramData\msmtprc.txt
User configuration file name: c:/Users/jkitchin/\msmtprc.txt

Copyright (C) 2008 Martin Lambers and others.
This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.
#+end_example

It is not the most recent version. Next, create c:/Users/jkitchin/\msmtprc.txt with contents that look like this. I have two accounts that I could send email from, and they are listed here.

#+BEGIN_SRC text
########################
account default
host smtp.andrew.cmu.edu
tls on
tls_certcheck off
auth on
from jkitchin@andrew.cmu.edu
user jkitchin
password tjkdjfkd
port 587
logfile c:\msmtplog.txt
########################
account gmail
host smtp.gmail.com
tls on
tls_certcheck off
auth on
from johnrkitchin@gmail.com
user johnrkitchin@gmail.com
password fjdklafd
port 587

logfile c:\msmtplog.txt
########################
#+END_SRC

Now we follow the suggestions at http://www.emacswiki.org/emacs/GnusMSMTP to configure emacs

#+BEGIN_SRC emacs-lisp
;; This is needed to allow msmtp to do its magic:
(setq message-sendmail-f-is-evil 't)

;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("--read-envelope-from"))

(setq message-send-mail-function 'message-send-mail-with-sendmail)

;; we substitute sendmail with msmtp
(setq sendmail-program "C:/Program Files (x86)/Git/bin/msmtp.EXE")

;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("-a" "andrew"))
#+END_SRC


* Is my cursor on a link


#+BEGIN_SRC emacs-lisp
(defun label-p ()
 "determine if the cursor is on a label link. return the path if so, nil otherwise"
  (interactive)
  (let ((object (org-element-context)))
    (message "%s" (when
	(and (equal (org-element-type object) 'link)
	     (equal (org-element-property :type object) "label"))
      (org-element-property :path object)))))
#+END_SRC


label:test1
   label:test

[[file:~/Dropbox/kitchingroup/jmax/org-mode/lisp/org.el::((looking-at%20org-any-link-re)][file:~/Dropbox/kitchingroup/jmax/org-mode/lisp/org.el::((looking-at org-any-link-re)]]



* miscellaneous links

see http://draketo.de/light/english/emacs/convert-ris-citations-bibtex-bibutils

http://draketo.de/english/emacs/writing-papers-in-org-mode-acpd


* Advising org-ctrl-c-ctrl-c
  :PROPERTIES:
  :categories: org-mode,emacs
  :END:
I use a lot of equations in org-mode, and I like to use the LaTeX overlays (C-c C-x C-l (org-preview-latex-fragment)). I also use a lot of code blocks in my org-documents, and I like to run them during lectures, which I do with C-c C-c. However, this also removes the overlays from my equations, causing two irritations: 1) the code did not run when I thought it would, and I have to press C-c C-c again, 2) the equations that the code implements disappears so then I have C-c C-x C-l to get them back.  A lot of extra key strokes. The issue is one line in org.el at line 20222: (org-remove-latex-fragment-image-overlays).

I have been thinking about how to change that behavior. I do not want to patch my org-mode, because I do not want to deal with future updates. The simplest idea is to just redefine that function in my init files, with the offending line commented out. Here it is.

#+BEGIN_SRC emacs-lisp
(defun org-ctrl-c-ctrl-c (&optional arg)
  "Set tags in headline, or update according to changed information at point.

This command does many different things, depending on context:

- If a function in `org-ctrl-c-ctrl-c-hook' recognizes this location,
  this is what we do.

- If the cursor is on a statistics cookie, update it.

- If the cursor is in a headline, prompt for tags and insert them
  into the current line, aligned to `org-tags-column'.  When called
  with prefix arg, realign all tags in the current buffer.

- If the cursor is in one of the special #+KEYWORD lines, this
  triggers scanning the buffer for these lines and updating the
  information.

- If the cursor is inside a table, realign the table.  This command
  works even if the automatic table editor has been turned off.

- If the cursor is on a #+TBLFM line, re-apply the formulas to
  the entire table.

- If the cursor is at a footnote reference or definition, jump to
  the corresponding definition or references, respectively.

- If the cursor is a the beginning of a dynamic block, update it.

- If the current buffer is a capture buffer, close note and file it.

- If the cursor is on a <<<target>>>, update radio targets and
  corresponding links in this buffer.

- If the cursor is on a numbered item in a plain list, renumber the
  ordered list.

- If the cursor is on a checkbox, toggle it.

- If the cursor is on a code block, evaluate it.  The variable
  `org-confirm-babel-evaluate' can be used to control prompting
  before code block evaluation, by default every code block
  evaluation requires confirmation.  Code block evaluation can be
  inhibited by setting `org-babel-no-eval-on-ctrl-c-ctrl-c'."
  (interactive "P")
  (cond
   ((or (and (boundp 'org-clock-overlays) org-clock-overlays)
	org-occur-highlights
	org-latex-fragment-image-overlays)
    (and (boundp 'org-clock-overlays) (org-clock-remove-overlays))
    (org-remove-occur-highlights)
    ;; commented out by jkitchin 2014-03-01 to avoid removing latex images
    ;; on running code blocks.
    ;(org-remove-latex-fragment-image-overlays)
    (message "Temporary highlights/overlays removed from current buffer"))
   ((and (local-variable-p 'org-finish-function (current-buffer))
	 (fboundp org-finish-function))
    (funcall org-finish-function))
   ((run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-hook))
   (t
    (let* ((context (org-element-context)) (type (org-element-type context)))
      ;; Test if point is within a blank line.
      (if (save-excursion (beginning-of-line) (looking-at "[ \t]*$"))
	  (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	      (user-error "C-c C-c can do nothing useful at this location"))
	(case type
	  ;; When at a link, act according to the parent instead.
	  (link (setq context (org-element-property :parent context))
		(setq type (org-element-type context)))
	  ;; Unsupported object types: check parent element instead.
	  ((bold code entity export-snippet inline-babel-call inline-src-block
		 italic latex-fragment line-break macro strike-through subscript
		 superscript underline verbatim)
	   (while (and (setq context (org-element-property :parent context))
		       (not (memq (setq type (org-element-type context))
				  '(paragraph verse-block table-cell)))))))
	;; For convenience: at the first line of a paragraph on the
	;; same line as an item, apply function on that item instead.
	(when (eq type 'paragraph)
	  (let ((parent (org-element-property :parent context)))
	    (when (and (eq (org-element-type parent) 'item)
		       (= (point-at-bol) (org-element-property :begin parent)))
	      (setq context parent type 'item))))
	;; Act according to type of element or object at point.
	(case type
	  (clock (org-clock-update-time-maybe))
	  (dynamic-block
	   (save-excursion
	     (goto-char (org-element-property :post-affiliated context))
	     (org-update-dblock)))
	  (footnote-definition
	   (goto-char (org-element-property :post-affiliated context))
	   (call-interactively 'org-footnote-action))
	  (footnote-reference (call-interactively 'org-footnote-action))
	  ((headline inlinetask)
	   (save-excursion (goto-char (org-element-property :begin context))
			   (call-interactively 'org-set-tags)))
	  (item
	   ;; At an item: a double C-u set checkbox to "[-]"
	   ;; unconditionally, whereas a single one will toggle its
	   ;; presence.  Without an universal argument, if the item
	   ;; has a checkbox, toggle it.  Otherwise repair the list.
	   (let* ((box (org-element-property :checkbox context))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (parents (org-list-parents-alist struct))
		  (prevs (org-list-prevs-alist struct))
		  (orderedp (org-not-nil (org-entry-get nil "ORDERED"))))
	     (org-list-set-checkbox
	      (org-element-property :begin context) struct
	      (cond ((equal arg '(16)) "[-]")
		    ((and (not box) (equal arg '(4))) "[ ]")
		    ((or (not box) (equal arg '(4))) nil)
		    ((eq box 'on) "[ ]")
		    (t "[X]")))
	     ;; Mimic `org-list-write-struct' but with grabbing
	     ;; a return value from `org-list-struct-fix-box'.
	     (org-list-struct-fix-ind struct parents 2)
	     (org-list-struct-fix-item-end struct)
	     (org-list-struct-fix-bul struct prevs)
	     (org-list-struct-fix-ind struct parents)
	     (let ((block-item
		    (org-list-struct-fix-box struct parents prevs orderedp)))
	       (if (and box (equal struct old-struct))
		   (if (equal arg '(16))
		       (message "Checkboxes already reset")
		     (user-error "Cannot toggle this checkbox: %s"
				 (if (eq box 'on)
				     "all subitems checked"
				   "unchecked subitems")))
		 (org-list-struct-apply-struct struct old-struct)
		 (org-update-checkbox-count-maybe))
	       (when block-item
		 (message "Checkboxes were removed due to empty box at line %d"
			  (org-current-line block-item))))))
	  (keyword
	   (let ((org-inhibit-startup-visibility-stuff t)
		 (org-startup-align-all-tables nil))
	     (when (boundp 'org-table-coordinate-overlays)
	       (mapc 'delete-overlay org-table-coordinate-overlays)
	       (setq org-table-coordinate-overlays nil))
	     (org-save-outline-visibility 'use-markers (org-mode-restart)))
	   (message "Local setup has been refreshed"))
	  (plain-list
	   ;; At a plain list, with a double C-u argument, set
	   ;; checkboxes of each item to "[-]", whereas a single one
	   ;; will toggle their presence according to the state of the
	   ;; first item in the list.  Without an argument, repair the
	   ;; list.
	   (let* ((begin (org-element-property :contents-begin context))
		  (beginm (move-marker (make-marker) begin))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (first-box (save-excursion
			       (goto-char begin)
			       (looking-at org-list-full-item-re)
			       (match-string-no-properties 3)))
		  (new-box (cond ((equal arg '(16)) "[-]")
				 ((equal arg '(4)) (unless first-box "[ ]"))
				 ((equal first-box "[X]") "[ ]")
				 (t "[X]"))))
	     (cond
	      (arg
	       (mapc (lambda (pos) (org-list-set-checkbox pos struct new-box))
		     (org-list-get-all-items
		      begin struct (org-list-prevs-alist struct))))
	      ((and first-box (eq (point) begin))
	       ;; For convenience, when point is at bol on the first
	       ;; item of the list and no argument is provided, simply
	       ;; toggle checkbox of that item, if any.
	       (org-list-set-checkbox begin struct new-box)))
	     (org-list-write-struct
	      struct (org-list-parents-alist struct) old-struct)
	     (org-update-checkbox-count-maybe)
	     (save-excursion (goto-char beginm) (org-list-send-list 'maybe))))
	  ((property-drawer node-property)
	   (call-interactively 'org-property-action))
	  ((radio-target target)
	   (call-interactively 'org-update-radio-target-regexp))
	  (statistics-cookie
	   (call-interactively 'org-update-statistics-cookies))
	  ((table table-cell table-row)
	   ;; At a table, recalculate every field and align it.  Also
	   ;; send the table if necessary.  If the table has
	   ;; a `table.el' type, just give up.  At a table row or
	   ;; cell, maybe recalculate line but always align table.
	   (if (eq (org-element-property :type context) 'table.el)
	       (message "Use C-c ' to edit table.el tables")
	     (let ((org-enable-table-editor t))
	       (if (or (eq type 'table)
		       ;; Check if point is at a TBLFM line.
		       (and (eq type 'table-row)
			    (= (point) (org-element-property :end context))))
		   (save-excursion
		     (if (org-at-TBLFM-p)
			 (progn (require 'org-table)
				(org-table-calc-current-TBLFM))
		       (goto-char (org-element-property :contents-begin context))
		       (org-call-with-arg 'org-table-recalculate (or arg t))
		       (orgtbl-send-table 'maybe)))
		 (org-table-maybe-eval-formula)
		 (cond (arg (call-interactively 'org-table-recalculate))
		       ((org-table-maybe-recalculate-line))
		       (t (org-table-align)))))))
	  (timestamp (org-timestamp-change 0 'day))
	  (otherwise
	   (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	       (user-error
		"C-c C-c can do nothing useful at this location")))))))))
#+END_SRC


$x^2$

* Making sure you have a notes entry for each bibtex entry
As I mentioned [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf/][here]], I like to have a notes entry for each bibtex entry in an org-mode file. There are a couple of reasons for that:
1. I can tag the org-mode entries to help me find entries later
2. I can organize the org-mode entries by topic, including using links to entries when they belong in multiple places.
3. I can mark the entry as TODO to make it easy to find unfiled entries
4. I can keep typed notes in these entries.

It is usually part of my workflow to create these entries when I enter the bibtex entry, but occasionally I do not get to that. As part of the regular maintenance of my bibtex file, I like to find entries with no notes entry, and make them.

* non-ascii characters
 "
 "

  \beta
 $^{\circ}$
 \v{a}
 '
 \'{e}
 \~{n}
 \'{i}
 \~{a}
 \v{s}
 \delta




* TODO A gradebook app for emacs
  :PROPERTIES:
  :categories: emacs-lisp
  :END:
The goal is to create an emacs library to compute grades from a table in org-mode.

All grades are stored in a table with this structure.

#+tblname: gradebook
| first name | last name | email       | Hwk 1 | Hwk2 | exam1 | project 1 |
|            |           |             | 10    | 10   | 60    | 20        |
|------------+-----------+-------------+-------+------+-------+-----------|
| Jane       | Doe       | jd@cmu.edu  | A     | A    | B     | B         |
| John       | Dillinger | jdi@cmu.edu | B     | B/C  | A     | C         |
| jill       | wutz      | jw@cmu.edu  | D     | D    | R     | R         |

The grading system works like this:

1. Each assignment is worth a certain number of points (in row2).
2. Each assignment for a student is given a letter grade that indicates the quality and correctness of the work.
3. Each letter grade corresponds to a point multiplier:

| A++ |  1.0 |
| A+  | 0.95 |
| A   |  0.9 |
| A-  | 0.85 |
| A/B |  0.8 |
| B+  | 0.75 |
| B   |  0.7 |
| B-  | 0.65 |
| C/B |  0.6 |
| C+  | 0.55 |
| C   |  0.5 |
| C-  | 0.45 |
| C/D |  0.4 |
| D+  | 0.35 |
| D   |  0.3 |
| D-  | 0.25 |
| D/R |  0.2 |
| R+  | 0.15 |
| R   |  0.1 |
| R-  | 0.05 |
| R-- |  0.0 |

4. The number of points earned for an assignment is the point multiplier for the letter grade times the number of points for that assignment.
5. The overall grade is computed as sum(multiplier*points)/sum(points).
6. The overall letter grade is determined by the fraction of overall points received, mapped back on to the letter grade scale.

For example, in the table above, Jane Doe's grade is:

#+BEGIN_SRC emacs-lisp :results value
(let* ((multipliers '(0.9 0.9 0.7 0.7))
       (points '(10 10 60 20))
       (earned-points (mapcar* (lambda (a b) (* a b)) multipliers points))
       (total-earned-points (apply '+ earned-points))
       (total-points (apply '+ points)))
  (/ total-earned-points total-points))
#+END_SRC
#+RESULTS:
: 0.74

Which corresponds to an overall grade of B.

The goal here is to write emacs-lisp code to compute the overall grade of each student and convert it to an overall letter grade and write a little report.

We start by defining a variable to hold the multipliers. We will use an association list. We will prefix every variable and function with =gb/= to indicate it is part of our gradebook code.

#+BEGIN_SRC emacs-lisp
(defvar gb/MULTIPLIERS
  '(("A++" . 1.0)
    ("A+"   . 0.95)
    ("A"    . 0.9)
    ("A-"   . 0.85)
    ("A/B"  . 0.8)
    ("B+"   . 0.75)
    ("B"    . 0.7)
    ("B-"   . 0.65)
    ("B/C"  . 0.6)
    ("C+"   . 0.55)
    ("C"    . 0.5)
    ("C-"   . 0.45)
    ("C/D"  . 0.4)
    ("D+"   . 0.35)
    ("D"    . 0.3)
    ("D-"   . 0.25)
    ("D/R"  . 0.2)
    ("R+"   . 0.15)
    ("R"    . 0.1)
    ("R-"   . 0.05)
    ("R--"  . 0.0))
  "Numeric multipliers for letter grades")
#+END_SRC

#+RESULTS:

Here are two examples of using the gb/MULTIPLIER variable. It is an association list, so the multipler we want is the =cdr= of what the letter is associated with. We take the =cdr= of the return value, which is the numeric multiplier

#+BEGIN_SRC emacs-lisp :results value
(cdr (assoc "A" gb/MULTIPLIERS))
#+END_SRC

#+RESULTS:
: 0.9

We are going to write a series of functions that will compute the overall grade for each student.

A function we will need is to move the cursor into the table. Here is a function that will do that. This function moves the cursor to the beginning of the buffer, searches forward to find a line starting with a #+tblname: "name", and then moves the cursor to the next line which is in the table.

#+BEGIN_SRC emacs-lisp
(defun gb/goto-table (tblname)
  "move cursor into the table labeled tblname"
  (interactive)
  (goto-char (point-min))
  (search-forward-regexp (format "^#\\+tblname:\s+%s" tblname))
  (next-line))
#+END_SRC

#+RESULTS:

We use the function to move the cursor into the table, and then extract all the contents out.  We wrap the function call inside =save-excursion= so that the cursor gets put back where we want it. In this snippet, we use the (org-table-to-lisp) function to convert the table to a lisp structure which we can do further analysis on.

#+BEGIN_SRC emacs-lisp :results value verbatim
;; http://orgmode.org/worg/org-api/org-table-api.html
(require 'org-table) ; needed for access to org-table api

(defun gb/get-gradebook-lisp ()
  (interactive)
  (save-excursion
    (gb/goto-table "gradebook")
    (org-table-to-lisp)))

(gb/get-gradebook-lisp)
#+END_SRC
#+RESULTS:
: (("first name" "last name" "email" "Hwk 1" "Hwk2" "exam1" "project 1") ("" "" "" "10" "10" "60" "20") hline ("Jane" "Doe" "jd@cmu.edu" "A" "A" "B" "B") ("John" "Dillinger" "jdi@cmu.edu" "B" "B/C" "A" "C") ("jill" "wutz" "jw@cmu.edu" "D" "D" "R" "R"))

This is handy. Now we can think about processing the lisp data. Let us get the assignment names, and point values and save them in variables. The assignment names are in the first row, and start in column 3.

#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row1 (car (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENTS (mapcar 'identity (nthcdr 3 row1))))

gb/ASSIGNMENTS
#+END_SRC

#+RESULTS:
: ("Hwk 1" "Hwk2" "exam1" "project 1")

And now the point values, and total points.
#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row2 (cadr (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENT-POINTS (mapcar 'string-to-number (nthcdr 3 row2)))
 (setq gb/TOTAL-POINTS (apply '+ gb/ASSIGNMENT-POINTS)))

(format "ASSIGNMENT-POINTS=%s TOTAL-POINTS=%s" gb/ASSIGNMENT-POINTS gb/TOTAL-POINTS)
#+END_SRC

#+RESULTS:
: "ASSIGNMENT-POINTS=(10 10 60 20) TOTAL-POINTS=100"

So far, so good. Now, we need to get the letter grades for each student, and turn them into point multipliers.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-multiplier (LG)
  "return numeric multiplier for a letter grade"
  (interactive)
  (cdr (assoc (upcase LG) gb/MULTIPLIERS)))

(defun gb/get-multipliers(LGS)
  "apply get-multiplier to a list of letter grades"
  (interactive)
  (mapcar 'gb/get-multiplier LGS))

(defun gb/get-all-student-multipliers ()
  (mapcar 'gb/get-multipliers
          (mapcar (lambda (x)
                    (nthcdr 3 x))
                  (cdddr (gb/get-gradebook-lisp)))))

(gb/get-all-student-multipliers)
#+END_SRC

#+RESULTS:
: ((0.9 0.9 0.7 0.7) (0.7 0.6 0.9 0.5) (0.3 0.3 0.1 0.1))


Finally, we need the product of each multiplier with the gb/ASSIGNMENT-POINTS. This needs some care; some grades may be nil, which we cannot multiply. For now we neglect this detail.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-earned-points (multipliers)
  (mapcar* (lambda (a  b) (* a b)) multipliers gb/ASSIGNMENT-POINTS))

(defun gb/get-all-earned-points ()
  "returns total points earned by each student"
  (mapcar 'gb/get-earned-points  (gb/get-all-student-multipliers)))

(gb/get-all-earned-points)
#+END_SRC

#+RESULTS:
: ((9.0 9.0 42.0 14.0) (7.0 6.0 54.0 10.0) (3.0 3.0 6.0 2.0))

Next, we need to sum all the points and divide by the total points to get the overall numeric grade.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-all-numeric-grades ()
(mapcar (lambda (x)
          (/ (apply '+ x) gb/TOTAL-POINTS))
          (gb/get-all-earned-points)))

(gb/get-all-numeric-grades)
#+END_SRC

#+RESULTS:
: (0.74 0.77 0.14)

And finally, convert the numeric grades to letter grades. This involves finding the highest letter grade multiplier that the overall grade is larger than.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-final-letter-grade (grade)
 (dolist (pair gb/MULTIPLIERS letter-grade)
   (if (< (cdr pair) grade)
       (progn
         (setq letter-grade (car pair))
         (return letter-grade)))))

(mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))
#+END_SRC

#+RESULTS:
: ("B" "B+" "R")

That looks good. Now, let's make a final report of the results.

#+BEGIN_SRC emacs-lisp :results value
(let ((emails (mapcar '(lambda (x) (nth 2 x)) (cdddr (gb/get-gradebook-lisp))))
      (first-names (mapcar '(lambda (x) (nth 0 x)) (cdddr (gb/get-gradebook-lisp))))
      (last-names (mapcar '(lambda (x) (nth 1 x)) (cdddr (gb/get-gradebook-lisp))))
      (final-grades (mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))))
(mapcar* (lambda (fn ln em fg)
           `(,fn ,ln ,em ,fg))
         first-names
         last-names
         emails
         final-grades))
#+END_SRC

#+RESULTS:
| Jane | Doe       | jd@cmu.edu  | B  |
| John | Dillinger | jdi@cmu.edu | B+ |
| jill | wutz      | jw@cmu.edu  | R  |

** Summary
This is a pretty functional bit of code for computing final grades of a fixed format gradebook. It is missing some features. For example, it would not work well if any grades are missing, or if the gradebook is incomplete.

* TODO Testing units
#+BEGIN_SRC python
from pycse.units import units

u = units()

a = 5 * u.kJ
print repr(a)

b = u.kJ**2# * (1.0 / u.kJ)
print repr(b)
c = (1.0 / u.kJ)
print repr(c)

print repr(b*c)
print a.AS((1.0 / u.kJ) * u.kJ**2)
#print a.as_units(u.m)

#print '{0:1.3e}'.format(a)
#print '{0:f kJ}'.format(a)
#+END_SRC

#+RESULTS:
: Unit(5000.0, exponents=[ 2 -2  1  0  0  0  0], label=kJ)
: Unit(1000000.0, exponents=[ 4 -4  2  0  0  0  0], label=kJ^2)
: Unit(0.001, exponents=[-2  2 -1  0  0  0  0], label=kJ^-1)
: Unit(1000.0, exponents=[ 2 -2  1  0  0  0  0], label=(kJ^2)*(kJ^-1))
: 5.0 * (kJ^-1)*(kJ^2)



#+BEGIN_SRC python
from pycse.units import *
from pycse.umath import quad


u = units()
k = 0.23 * 1 / u.min
Cao = 2 * u.mol / u.L
V = 1 * u.L

Nao = Cao * V

def integrand(Na):
    return 1 / (k * Na)

t, terr = quad(integrand, 0.5 * Nao, Nao)
print t
#+END_SRC

#+RESULTS:
: 180.821003624 * s

* TODO Overloading subclass methods

#+BEGIN_SRC python
import numpy as np

class A(np.ndarray):

    def __new__(cls, input_array, label=None):
        # Input array is an already formed ndarray instance
        # We first cast to be our class type
        obj = np.asarray(input_array).view(cls)
        # add the new attribute to the created instance
        obj.label = label
        # Finally, we must return the newly created object:
        return obj

    def __array_finalize__(self, obj):
        if obj is None: return
        self.label = getattr(obj, 'label', None)

    def __array_wrap__(self, out_arr, context=None):
        return np.ndarray.__array_wrap__(self, out_arr, context)

    def __str__(self):
        return 'A({0}, label={1!s})'.format(np.array(self), self.label)


a = A(2)
print a

print a * 2
print np.float(2) * a
print np.float32(2) * a
print np.float64(2) * a
print np.__version__

#+END_SRC

#+RESULTS:
: A(2, label=None)
: A(4, label=None)
: A(4.0, label=None)
: A(4.0, label=None)
: 4.0
: 1.6.1
: 1.6.1
* TODO Testing out a new python units package
  :PROPERTIES:
  :categories: units
  :END:

#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()

distance = 1.0 * u.meter

dd = distance / (1*u.cm)
print 'dd = ',dd
print dd.magnitude, dd.dimensionality
print dd.to('dimensionless')
print
print 5 * dd * u.cm
print 'float = ',float(dd)
import numpy as np
print np.log(dd)


E = 10 * u.kJ/u.mol
R = 2 * u.cal/u.mol/u.K
T = 300 * u.K

print E/R/T
#+END_SRC

#+RESULTS:
: dd =  1.0 meter / centimeter
: 1.0 dimensionless

: 100.0 dimensionless
:
: 5.0 meter
: float =  100.0
: 4.60517018599
: 0.0166666666667 kilojoule / cal



#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()


from scipy.optimize import fsolve
Fa0 = 3.0                 # mol/min
Fa = Fa0 * (1.0 - 0.8)    # mol/min
G = Fa / Fa0

def objective(D):
    return 1 - G - D * G

Dsol, = fsolve(objective, 1.0)


nu = 1 * u.L / u.min
k = 0.34 * 1 / u.hr

# V = D * nu / k
print Dsol * nu / k   # this prints oddly because the units are not simplified
print (Dsol * nu / k).to(u.L)

#+END_SRC

#+RESULTS:
: 11.7647058824 hour * liter / minute
: 705.882352941 liter

* TODO erf and erfc for switching functions
In a [[http://jkitchin.github.io/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions/][previous post]] I examined a way to switch between discontinuous functions smoothly using a sigmoid function. The [[http://en.wikipedia.org/wiki/Error_function][error function]] has similar properties to the sigmoid function we used previously, and the complementary error function (erfc) is defined as 1 - erf. So, these are two functions we could use to smoothly transition from one function to another.


#+BEGIN_SRC python
import numpy as np
from scipy.special import erf, erfc

xspan = np.linspace(-5, 5)

import matplotlib.pyplot as plt

plt.plot(xspan, 0.5 * (1 + erf(xspan)), xspan, 0.5 * erfc(xspan))
plt.legend(['erf', 'erfc'])
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
from scipy.special import erf, erfc

def fF_laminar(Re):
    return 16.0 / Re

def fF_turbulent_unvectorized(Re):
    # Nikuradse correlation for turbulent flow
    # 1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)
    # we have to solve this equation to get f
    def func(f):
        return 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    fguess = 0.01
    f, = fsolve(func, fguess)
    return f

# this enables us to pass vectors to the function and get vectors as
# solutions
fF_turbulent = np.vectorize(fF_turbulent_unvectorized)

# Now we plot the correlations.

Re1 = np.linspace(500, 3000)
f1 = fF_laminar(Re1)

Re2 = np.linspace(3000, 10000)
f2 = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label='laminar')
plt.plot(Re2, f2, label='turbulent')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()


def fanning_friction_factor(Re):
    alpha = 20
    f =  0.5 * erfc(alpha*(Re-3000))* fF_laminar(Re) + 0.5 * (1 + erf(alpha*(Re-3000))) * fF_turbulent(Re)
    return f

Re = np.linspace(500,10000);
f = fanning_friction_factor(Re);

# add data to figure 1
plt.figure(1)
plt.plot(Re,f, label='smooth transition')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
* TODO Penalizing digital assignments that are turned in late

This semester I have experimented with using box.com to have students turn in assignments. The assignments often have deadlines. For homeworks, we were soft on this, and there was often time between the deadline and when assignments were "collected" for grading. As long as the assignments were available by the time we collected them, we gave students credit for the assignments. Still, some students turned in assignments after that, and we did not have a good strategy for dealing with that.

A new wrinkle came about when I started using box.com to give quizzes and exams. I learned how to make students collaborators on a folder for the duration of the quiz/exam, and then to turn off their ability to upload at the end of the quiz. The first time I ran this, students were unprepared for the amount of time it could take to upload, and a good fraction failed to turn in their quiz. They were /very/ unhappy. I tried modifying the approach to give them a visual timer, with a warning, and a buffer time to enable uploads. That helped, but some were still unable to upload in time. This puts you in an uncomfortable position of telling students they get no credit, or dealing with emails from them of their assignments after they are due, and then figuring out an appropriate penalty. The students are stressed out because they are worried about their grades, and they don't think it is fair. Even if they are deservedly so, worried, stressed out students aren't learning.

Now, I recognize these students should have turned it in when told to, and if this were a paper exam, there is a hard deadline of me walking out the door with the exams. Digitally turned in assignments do not have this kind of behavior. A way to reduce the overall stress around this is that rather than shutting off access to the upload, we should simply use an appropriate late penalty. That way, students get to turn in their work, which is psychologically less stressful, and they are appropriately penalized for being late.

Now, why is this difficult? It turns out it is not that easy to tell when a file is uploaded or modified on box.com. You can do it through the box.com api, but the timestamp comes in an unfamiliar form. Second, late is a difference in time.  The local time on a computer is not the same as the time on the box.com servers, so we cannot (or should not) use that difference to determine lateness.

#+BEGIN_SRC python
from box_course.box import *
import json

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

print json.dumps(jf, sort_keys=True, indent=4)
#+END_SRC

#+RESULTS:
#+begin_example
{
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
    "created_at": "2013-12-08T06:31:46-08:00",
    "created_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "description": "",
    "etag": "0",
    "id": "12178719122",
    "item_status": "active",
    "modified_at": "2013-12-08T06:31:47-08:00",
    "modified_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "name": "reference.txt",
    "owned_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "parent": {
        "etag": "0",
        "id": "1364917348",
        "name": "test",
        "sequence_id": "0",
        "type": "folder"
    },
    "path_collection": {
        "entries": [
            {
                "etag": null,
                "id": "0",
                "name": "All Files",
                "sequence_id": null,
                "type": "folder"
            },
            {
                "etag": "1",
                "id": "1328895168",
                "name": "group-course",
                "sequence_id": "1",
                "type": "folder"
            },
            {
                "etag": "0",
                "id": "1364917348",
                "name": "test",
                "sequence_id": "0",
                "type": "folder"
            }
        ],
        "total_count": 3
    },
    "purged_at": null,
    "sequence_id": "0",
    "sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "shared_link": null,
    "size": 0,
    "trashed_at": null,
    "type": "file"
}
#+end_example


I think the relevant information is:
#+BEGIN_EXAMPLE
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
#+END_EXAMPLE

These timestamps are described [[https://www.ietf.org/rfc/rfc3339.txt][here]]. These timestamps are related to utc time, and can be converted to local time like this:

#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

def utc_to_local(timestamp):
    utc = parser.parse(timestamp)
    to_zone = tz.gettz('America/New_York')
    return utc.astimezone(to_zone)

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

from dateutil import parser
dc = jf['content_created_at']
print utc_to_local(dc)
#+END_SRC

#+RESULTS:
: 2013-12-08 09:31:46-05:00

In fact, I did create that file around 9:31am on 12/8. The =-05:00= is related t the offset of our local time with utc.

Now, the key idea in calculating lateness is that I have a reference time on box.com now, by virtue of having created reference.txt at the beginning of the assignment. I created two assignment files, assignment1.txt and assignment2.txt that I uploaded about 30 seconds, and one minute after the reference.txt was created. Below, I calculate the amount of time elapsed between the reference file and assignment files.


#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
jf = get_file_information(j['id'])
t0 = jf['content_modified_at']

j1 = get_item('group-course/test/assignment1.txt')
jf1 = get_file_information(j1['id'])
t1 = jf1['content_modified_at']

j2 = get_item('group-course/test/assignment2.txt')
jf2 = get_file_information(j2['id'])
t2 = jf2['content_modified_at']

p2 = parser.parse(t2)
p1 = parser.parse(t1)
p0 = parser.parse(t0)

d1 = p1 - p0
d2 = p2 - p0

print d1.total_seconds()
print d2.total_seconds()
#+END_SRC

#+RESULTS:
: 25.0
: 63.0

So, now we have a quantitative way to measure lateness. It is not a speedy method, since you have to make several box.com api calls, but, we can say how late it is, and since we use a reference file created on box.com at the beginning of the assignment, we take out the local time issue. The reference file could be created at the end of the assignment to mark when it is done.

Now about the penalty function. This is arbitrary, but should be a function that decays from 100% credit to some lower level of credit that is appropriate. For a homework, you might choose 50% as a floor, with some hours of decay time, whereas for a quiz/exam, it should be minutes of decay time down to 0%. Linear decay is the simplest. Let us say we want the credit to go from 100% to 50% over a 5 minute span. It would look like this:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

@np.vectorize
def penalty(t):
    if t < (5 * 60):
        p = 1.0 - (1.0 - 0.5) / (5 * 60) * t
    else:
        p = 0.5
    return p

t = np.linspace(0, 600, 100)
p = penalty(t)

plt.plot(t, p)
plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-penalty.png')
#+END_SRC

#+RESULTS:

[[./images/example-penalty.png]]

There are many options for a smooth decrease. Let us examine this gaussian function. We define a function that decays in the normal distribution sense, and allows you to set upper and lower bounds. To go from 1.0 to 0.5 we use this code:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

def penalty(t, mu=0.0, sigma=5, ub=1.0, lb = 0.0):
    return (ub - lb) * np.exp(-(t-mu)**2 / (2 * sigma**2)) + lb

t = np.linspace(0, 30)
plt.plot(t, penalty(t, lb=0.5))

plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-gaussian-penalty.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/example-gaussian-penalty.png]]

You can see that after about 15 minutes (3 * sigma), the penalty will be


I think this would help reduce stress in the classroom, and make it more systematic to apply lateness penalties to assignments. I still have not worked out precisely how to integrate this into a grading workflow, since you need to run a script to get the penalties for each assignment, and then multiply the grade by it to get the penalized grade. You could grade normally, and have the script create a late file in the directory which is only used in calculating the overall grade.

* TODO Exporting LaTeX manuscripts from org-mode
  :PROPERTIES:
  :categories: org-mode
  :END:
We have been using org-mode to write manuscripts for submission to journals for publication. Our typical workflow is writing in org-mode, and then using a custom export function to turn the document into LaTeX, and then compiling to pdf via pdflatex. This /mostly/ works great, except for the following two issues:

1. We use BibTex for references, and most journals want us to replace the \bibliography{} lines with the contents of the .bbl file so it is self-contained.
2. We use png files in the org file so they show up in emacs. However, most journals want eps files, and we have to manually remove the .png extension from the LaTeX file so it will build on the journal site (which does not use pdflatex).

I am exploring some code that would automate those things.

** Replacing the bibliography line
Starting with item one, we need to get the contents of the bbl file, and then replace the bibliography line with that. The .bbl file is typically named after the tex file, which is named after the org file. So, if the org-file is blog.org, the tex file would be blog.tex, and the corresponding bbl file would be blog.bbl.

#+BEGIN_SRC emacs-lisp
; derive bbl filename from org file
(concat (file-name-sans-extension (file-name-nondirectory (buffer-file-name))) ".bbl")
#+END_SRC

An alternative approach is to replace text using a regexp.
#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name)))
#+END_SRC

Now, we need a way to get the contents of the bbl file. This works:
#+BEGIN_SRC emacs-lisp
(let* ((bbl-file (replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name))))
       (contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string))))
  (princ contents))
#+END_SRC

#+RESULTS:
: You got the contents of blog.bbl!

Finally, we should replace the bibliography string in the tex file with the contents of the bbl file. This block seems to do that. I think as long as the bibliography line does not span more than one line, and that there is not more than one of them this should work fine.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (bbl-file (replace-regexp-in-string "org$" "bbl" org-file))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (bbl-contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string)))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string "\\\\bibliography{.*}" bbl-contents tex-contents))))
#+END_SRC

#+RESULTS:

A work flow here would be to run a code block that exports the org-file to LaTeX, then run the code block above to insert the bbl file.

** Removing the image extensions
We put the .png extension in the figure links in org-mode so that org-mode will show the images in the buffer. That is convenient for writing. It is also fine if one uses pdflatex to compile the resulting LaTeX source. Some journals, however, use latex to build the document, and latex does not support png files; encapsulated postscript is preferrable for latex.

Luckily, you do not have to specify a file extension to latex, it will automatically look for the right extension (.eps for latex, .pdf or .png for pdflatex). So, we just need to strip the extension off of the image paths. Here is a regular expression and code block that seems to do this correctly.

#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"
 "\includegraphics{./images/test.png}


\\includegraphics{image/with/no/extension}
other latex

\\includegraphics[width=2in]{images/figure2.png}

\\includegraphics[width=3in]{./images/bulkmodulus-volume.png}
")
#+END_SRC

#+RESULTS:
: includegraphics{./images/test}
:
:
: \includegraphics{image/with/no/extension}
: other latex
:
: \includegraphics[width=2in]{images/figure2}
:
: \includegraphics[width=3in]{./images/bulkmodulus-volume}


We can combine this with the previous work on replacing the bibliography to replace all the extensions like this.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}\.].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"  tex-contents))))
#+END_SRC

#+RESULTS:

** Putting this together
What we want to create is a function we could use to create the manuscript. There would be a function like this for different journals and/or publishers. For instance, APS journals use revtex, while ACS journals use achemso. There could be one publisher function that takes some options for the specific journal.

#+BEGIN_SRC emacs-lisp

#+END_SRC
* TODO textify html

#+BEGIN_EXAMPLE
	<title>Philip Herron: Cython Book</title>	<guid>http://redbrain.co.uk/?p=147</guid>	<link>http://redbrain.co.uk/cython-book/</link>		<description><p>Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. <a href="http://bit.ly/195ahQs">http://bit.ly/195ahQs</a></p> <p><a href="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"><img class="aligncenter size-full wp-image-148" alt="photo" src="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg" width="640" height="480" /></a>The code can be found: <a href="https://github.com/redbrain/cython-book">https://github.com/redbrain/cython-book</a></p></description>		<pubDate>Tue, 10 Dec 2013 14:45:08 +0000</pubDate>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun ph (start end) (interactive "r")
 (setq output (libxml-parse-html-region start end)))
#+END_SRC

(cdr '(a nil b))


#+BEGIN_SRC emacs-lisp :results output
(setq phtml
'(html nil
      (head nil
            (title nil "Philip Herron: Cython Book")
            (guid nil "http://redbrain.co.uk/?p=147")
            (link nil))
      (body nil
            (p nil "http://redbrain.co.uk/cython-book/		"
               (description nil
                            (p nil "Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. "
                               (a
                                ((href . "http://bit.ly/195ahQs"))
                                "http://bit.ly/195ahQs"))
                            " "
                            (p nil
                               (a
                                ((href . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"))
                                (img
                                 ((class . "aligncenter size-full wp-image-148")
                                  (alt . "photo")
                                  (src . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg")
                                  (width . "640")
                                  (height . "480"))))
                               "The code can be found: "
                               (a
                                ((href . "https://github.com/redbrain/cython-book"))
                                "https://github.com/redbrain/cython-book")))
               (pubdate nil "Tue, 10 Dec 2013 14:45:08 +0000")))))


;; (defun print-elements-recursively (list)
;;        "Print each element of LIST on a line of its own.
;;      Uses recursion."
;;        (when list                            ; do-again-test
;;              (print (car list))              ; body
;;              (if (listp (cdr list)) (print-elements-recursively (cdr list)))
;;              (print-elements-recursively     ; recursive call
;;               (cdr list))))                  ; next-step-expression

;(print-elements-recursively phtml)

(defun print-list (lst)
 (when lst
   (if (atom (car lst))
     (print (car lst)) (print-list (cdr lst)))))


(print-list phtml)
#+END_SRC

#+RESULTS:
:
: html






** another approach

<p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA"><img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img></a>
</div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
[[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>

(defun ph (r1 r2) (interactive "r") (setq html (buffer-substring r1 r2)))
#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1]]"  html)
#+END_SRC

#+RESULTS:
: <p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA]]
: </div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
: [[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>


http://www.mkyong.com/regular-expressions/how-to-extract-html-links-with-regular-expression/

these worked in re-builder (C-c C-w) then c-y to get them

"<p>\\(.+?\\)</p>" \\1 is the stuff between them


#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]"  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>")
#+END_SRC

#+RESULTS:
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]



(url-file-local-copy "http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA")

[[./tst.png]]


** downloading images

#+BEGIN_SRC emacs-lisp :results raw
(defun download-src (arg)
  (format "[[%s][image]]" (save-match-data
                            (url-file-local-copy
                             (replace-regexp-in-string
                              "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"
                              "\\1"
                              arg)))))

(princ (replace-regexp-in-string "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>" #'download-src  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA">[[c:/Users/jkitchin/AppData/Local/Temp/url8408MBa][image]]</a>


** replacing <a>
#+BEGIN_SRC emacs-lisp :results raw
(princ (replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]" "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
[[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]

** some regexs
"<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>"  \\1 is the href \\2 is the target

"<img\\([^>]+\\)></img>"

"<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"  \\1 is the src
* TODO Copy a bibtex entry with some formatting

#+BEGIN_SRC emacs-lisp
(defun formatted ()
  "copy entry to formatted string"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((bibtex-expand-strings t)
         (entry (bibtex-parse-entry t))
         (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
         (year  (reftex-get-bib-field "year" entry))
         (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
         (key (reftex-get-bib-field "=key=" entry))
         (journal (reftex-get-bib-field "journal" entry))
         (volume (reftex-get-bib-field "volume" entry))
         (issue (reftex-get-bib-field "issue" entry))
         (pages (reftex-get-bib-field "pages" entry))
         (doi (reftex-get-bib-field "doi" entry))
         (output))
    (setq output (concat (when author author) ", "
                         (when title title) ", "
                         (when journal journal) ", "
                         (when volume volume)
                         (if issue (format "(%s), " issue) ", ")
                         (when pages pages) ", "
                         (when year (format "(%s)." year))
                         (when doi (format " http://dx.doi.org/%s" doi))))
    (kill-new output)))

#+END_SRC

Abild-Pedersen, F. and Greeley, J. and Studt, F. and  Rossmeisl, J. and Munter, T. R. and Moses, P. G. and  Sk\'ulason, E. and Bligaard, T. and N\o{}rskov,  J. K., Scaling Properties of Adsorption Energies for  Hydrogen-Containing Molecules on Transition-Metal  Surfaces, Phys. Rev. Lett., 99(1),016105, (2007). http://dx.doi.org/10.1103/PhysRevLett.99.016105
* TODO Email buffer after time out

(timer-duration "0.5 min")


#+BEGIN_SRC emacs-lisp
(run-at-time 5 nil
             (lambda (args)
(princ "uuuu")
               (let ((body (buffer-string)))
                 (mail)
                 (mail-to)
                 (insert "jkitchin@andrew.cmu.edu")
                 (mail-subject)
                 (insert "exam")
                 (mail-text)
                 (insert body)
                 (mail-send-and-exit))))
#+END_SRC

#+RESULTS:


(run-at-time 5 nil
             (lambda (args) (insert "done")))

"09:40pm" 10

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defvar jao-totd-timer (run-at-time "12:00am" (* 30 1) 'totd))
(cancel-timer jao-totd-timer)


(defun jao-cancel-totd
  (interactive)
  (cancel-timer jao-totd-timer))

(defun td ()
  (interactive)
  (with-output-to-temp-buffer "*my-timer*"
  (insert "done")))

(defvar jao-totd-timer (run-at-time "12:00am" 1 'td))
(cancel-timer jao-totd-timer)



* DONE Putting link references to lines of code in a source block
  CLOSED: [2014-04-22 Tue 20:59]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/04/22 20:59:30
  :updated:  2014/04/22 20:59:30
  :END:
I keep forgetting about this interesting gem of a feature in org-mode code blocks. You can put references to specific lines of code outside the block!
http://orgmode.org/manual/Literal-examples.html#Literal-examples

The following code block has some references in it that we can refer to later:
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC


In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]] jumps to point-min.

To make this work with python we have to make a slight change to the reference format in the header.

#+BEGIN_EXAMPLE
#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC
#+END_EXAMPLE

#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC

#+RESULTS:
: 0
: 1
: 2
: 3
: 4


In line [[(for)]] we initialize the loop, and in line [[(body)]] we run it.


* Storing INCAR parameters in a yaml file

#+BEGIN_SRC python
import yaml
document = r'''
encut:
  type: float
  units: eV
  description:  "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$   The number of plane waves differs for each k-point, leading to a superior beahviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations." '''

print yaml.load(document)
#+END_SRC

#+RESULTS:


There doesn't appear to be an emacs yaml reader. This is a dead end for now. Also, it is not clear that yaml is flexible enough to contain the markup.

* Storing INCAR parameters in a json file

I am exploring a way to list all the INCAR parameters for VASP in a file format that would allow me to generate the list of keywords in Python /and/ provide documentation in Emacs. Right now these keywords exist in a set of lists in ase.calculators.vasp, with some comments that indicate what they are. However, the only way to access the comments is via the source code. There is no way to show them to the user via a help command. Furthermore, most of the keywords are built in VASP keywords, but some are ase specific. For the VASP keywords, one can search the internet for them, which often brings up the VASP documentation, but sometimes that is slow. For the ase keywords, which implement convenience, one has to read the source. It would be nice to avoid all these issues, and provide documentation that is accessible in an editor too, e.g. in Emacs.

Here we explore doing all of this in a json file. There are json parsers for python and emacs, so it seems possible.

Here is an example of what the json file might look like. The encut documentation is adapted from the VASP documentation

#+BEGIN_SRC text :tangle incar.json
{
    "ispin": {
        "description": "turn spin polarization on (2) or off (1)",
        "default": 1,
        "allowed_values": [
            1,
            2
        ],
        "units": null,
        "type": "int",
        "long_description": "The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. "
    },
    "encut": {
        "units": "eV",
        "type": "float",
        "description": "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. "
    }
}
#+END_SRC

Now, we parse it with Python.
#+BEGIN_SRC python
import json

with open('incar.json') as f:
    data = json.loads(f.read())

print data

print data.keys()
#+END_SRC

#+RESULTS:
: {u'ispin': {u'description': u'turn spin polarization on (2) or off (1)', u'default': 1, u'allowed_values': [1, 2], u'units': None, u'type': u'int', u'long_description': u'The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. '}, u'encut': {u'units': u'eV', u'type': u'float', u'description': u'Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. '}}
: [u'ispin', u'encut']

That is easy enough. We only have to remember that the strings are read in a unicode. It is similarly easy in Emacs.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(let ((my-json (json-read-from-string (with-temp-buffer
					(insert-file-contents "incar.json")
					(buffer-string)))))
  (princ my-json)
  (princ "\n")
  (princ (mapcar (lambda (x) (car x)) my-json)))
#+END_SRC

#+RESULTS:
: ((encut (description . Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$
:
: The number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. ) (type . float) (units . eV)) (ispin (long_description . The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. ) (type . int) (units) (allowed_values . [1 2]) (default . 1) (description . turn spin polarization on (2) or off (1))))
: (encut ispin)

This looks pretty promising. I could have a json file that describes the keywords, provides documentation of the keywords, etc... In python I would use that file to generate the lists that vasp.py uses for each type of keyword, and to provide help functions in python. I could also do that in Emacs too.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((my-json (json-read-from-string (with-temp-buffer
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc 'description (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help 'ispin))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

It might be confusing for a while that you use symbols instead of strings here. That is changeable with the json-object-type and json-key-type variable which can make them into strings. Here is an example.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((json-key-type 'string)
	 (my-json (json-read-from-string (with-temp-buffer
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc "description" (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help "ispin"))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

This seems like a promising approach to provide flexible documentation to the keywords.

* Set a headline to DONE
  CLOSED: [2014-01-27 Mon 13:50]

#+BEGIN_SRC emacs-lisp
(org-narrow-to-subtree)
(goto-char (point-min)) ; beginning of buffer
(org-todo 'done)
(widen)
#+END_SRC

#+RESULTS:

* Using org-mode files as databases

Below are subheadings that contain data, properties and tags. Here, we use this entry as a database to summarize data.

#+BEGIN_SRC emacs-lisp
(let* ((total-units 0)
      (units)
      (course)
      (courses (org-map-entries (lambda ()
				  (setq units (string-to-number (org-entry-get (point) "UNITS"))
					total-units (+ total-units units)
					course (nth 4 (org-heading-components)))
				  `(,course  ,units ,(org-entry-get (point) "SEMESTER")))
				"chemistry|biology|physics|math" 'tree nil)))
  (add-to-list 'courses `(nil "Total units"  ,total-units) t))
#+END_SRC

#+RESULTS:
| 09-105 |           9 |  1 |
| 09-106 |           9 |  2 |
| 33-105 |          12 |  1 |
| 33-106 |          12 |  3 |
| 21-120 |           9 |  1 |
| 21-122 |           9 |  2 |
| 21-259 |           9 |  3 |
| 03-232 |           9 |  5 |
|    nil | Total units | 78 |





How about classes with less than 12 units?

#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil)
#+END_SRC

#+RESULTS:
| Using org-mode files as databases | nil |
|                            09-105 |   9 |
|                            09-106 |   9 |
|                            21-120 |   9 |
|                            21-122 |   9 |
|                            21-259 |   9 |
|                            03-232 |   9 |

I am surprised by the nil entry above. I would have thought an entry with out a property should not be counted. That suggests some list pruning is in order. There is a remove-if-not macro in the cl (common-lisp) library.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(remove-if-not
  (lambda (arg) (nth 1 arg))
    (org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil))
#+END_SRC

#+RESULTS:
| 09-105 | 9 |
| 09-106 | 9 |
| 21-120 | 9 |
| 21-122 | 9 |
| 21-259 | 9 |
| 03-232 | 9 |

** 09-105							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :END:
** 09-106							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :END:
** 33-105							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :END:
** 33-106							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 3
   :END:
** 21-120							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :END:
** 21-122							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :END:
** 21-259							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 3
   :END:
** 03-232							    :biology:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 5
   :END:
** 06-100							:engineering:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :END:
* A widget based quiz in Emacs
  :PROPERTIES:
  :categories: emacs
  :END:

I have been interested in making quizzes in Emacs. Quizzes that
students would take, and somehow submit. One issue with an org-mode
quiz is the totally free-form; everything can be edited. Enter the
[[https://www.gnu.org/software/emacs/manual/html_mono/widget.html][widget]] library in Emacs. Below is an illustrative example of making a
quiz, adapted from [[https://www.gnu.org/software/emacs/manual/html_mono/widget.html#Programming-Example][here]]. I also adapted some code from [[http://stackoverflow.com/questions/13590811/how-i-can-get-values-of-all-widgets-in-current-widget-minor-mode-buffer-in-emacs][here]] to get a
list of widgets in a buffer, how they are tagged, and their values.

#+BEGIN_SRC emacs-lisp
(require 'widget)

(eval-when-compile
  (require 'wid-edit))

(require 'cl)
(defun get-widgets ()
  "return a list of widget tags and values from the buffer"
  (mapcar (lambda (x)
	      `(,(widget-get x :tag) ,(widget-value x)))
	  (save-excursion
	    (goto-char (point-min))
	    (loop while (not (eobp))
		  for new = (widget-at)
		  and old = nil then new
		  when (and new (not (eq new old))) collect new
		  do (goto-char (next-overlay-change (point)))))))

(defun submit-quiz (&rest ignore)
  "email results from quiz"
  (interactive)
  (let ((widgets (get-widgets)))
    (mail)
    (mail-to)
    (insert "jkitchin@andrew.cmu.edu")
    (mail-subject)
    (insert "quiz1")
    (mail-text)
    (insert (format "%s" widgets))
;    (insert quiz)
    (mail-send-and-exit)))

(defun quiz1 ()
  "create a simple quiz"
  (interactive)
  (switch-to-buffer "*Quiz 1*")
  (kill-all-local-variables)
  (let ((inhibit-read-only t))
    (erase-buffer))
  (remove-overlays)
  (widget-insert "You will take a quiz.\n\n")
  (widget-create 'editable-field
		 :size 13
                 :tag "quiz1-name"
		 :format "Name: %v ")

  (widget-insert "\n\nCheck all true statements:\n")
  (widget-create 'checkbox :tag "p1-a" nil)
  (widget-insert " 2+2 = 4\n")
  (widget-create 'checkbox :tag "p1-b" nil)
  (widget-insert " 3*3=8\n")
  (widget-create 'checkbox :tag "p1-c" nil)
  (widget-insert " widgets are cool.\n")

  (widget-insert " \n\nSelect the best answer. \\sqrt{64} = \n\n")
  (widget-create 'radio-button-choice
		 :tag "p2" :value nil
		 '(item "2")
                 '(item "4")
		 '(item "8"))

  (widget-insert "\n\nWrite a long essay.\n")
  (widget-create 'editable-field
                  :format "Text: %v "
                  :tag "p3-essay"
                  :size 20)

  (widget-insert "\n")
  (widget-create 'push-button
		 :notify #'submit-quiz
		 "Submit")
  (widget-insert " ")
  (widget-create 'push-button
		 :notify (lambda (&rest ignore) (kill-buffer))
		 "Quit")

  (use-local-map widget-keymap)
  (widget-setup))
#+END_SRC

#+RESULTS:
: quiz1

Now, we just run [[elisp:(quiz1)]] and we get a "form" to fill out.

On my computer, I get this after I fill it out:

[[./images/quiz1.png]]


After I press submit, this gets emailed to me:

[[./images/quiz1-answers.png]]

It is obviously not perfect, since it did not capture the radio
buttons in a useful way, and it collected the Submit and Quit buttons,
since they are widgets. Those can probably all be fixed with better
code, or maybe more specific code.

It is not too simple to write a quiz like this, but with some
practice, and best practice development, it might be pretty
straightforward after a while. The benefits are a more tightly
controlled quiz environment. Submission may still be tricky, since at
least in this case I rely on Emacs being setup for email. Other
methods might work too, e.g. an http POST, or saving a file to a shared
location.

See these links too:
- http://www.emacswiki.org/emacs/widget-demo.el

* Using macro expansions in org-mode

#+EMAIL: jkitchin@andrew.cmu.edu

#+RANDOM-KEYWORD: interesting

#+MACRO: my-animal-macro  a $1 has $2

Send me mail at {{{email}}}. My response will be {{{random-keyword}}}. Finally, you may be interested to know that {{{my-animal-macro(zebra,stripes)}}}.

* Converting Endnote libraries to bibtex files
  :PROPERTIES:
  :categories: bibtex
  :END:
I have had a need lately to convert Endnote libraries into bibtex files. Endnote has a BibTeX-Export style that will export your library. One issue with that style is it expects you to have a label in each entry. If you are a normal Endnote user, you do not have labels on any entry. There is no need for them. I also found that for entries with no label, there is no comma in the entry header, which causes Emacs to think the entry is syntactically incorrect. I fixed up the style to prevent that from happening. You can get a copy of the style [[C:\Users\jkitchin\Documents\EndNote\Styles\BibTeX-Export-kitchin.ens][here]].

Now, if you load that style, you can export a library to a
file. Endnote insists on making it a text file. We need to rename the
file, then we need to create keys for each entry. Normally, I would do
that with =bibtex-clean-entry=, which mostly works by hand. However, the bibtex entries are not correct yet, because they have no keys. We will add simple numeric keys, and then map over each entry to add proper keys.

#
#+BEGIN_SRC python
from bibtexparser.bparser import BibTexParser
from bibtexparser.customization import convert_to_unicode
import textwrap

def format_bibtex_entry(entry):
    # field, format, wrap or not
    field_order = [(u'author', '{{{0}}},\n', True),
                   (u'title', '{{{0}}},\n', True),
                   (u'journal','"{0}",\n', True),
                   (u'volume','{{{0}}},\n', True),
                   (u'number', '{{{0}}},\n', True),
                   (u'pages', '{{{0}}},\n', True),
                   (u'year', '{0},\n', True),
                   (u'doi','{{{0}}},\n', False),
                   (u'url','{{\url{{{0}}}}},\n', False),
                   (u'link','{{\url{{{0}}}}},\n', False)]

    keys = set(entry.keys())

    extra_fields = keys.difference([f[0] for f in field_order])
    # we do not want these in our entry
    extra_fields.remove('type')
    extra_fields.remove('id')

    # Now build up our entry string
    s = '@{type}{{{id},\n'.format(type=entry['type'].upper(),
                                  id=entry['id'])

    for field, fmt, wrap in field_order:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = fmt.format(entry[field])
            s3 = '{0:17s}{1}'.format(s1, s2)
            if wrap:
                # fill seems to remove trailing '\n'
                s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    for field in extra_fields:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = entry[field]
            s3 = '{0:17s}{{{1}}}'.format(s1, s2)
            s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    s += '}\n\n'
    return s


import os
if os.path.exists('ternary-alloys-exported.bib'):
    os.unlink('ternary-alloys-exported.bib')

# get the entries
with open('ternary-alloys.bib', 'r') as bibfile:
    bp = BibTexParser(bibfile)
    entries = bp.get_entry_list()


for i, entry in enumerate(entries):
    # set key to a simple number
    entry['id'] = i
    with open('ternary-alloys-exported.bib', 'a') as f:
        f.write(format_bibtex_entry(entry))
#+END_SRC

#+RESULTS:


Ok, finally, our goal is consistency with Emacs. Now the entries are syntactically correct, and we can clean each entry. This block runs through each entry and replaces the numeric key with a key formatted our way. Unfortunately you still have to press enter for each entry.

#+BEGIN_SRC emacs-lisp
(find-file "ternary-alloys-exported.bib")
(bibtex-map-entries (lambda (entry start end)
(condition-case ex
    (bibtex-clean-entry t nil)
  ('error (message (format "Caught exception: [%s]" ex))))))
#+END_SRC

#+RESULTS:


[[./ternary-alloys-exported.bib]]




* Introspecting the variables in a python script

I want to build an emacs command that views an atoms, or prints a summary of a calculator in a code block. The idea is to get the python code in the block, run it in an interpreter, then view the atoms or print the calculator.

The reason I want to try this is that I often want a quick view of the atoms, but I do not want to import the module, write in the view line, and then comment them out.

#+BEGIN_SRC emacs-lisp
(defun get-source ()
  "mark region of source block"
  (interactive)
  (let ((case-fold-search nil)
	(start)
	(end))
    (re-search-backward "^#\\+BEGIN_SRC")
    (forward-line)
    (setq start (point))

    (re-search-forward "^#\\+END_SRC")
    (previous-line)
    (end-of-line)
    (setq end (point))
    ;(message-box "%s %s %s" start end (buffer-substring start end))
    (buffer-substring start end)))

(defun print-calculator ()
  "print any calculators found in *jasp-calculator*"
  (interactive)
  (python-shell-internal-send-string (concat (get-source) "\n"))

  (switch-to-buffer "*jasp-calculator*")
  (erase-buffer)
  (insert (python-shell-internal-send-string "
for k,v in globals().items():
    if isinstance(v, ase.calculators.vasp.Vasp):
        print v
")))

(defun view-atoms ()
  (interactive)
  "view any Atoms objects found"
  (python-shell-internal-send-string (concat (get-source) "\n"))
  (insert (python-shell-internal-send-string "
from ase.visualize import view

for k,v in globals().items():
    if isinstance(v, ase.atoms.Atoms):
        view(v)
")))

#+END_SRC

#+RESULTS:
: view-atoms

#+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

atoms = Atoms([Atom('O',[5, 5, 5], magmom=1)],
             cell=(6, 6, 6))

with jasp('O_sv',
          encut=300,
          xc='PBE',
          ispin=2,
          ismear=0,
          sigma=0.001,
          setups={'O':'_sv'}, # specifies O_sv potential
          atoms=atoms) as calc:
    print type(calc)
    print calc.__class__
    atoms.get_potential_energy()
#end
#+END_SRC

#+RESULTS:
: <type 'instance'>
: ase.calculators.vasp.Vasp
* Footnotes

[fn:1] Box Sync 4 renames your sync directory from "~/Documents/My Box Files" to "~/Box Sync".

[fn:2] You will have to read the raw org-source to see how the code-block arguments look.

[fn:3] It is true there are packages like FiPy (http://www.ctcms.nist.gov/fipy/) for PDEs, and scikits for BVPS, (http://scikits.appspot.com/bvp1lg, http://scikits.appspot.com/bvp_solver). But these are not easily installed on all platforms, and typically require some developer experience in compiling.

[fn:4] I know I can pretty conveniently collapse a code block by pressing tab on the header. Sometimes that is not enough.

[fn:5] It is not much harder, C-s will let you search for the named block. I do not know if there are nice convenient navigation commands for this.
