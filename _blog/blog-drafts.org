* images in export by uri

Here is an image for fun:

#+attr_org: :width 20%
[[./Au-icosahedron-3.png]]

#+BEGIN_SRC emacs-lisp
(defun org-image-data-uri (path)
  (let ((data (with-temp-buffer (insert-file-contents path) (buffer-string))))
(message "Data baby!")
    (concat "<img src=\""
            "data:image/png;charset=utf-8;base64,"
	    (base64-encode-string (encode-coding-string data 'binary) t)
	    "\"/>")))

(defun my-link (link contents info)
  (let ((type (org-element-property :type link))
	(path (org-element-property :path link)))
    (if (and (string= type "file")
	     (f-ext? path "png"))
	(org-image-data-uri path)
      (org-html-link link contents info))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((link . my-link)))

(browse-url (org-export-to-file 'my-html "embedded-image.html"))
#+END_SRC

#+RESULTS:
: #<process open /Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/embedded-image.html>



* Happy Thanksgiving!

Hi everyone! Today is a day we traditionally give thanks to many things in our lives we often take for granted: our friends, our families, the people around us. The semester is nearly finished, and as busy as it will get until it is over. Today I am taking some time to say thanks for everything this semester: your hard work, your patience, your perseverance at learning a lot of new things all at once. I am proud to see what you have learned so far and look forward to seeing you continue to grow as engineers.

As you know by now, no message would be complete without some code in it. First, we get an image we will use in a bit.

#+BEGIN_SRC sh
wget http://insanityflows.net/wp-content/uploads/2016/11/Happy-Thanksgiving.jpg
#+END_SRC

#+RESULTS:

Next, we consider that we have some delicious cranberry sauce, and that we eat it at a rate proportional to the amount of cranberry sauce that remains. We wonder how long it will take until it is half gone. Now you are all experts at this kind of modeling, and you can read off of the graph here to see it will take a little over 5 hours. The good news is, you will still have many hours after that to continue enjoying it! I hope you are all enjoying yourself today. Happy Thanksgiving!

#+RESULTS: thanksgiving
:RESULTS:
[[file:thanksgiving-batch.png]]
:END:

#+name: thanksgiving
#+BEGIN_SRC python :results output org drawer
import numpy as np
import matplotlib.pyplot as plt
from scipy.misc import imread
from scipy.integrate import odeint
import pycse.orgmode as org

Ca0 = 2 # M
k = 0.11  # 1/hr

def batch(Ca, t):
    return - k * Ca

tspan = np.linspace(0, 24)
Ca = odeint(batch, Ca0, tspan)

img = imread('Happy-Thanksgiving.jpg')

plt.imshow(img, zorder=0, extent=[0.0, 24.0, 0, 2], aspect='auto')
plt.plot(tspan, Ca, zorder=1)
plt.xlim([0, 24])

plt.xlabel('Time (hr)')
plt.ylabel('Ca (mol/L)')
org.figure(plt.savefig('thanksgiving-batch.png'))
#+END_SRC







* html bibentry


#+BEGIN_SRC emacs-lisp :results silent
(org-link-set-parameters
 "bibentry"
 :export (lambda (key desc backend)
	   "Convert KEY to a bibtex entry"
	   (org-ref-get-bibtex-entry-html key)))
#+END_SRC


bibentry:kitchin-2015-examp
* htmlize file links
http://emacs.stackexchange.com/questions/28480/why-arent-my-org-links-being-htmlized/28481#28481

 [[./06-364.pdf]]                 [[test]]

#+BEGIN_SRC emacs-lisp
(org-link-set-parameters nil :htmlize-link
			 (lambda ()
			   (let* ((link (org-element-context))
				  (type (org-element-property :type  link))
				  (path (org-element-property :path link)))
			     (list :uri (format "%s:%s" type path)))))
#+END_SRC

#+RESULTS:
| :htmlize-link | (lambda nil (let* ((link (org-element-context)) (type (org-element-property :type link)) (path (org-element-property :path link))) (list :uri (format %s:%s type path)))) |

(browse-url (with-current-buffer (htmlize-buffer) (write-file "test.html") "test.html"))

* Remote image urls

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "image-url"
 (lambda (path)
   (let ((img (expand-file-name
	       (concat (md5 path) "." (file-name-extension path))
	       temporary-file-directory)))
     (if (file-exists-p img)
	 (find-file img)
       (url-copy-file path img)
       (find-file img)))))
#+END_SRC

#+RESULTS:
| lambda | (path) | (let ((img (expand-file-name (concat (md5 path) . (file-name-extension path)) temporary-file-directory))) (if (file-exists-p img) (find-file img) (url-copy-file path img) (find-file img))) |

[[image-url:https://d1ra4hr810e003.cloudfront.net/media/27FB7F0C-9885-42A6-9E0C19C35242B5AC/0/D968A2D0-35B8-41C6-A94A0C5C5FCA0725/F0E9E3EC-8F99-4ED8-A40DADEAF7A011A5/dbe669e9-40be-51c9-a9a0-001b0e022be7/thul-IMG_2100.jpg]]


Now, we write a function to make the overlays.

#+BEGIN_SRC emacs-lisp
(defun image-url-overlays ()
  "Put image overlays on remote image urls."
  (interactive)
  (loop for image-url in (org-element-map (org-element-parse-buffer) 'link
			   (lambda (link)
			     (when (string= "image-url" (org-element-property :type link))
			       link)))
	do
	(let* ((path (org-element-property :path image-url))
	       (ov (make-overlay (org-element-property :begin image-url)
				 (org-element-property :end image-url)))
	       (img (create-image (expand-file-name
				   (concat (md5 path)
					   "."
					   (file-name-extension
					    path))
				   temporary-file-directory))))
	  (overlay-put ov 'display img)
	  (overlay-put ov 'image-url t))))

(defun image-url-clear-overlays ()
  "Reove overlays on image-urls."
  (interactive)
  (require 'ov)
  (ov-clear 'image-url))
#+END_SRC
#+RESULTS:
: image-url-clear-overlays

#+BEGIN_SRC emacs-lisp

#+END_SRC

#+RESULTS:


* Copying images around

(with-temp-buffer
  (insert-file-contents "~/Desktop/Screen Shot 2016-08-15 at 4.21.35 PM.png")
  (hexlify-buffer)
  (let ((hex (mapconcat (lambda (line)
			  (replace-regexp-in-string " " "" line))
			(delete-extract-rectangle 11 (progn (goto-char (point-max))
							    (previous-line)
							    (beginning-of-line)
							    (forward-char 49)
							    (point)))
			"")))
    (with-temp-buffer
      (insert (format "{\\rtf1\\ansi\\deff0
	{\\pict\\pngblip\\picw10449\\pich3280\\chgoal1860 %s}}"
		      hex))
      (shell-command-on-region (point-min) (point-max) "pbcopy"))))

#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (insert-file-contents "~/Desktop/Screen Shot 2016-08-15 at 4.21.35 PM.png")
  (hexlify-buffer)
  (let ((hex (mapconcat (lambda (line)
			  (replace-regexp-in-string " " "" line))
			(delete-extract-rectangle 11 (progn (goto-char (point-max))
							    (previous-line)
							    (beginning-of-line)
							    (forward-char 49)
							    (point)))
			"")))
    (with-temp-buffer
      (insert (format "{\\rtf1\\ansi\\deff0
	{\\pict\\pngblip\\picw10449\\pich3280\\chgoal1860 %s}}"
		      hex))
      (shell-command-on-region (point-min) (point-max) "pbcopy"))))
#+END_SRC

#+RESULTS:
: 0

* test looking-back

#+BEGIN_SRC emacs-lisp
(defun f1 ()
  (interactive)
  (let ((type "cite:"))
    (forward-char (length type))
    (re-search-backward type)))
#+END_SRC

#+RESULTS:
: f1

   cite:test


#+BEGIN_SRC emacs-lisp
(defun f2 ()
  (interactive)
  (when (looking-back "cite:" (point-min) t)
    (goto-char (match-beginning 0))))
#+END_SRC

#+RESULTS:
: f2

* sys.displayhook

#+BEGIN_SRC python :results output org drawer
from sympy import pprint
import numpy as np
#import sys; sys.displayhook = pprint

print(np.array([[1, 2], [3, 4]]))
#+END_SRC

#+RESULTS:
:RESULTS:
[[1 2]
 [3 4]]
:END:

#+BEGIN_SRC python :results org drawer
import sympy
print(sympy.pprint)
#+END_SRC

#+RESULTS:
:RESULTS:
None
:END:

* A new navigation hydra

use ijkl for navigation.

j left/back
i up/previous
k down /next
l right/forward

use awp to switch char/word/paragraph
a char
s subword
w word
p paragraph
g page
b buffer
x sexp


#+BEGIN_SRC emacs-lisp

(defvar gravy-forward 'forward-char
  "The next item in a forward sense.")

(defvar gravy-backward 'backward-char
  "The previous item in a backward sense.")

(defvar gravy-up 'previous-line
  "The previous item in an up sense.")

(defvar gravy-down 'next-line
  "The next item in a down sense.")

(defvar gravy-avy-1 'avy-goto-char-in-line
  "Preferred avy for item.")

(defvar gravy-avy-2 'avy-goto-char-2
  "Preferred 2nd avy")

(defvar gravy-avy-3 'avy-goto-line
  "Preferred 3rd avy")

(defvar gravy-beginning 'beginning-of-visual-line
  "The beginning of an item.")

(defvar gravy-end 'end-of-visual-line
  "The end of an item.")


(defhydra gravy (:color red :hint nil)
  "
_j_: ← _i_: ↑ _k_: ↓ _l_: →
"
  ("j" (funcall gravy-backward))
  ("l" (funcall gravy-forward))
  ("i" (funcall gravy-up))
  ("k" (funcall gravy-down))

  ("q" nil "quit" :color blue)

  ("h" (call-interactively gravy-beginning))
  (";" (call-interactively gravy-end))

  ("'" (call-interactively gravy-avy-1))
  ("," (call-interactively gravy-avy-2))
  ("." (call-interactively gravy-avy-3))

  ("<" beginning-of-buffer)
  (">" end-of-buffer)
  ;; these are different modes
  ;; char
  ("c" (lambda ()
	 (interactive)
	 (setq gravy-backward 'backward-char
	       gravy-up 'previous-line
	       gravy-forward 'forward-char
	       gravy-down 'next-line
	       gravy-avy-1 'avy-goto-char-in-line
	       gravy-avy-2 'avy-goto-char-2
	       gravy-avy-3 'avy-goto-line))
   "char mode")
  ("w" (lambda ()
	 (interactive)
	 (setq gravy-backward 'backward-word
	       gravy-up 'previous-line
	       gravy-forward 'forward-word
	       gravy-down 'next-line
	       gravy-avy-1 'avy-goto-char-in-line
	       gravy-avy-2 avy-goto-word-1
	       gravy-avy-3 avy-goto-word-or-subword-1))
   "word mode")
  ("s" (lambda ()
	 (interactive)
	 (setq gravy-backward 'backward-sentence
	       gravy-up 'previous-line
	       gravy-down 'next-line
	       gravy-forward 'forward-sentence
	       gravy-avy-1 'avy-goto-char-in-line
	       gravy-avy-2 avy-goto-char-2
	       gravy-avy-3 avy-goto-word-1))
   "sentence mode")

  ("p" (lambda ()
	 (interactive)
	 (setq gravy-backward 'backward-paragraph
	       gravy-forward 'forward-paragraph
	       gravy-up 'previous-line
	       gravy-down 'next-line
	       gravy-avy-1 'avy-goto-char-in-line
	       gravy-avy-2 avy-goto-char-2
	       gravy-avy-3 avy-goto-line))
   "paragraph mode")

  ("x" (lambda ()
	 (interactive)
	 (setq gravy-backward 'backward-sexp
	       gravy-forward 'forward-sexp
	       gravy-up 'previous-line
	       gravy-down 'next-line
	       gravy-avy-1 'avy-goto-char-in-line
	       gravy-avy-2 'lispy-ace-paren
	       gravy-avy-3 'lispy-ace-symbol))
   "sexp mode"))

#+END_SRC

#+RESULTS:
: gravy/body


* biblio arxiv

#+BEGIN_SRC emacs-lisp
(define-key biblio-selection-mode-map (kbd "o") #'org-ref-biblio-arxiv)

(defun org-ref-biblio-arxiv (&optional arg)
  (interactive)
  (biblio--selection-copy)
  (with-current-buffer (find-file-noselect (completing-read
					    "Bibfile: "
					    org-ref-bibliography-files
					    nil t
					    (car org-ref-bibliography-files)))
    (goto-char (point-max))
    (yank)
    (insert "\n\n")
    (org-ref-bibtex-previous-entry)
    (org-ref-clean-bibtex-entry)))
#+END_SRC

* Goto a named table in org-mode

#+name: goto-table
#+BEGIN_SRC emacs-lisp
(defun org-goto-named-table (&optional name)
  "Jump to a named table."
  (interactive)
  (let ((tables '())
	(case-fold-search t))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^#\\+tblname: +\\(.*\\)$" nil t)
	(pushnew (cons (match-string 1) (match-beginning 0)) tables)))
    (if name
	(goto-char (cdr (assoc name tables)))
      (goto-char (cdr (assoc (org-icompleting-read
			      "Table name: " (mapcar 'car tables)
			      nil t)
			     tables))))))
#+END_SRC

#+RESULTS: goto-table
: org-goto-named-table

#+RESULTS:
: org-goto-named-table





#+tblname: some-table
| 3 | 4 | 5 |


#+TBLNAME: some-other-table
| 3 | 4 | 5 |


* helm-tagger			:tag1:engineering:

#+BEGIN_SRC emacs-lisp
(defun helm-tagger ()
  (interactive)
  (helm
   :sources
   `((name . "HELM tag setter")
     (candidates . ,(mapcar 'car org-tag-persistent-alist))
     (action . (lambda (candidate)
                 (org-set-tags-to (helm-marked-candidates)))))))
#+END_SRC



(require 'counsel)
(require 'jedi)
* Cleaning up the pyshow directory

I want to get rid of files that are not linked anymore. these

#+BEGIN_SRC python
import os
import re
import glob

imgs = []

for orgfile in glob.glob('*.org'):
    with open(orgfile, 'r') as f:
        try:
            contents = f.read()
            imgs += re.findall(u'\[\[file:(pyshow/[0-9a-z]*\.png)\]\]', contents)
        except:
            print('Could not read {}'.format(orgfile))

print(imgs)

for png in (glob.glob('pyshow/*.png')):
    if png not in imgs:
        os.unlink(png)

print(glob.glob('pyshow/*.png'))
#+END_SRC

#+RESULTS:
: Could not read ase-db.org
: ['pyshow/56bc77cfebd90f8a1cb22421c1c4f2c4a05fedeb.png', 'pyshow/2daee706d3b906a25914a6ca975906047af7fa35.png']
: ['pyshow/2daee706d3b906a25914a6ca975906047af7fa35.png', 'pyshow/56bc77cfebd90f8a1cb22421c1c4f2c4a05fedeb.png']

* ob-ipython
https://github.com/gregsexton/ob-ipython

You can ask the running IPython kernel for documentation. Open a SRC block, place the point on the thing you’re interested in and run

M-x ob-ipython-inspect

I recommend you bind this to a key.

It’s often easier to play with code using a REPL. With the point in an ipython SRC block, you can open a REPL connected to the current kernel by running C-c C-v C-z. I recommend you do this anyway, as python-mode can now use this REPL to provide completion in code buffers.

If evaluated code produces an error, this will be displayed nicely in a buffer using IPython’s traceback support.

Stdout from code evaluation is displayed in a popup buffer. This is great for debugging or getting verbose output that is best left out of documents. If you wish to capture stdout in your document use the :results output SRC block header.
You can interrupt or kill a running kernel. This is helpful if things get stuck or really broken. See

M-x ob-ipython-interrupt-kernel
M-x ob-ipython-kill-kernel

(require 'ob-ipython)

#+BEGIN_SRC ipython :session :results output
print(6)
#+END_SRC

#+RESULTS:
: 6


#+BEGIN_SRC ipython :session :results value
%matplotlib inline

import matplotlib.pyplot as plt

plt.plot([1, 2, 3])
#+END_SRC

#+RESULTS:
: [<matplotlib.lines.Line2D at 0x10dac2c88>]

* helm tag setter		       :tag1:tag3:

#+BEGIN_SRC emacs-lisp
(defun tag-lister ()
  "Function that gets and returns possible tags."
  (list "tag1" "tag2" "tag3"))

(defun helm-tagger ()
  (interactive)
  (helm
   :sources
   `((name . "HELM tag setter")
     (candidates . ,(tag-lister))
     (action . (lambda (candidate)
		 (org-set-tags-to (helm-marked-candidates)))))))


#+END_SRC

#+RESULTS:
: helm-tagger

* Symmetry equivalent atoms with spglib

#+BEGIN_SRC python
import pycse.orgmode as org
from ase import Atom, Atoms
import numpy as np

B = 'Ti'; X = 'O'; a = 3.7842; c = 2*4.7573; z = 0.831;

a1 = a * np.array([1.0, 0.0, 0.0])
a2 = a * np.array([0.0, 1.0, 0.0])
a3 = np.array([0.5 * a, 0.5 * a, 0.5 * c])

atoms = Atoms([Atom(B, -0.125 * a1 + 0.625 * a2 + 0.25 * a3),
               Atom(B,  0.125 * a1 + 0.375 * a2 + 0.75 * a3),
               Atom(X, -z*a1 + (0.25-z)*a2 + 2.*z*a3),
               Atom(X, -(0.25+z)*a1 + (0.5-z)*a2 + (0.5+2*z)*a3),
               Atom(X, z*a1 - (0.25 - z)*a2 + (1-2*z)*a3),
               Atom(X, (0.25 + z)*a1 + (0.5 + z)*a2 + (0.5-2*z)*a3)],
               cell=[a1,a2,a3])

org.result(atoms)

import spglib as sp
org.result(sp.find_primitive(atoms))
org.comment('')
org.result(sp.get_symmetry_dataset(atoms)['equivalent_atoms'])
#+END_SRC
#+RESULTS:
:RESULTS:
: Atoms(symbols='Ti2O4', positions=..., cell=[[3.7842, 0.0, 0.0], [0.0, 3.7842, 0.0], [1.8921, 1.8921, 4.7573]], pbc=[False, False, False])
: (array([[-1.8921,  1.8921,  4.7573],
:        [ 1.8921, -1.8921,  4.7573],
:        [ 1.8921,  1.8921, -4.7573]]), array([[ 0.75 ,  0.25 ,  0.5  ],
:        [ 0.   ,  0.   ,  0.   ],
:        [ 0.956,  0.956,  0.   ],
:        [ 0.706,  0.206,  0.5  ],
:        [ 0.794,  0.294,  0.5  ],
:        [ 0.044,  0.044,  0.   ]]), array([22, 22,  8,  8,  8,  8], dtype=int32))

: [0 0 2 2 2 2]
:END:


* Getting matplotlib figs


#+BEGIN_SRC python
import matplotlib.pyplot as plt

plt.plot([5, 6, 7, 8])

figs = list(map(plt.figure, plt.get_fignums()))
#print(figs)


#for i in plt.get_fignums():
#    plt.figure(i)
#    plt.savefig('figure%d.png' % i)
#+END_SRC
#+RESULTS:
: y

so i can get the figures. they need to be saved, and put in the buffer to see them inline. if saved, they need unique, reproducible filenames. probably hash-n.png in a directory. unless the code-block has a name. then name-1.png

IDea 2: patch matplotlib.pyplot.savefig

https://github.com/jkitchin/pycse/blob/master/pycse/publish.py
* error catching
#+BEGIN_SRC emacs-lisp
(defun pydoc-user-modules ()
  "Return a list of strings for user-installed modules."
  (mapcar
   'symbol-name
   (read
    (shell-command-to-string
     "python -c \"import pipp; mods = sorted([i.key for i in pip.get_installed_distributions()]); print('({})'.format(' '.join(['\"{}\"'.format(x) for x in mods])))  \""))))

(condition-case err
    (pydoc-user-modules)
  (wrong-type-argument
   (princ (format "Error caught: %s" err))
   '()))
#+END_SRC

#+RESULTS:
| t |

#+BEGIN_SRC emacs-lisp
(setq baz 34)

(condition-case err
    (if (eq baz 35)
        t
      ;; This is a call to the function error.
      (error "Rats!  The variable %s was %s, not 35" 'baz baz))
  ;; This is the handler; it is not a form.
  (error (princ (format "The error was: %s" err))
         2))
#+END_SRC

#+RESULTS:
: 2

* links in src

in comments they do not export.
#+BEGIN_SRC emacs-lisp
(princ "Hello World!")  ;; [[http://stackoverflow.com/blabla1234][Got this from SO.]]
(princ "Hello World!")  ;; <a href="http://stackoverflow.com/blabla1234">
#+END_SRC

#+RESULTS:
: Hello World!

* python 2
#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:python2 (body params)
  (let ((org-babel-python-command "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/bin/python2"))
    (org-babel-execute:python body params)))

#+END_SRC


#+BEGIN_SRC python2
print 'Hello'
#+END_SRC
#+RESULTS:
: Hello


* Getting tooltips on Vasp keywords
  :PROPERTIES:
  :categories: python,vasp,lisp,emacs
  :END:

We do a lot of molecular simulations, and I do a fair bit of teaching people how to do molecular simulations, particularly using Vasp for density functional theory calculations. One of the limitations I have come across is the disconnect between documentation and simulations. The documentation for Vasp is on webpages, and not accessible from Python, or Emacs. This makes it also difficult to validate parameters, or easily access what the parameters do, and what values they can take. =jasp= has been a workhorse for us for a while, but it is time to consider a rewrite (you can see the work in progress here: https://github.com/jkitchin/vasp).  I have a few goals for this:

1. Use the ase Calculator interface with native support of ase-db
2. Make functional programming possible, and especially to enable hy for molecular simulation
3. Simplify the interface and maintenance - no list of keywords
4. Add validation and documentation to the keywords

I am going to talk about the 4th point here. I started a vasp.validate module. It has functions and docstrings for many keywords. It has a function called keywords that returns ... wait for it ... a list of keywords defined in the module, in a form easy for Lisp to digest. Here it is.

#+BEGIN_SRC python
from vasp.validate import keywords
print keywords()
#+END_SRC

#+RESULTS:
: ("ediffg" "encut" "ibrion" "isif" "ismear" "ispin" "nsw" "prec" "sigma" "xc")

That function will keep the list up to date based on what is defined in the module. We can access the docstring of each keyword like this.

#+BEGIN_SRC python
from vasp.validate import ibrion
print(ibrion.__doc__)
#+END_SRC

#+RESULTS:
: IBRION determines how the ions are updated and moved.

We can get these functionally into Emacs like this:

#+BEGIN_SRC emacs-lisp
(defun vasp-keywords ()
  "Returns a list of vasp keywords."
  (read
   (shell-command-to-string
    "python -c \"from vasp.validate import keywords; print keywords()\"")))

(vasp-keywords)
#+END_SRC

#+RESULTS:
| ediffg | encut | ibrion | isif | ismear | ispin | nsw | prec | sigma | xc |

And we can get to the docstrings in Emacs too.

#+BEGIN_SRC emacs-lisp
(defun vaspdoc (keyword)
  "Get docstring for KEYWORD."
  (shell-command-to-string
   (format
    "python -c \"from vasp.validate import %s; print(%s.__doc__)\""
    keyword keyword)))

(vaspdoc "ibrion")
#+END_SRC
#+RESULTS:
: IBRION determines how the ions are updated and moved.

We can put these together with font-lock to provide tooltips. First, here is a regexp that will find the words we want.

#+BEGIN_SRC emacs-lisp
(defvar *vasp-keywords-regex*
  (regexp-opt (vasp-keywords))
  "Regexp for vasp keywords.")
#+END_SRC
#+RESULTS:
: *vasp-keywords-regex*

Now we use this recipe to provide tooltips and clickable text for the keywords we know how to validate and have documentation for. We modify the docstring a bit, so only the first line is the tooltip, and clicking on the keyword opens a pydoc window of the full docstring.

#+BEGIN_SRC emacs-lisp
(defun vasp-tooltip-1 (window object position)
  "Get the one line tooltip for the keyword under point."
  (save-excursion
    (goto-char position)
    (car (s-split "\n" (vaspdoc (thing-at-point 'word))))))

(defun next-vasp-keyword (&optional limit)
  "Find vasp keywords."
  (while (re-search-forward *vasp-keywords-regex* limit t)
    (flyspell-delete-region-overlays (match-beginning 0)
				     (match-end 0))
    (let ((map (make-sparse-keymap)))
      (define-key map [mouse-1]
	(lambda ()
	  (interactive)
	  (pydoc (format "vasp.validate.%s" (thing-at-point 'word)))))
      (add-text-properties
       (match-beginning 0)
       (match-end 0)
       (list
	'help-echo 'vasp-tooltip
	'local-map map
	'face 'font-lock-keyword-face
	'mouse-face 'highlight)))))

(font-lock-add-keywords
 nil
 `((next-vasp-keyword 0 font-lock-keyword-face)) t)
#+END_SRC


Here is a list of the currently defined keywords to test out the idea.

ediffg encut ibrion isif ismear ispin nsw prec sigma xc

Here it is in Python, to get a sense for how it is going to look. cite:2006-acs-style-guide,2007-basic-resear-needs,2010-reprod-resear,2011-mater-genom

#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('some-dir',
            encut=350,
            xc='pbe',
            sigma=0.2,
            ibrion=2)
#+END_SRC

This looks like it will be great. Now to integrate the validation code into vasp.py and give it a shot!

#+BEGIN_SRC hy
(import vasp [Vasp])

(setv calc (Vasp "some-dir" :encut 450))
#+END_SRC

* vasp test


#+BEGIN_SRC python
from ase.calculators.vasp import Vasp
from ase import Atom, Atoms
import os

os.chdir('/tmp')
co = Atoms([Atom('C',[0,   0, 0]),
            Atom('O',[1.2, 0, 0])],
            cell=(6., 6., 6.))

calc = Vasp(xc='PBE',  # the exchange-correlation functional
            nbands=6,  # number of bands
            encut=350, # planewave cutoff
            ismear='10.0',  # Methfessel-Paxton smearing
            sigma=0.01,# very small smearing factor for a molecule
            lhfcalc=0.2)

calc.spinpol=False

co.set_calculator(calc)

calc.write_incar(co)
print calc

print open('/tmp/INCAR').read()

#+END_SRC

#+RESULTS:

* Pelican link
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pelican"
 (lambda (path) (org-open-file path))
 ;; ; export
 (lambda (path desc backend)
   (cond
    ((eq backend 'html)
     (format "{filename}/%s" (file-relative-name path))))))
#+END_SRC


Link to internal content pelican:/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org

#+BEGIN_SRC sh
pwd
#+END_SRC

#+RESULTS:
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog

exports to:
<p>
Link to internal content {filename}/blog.org
</p>



[[foo bar]]
* Import arxiv pdfs

#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (insert (shell-command-to-string (format "%s %s -"
					   pdftotext-executable
					   "~/Desktop/1409.7985.pdf")))
  (goto-char (point-min))
  (let ((matches '()))
    (while (re-search-forward "arxiv:\\(.*?\\..*?\\)v" nil t)
      ;; I don't know how to avoid a trailing . on some dois with the
      ;; expression above, so if it is there, I chomp it off here.
      (let ((m (match-string 1)))
	(cl-pushnew m matches :test #'equal)
	))
    matches))
#+END_SRC

#+RESULTS:
| 1409.7985 |


#+BEGIN_SRC emacs-lisp
(arxiv-get-bibtex-entry (arxiv-get-bibliographic-code "1409.7985"))
#+END_SRC

#+RESULTS:
#+begin_example

@ARTICLE{2014arXiv1409.7985S,
   author = {{Sim}, Y. and {Routledge}, B. and {Smith}, N.~A.},
    title = "{The Utility of Text: The Case of Amicus Briefs and the Supreme Court}",
  journal = {ArXiv e-prints},
archivePrefix = "arXiv",
   eprint = {1409.7985},
 primaryClass = "cs.CL",
 keywords = {Computer Science - Computation and Language, Computer Science - Artificial Intelligence, Computer Science - Computer Science and Game Theory, Computer Science - Learning},
     year = 2014,
    month = sep,
   adsurl = {http://adsabs.harvard.edu/abs/2014arXiv1409.7985S},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

#+end_example


* A better monkey patch by decoration

None other than Guido van Rossum brought up ways to monkey patch a class here:
https://mail.python.org/pipermail/python-dev/2008-January/076194.html. I use monkey patching in jasp /everywhere/. Here I add some functionality

#+BEGIN_SRC python
def monkeypatch_method(cls):
    def decorator(func):
        setattr(cls, func.__name__, func)
        s = ('\n\nMonkey-patch defined in '
             '{f.func_code.co_filename} '
             'at line {f.func_code.co_firstlineno}')
        func.__doc__ +=  s.format(f=func)
        return func
    return decorator

from ase.calculators.vasp import Vasp

@monkeypatch_method(Vasp)
def newfunc(self, a, b):
    "Return a + b."
    return a + b

help(Vasp.newfunc)

c = Vasp()
print c.newfunc(1, 2)
help(c.newfunc)
#+END_SRC




#+BEGIN_SRC python
def monkeypatch_class(name, bases, namespace):
    assert len(bases) == 1, "Exactly one base class required"
    base = bases[0]
    for name, value in namespace.iteritems():
        if name != "__metaclass__":
            setattr(base, name, value)
    return base

# To use:

from ase.calculators.vasp import Vasp

class VASP(Vasp):
    __metaclass__ = monkeypatch_class

    def newfunc(self):
        return 'done'

#This adds <method1>, <method2>, etc. to <someclass>, and makes
#<newclass> a local alias for <someclass>.

v = VASP()

print v.newfunc()
#+END_SRC

#+RESULTS:
: done






* Subclassing ase.calculators.vasp
this lets me add some kwargs to Vasp. Now if I can combine this with the metaclass and restart, we might be good!

#+BEGIN_SRC python
import os
import types

class WithCurrentDirectory(type):
   """Metaclass that decorates all of its methods except __init__."""
   def __new__(cls, name, bases, attrs):
      return super(WithCurrentDirectory, cls).__new__(cls, name, bases, attrs)

   def __init__(cls, name, bases, attrs):
      """Decorate all the methods of the class instance with the classmethod cd.

      We skip __init__ because that is where the attributes are actually set.
      It is an error to access them before they are set.
      """
      print bases, bases[0], dir(bases[0])
      print bases, bases[1], dir(bases[1])
      print 'atts: ',attrs
      for attr_name, attr_value in attrs.iteritems():
         if attr_name != '__init__' and isinstance(attr_value, types.FunctionType):
            setattr(cls, attr_name, cls.cd(attr_value))
            print 'set ',cls, attr_name

      # hack for this example
      for attr_name,attr_value in bases[1].__dict__.iteritems():
         if isinstance(attr_value, types.FunctionType):
            setattr(cls, attr_name, cls.cd(attr_value))

   @classmethod
   def cd(cls, func):
      """Decorator to temporarily run cls.func in the directory stored in cls.wd.

      The working directory is restored to the original directory afterwards.
      """
      print cls, func; import sys; sys.exit()
      def wrapper(self, *args, **kwargs):
         if self.verbose:
            print('\nRunning {}'.format(func.__name__))
            print("Started in {}".format(os.getcwd()))
         os.chdir(self.wd)
         if self.verbose:
            print("  Entered {}".format(os.getcwd()))
         try:
            result = func(self, *args, **kwargs)
            if self.verbose:
               print('  {}'.format(result))
            return result
         except Exception, e:
            # this is where you would use an exception handling function
            print('  Caught {}'.format(e))
            pass
         finally:
            os.chdir(self.owd)
            if self.verbose:
               print("  Exited to {}\n".format(os.getcwd()))

      wrapper.__name__ = func.__name__
      wrapper.__doc__ = func.__doc__
      return wrapper

#from jasp import *
import jasp.jasp_extensions  # adds some of the jasp extensions
import logging
from ase import Atom, Atoms
import ase.calculators.vasp

class VASP(object, ase.calculators.vasp.Vasp):
    __metaclass__ = WithCurrentDirectory
    def __init__(self, wd,
                 verbose=True,
                 debug=None,
                 atoms=None,
                 ,**kwargs):
        self.wd = wd
        self.verbose = verbose
        ase.calculators.vasp.Vasp.__init__(self, **kwargs)
        atoms.calc = self



co = Atoms([Atom('C',[0,   0, 0]),
            Atom('O',[1.2, 0, 0])],
            cell=(6., 6., 6.))

calc = VASP('/tmp/simple-co', #output dir
            xc='PBE',  # the exchange-correlation functional
            nbands=6,  # number of bands
            encut=350, # planewave cutoff
            ismear=1,  # Methfessel-Paxton smearing
            sigma=0.01,# very small smearing factor for a molecule
            verbose=True, debug=logging.DEBUG,
            atoms=co)

print calc

#+END_SRC

#+RESULTS:
: (<type 'object'>, <class ase.calculators.vasp.Vasp at 0x1068f5460>) <type 'object'> ['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
: (<type 'object'>, <class ase.calculators.vasp.Vasp at 0x1068f5460>) ase.calculators.vasp.Vasp ['__doc__', '__init__', '__module__', '__repr__', '__str__', 'add_to_db', 'archive', 'bader', 'calculate', 'calculation_required', 'check_state', 'chgsum', 'clean', 'clone', 'create_metadata', 'dict', 'get_atoms', 'get_beefens', 'get_bz_k_points', 'get_charge_density', 'get_default_number_of_electrons', 'get_dipole_moment', 'get_eigenvalues', 'get_elapsed_time', 'get_electronic_temperature', 'get_elf', 'get_energy_components', 'get_fermi_level', 'get_forces', 'get_ibz_k_points', 'get_ibz_kpoints', 'get_infrared_intensities', 'get_k_point_weights', 'get_local_potential', 'get_magnetic_moment', 'get_magnetic_moments', 'get_name', 'get_nearest_neighbor_table', 'get_neb', 'get_nonselfconsistent_energies', 'get_number_of_bands', 'get_number_of_electrons', 'get_number_of_grid_points', 'get_number_of_ionic_steps', 'get_number_of_iterations', 'get_number_of_spins', 'get_occupation_numbers', 'get_orbital_occupations', 'get_potential_energy', 'get_property', 'get_pseudo_density', 'get_pseudo_wavefunction', 'get_pseudopotentials', 'get_required_memory', 'get_spin_polarized', 'get_stress', 'get_valence_electrons', 'get_version', 'get_vibrational_frequencies', 'get_vibrational_modes', 'get_xc_functional', 'initialize', 'is_neb', 'job_in_queue', 'json', 'name', 'org', 'plot_neb', 'post_run_hooks', 'prepare_input_files', 'pretty_json', 'python', 'read', 'read_convergence', 'read_default_number_of_electrons', 'read_dipole', 'read_eigenvalues', 'read_electronic_temperature', 'read_energy', 'read_fermi', 'read_forces', 'read_ibz_kpoints', 'read_incar', 'read_k_point_weights', 'read_kpoints', 'read_ldau', 'read_magnetic_moment', 'read_magnetic_moments', 'read_metadata', 'read_nbands', 'read_number_of_electrons', 'read_number_of_iterations', 'read_occupation_numbers', 'read_outcar', 'read_potcar', 'read_relaxed', 'read_stress', 'read_version', 'read_vib_freq', 'register_post_run_hook', 'register_pre_run_hook', 'restart_load', 'results', 'run', 'set', 'set_atoms', 'set_nbands', 'set_results', 'strip', 'strip_warnings', 'todict', 'update', 'write_incar', 'write_kpoints', 'write_metadata', 'write_potcar', 'write_sort_file', 'xml']
: atts:  {'__module__': '__main__', '__metaclass__': <class '__main__.WithCurrentDirectory'>, '__init__': <function __init__ at 0x10692fcf8>}
: <class '__main__.WithCurrentDirectory'> <function pretty_print at 0x106918230>


* Automatic actions when entering an org heading
  :PROPERTIES:
  :END:
  :LOGBOOK:
  CLOCK: [2016-04-26 Tue 11:28]--[2016-04-26 Tue 11:28] =>  0:00
  CLOCK: [2016-04-26 Tue 11:28]--[2016-04-26 Tue 11:28] =>  0:00
  CLOCK: [2016-04-26 Tue 11:23]--[2016-04-26 Tue 11:23] =>  0:00
  CLOCK: [2016-04-26 Tue 11:23]--[2016-04-26 Tue 11:23] =>  0:00
  CLOCK: [2016-04-26 Tue 11:22]--[2016-04-26 Tue 11:23] =>  0:01
  CLOCK: [2016-04-26 Tue 11:20]--[2016-04-26 Tue 11:20] =>  0:00
  CLOCK: [2016-04-26 Tue 11:20]--[2016-04-26 Tue 11:20] =>  0:00
  CLOCK: [2016-04-26 Tue 11:20]--[2016-04-26 Tue 11:20] =>  0:00
  CLOCK: [2016-04-26 Tue 11:19]--[2016-04-26 Tue 11:19] =>  0:00
  CLOCK: [2016-04-26 Tue 11:12]--[2016-04-26 Tue 11:18] =>  0:06
  :END:
  :PROPERTIES:
  :AUTOCLOCK: t
  :END:

org-clock-marker

org-clock-in


post-command-hook


#+BEGIN_SRC emacs-lisp
(defun action-1 ()
  "hook function to run in headings with a clock"
  (and (eq major-mode 'org-mode)
       (not (org-before-first-heading-p)))
  (if (org-entry-get (point) "AUTOCLOCK")
      (org-clock-in)
    (when (marker-buffer org-clock-marker) (org-clock-out))))

(add-hook 'post-command-hook 'action-1)
#+END_SRC

#+RESULTS:
| action-1 | matlab-start-block-highlight-timer | eldoc-schedule-timer |

** test
   :PROPERTIES:
   :END:
   :LOGBOOK:
   CLOCK: [2016-04-26 Tue 11:24]--[2016-04-26 Tue 11:24] =>  0:00
   CLOCK: [2016-04-26 Tue 11:23]--[2016-04-26 Tue 11:24] =>  0:01
   CLOCK: [2016-04-26 Tue 11:23]--[2016-04-26 Tue 11:23] =>  0:00
   :END:
   :PROPERTIES:
   :AUTOCLOCK: t
   :END:





* pdfview
pdfview:./pdfsync.pdf::2

#+BEGIN_SRC emacs-lisp
;;; org-pdfview.el --- Support for links to documents in pdfview mode -*- lexical-binding: t; -*-

;; Copyright (C) 2014 Markus Hauck

;; Author: Markus Hauck <markus1189@gmail.com>
;; Maintainer: Markus Hauck <markus1189@gmail.com>
;; Keywords: org, pdf-view, pdf-tools
;; Version: 0.1
;; Package-Requires: ((org "6.01") (pdf-tools "0.40"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:
;; Add support for org links from pdfview buffers like docview.
;;
;; To enable this automatically, use:
;;     (eval-after-load 'org '(require 'org-pdfview))

;; If you want, you can also configure the org-mode default open PDF file function.
;;     (add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
;;     (add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))

;;; Code:
(require 'org)
(require 'pdf-tools)
(require 'pdf-view)

(org-add-link-type "pdfview" 'org-pdfview-open 'org-pdfview-export)
(add-hook 'org-store-link-functions 'org-pdfview-store-link)

(defun org-pdfview-open (link)
  "Open LINK in pdf-view-mode."
  (setq link (substring-no-properties link))
  (cond ((string-match "\\(.*\\)::\\([0-9]*\\)\\+\\+\\([[0-9]\\.*[0-9]*\\)"  link)
         (let* ((path (match-string 1 link))
                (page (string-to-number (match-string 2 link)))
                (height (string-to-number (match-string 3 link))))
           (org-open-file path 1)
           (pdf-view-goto-page page)
           (image-set-window-vscroll
            (round (/ (* height (car (pdf-view-image-size))) (frame-char-height))))))
        ((string-match "\\(.*\\)::\\([0-9]+\\)$"  link)
         (let* ((path (match-string 1 link))
                (page (string-to-number (match-string 2 link))))
(message-box "%s - %s" path page)
           (org-open-file path 1)
           (pdf-view-goto-page page)))
        (t
         (org-open-file link 1))
        ))

(defun org-pdfview-store-link ()
  "Store a link to a pdfview buffer."
  (when (eq major-mode 'pdf-view-mode)
    ;; This buffer is in pdf-view-mode
    (let* ((path buffer-file-name)
           (page (pdf-view-current-page))
           (link (concat "pdfview:" path "::" (number-to-string page))))
      (org-store-link-props
       :type "pdfview"
       :link link
       :description path))))

(defun org-pdfview-export (link description format)
  "Export the pdfview LINK with DESCRIPTION for FORMAT from Org files."
  (let* ((path (when (string-match "\\(.+\\)::.+" link)
                 (match-string 1 link)))
         (desc (or description link)))
    (when (stringp path)
      (setq path (org-link-escape (expand-file-name path)))
      (cond
       ((eq format 'html) (format "<a href=\"%s\">%s</a>" path desc))
       ((eq format 'latex) (format "\\href{%s}{%s}" path desc))
       ((eq format 'ascii) (format "%s (%s)" desc path))
       (t path)))))

(defun org-pdfview-complete-link ()
  "Use the existing file name completion for file.
Links to get the file name, then ask the user for the page number
and append it."
  (concat (replace-regexp-in-string "^file:" "pdfview:" (org-file-complete-link))
	  "::"
	  (read-from-minibuffer "Page:" "1")))


(provide 'org-pdfview)
;;; org-pdfview.el ends here
#+END_SRC

#+RESULTS:
: org-pdfview


#+BEGIN_SRC emacs-lisp
(add-to-list 'org-file-apps '("\\.pdf\\'" . org-pdfview-open))
(add-to-list 'org-file-apps '("\\.pdf::\\([[:digit:]]+\\)\\'" . org-pdfview-open))
#+END_SRC

#+RESULTS:

* matalbbin

#+BEGIN_SRC matlab :tangle myfunc.m
function myfunc
    disp('External function')
end
#+END_SRC


#+BEGIN_SRC emacs-lisp
(org-babel-tangle)
#+END_SRC
#+RESULTS:
| myfunc.m |

#+BEGIN_SRC matlab
myfunc()
#+END_SRC
#+RESULTS:
#+begin_example

                            < M A T L A B (R) >
                  Copyright 1984-2013 The MathWorks, Inc.
                     R2013a (8.1.0.604) 64-bit (maci64)
                             February 15, 2013


To get started, type one of these: helpwin, helpdesk, or demo.
For product information, visit www.mathworks.com.

>> External function
>>
#+end_example

#+BEGIN_SRC emacs-lisp
(defvar matlab-cli-file-path "/Applications/MATLAB_R2013a.app/bin/matlab")
(defvar matlab-cli-arguments '("-nosplash" "-nodesktop"))
(defun run-matlab ()
  "Run an inferior instance of `matlab-cli' inside Emacs."
  (interactive)
  (let* ((matlab-program matlab-cli-file-path)
         (buffer (comint-check-proc "Matlab")))
    ;; pop to the "*Matlab*" buffer if the process is dead, the
    ;; buffer is missing or it's got the wrong mode.
    (pop-to-buffer-same-window
     (if (or buffer (not (derived-mode-p 'matlab-mode))
             (comint-check-proc (current-buffer)))
         (get-buffer-create (or buffer "*Matlab*"))
       (current-buffer)))
    ;; create the comint process if there is no buffer.
    (unless buffer
      (apply 'make-comint-in-buffer "Matlab" buffer
             matlab-program matlab-cli-arguments))))

(setq comint-prompt-regexp ">> ")

(run-matlab)

(comint-simple-send (get-buffer-process "*Matlab*") "disp('t')")
(accept-process-output (get-buffer-process "*Matlab*"))


(defun mymode--output-filter (process string)
  (let ((buffer (process-buffer process)))
    (when (buffer-live-p buffer)
      (with-current-buffer buffer
        (goto-char (point-max))
        (forward-line 0)
        (when (mymode-looking-at-prompt)
          (do-something)
          (goto-char (point-max)))))))
(set-process-filter 'mymode--output-filter)

#+END_SRC
#+RESULTS:
: run-matlab


* exception handling tips and tricks

Here is a usage pattern I deal with a lot. I want to change into some directory temporarily, do something there, and when I cam done change back to the directory I was in. If there are never errors, no problem. If there are any errors however, we have to deal with them and make sure we still get back to our original directory, "or bad things can happen"™, like in the next step of your program creating files in the wrong place.

Python provides some tools to handle this, using exception handling. Here is a minimal example that shows what we want. We try some code, and then handle exceptions, and finally change back to where we started.

#+BEGIN_SRC python
import os

print(os.getcwd())
try:
    cwd = os.getcwd()
    os.chdir('/tmp')
    with open('non-existant-file') as f:
        print(f.read())
except IOError, e:
    print('    Caught an IOError:' + str(e))
except Exception, e:
    print('    ' + str(e))
    print('    In ' + os.getcwd())
else:
    print('No exceptions occurred!')
finally:
    os.chdir(cwd)

print(os.getcwd())
#+END_SRC

#+RESULTS:
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
:     Caught an IOError:[Errno 2] No such file or directory: 'non-existant-file'
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog

So, that works, but has the smell of context-management, that is, we want to perform some actions in a "context" which is some other directory and we want to restore the previous context afterwards. My preference of context manager is a class with __enter__ and __exit__ methods. In __enter__ we change directory, and on __exit__ we handle any exceptions and go back.

We put this into a python module called cm.py. This is more verbose than the original try block, but it is reusable as we will see.

#+BEGIN_SRC python :tangle cm.py
import os

class current_directory:
    def __init__(self, newdir, handler=None):
        """newdir is where we change to.
        handler is a function that will handle exceptions.
        It has a signature of handler(exception_type, exception_value, traceback).
        It should return True if the exception was handled, and False otherwise.

        """
        self.cwd = os.getcwd()
        self.newdir = newdir
        self.handler = handler
        print('init: ', os.getcwd())

    def __str__(self):
        s = 'current_directory CM (dir: {0} contextdir: {1} handler: {2})'
        return s.format(self.cwd, self.newdir, self.handler)

    def __enter__(self):
        # Enter the directory
        os.chdir(self.newdir)
        print('entered: ', os.getcwd())

    def __exit__(self, type, value, traceback):
        # return to where we came from first.
        os.chdir(self.cwd)
        print('exited: ', os.getcwd())
        if type is not None:
            if self.handler is not None:
                return self.handler(self, type, value, traceback)
            else:
                return False
        else:
            return True
#+END_SRC


Now we use it like this. Here is an example with no exceptions, and no handler.

#+BEGIN_SRC python
from cm import current_directory
import os

with current_directory('/tmp'):
    print(os.getcwd())
#+END_SRC
#+RESULTS:
: ('init: ', '/Users/jkitchin/blogofile-jkitchin.github.com/_blog')
: ('entered: ', '/private/tmp')
: /private/tmp
: ('exited: ', '/Users/jkitchin/blogofile-jkitchin.github.com/_blog')

Here, we pass a handler function to the context manager so we can handle any exceptions that come up.

#+BEGIN_SRC python
from cm import current_directory
import os

def handler(self, e, v, tr):
    if isinstance(v, IOError):
        # self is the context manager, and we can access information in it
        print(self)
        print('    Caught an IOError in ' + os.getcwd())
        return True
    else:
        print((e, v, tr))
        return False

# We can nest context managers
with current_directory('/tmp', handler),\
     open('non-existant-file') as f:
    print(f.read())

print(os.getcwd())
#+END_SRC

#+RESULTS:
: ('init: ', '/Users/jkitchin/blogofile-jkitchin.github.com/_blog')
: ('entered: ', '/private/tmp')
: ('exited: ', '/Users/jkitchin/blogofile-jkitchin.github.com/_blog')
: current_directory CM (dir: /Users/jkitchin/blogofile-jkitchin.github.com/_blog contextdir: /tmp handler: <function handler at 0x1004a0668>)
:     Caught an IOError in /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog

That is approximately the same amount of code as we previously had, but the error handling is done differently. We don't have to handle the directory changing ourselves with this context manager, but we still do have handle exception handling.











* Nested context managers		    :sent:
  :PROPERTIES:
  :SENT-ON:  Tue Apr 19 11:46:21 2016
  :TO:       jboes@andrew.cmu.edu
  :Message-ID: [[mu4e:msgid:m2oa95bnzo.fsf@andrew.cmu.edu][Nested context managers (Tue Apr 19 11:46:21 2016)]]
  :END:

#+BEGIN_SRC python
from __future__ import print_function

class cd:
    """Context manager for changing directories.

    On entering, store initial location, change to the desired directory,
    creating it if needed.  On exit, change back to the original directory.

    Example:
    with cd('path/to/a/calculation'):
        calc = Jasp(args)
        calc.get_potential energy()
    """

    def __init__(self, working_directory):
        self.origin = os.getcwd()
        self.wd = working_directory

    def __enter__(self):
        # make directory if it doesn't already exist
        if not os.path.isdir(self.wd):
            os.makedirs(self.wd)

        # now change to new working dir
        os.chdir(self.wd)

    def __exit__(self, *args):
        os.chdir(self.origin)
        return False  # allows body exceptions to propagate out.


class unwind:
    def __init__(self,  exception_handler=None):
        self.exception_handler = exception_handler

    def __enter__(self):
        pass

    def __exit__(self, *args):
        print(args)
        if self.exception_handler:
            self.exception_handler(*args)
        return True



import os


print(os.getcwd())
with unwind(), cd('/tmp'):
    print(os.getcwd())
    raise Exception('boom')

print(os.getcwd())


print()
def f(a, b, c): print ("test", a, b, c)

with unwind(lambda a,b,c: print("lambda: ",a,b,c)), cd('/tmp'):
    print(os.getcwd())
    raise Exception('boom')

print(os.getcwd())

print()
def f(a, b, c): print ("test", a, b, c)

with unwind(f), \
     cd('/tmp'):
    print()rint(os.getcwd())
    raise Exception('boom')

print(os.getcwd())
#+END_SRC

#+RESULTS:
#+begin_example
/Users/jkitchin/blogofile-jkitchin.github.com/_blog
/private/tmp
(<type 'exceptions.Exception'>, Exception('boom',), <traceback object at 0x1004b2440>)
/Users/jkitchin/blogofile-jkitchin.github.com/_blog

/private/tmp
(<type 'exceptions.Exception'>, Exception('boom',), <traceback object at 0x1004b24d0>)
lambda:  <type 'exceptions.Exception'> boom <traceback object at 0x1004b24d0>
/Users/jkitchin/blogofile-jkitchin.github.com/_blog

/private/tmp
(<type 'exceptions.Exception'>, Exception('boom',), <traceback object at 0x1004b23f8>)
test <type 'exceptions.Exception'> boom <traceback object at 0x1004b23f8>
/Users/jkitchin/blogofile-jkitchin.github.com/_blog
#+end_example

These don't seem to work as expected.

#+BEGIN_SRC python
try:
   1 / 0

finally:
   print 'done'

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
try:
    raise KeyboardInterrupt
finally:
    print 'Goodbye, world!'

#+END_SRC

#+RESULTS:

* closures in elisp

#+BEGIN_SRC emacs-lisp
(setq counter
      (lexical-let ((x 0))
	     (lambda () (incf x))))

(print  (funcall counter))
(print  (funcall counter))
#+END_SRC

#+RESULTS:
:
: 1
:
: 2

So cool!

#+BEGIN_SRC emacs-lisp :results output
(setq counter
      (lexical-let ((x 0))
	(defun inf () (incf x))
	(defun def () (decf x))
	(defun restart () (setq x 0))))

(print (inf))
(print (inf))
(print (def))
(print (inf))
(print (restart))
(print (inf))
#+END_SRC

#+RESULTS:
#+begin_example

1

2

1

2

0

1
#+end_example

* self in a macro

http://letoverlambda.com/index.cl/guest/chap6.html


#+BEGIN_SRC emacs-lisp
(setq x 4)
#+END_SRC

#+RESULTS:
: 4


#+BEGIN_SRC emacs-lisp
(+ x 9)
#+END_SRC

#+RESULTS:
: 13

This will not work unless evaluated with lexical-binding
#+BEGIN_SRC emacs-lisp :results value :lexical t
;; Graham's alambda
(defmacro alambda (parms &rest body)
  `(cl-labels ((self ,parms ,@body))
     #'self))

(setq
 N
 (alambda (n)
	  (if (> n 0)
	      (cons
	       n
	       (self (- n 1))))))

(princ (funcall N 3))
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 |

#+BEGIN_SRC emacs-lisp :lexical '((x . 23))
(print x)
#+END_SRC

#+RESULTS:
: 23


#+BEGIN_SRC emacs-lisp :lexical t
;; Graham's alambda
(defmacro alambda (parms &rest body)
  `(cl-labels ((self ,parms ,@body))
     #'self))

(setq
 counter
 (alambda (n)
	  (let ((i n))
	    (defun inc (self)
	      (incf i))
	    (defun dec (self)
	      (decf i)))))



(princ (dec N))
;(princ (dec N))
;(princ (dec N))
;(print (inc N))
(princ counter)
#+END_SRC

#+RESULTS:
| lambda | (n) | (let ((i n)) (defalias (quote inc) (function (lambda (self) (setq i (1+ i))))) (defalias (quote dec) (function (lambda (self) (setq i (1- i)))))) |





#+BEGIN_SRC emacs-lisp
(org-babel-tangle)
(load-file "alambda.el")
(funcall N 3)
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 |

How about this annoying bit of code where we store the result of a test. What is annoying? The let statement, the nested parentheses, its not much, but we can get by without it.

#+BEGIN_SRC emacs-lisp
(let ((x (> 2 0)))
  (if x
      "True"
    "False"))
#+END_SRC

#+RESULTS:
: True

We can define a macro (derived from Let Over Lambda, and On Lisp)

#+BEGIN_SRC emacs-lisp :results value :lexical nil
;; Graham's aif
(defmacro aif (test then &optional else)
  `(let ((it ,test))
     (if it ,then ,else)))

(list (aif (> 2 0) (format "True: %s" it) (format "False: %s" it))
      (aif (< 2 0) (format "True: %s" it) (format "False: %s" it)))
#+END_SRC
#+RESULTS:
| True: t | False: nil |

What do we really get there? The value of the test for use inside the body in the variable =it=.

* show snippets of a script
#+BEGIN_SRC sh :wrap src python :exports results
sed -n 9,18p wos.py
#+END_SRC

#+RESULTS:
#+BEGIN_src python
class HTTPSudsPreprocessor(urllib2.BaseHandler):
    def __init__(self, SID):
        self.SID = SID

    def http_request(self, req):
        req.add_header('cookie', 'SID="'+self.SID+'"')
        return req

    https_request = http_request

#+END_src

#+BEGIN_SRC python :results code :exports results
with open("wos.py") as f:
    print("".join(f.readlines()[8:17]))
#+END_SRC
#+RESULTS:
#+BEGIN_SRC python
class HTTPSudsPreprocessor(urllib2.BaseHandler):
    def __init__(self, SID):
        self.SID = SID

    def http_request(self, req):
        req.add_header('cookie', 'SID="'+self.SID+'"')
        return req

    https_request = http_request

#+END_SRC

* Moonshot
#+BEGIN_SRC emacs-lisp
(defun future (&rest args) "Carnegie Mellon University")
(defun need (&rest args) "Carnegie Mellon University")
(defun requires (&rest args) "Carnegie Mellon University")
(defun past (&rest args) "Carnegie Mellon University")
(defun integrated (&rest args) "Carnegie Mellon University")
(defun investment (&rest args) "Carnegie Mellon University")
(defun improvement (&rest args) "Carnegie Mellon University")
(defun roots (&rest args) "Carnegie Mellon University")
(defun collaboration (&rest args) "Carnegie Mellon University")
(defun enhance (&rest args) "Carnegie Mellon University")
(defun research-agent (&rest args) "Carnegie Mellon University")
#+END_SRC

#+RESULTS:
: research-agent

#+BEGIN_SRC emacs-lisp
(future
 (need (integrated 'research 'data 'methods 'learning))
 (need (enhance (research-agent) 'artificial-intelligence))
 (requires (investment 'sustained)
	   (improvement 'continuous 'education 'research 'software 'hardware))
 (requires (collaboration
	    'multidisciplinary
	    'humanities 'sciences 'engineering 'computing))
 (past (roots 'of 'AI 'human-computer-interaction)))

(future (> years-from-now 10)
 (goal (integrate 'research 'data 'methods 'learning))
 (goal (loop for attr in '(machine-readable reusable)
          do (enable research attr))
 (goal (with (enhance (research-agent) 'artificial-intelligence)
         (leverage 'human 'ingenuity)
         (maximize 'human-learning 'research-productivity))
 (requires (investment 'sustained)
                (continuous-improvement 'education 'research
                                    'software 'hardware))
 (requires (collaboration
            'multidisciplinary
                'humanities 'sciences 'arts 'engineering 'computing))
 (given (@CMU origin 'of 'AI 'human-computer-interaction))
 (compute (optimal-reason-place-and-team)))

#+END_SRC

#+RESULTS:
: Carnegie Mellon University

* Psychedelic medicines
http://cen.acs.org/articles/94/i13/Psychedelic-compounds-like-ecstasy-just.html

** The molecules in the article
*** Ibogaine

#+BEGIN_SRC sh :var smiles=ibogaine :file ibogaine.svg :exports output
echo $smiles | obabel -ismi -osvg
#+END_SRC

#+RESULTS:
[[file:ibogaine.svg]]

*** MDMA
#+BEGIN_SRC sh :var smiles=mdma :file mdma.svg :exports output
echo $smiles | obabel -ismi -osvg
#+END_SRC

#+RESULTS:
[[file:mdma.svg]]

*** THC
#+BEGIN_SRC sh :var smiles=thc :file thc.svg :exports output
echo $smiles | obabel -ismi -osvg
#+END_SRC

#+RESULTS:
[[file:thc.svg]]

*** Ketamine
#+BEGIN_SRC sh :var smiles=ketamine :file ketamine.svg :exports output
echo $smiles | obabel -ismi -osvg
#+END_SRC

#+RESULTS:
[[file:ketamine.svg]]

*** Psilocybin
#+BEGIN_SRC sh :var smiles=psilocybin :file psilocybin.svg :exports output
echo $smiles | obabel -ismi -osvg
#+END_SRC

#+RESULTS:
[[file:psilocybin.svg]]

** Molecule database

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
	     '("mol"
	       "#+header:\n#+name:?\n#+begin_molecule\n\n#+end_molecule\n"))
#+END_SRC


#+header: :src https://pubchem.ncbi.nlm.nih.gov/compound/197060#section=Names-and-Identifiers
#+header: :format smiles
#+name: ibogaine
#+begin_molecule
CCC1CC2CC3C1N(C2)CCC4=C3NC5=C4C=C(C=C5)OC
#+end_molecule

#+header: :src https://pubchem.ncbi.nlm.nih.gov/compound/ketamine :format smiles
#+name: ketamine
#+begin_molecule
CNC1(CCCCC1=O)C2=CC=CC=C2Cl
#+end_molecule


#+header: :src https://pubchem.ncbi.nlm.nih.gov/compound/1615#section=Names-and-Identifiers :format smiles
#+name: mdma
#+begin_molecule
CC(CC1=CC2=C(C=C1)OCO2)NC
#+end_molecule

#+header: :src https://pubchem.ncbi.nlm.nih.gov/compound/16078#section=Names-and-Identifiers :format smiles
#+name: THC
#+begin_molecule
CCCCCC1=CC2=C(C3C=C(CCC3C(O2)(C)C)C)C(=C1)O
#+end_molecule

#+header: :src https://pubchem.ncbi.nlm.nih.gov/compound/10624#section=Names-and-Identifiers :format smiles
#+name: psilocybin
#+begin_molecule
CN(C)CCC1=CNC2=C1C(=CC=C2)OP(=O)(O)O
#+end_molecule

* Export table from src-block to csv

#+name: mytable
| a | b |
| 1 | 2 |
| 3 | 4 |


#+BEGIN_SRC emacs-lisp
(save-excursion
  (org-open-link-from-string "[[mytable]]")
  (while (not (org-table-p)) (forward-line))
  (org-table-export "mytable.csv" "orgtbl-to-csv"))
#+END_SRC
#+RESULTS:
: Export done.

#+BEGIN_SRC sh
cat mytable.csv
#+END_SRC
#+RESULTS:
: a,b
: 1,2
: 3,4


* isearch

#+BEGIN_SRC emacs-lisp
(add-hook 'isearch-mode-end-hook
          #'endless/goto-match-beginning)

(defun endless/goto-match-beginning ()
  "Go to the start of current isearch match.
Use in `isearch-mode-end-hook'."
  (when (and isearch-forward
             (number-or-marker-p isearch-other-end)
             (not mark-active)
             (not isearch-mode-end-hook-quit))
    (goto-char isearch-other-end)))
#+END_SRC

#+RESULTS:
: endless/goto-match-beginning

* An Emacs interface to the ase-db
  :PROPERTIES:
  :categories: ase, database
  :date:     2014/04/24 09:33:44
  :updated:  2014/04/24 09:33:44
  :ID:       D32E042F-F330-418E-A088-D399E3E182BB
  :END:
The [[https://wiki.fysik.dtu.dk/ase/ase/db/db.html#ase-db][ase-db]] has a command-line interface, a Python API, and a web-based interface. None of these do everything I would like at once. Here we investigate an Emacs interface to the ase-db using ivy. This will give us the power of the command-line interface with the selection and multiple actions of ivy.

First, we make a little database to play with.

#+BEGIN_SRC python
import os
if os.path.exists('abc.db'): os.unlink('abc.db')

from ase import Atoms
from ase.db import connect
c = connect('abc.db')

c.write(Atoms('Fe'))
c.write(Atoms('Al'))
c.write(Atoms('Ni'))
c.write(Atoms('FeNi'))
c.write(Atoms('FeAl'))
c.write(Atoms('NiAl'))
c.write(Atoms('FeNiAl'))
#+END_SRC
#+RESULTS:

Now, let us see the contents to be sure what is in there. Each row of this output is a candidate we might want to do something with.

#+BEGIN_SRC sh
ase-db abc.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|pbc|volume|charge|   mass
:  1| 6s|jkitchin|Fe     |FFF| 1.000| 0.000| 55.847
:  2| 6s|jkitchin|Al     |FFF| 1.000| 0.000| 26.982
:  3| 6s|jkitchin|Ni     |FFF| 1.000| 0.000| 58.693
:  4| 6s|jkitchin|FeNi   |FFF| 1.000| 0.000|114.540
:  5| 6s|jkitchin|AlFe   |FFF| 1.000| 0.000| 82.829
:  6| 6s|jkitchin|AlNi   |FFF| 1.000| 0.000| 85.675
:  7| 6s|jkitchin|AlFeNi |FFF| 1.000| 0.000|141.522
: Rows: 7

We can split this pretty cleanly. For candidates we can ignore the first row, and the last two rows.

#+BEGIN_SRC emacs-lisp
(mapcar (lambda (s) (split-string s "|"))
	(split-string  (shell-command-to-string "ase-db abc.db") "\n"))
#+END_SRC

#+RESULTS:
|      id | age | user     | formula | pbc | volume | charge |    mass |
|       1 | 18m | jkitchin | Fe      | FFF |  1.000 |  0.000 |  55.847 |
|       2 | 18m | jkitchin | Al      | FFF |  1.000 |  0.000 |  26.982 |
|       3 | 18m | jkitchin | Ni      | FFF |  1.000 |  0.000 |  58.693 |
|       4 | 18m | jkitchin | FeNi    | FFF |  1.000 |  0.000 | 114.540 |
|       5 | 18m | jkitchin | AlFe    | FFF |  1.000 |  0.000 |  82.829 |
|       6 | 18m | jkitchin | AlNi    | FFF |  1.000 |  0.000 |  85.675 |
|       7 | 18m | jkitchin | AlFeNi  | FFF |  1.000 |  0.000 | 141.522 |
| Rows: 7 |     |          |         |     |        |        |         |
|         |     |          |         |     |        |        |         |

Let's turn this into a function
#+BEGIN_SRC emacs-lisp
(defun ase-db-info (s)
  (with-help-window (help-buffer)
      (princ
       (shell-command-to-string
	(format "ase-db \"abc.db\" id=%s -l" (s-trim (car (split-string s "|"))))))))

(ivy-read "Select: " (split-string  (shell-command-to-string
				     "ase-db abc.db") "\n")
	  :require-match t
	  :action '(1
		    ("i" ase-db-info "Info")))
#+END_SRC

#+RESULTS:
:  2|11d|jkitchin|Al     |FFF| 1.000| 0.000| 26.982


#+BEGIN_SRC emacs-lisp
(defvar db "/Users/jkitchin/Dropbox/CMU/manuscripts/2015/manuscript-corelevelshift/supporting-information/data.json"
  "The database.")

(helm :sources (helm-build-async-source "ase-db"
		 :delayed t
                 :candidates-process (lambda ()
				       (start-process
					"ase-db" nil
					"ase-db" db helm-pattern))
		 :action '(("Info" . (lambda (s)
				       (with-help-window (help-buffer)
					 (princ
					  (shell-command-to-string
					   (format "ase-db %s id=%s -l"
						   db
						   (s-trim (car (split-string s "|")))))))))
			   ("View" . (lambda (s)
				       (let ((py (format "from ase.visualize import view
from ase.io import read
atoms = read(\"%s@%s\")
view(atoms)
" db  (s-trim (car (split-string s "|")))))
					     (tf)
					     (temporary-file-directory "."))
					 (setq tf (make-temp-file "py-" ))
					 (with-temp-file tf
					   (insert py))
					 (call-process "python" tf)
					 (delete-file tf))))))
      :buffer "*helm async source*")
#+END_SRC

#+RESULTS:
#+begin_example
name      |unit  |value
id        |      |2
age       |      |15.607 months
formula   |      |Cu54Pd18
user      |      |jboes
calculator|      |vasp
energy    |eV    |-586.621877
charge    ||e|   |0.0
mass      |au    |5347.044
unique id |      |315485abf551402f083bca9929bf9671
volume    |Ang^3 |936.858562646

Unit cell in Ang:
axis|periodic|          x|          y|          z
   1|     yes|    -11.201|      0.000|      0.000
   2|     yes|      0.000|      0.000|     11.201
   3|     yes|      0.000|      7.467|      0.000

Key-value pairs:
GS     |1
_0_75Cu|1
_1cl   |1
_72atom|1
fcc    |1
#+end_example



** SQL interactions
Now, suppose I want to find entries that do not contain Ni. We can find the entries that do contain Ni like this.

#+begin_src sqlite :db abc.db :list
SELECT species.id  FROM species
WHERE species.Z == 28;
#+end_src

#+RESULTS:
: 3
: 4
: 6
: 7

You can see there is a Ni in each found entry. Now, we select the ids from the systems table that do not exist in that list.

#+begin_src sqlite :db abc.db :list
select id from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28);
#+end_src

#+RESULTS:
: 1
: 2
: 5

And you can see none of these entries contain Ni.






** python + sql

I am examining how to query the ase-db, and this post looks at how to find results that do not contain a particular atom. The solution is based on a email from the mailing list (http://listserv.fysik.dtu.dk/pipermail/ase-developers/2014-April/002097.html).

We begin by making a test database. This will only contain some atoms objects with different stoichiometries. We also add keywords for the stoichiometry, because the queries will be developed directly in SQL, which cannot read the numpy arrays stored in the tables.


It is probably more common to interact with the ase-db using Python.

#+BEGIN_SRC python
from ase.db import connect

c = connect('abc.db')
con = c._connect()
cur = con.cursor()
for row in  cur.execute('''select * from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28)'''):
    print(row)
#+END_SRC
#+RESULTS:
: (1, '6ef3f57e457c4a5a24f85ba8508ff9fe', 16.22150360339677, 16.22150360339677, 'jkitchin', b'\x1a\x00\x00\x00', b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, '{}', 'null', 1, None, None, 1.0, 55.847, 0.0)
: (2, '1da038ce751e1a5bfe37d2679bcb4ea7', 16.221503603700942, 16.221503603700942, 'jkitchin', b'\r\x00\x00\x00', b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, '{}', 'null', 1, None, None, 1.0, 26.98154, 0.0)
: (5, 'eba4d7c7271fcc991563e08e3c24b2c5', 16.2215036038939, 16.2215036038939, 'jkitchin', b'\x1a\x00\x00\x00\r\x00\x00\x00', b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00', b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0?', 0, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, '{}', 'null', 2, None, None, 1.0, 82.82854, 0.0)

[[./O_sv]]

[[./O_sv][test dir]]

* TODO A better tab in org-mode for Python blocks.
  :PROPERTIES:
  :ID:       47FE9730-983C-4732-953B-E7D5D2E36FED
  :categories: emacs,orgmode
  :END:
We write a lot of Python code in org-mode. In python-mode TAB does nice things like indenting code, and we would like that in org-mode too. The problem is org-mode also makes heavy use of TAB for too many other useful things to give it up. What we really want is TAB to act differently in Python blocks, and the same everywhere else.

Enter the [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][context aware keybindings]]. We bind a menu-item to TAB that uses a filter function to determine what it does. If the filter function evaluates to t then it is run, and otherwise the usual meaning of TAB is used. There is also the convenient function =org-babel-do-key-sequence-in-edit-buffer= which will let us make TAB act like it does in python-mode!

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map (kbd "<tab>")
  '(menu-item "org-mode-tab" nil
	      :filter (lambda (&optional _)
			(when
			    (and
			     (org-in-src-block-p t)
			     (string= "python"
				      (org-element-property
				       :language
				       (org-element-context))))
			  (org-babel-do-key-sequence-in-edit-buffer
			   (kbd "<tab>"))))))

;; this doesn't work as expected, there are too many lines put in.
;; (define-key org-mode-map (kbd "C-j")
;;   '(menu-item "org-mode-ret" nil
;;	      :filter (lambda (&optional _)
;;			(when
;;			    (and
;;			     (org-in-src-block-p t)
;;			     (string= "python"
;;				      (org-element-property
;;				       :language
;;				       (org-element-context))))
;;			  (org-babel-do-key-sequence-in-edit-buffer
;;			   (kbd ""))))))
#+END_SRC

#+RESULTS:
| menu-item | org-mode-ret | nil | :filter | (lambda (&optional _) (when (and (org-in-src-block-p t) (string= python (org-element-property :language (org-element-context)))) (org-babel-do-in-edit-buffer (newline) (indent-relative)) t)) |

While we are improving things... Ken Mankoff on the org-mode mailing list pointed out this gem for commenting in src blocks: https://lists.gnu.org/archive/html/emacs-orgmode/2013-11/msg00318.html.

#+BEGIN_SRC emacs-lisp :results none
;; allow comment region in the code edit buffer (according to language)
(defun my-org-comment-dwim (&optional arg)
  (interactive "P")
  (or (org-babel-do-key-sequence-in-edit-buffer (kbd "M-;"))
      (comment-dwim arg)))

;; make `C-c C-v C-x M-;' more convenient
(define-key org-mode-map
  (kbd "M-;") 'my-org-comment-dwim)
#+END_SRC

Now, if you select a region you can comment/uncomment it, or if on a line, add a comment to the line (usually at the end).

#+BEGIN_SRC python
for i in range(5):


#+END_SRC

* TODO Equation image tooltips over LaTeX fragments in org-mode
  :PROPERTIES:
  :ID:       603BDAF5-59DA-48F4-97F7-4C19F00AAE80
  :categories: emacs,orgmode
  :END:

This post has one  goal: to fontify LaTeX fragments in org-mode and make tooltips with the rendered equations. I previously looked at doing something like this with the [[http://kitchingroup.cheme.cmu.edu/blog/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment/][cursor]], but now I want to try with the mouse.

=org-latex-regexps= contains regexp patterns We will use those to build a function that matches fragments, and puts some text properties on the match to make them clickable. What we need to do then, is make a function for font-lock that will put a tool tip on our fragments, and generate the image for us on the fly. I am going to set a property containing the fragment string on the text during font-lock, and we will use that property in the tool-tip. So, first the tooltip function. We store the images in calculatable names so we can reuse them. We also provide options to make the images larger so they are easier to see.

#+BEGIN_SRC emacs-lisp
(defun latex-fragment-tooltip (object window position)
  (save-excursion
    (goto-char position)
    (let* ((f (concat temporary-file-directory
		      "latex-tooltip-"
		      (md5 (get-text-property (point) 'latex-fragment))
		      ".png"))
	   (png))
      (unless (file-exists-p f)
	(message "creating image for %s. Please wait."
		 (get-text-property (point) 'latex-fragment))
	(org-create-formula-image
	 (get-text-property (point) 'latex-fragment)
	 f
	 '(:foreground default :background default
		       :scale 4.0 :html-foreground "Black"
		       :html-background "Transparent" :html-scale 4.0
		       :matchers
		       ("begin" "$1" "$" "$$" "\\(" "\\["))
	 (current-buffer)
	 org-latex-create-formula-image-program)
	(message ""))
      (propertize
       " " 'display
       (create-image f)))))
#+END_SRC

#+RESULTS:
: latex-fragment-tooltip

Now, we need to propertize the fragments. We use one function for that here, and this function will be called via font-lock. Basically we just put the fragment as a property for easy retrieval by the tooltip function.

#+BEGIN_SRC emacs-lisp
(defun propertize-fragment ()
  (put-text-property
   (match-beginning 0) (match-end 0)
   'latex-fragment (match-string-no-properties 0))
  (put-text-property
   (match-beginning 0) (match-end 0)
   'help-echo 'latex-fragment-tooltip))
#+END_SRC

#+RESULTS:
: propertize-fragment

Now a series of functions to propertize different types of LaTeX fragments. The regexps are approximately those found in org-latex-regexps, but not exactly. I found those caused some org-eldoc errors in these src blocks presumably from the non-ascii characters in them. They don't cause problems otherwise.

#+BEGIN_SRC emacs-lisp
(defun next-latex-overlay-1 (limit)
  "Overlay images on \(eqn\) up to LIMIT."
  (while (re-search-forward "\\\\(.*?\\\\)" limit t)
    (propertize-fragment)))

(defun next-latex-overlay-2 (limit)
  "Overlay images on \[eqn\] up to LIMIT."
  (while (re-search-forward "\\\\\\[.*?\\\\\\]" limit t)
    (propertize-fragment)))

(defun next-latex-overlay-3 (limit)
  "Overlay images on $$eqn$$ up to LIMIT."
  (while (re-search-forward "\\$\\$[^$]*?\\$\\$" limit t)
    (propertize-fragment)))

(defun next-latex-overlay-4 (limit)
  "Overlay images on $eqn$ up to LIMIT.
this is less robust than useing \(\)"
  (while (re-search-forward "\\b\\$[^$]+?\\$\\b" limit t)
    (propertize-fragment)))
#+END_SRC

#+RESULTS:
: next-latex-overlay-4

Finally, add the font lock keywords.

#+BEGIN_SRC emacs-lisp :results silent
(font-lock-add-keywords
 nil
 '((next-latex-overlay-1 0 font-lock-keywords)
   (next-latex-overlay-2 0 font-lock-keywords)
   (next-latex-overlay-3 0 font-lock-keywords)
   (next-latex-overlay-4 0 font-lock-keywords)))
#+END_SRC

Now, we get tooltips of equation images!

\[\int_0^x 500 dx\]

1. $e^{x^2}$

2. $$\exp{x^2}$$

3. \(\frac{2}{3x}\)

4. \[\log{4x}\]

This is primarily limited to one line equations that are easily matched.


* TODO Numbering lines in a a table
  :PROPERTIES:
  :ID:       3C1EC95A-079C-46DC-9699-F190648DE4AF
  :END:


#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line-table ()
  (interactive)
  (save-excursion
    ;; you are in a cell in a row in a table. we get the table.
    (let* ((table (org-element-property
		   :parent
		   (org-element-property :parent (org-element-context))))
	   (i 1)) (message-box "%s" table)
	   (goto-char (org-element-property :begin table))
	   (while (s-starts-with? "|" (org-current-line-string))
	     (beginning-of-line)
	     (let (ov)
	       (setq ov (make-overlay (point) (point)))
	       (overlay-put ov 'before-string (format "%3s. " (number-to-string i)))
	       (add-to-list 'number-line-overlays ov))
	     (setq i (1+ i))
	     (next-line))))

  ;; now read a char to clear them
  (read-key "Press a key to clear numbers.")
  (mapc 'delete-overlay number-line-overlays)
  (setq number-line-overlays '()))
#+END_SRC

#+RESULTS:
: number-line-table

| 3 |
| 8 |
| 9 |
| 0 |
| 0 |
* TODO Lispy navigation in Python mode
  :PROPERTIES:
  :categories: emacs,python
  :END:
I am not going to sugar coat this. Editing emacs-lisp code with lispy beats the pants off editing python in any mode I have tried so far. What is so great about it? modal navigation and editing. Lispy recognizes some special locations, e.g. the beginning of a sexp, and makes hotkeys active at these positions. So, you can use [ and ] to navigate by sexp, and a boatload of hotkeys like n to make a new copy, or c to clone, or a to enter an ace-mode to jump to an open parenthesis, and [[http://oremacs.com/lispy/][many, many others]]. I have gotten used to it. I want it in python-mode.

I want my python-mode to have hotkeys at the beginning of def, blocks and statements so I can easily jump to the next one, mark it, copy it, clone it, move it, etc.... @AMalabarba wrote an interesting blog post on [[http://endlessparentheses.com/define-context-aware-keys-in-emacs.html][context-aware keybindings]] that I am going to use extensively to achieve this. The idea is to define keys that do things differently depending on the context. Here if the cursor is at the beginning of a def, then when I press n i want to go to the next def, but if I am at the beginning of a block, I want the next block, at the beginning of a statement the next statement, and anywhere else, I want to type the letter n.

Here are the current hotkey definitions I have defined for python-mode. The code is relatively long so if you find this interesting, you should check it out here (https://github.com/jkitchin/jmax/blob/master/lispypy.el). I have just started using these, so most likely I will be finding bugs and fixing them in the future ;)

Here is a summary of the hotkeys. You should probably just watch this video to see them in action:

| hotkey | action                                         |
|--------+------------------------------------------------|
| [      | go to beginning of current/previous statement  |
| ]      | go to end of current/next statement            |
| {      | insert a pair of {}                            |
| }      | insert a pair of []                            |
|--------+------------------------------------------------|
| n      | next def, block or statement                   |
| p      | previous def, block or statement               |
| e      | goto end of def, block or statement            |
|--------+------------------------------------------------|
| l      | jump to a line with avy-goto-line              |
| d      | jump to a def or block/statement with avy      |
|--------+------------------------------------------------|
| m      | mark the def, block or statement               |
| w      | copy the def, block or statement               |
| c      | clone the def, block or statement              |
| k      | kill the def, block or statement               |
|--------+------------------------------------------------|
| i      | auto-indent the def, block or statement        |
|--------+------------------------------------------------|
| >      | indent the def, block or statement in a level  |
| <      | indent the def, block or statement out a level |
|--------+------------------------------------------------|
| " "    | (space) type a hotkey in the special place     |
* TODO Parsing sexps in plain text and putting overlays on them
  :PROPERTIES:
  :ID:       480C2539-01DE-42B9-B835-FC1E6489142D
  :END:

I am exploring a kind of richer markup here to put context into plain text using sexp notation instead of [[http://www.w3.org/TR/rdfa-lite/][RDF]] notation. RDF notation is just heavy for an author to write. Sexp notation, on the other hand, is lighter in my opinion. You can even imagine this relatively readable markup being code in addition to data (see this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/][post]] on a sexp notation for bibtex for example).

I will use Emacs overlays to hide the sexp and display the contents. For example, say we markup a "person" like this @(:person "John Kitchin" :email "jkitchin@andrew.cmu.edu"). It seems in this approach it is necessary to put strings in quotes because we eventually read these sexps into lisp. I want Emacs to find these, and replace it with an overlay of a more human readable content, and some contextual tooltip about the real content.

For fun, let us see if we can nest a sexp in the sexp, here to have some code that constructs an email address. For example, (:person "John" :email (concat "jkitchin" "@cmu.edu")) has code to build the email address. This works, but the code is not actually executed anywhere. You would have to do that somewhere else.

Ok, here is a little code block that "renders" our buffer to show the person entries with an overlay. This is kind of like what a browser would do with html tags, but with my lispy markup. Here we rely on a particular data structure that we know in advance. We could probably be smarter about it, and check that there is a :person in the sexp, but for now we keep it simple, and make that be the car of the sexp. We will make an overlay of the name in angle brackets with an underline to indicate it is not the original text, and make a tooltip of the contents.

#+BEGIN_SRC emacs-lisp
(require 'ov)

(save-excursion
  (goto-char (point-min))
  (while (and  (re-search-forward "@(" nil t)
	       (sexp-at-point))
    (let ((beg)
	  (end)
	  (sexp))
      (backward-char)
      (setq beg (point))
      (setq sexp (read (current-buffer)))
      (when (and (listp sexp)
		 (eq :person (car (sexp-at-point))))
	(scan-sexps (point) 1)
		(setq end (point))
	(ov beg end 'help-echo (format "%S" sexp)
	    'face '(:underline t)
	    'display (concat "<" (plist-get sexp :person) ">")
	    'person t)))))
#+END_SRC

#+RESULTS:

That seems to work nicely. We can remove the overlays like this we can see the plain text.

#+BEGIN_SRC emacs-lisp
(ov-clear 'person)
#+END_SRC

#+RESULTS:

One reason for doing this, is the possibility of machine reading documents to extract data. Let's get the "people" out of this document.

#+BEGIN_SRC emacs-lisp
(save-excursion
  (goto-char (point-min))
  (let ((beg)
	(end)
	(sexp)
	(people '()))
    (while (and  (re-search-forward "(" nil t)
		 (sexp-at-point))
      (backward-char)
      (setq beg (point))
      (setq sexp (read (current-buffer)))
      (when (and (listp sexp)
		 (eq :person (car (sexp-at-point))))
	(add-to-list 'people sexp)))
    people))
#+END_SRC

#+RESULTS:
| :person | John         | :email | (concat jkitchin @cmu.edu) |
| :person | John Kitchin | :email | jkitchin@andrew.cmu.edu    |

Now, we have a nice list of "persons" we can do something with, e.g. add them to an org-contacts database, send a mail merge, etc... For sufficiently complex data structures, there might be some functions to help insert them. Let us do show a simple example to insert a "person" from a name in my org-contacts database.

#+BEGIN_SRC emacs-lisp
(defun insert-person (name)
  "Insert a person sexp for the NAME entry in `org-contacts-db'."
  (interactive "sName: ")
  (let ((contact (assoc name (org-contacts-db)))
	(p '()))
    (when contact
      (setq p (plist-put p :person (substring-no-properties(car contact))))
      (setq p (plist-put p :email (cdr (assoc "EMAIL" (nth 2 contact)))))
      (insert (format "%S" p)))))
#+END_SRC

#+RESULTS:
: insert-person


No doubt there are potential security issues with this. You would not want to do this with untrusted documents. But, with trusted documents, what an amazing opportunity to do something that is just not possible otherwise! This is like the best of both worlds in text, where you get easy authoring of some parts, the text part, and machine-readability in the data parts, which also look pretty readable, especially after the overlays.

You would need some kind of way to know how to render any things marked up this way. These are usually called [[http://www.w3schools.com/schema/][schemas]], and somewhere in the document you would put some kind of information about that. This could range from code that loads the overlay library, e.g. (:schema 'person), or some kind of url that defines the schema, e.g. (:schema "http://kitchingroup.cheme.cmu/person"). I have not thought too much about this point yet.

There are some related ideas around, e.g. [[http://racket-lang.org][racket]] and its scribble extension. [[http://www.dexy.it][dexy]] is a project that lets you embed code in documents that can be rendered in different outputs. Over on oremacs there is a project called [[http://oremacs.com/2015/01/23/eltex/][eltex]] where a LaTeX document is written totally in emacs-lisp. We previously  wrote about [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/05/Extending-the-org-mode-link-syntax-with-attributes/][org-mode links with attributes]]. There is also the linked text library [[http://www.emacswiki.org/emacs/linkd.el][linkd.el]] that provides a syntax for making sexps in text clickable. That package is especially interesting because, among many other things, it ties sexps into font-lock to automatically recognize them, and it provides some export support to other formats, making it possible to do some preprocessing to handle the sexps, and then to have an org-mode export. This package definitely needs more study!


Why not use html/xml for this kind of markup? There are some strong opinions out there, including http://c2.com/cgi/wiki?LispVsXml and https://rwmj.wordpress.com/2009/10/30/xml-or-s-expressions/. Here the bottom line is we can integrate the sexp notation pretty well with the editor we are using; it natively speaks them, unlike those other MLs.
* TODO Getting help on lispy keys

#+BEGIN_SRC emacs-lisp
;;* test
;;** testt
(defun lispy-help ()
  (interactive)
  (with-help-window (help-buffer)
    (princ "
f: step in list                b: back
h: next form at higher level   g: goto        s: sexp down w: sexp up
j: next form at this level     a: ace-symbol  n: new copy  N: narrow   >: slurp
k: previous form at this level q: ace-paren   P: paste     W: widen    <: barf
l: end of next higher form     Q: ace-char    t: teleport  y: occur
G: jump to tag                                c: clone     d: switch cursor
e: eval                        E: eval/insert i: indent
C-1: documentation             C-2: args
O: one-liner                   M: multi-liner
---------------------------------------------------------------------------------
xe: edebug        xd: lambda->defun      xl: defun->lambda  xr: eval/replace
xf: flatten       xc: if->cond           xi: cond->if
---------------------------------------------------------------------------------
oh: left/out   ol: right/out
oj: move 1st   ok: move last
---------------------------------------------------------------------------------
V: Visit file  2V:
J: forward outline K: backward outline L: outline child
")))

(define-key lispy-mode-map (kbd "?") 'lispy-help)
#+END_SRC

#+RESULTS:
: lispy-help

* TODO Using ivy-mode to insert citations in org-ref
  :PROPERTIES:
  :categories: emacs,orgref,ivy
  :END:
Ivy is a new completion engine for Emacs. It comes as part of [[https://github.com/abo-abo/swiper][swiper]]. It is an alternative to helm, which I have used a lot in org-ref. Here we consider an approach to use ivy in org-ref for inserting citations. We will develop an ivy command to query a bibtex file, and either insert a citation, open the entry or the PDF file.

With any completion framework, you need a list of candidates. org-ref provides an alist of citation strings, and all the fields of the corresponding bibtex entry. For example, here is the first entry.

#+BEGIN_SRC emacs-lisp :results code
(car (orhc-bibtex-candidates))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("  |2006-acs-style-guide| , The ACS Style Guide (2006) :test: :word:."
 ("url" . "https://doi.org/10.1021/bk-2006-STYG")
 ("doi" . "10.1021/bk-2006-styg")
 ("pages" . "nil")
 ("year" . "2006")
 ("publisher" . "American Chemical Society (ACS)")
 ("series" . "nil")
 ("date_added" . "Wed Apr  1 10:17:54 2015")
 ("keywords" . "test, word")
 ("title" . "The ACS Style Guide")
 ("author" . "")
 ("=type=" . "book")
 ("=key=" . "2006-acs-style-guide")
 ("bibfile" . "/Users/jkitchin/Dropbox/bibliography/references.bib")
 ("position" . 1839))
#+END_SRC

We use the string to narrow down our selection. Depending on the completion tool, the fields usually get sent to some kind of action function. Upon selection, we will need a few actions:
1. Insert a citation
2. Open the bibtex entry
3. Open the pdf of the entry.


First, an insert citation function. This will take a bibtex entry from ivy, and insert a citation. This is only moderately advanced; if you are on a citation, or at the end or beginning, the selected key is inserted appropriately at the end of the citation, and if not a new citation is inserted.

#+BEGIN_SRC emacs-lisp
(defun looking-forward-cite ()
  "Return if point is in the position before a citation."
  (save-excursion
    (forward-char)
    (-contains? org-ref-cite-types
	      (org-element-property
	       :type
	       (org-element-context)))))


(defun looking-back-cite ()
  "Return if point is in the position after a citation."
  (save-excursion
    (forward-char -1)
    (-contains? org-ref-cite-types
		(org-element-property
		 :type
		 (org-element-context)))))


(defun ivy-bibtex-insert-cite (entry)
  "Insert a citation for ENTRY.
ENTRY is selected from `orhc-bibtex-candidates'."
  (with-current-buffer cb
    (let ((key (cdr (assoc "=key=" entry))))
      (cond
       ;; on a cite
       ((-contains? org-ref-cite-types
		    (org-element-property
		     :type
		     (org-element-context)))
	(goto-char (org-element-property :end (org-element-context)))
	(insert (concat "," key)))
       ;; at end of a cite
       ((looking-back-cite)
	(insert (concat "," key)))
       ;; right before a cite
       ((looking-forward-cite)
	(forward-char)
	(goto-char (org-element-property :end (org-element-context)))
	(insert (concat "," key)))
       ;; insert a new cite
       (t
	(insert (concat "cite:" key)))))))
#+END_SRC

#+RESULTS:
: ivy-bibtex-insert-cite

Here are two functions to open the PDF and the bibtex entry.
#+BEGIN_SRC emacs-lisp
(defun ivy-bibtex-open-pdf (entry)
  "Open the pdf associated with ENTRY."
  (let ((pdf (expand-file-name
	      (format "%s.pdf"
		      (cdr (assoc "=key=" entry)))
	      org-ref-pdf-directory)))
    (if (file-exists-p pdf)
	(org-open-file pdf)
      (message "No pdf found for %s" (cdr (assoc "=key=" entry))))))


(defun ivy-bibtex-open-entry (entry)
  (find-file (cdr (assoc "bibfile" entry)))
  (goto-char (cdr (assoc "position" entry)))
  (bibtex-beginning-of-entry))
#+END_SRC

#+RESULTS:
: ivy-bibtex-open-entry

Finally, our selection function. We tell ivy to ignore order so it does not matter what order the authors are typed in, etc...
bibliography:~/Dropbox/bibliography/references.bib
#+BEGIN_SRC emacs-lisp :results silent
(defun ivy-cite (_)
  (interactive)
  (let ((cb (current-buffer))
	(org-ref-bibtex-files (org-ref-find-bibliography)))

    (ivy-read "Open: " (orhc-bibtex-candidates)
	      :require-match t
	      :action '(1
			("i" ivy-bibtex-insert-cite "Insert citation")
			("o" ivy-bibtex-open-entry "Open entry")
			("p" ivy-bibtex-open-pdf "open Pdf")))))

(add-to-list 'ivy-re-builders-alist (cons 'ivy-cite 'ivy--regex-ignore-order))
#+END_SRC

#+RESULTS:

When you run this command, you get an ivy selection buffer. Start typing some words to find what you want, and press enter to insert the citation.

Alternatively, when you have selected what you want type C-m. This is notable because if you type C-M-m, the selection buffer stays open and you can take advantage of this to insert several citations in succession.

If you forget what the actions are, type M-o and you will get a hydra menu of the actions. See what you want in the selection window? Type C-', and you get an avy like completion where one letter will make the final selection.

C-o will open a hydra menu for navigation and selection.

Overall, ivy seems like an interesting alternative for org-ref. I need to refactor some things in org-ref to enable easier switching between completion engines.  Currently, you can choose between these cite insertion engines:

- org link completion
- reftex
- helm-bibtex
- org-ref-helm-cite
- ivy

* TODO Getting VASP output from vasprun.xml in Python and Emacs
  :PROPERTIES:
  :categories: python,vasp,lisp
  :ID:       911077BA-93C7-42ED-A5F9-30049C4EB194
  :END:

[[https://www.vasp.at][VASP]] outputs a lot of its data in XML. Here we examine that output in Python and emacs-lisp to see how easy it is to use it. Where feasible, this is probably better than trying to parse the text-based OUTCAR file.

The XML is organized in "sections". Here, we look at the top level sections in the [[./vasprun.xml]] file. This particular file is from a CuPd alloy calculation I ran a long time ago.

#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

for el in xml:
    print el

#+END_SRC

#+RESULTS:
: <Element 'generator' at 0x102931050>
: <Element 'incar' at 0x102931210>
: <Element 'kpoints' at 0x102931410>
: <Element 'parameters' at 0x10294d950>
: <Element 'atominfo' at 0x10295f7d0>
: <Element 'structure' at 0x102963210>
: <Element 'calculation' at 0x102963610>
: <Element 'structure' at 0x103c64510>

Now, let us look at the elements in the generator element. We are just exploring for now.

#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

def pr(el, indent=0):
    print ' ' * indent, el.tag, el.attrib
    for child in el:
        pr(child, indent + 2)

pr(xml.find('generator'))
#+END_SRC

#+RESULTS:
:  generator {}
:    i {'type': 'string', 'name': 'program'}
:    i {'type': 'string', 'name': 'version'}
:    i {'type': 'string', 'name': 'subversion'}
:    i {'type': 'string', 'name': 'platform'}
:    i {'type': 'string', 'name': 'date'}
:    i {'type': 'string', 'name': 'time'}

The generator element contains information about the VASP executable, version and computer platform the calculation was run on. We can extract this information in the next section. We "find" an element with an [[https://en.wikipedia.org/wiki/XPath][xpath]] which allows you to write something like a path to the node containing the information, including specifying the attributes of a node. Pretty sweet.

#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

print xml.find('generator/i[@name="program"]').text
print xml.find('generator/i[@name="version"]').text
print xml.find('generator/i[@name="subversion"]').text
#+END_SRC
#+RESULTS:
: vasp
: 5.2.12
: 11Nov11 complex                                                      serial

Next, we see about the incar element. This contains the entries you used in the INCAR.
#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

def pr(el, indent=0):
    print ' ' * indent, el.tag, el.attrib
    for child in el:
        pr(child, indent + 2)

pr(xml.find('incar'))
#+END_SRC

#+RESULTS:
:  incar {}
:    i {'type': 'string', 'name': 'PREC'}
:    i {'type': 'int', 'name': 'IBRION'}
:    i {'type': 'int', 'name': 'ISIF'}
:    i {'name': 'ENCUT'}
:    i {'type': 'int', 'name': 'NBANDS'}
:    i {'type': 'int', 'name': 'ISMEAR'}
:    i {'name': 'SIGMA'}

Let us print them in the form that could be used as an INCAR file. Note we can iterate over the incar element here.

#+BEGIN_SRC python :session
for el in xml.find('incar'):
    print '{0} = {1}'.format(el.attrib['name'],
                             el.text)
#+END_SRC
#+RESULTS:
: PREC = high
: IBRION =     -1
: ISIF =      2
: ENCUT =     350.00000000
: NBANDS =     34
: ISMEAR =     -5
: SIGMA =       0.10000000

Here we look at the kpoints/generation element.

#+BEGIN_SRC python :session
for el in xml.find('kpoints/generation'):
    print '{0} = {1}'.format(el.attrib['name'], el.text)
#+END_SRC
#+RESULTS:
: divisions =        8        8        8
: usershift =       0.00000000       0.00000000       0.00000000
: genvec1 =       0.12500000       0.00000000       0.00000000
: genvec2 =       0.00000000       0.12500000       0.00000000
: genvec3 =       0.00000000       0.00000000       0.12500000
: shift =       0.00000000       0.00000000       0.00000000


There are a whole bunch of things in the parameters element. Most of these are either default values or properties of the calculation. Here we look at the number of electrons, and the value of the [[http://cms.mpi.univie.ac.at/wiki/index.php/AMIX][AMIX]] parameter in the electronic mixer.
#+BEGIN_SRC python :session
print xml.find('parameters/separator[@name="electronic"]/i[@name="NELECT"]').text
print xml.find('parameters/separator[@name="electronic"]/separator[@name="electronic mixer"]/i[@name="AMIX"]').text
#+END_SRC

#+RESULTS:
: 43.00000000
: 0.40000000

The structure element contains two elements: the initialpos and the finalpos.

#+BEGIN_SRC python :session
for el in xml.findall('structure'):  print el.attrib['name']
#+END_SRC
#+RESULTS:
: initialpos
: finalpos

Get final structure:
#+BEGIN_SRC python :session
positions = [[float(x) for x in el.text.split()]
             for  el in xml.findall('structure[@name="finalpos"]/varray[@name="positions"]/v')]

unit_cell = [[float(x) for x in el.text.split()]
             for el in xml.findall('structure[@name="finalpos"]/crystal/varray[@name="basis"]/v')]

symbols = [el.text for el in xml.findall('atominfo/array[@name="atoms"]/set/rc/c[1]')]

for sym, pos in zip(symbols, positions):
    print '{0}: {1}'.format(sym, pos)

print 'UC = {0}'.format(unit_cell)
#+END_SRC

#+RESULTS:
: Cu: [0.25334331, 0.25334331, 0.25334331]
: Cu: [0.0, 0.0, 0.0]
: Cu: [0.74665669, 0.74665669, 0.74665669]
: Pd: [0.5, 0.5, 0.5]
: UC = [[-5.46362047, 3.5654701, 5.46362047], [-3.5654701, 5.46362047, 5.46362047], [-5.46362047, 5.46362047, 3.5654701]]

The calculation element contains the energies for the self-consistent iterations performed.
#+BEGIN_SRC python :session
for el in xml.findall('calculation/scstep/energy/i[@name="e_0_energy"]'):
    print float(el.text)
#+END_SRC
#+RESULTS:
: -16.49261096
: -16.50499056
: -16.48925155
: -16.48985986
: -16.48973695
: -16.48985835
: -16.48981957

There is a lot more information in the vasprun.xml file. It takes some exploration to figure out what is there, and how to get it. I am not aware of any documentation on this file anywhere. But, it seems a lot easier to extract data from this than to parse the OUTCAR file.

** Lisp version
   :PROPERTIES:
   :ID:       8BB26503-A897-44B6-B598-80BC46C63371
   :END:
Here is a lisp script that extracts some data.
#+BEGIN_SRC emacs-lisp
(let* ((xml (car  (xml-parse-file "vasprun.xml")))
       (generator (car (xml-get-children xml 'generator)))
       (i-nodes (xml-get-children generator 'i)))
  (list
   (loop for i-node in i-nodes
	 when (string= "program" (xml-get-attribute i-node 'name))
	 return (car (xml-node-children i-node)))
   (loop for i-node in i-nodes
	 when (string= "version" (xml-get-attribute i-node 'name))
	 return (car (xml-node-children i-node)))
   (loop for i-node in i-nodes
	 when (string= "subversion" (xml-get-attribute i-node 'name))
	 return (car (xml-node-children i-node)))))
#+END_SRC

#+RESULTS:
| vasp | 5.2.12 | 11Nov11 complex                                                      serial |

That is definitely a bit more verbose than the Python code, but I suspect that is because it uses lower level functions. The main thing missing here is the use of xpath in emacs-lisp.

Let's see if we can get a little closer to the Python syntax. First, we break down the parsed xml a bit. The returned value of xml-parse-file is a list of elements, in this case, it is one element named modeling. That element contains everything else.

#+BEGIN_SRC emacs-lisp :results code
(loop for element in  (xml-parse-file "vasprun.xml")
      collect (xml-node-name element))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(modeling)
#+END_SRC

Now, lets see what is in modeling. The modeling element is nested in the output of xml-parse-file, and I guess it is conceivable there could be more than one of them. Let us be general and allow for that. We create a lambda function that takes a node, and then collects the name of any children nodes. It is possible the child node is a string, in which case it is the "text" of the element. We only want to collect container nodes here, which are lists. We use our lambda function to loop over each element in the output of xml-parse-file, and on that element, examine the child nodes.

#+BEGIN_SRC emacs-lisp :results code
(mapcar
 (lambda (node)
   (loop for element in  (xml-node-children node)
	 when (listp element)
	 collect (xml-node-name element)))
 (xml-parse-file "vasprun.xml"))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((generator incar kpoints parameters atominfo structure calculation structure))
#+END_SRC

Here I just wrap a function to make it a little cleaner.

#+BEGIN_SRC emacs-lisp :results value raw
(defun collect-children-names (parent)
  (loop for element in  (xml-node-children parent)
	   when (listp element)
	   collect (xml-node-name element)))

(mapcar
 'collect-children-names
 (xml-parse-file "vasprun.xml"))
#+END_SRC

#+RESULTS:
((generator incar kpoints parameters atominfo structure calculation structure))

Ok, that gives us an idea of the secondary structure.  The returned structure is a list containing a list of symbols. One more example. Let's now consider what is in the generator. Let us refresh our mental model of the data. We start with a list containing one modeling element, which is itself a list. The modeling element contains a generator element, which is a list containing other elements.

((modeling (generator (node1) (node2))))

So, when we work on the parent xml, we will get an outer list containing a list of a list of generators for each modeling element in the file. Sounds confusing! We can just flatten our list to level two!

#+BEGIN_SRC emacs-lisp
(defun collect-children-names (parent)
  (loop for element in  (xml-node-children parent)
	   when (listp element)
	   collect (cons (xml-node-name element) (cdr element))))

(collect-children-names
 (-flatten-n 2(loop for modeling in (xml-parse-file "vasprun.xml")
		    collect (loop for generator in (xml-get-children modeling 'generator)
				  collect (xml-node-children generator)))))
#+END_SRC

#+RESULTS:
| i | ((name . version) (type . string))    | 5.2.12                                                                      |
| i | ((name . subversion) (type . string)) | 11Nov11 complex                                                      serial |
| i | ((name . platform) (type . string))   | LinuxIFC                                                                    |
| i | ((name . date) (type . string))       | 2012 04 19                                                                  |
| i | ((name . time) (type . string))       | 03:40:00                                                                    |

#+BEGIN_SRC emacs-lisp
(car (mapcar
 (lambda (generator)
   (-filter (lambda (node) (when (listp node) (eq (car node) 'i)))
	    (xml-node-children generator)))
 (xml-get-children (car (xml-parse-file "vasprun.xml")) 'generator)))

#+END_SRC

#+RESULTS:
| i | ((name . program) (type . string))    | vasp                                                                        |
| i | ((name . version) (type . string))    | 5.2.12                                                                      |
| i | ((name . subversion) (type . string)) | 11Nov11 complex                                                      serial |
| i | ((name . platform) (type . string))   | LinuxIFC                                                                    |
| i | ((name . date) (type . string))       | 2012 04 19                                                                  |
| i | ((name . time) (type . string))       | 03:40:00                                                                    |


I am working towards:

#+BEGIN_SRC emacs-lisp
(findall xml '((generator) (i . '((name . "program")))))
#+END_SRC


#+RESULTS:
* TODO Backend specific output

#+BEGIN_SRC emacs-lisp
(setq org-export-babel-evaluate t)
#+END_SRC

#+RESULTS:
: t

#+name: backend
#+BEGIN_SRC emacs-lisp
org-export-current-backend
#+END_SRC



#+BEGIN_SRC python :var backend=backend :results raw
import matplotlib.pyplot as plt

plt.plot([3, 4, 5, 6])

if backend == 'latex':
    plt.savefig('backend.pdf')
    print '''
,#+caption: Your figure in pdf.
[[./backend.png]]'''
elif backend == 'html':
    plt.savefig('backend.png')
    print '''
,#+caption: Your figure in html.
[[./backend.png]]'''
else:
    plt.show()
#+END_SRC


Desirable features in python-mode

1. speed keys for navigation

statement block M-n M-p

python-mark-defun

(python-nav-end-of-defun)

* TODO Saving state data to a file in Emacs
  :PROPERTIES:
  :categories: emacs,lisp
  :ID:       6707012D-406F-42FC-80D0-536A07FAEF92
  :END:

I want to be able to save state data to a file from Emacs, and read it in later, possible after Emacs has been closed and re-opened. Here we document how to save the results to a file, and then later read them in. First, say we have a list containing a string, and we want to write it to disk. We will use the print function [[elisp:(describe-function 'print)]] for this. The basic strategy is to print the variable to a buffer that is written to file. Later, we can read the data in.

#+BEGIN_SRC emacs-lisp
(setq assignments '("one"))
(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| one |

Now, to read it back, we will load the file in a buffer, and then use the [[elisp:(describe-function 'read)]].

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
 (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

We can add to the list, and update the file easy enough.

#+BEGIN_SRC emacs-lisp
(add-to-list 'assignments "two")

(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

And, checking the results:

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
  (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

In the next sections, we consider saving more complex data structures.

** Saving an alist
   :PROPERTIES:
   :ID:       45F4C1FE-DCA4-4357-A51E-9F013F40A42A
   :END:

We can save an alist

#+BEGIN_SRC emacs-lisp :results raw
(with-temp-file "state-alist.el"
  (print '(("title" . "the title")
           ("author" . "John Kitchin")
           ("email" . "jkitchin@cmu.edu"))
	 (current-buffer)))
#+END_SRC

#+RESULTS:
((title . the title) (author . John Kitchin) (email . jkitchin@cmu.edu))

And, then read it in and access data from it.

#+BEGIN_SRC emacs-lisp
(cdr (assoc "email"
	 (with-temp-buffer (insert-file-contents "state-alist.el")
	   (read (current-buffer)))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Writing and reading a plist
   :PROPERTIES:
   :ID:       255906AB-0B52-4A67-BA8D-7EAD6139E6A2
   :END:

The print function can handle a plist.

#+BEGIN_SRC emacs-lisp
(with-temp-file "state-plist.el"
  (print '(:title   "the title"
		    :author  "John Kitchin"
		    :email   "jkitchin@cmu.edu")
	 (current-buffer)))
#+END_SRC

#+RESULTS:
| :title | the title | :author | John Kitchin | :email | jkitchin@cmu.edu |

#+BEGIN_SRC emacs-lisp
(plist-get (with-temp-buffer
	       (insert-file-contents "state-plist.el")
	     (read (current-buffer))) :author)
#+END_SRC

#+RESULTS:
: John Kitchin

** Writing and reading a hash table
   :PROPERTIES:
   :ID:       308B0479-658E-4CA5-990A-B1863307470C
   :END:
We can save a hash table.

#+BEGIN_SRC emacs-lisp
(setq my-hash (make-hash-table :test 'equal))

(puthash "title" "the title" my-hash)
(puthash "author" "John Kitchin" my-hash)
(puthash "email" "jkitchin@cmu.edu" my-hash)

(with-temp-file "state-hash.el"
  (print my-hash (current-buffer)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data ("title" "the title" "author" "John Kitchin" "email" "jkitchin@cmu.edu"))

#+BEGIN_SRC emacs-lisp
(gethash "email"
	 (with-temp-buffer (insert-file-contents "state-hash.el")
	   (read (current-buffer))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Totally different approach using json
   :PROPERTIES:
   :ID:       CB17C02F-5B44-4217-8A11-2E4220DD4DCF
   :END:
I like the symmetry of code and data in Emacs-lisp. There might be some advantages to using a structured data format other than Emacs Lisp data/code. One of them is interoperability with other programs. If there are subprograms that need to analyze the data in Python, for example. Here we consider json as a data format. We can write the data like this.

#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "this.json"
  (let ((data   '(:title   "the title"
			   :author  "John Kitchin"
			   :email   "jkitchin@cmu.edu")))
    (insert (json-encode-plist data))))
#+END_SRC

#+RESULTS:

It is simple enough to read the json data back in. Note, this reads in as an a-list by default.

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdr (assoc 'email (json-read-file "this.json")))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

To get the json read in another form, we have to temporarily define the json-object-type variable.

#+BEGIN_SRC emacs-lisp
(require 'json)
(let ((json-object-type 'plist))
  (plist-get (json-read-file "this.json") :email))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Summary
   :PROPERTIES:
   :ID:       3F9929B6-D6F2-44B7-A6E3-6931F8441823
   :END:
There are a few options for saving and reading data in different structures and formats. I did not explore very complex data structures here, e.g. deeply nested data, or different types of data within one structure. I still have not completely internalized best practices in writing/reading data. There are several approaches that all involve getting the data into a buffer. That can be done with find-file, or find-file-noselect, or with temp-buffers and insert-file-contents. I do not know which of these approaches are the best. Apparently find-file affects other things such as recent-files, and the buffer list, which may be undesirable. Emacs treats this very differently than Python, where you can simply open a file, and read it to get a string (the closest Python has to a buffer concept are related to StringIO). Interestingly, the json-read-file function uses a temp-buffer, inserts the file contents, and then reads the data. The code resembles this block:

#+BEGIN_SRC emacs-lisp
(defun read-file (file)
  "Read contents of a FILE into a string"
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-string)))

(read-file "state-alist.el")
#+END_SRC
#+RESULTS:
:
: (("title" . "the title") ("author" . "John Kitchin") ("email" . "jkitchin@cmu.edu"))
* TODO Explode paragraph to numbered list

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

#+RESULTS:

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse viverra consectetur euismod. Donec non tempor turpis.

1. This is a test.
2. I am typing some random text here consisting of several sentences and now am approaching the end of the display window.
3. Even though the previous sentence did not end something odd happens.

#+BEGIN_SRC emacs-lisp
(defun explode-paragraph ()
  (interactive)
  (let (start end)
    ;; narrow to paragraph
    (backward-paragraph) (forward-line)
    (setq start (point))
    (forward-paragraph) (previous-line)
    (setq end (line-end-position))

    ;; now move by sentence, insert number and \n. at the end go to beginning
    ;; C-cC-c to renumber the list.
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (insert "1. ")
      (while (< (point) (point-max))
	(forward-sentence)
	(when (if sentence-end-double-space
		  (looking-at "  [[:alpha:]]")
		(looking-at " [[:alpha:]]"))
	  (insert "\n1. ")))
      (goto-char (point-min))
      (org-ctrl-c-ctrl-c))))

(defun unfill-paragraph ()
  "Unfill paragraph at or after point."
  (interactive "*")
  (let ((fill-column most-positive-fixnum))
    (fill-paragraph nil (region-active-p))))

(defun list-to-paragraph ()
  "Convert list at point to a paragraph."
  (interactive)
  ;; make sure we are at the beginning of the list
  (beginning-of-line)
  (let ((element (org-element-context))
	contents)
    (when (eq 'item (car element))
      (setq element (org-element-property :parent (org-element-context)))
      (goto-char
       (org-element-property
	:begin
	element)))
    ;; collect each sentence, minus the numbers.
    (setq contents (loop for node in
			 (org-element-property :structure element)
			 collect
			 ;; remove number and space
			 (replace-regexp-in-string
			  (regexp-quote (nth 2 node)) ""
			  (buffer-substring (nth 0 node)
					    (nth 6 node)))))
    ;; replace the list, and then unfill the paragraph.
    (setf (buffer-substring (org-element-property :begin element)
			    (- (org-element-property :end element) 1))
	  (mapconcat 'identity contents ""))
    (goto-char (org-element-property :begin element))
    (unfill-paragraph)))
#+END_SRC

#+RESULTS:
: list-to-paragraph

1. idea 1. idea 2. idea 3.

cite:antony-2012-pathw-c

* TODO [#B] indexing headlines	       :tag1:tag2:
  :PROPERTIES:
  :ID:       9D16D2DE-81D8-4F15-A41E-210180D61E23
  :special-property: 6
  :END:

We need to design a database scheme. Each headline will have an ID. On saving an org-file, we need to do the following:

1. delete entries from the database that no longer exist.
2. update entries that do exist
3. add new entries that don't exist

Might nees some escaping mechanism for some text.

[[id:728B810C-257E-4722-8AF0-5E03A9116288][A full database of org files with search]]
** an outline of how to do this
   :PROPERTIES:
   :ID:       CAD945E0-3DD3-4A8C-86CC-3BEFF203E2FD
   :END:
#+BEGIN_SRC sh
rm -f org.sqlite
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sqlite
CREATE VIRTUAL TABLE headlines USING fts4 (
  id INTEGER PRIMARY KEY,
  fname TEXT,
  orgid TEXT UNIQUE,
  position INTEGER,
  content TEXT);
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh
rm -fr org.sqlite
#+END_SRC

#+RESULTS:


#+BEGIN_SRC emacs-lisp
(require 'emacsql)

(setq db (emacsql-sqlite "org.sqlite"))

(emacsql db [:create-table headlines
			   ([(id integer :primary-key)
			     (orgid :unique)
			     fname
			     (position integer)
			     level
			     reduced-level
			     TODO
			     priority
			     title
			     tags
			     content])])
#+END_SRC

#+BEGIN_SRC emacs-lisp
(emacsql db [:insert :into headlines
		     :values $v1]
	 (org-map-entries
	  (lambda ()
	    (eval `(vector
		    nil			; auto-insert id
		    (org-id-get-create)
		    (buffer-file-name)
		    (point)
		    ,@(org-heading-components)
		    (buffer-substring
		     (org-entry-beginning-position)
		     (org-entry-end-position)))))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(emacsql db [:select [position] :from headlines :where (= orgid "001717E6-7B28-4FA8-BC30-DDAE8CB6AC37")])
#+END_SRC

#+RESULTS:
| 5365 |

** Deleting headlines not in the database
   :PROPERTIES:
   :ID:       09C5EB9B-121A-45E9-B05F-24A8AA9B5585
   :END:

First, get a list of orgids in our database for this file:
#+BEGIN_SRC emacs-lisp
(emacsql db [:select [orgid] :from headlines :where (= fname $s1)] (buffer-file-name))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("9D16D2DE-81D8-4F15-A41E-210180D61E23")
 ("001717E6-7B28-4FA8-BC30-DDAE8CB6AC37"))
#+END_SRC

Here are the headlines in the current buffer
#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda () (org-id-get-create)))
#+END_SRC

#+RESULTS:
| 9D16D2DE-81D8-4F15-A41E-210180D61E23 | 09C5EB9B-121A-45E9-B05F-24A8AA9B5585 | F390E6CD-57DD-43A6-ADBD-AB917E243A90 | 001717E6-7B28-4FA8-BC30-DDAE8CB6AC38 |

The ones in the database that do not exist in the buffer are:

#+BEGIN_SRC emacs-lisp
(let ((-compare-fn (lambda (a b) (string= (car a) b))))
  (-difference
   (emacsql db [:select [orgid] :from headlines :where (= fname $s1)]
	    (buffer-file-name))
   (org-map-entries (lambda () (org-id-get-create)))))
#+END_SRC

#+RESULTS:
| 001717E6-7B28-4FA8-BC30-DDAE8CB6AC37 |

Now, we delete entries that do not exist
#+BEGIN_SRC emacs-lisp
(defun db-prune-headlines ()
  "Removes headlines in the database that are not in the current buffer."
  (mapc
   (lambda (x)
     (emacsql db
	      [:delete :from headlines
		       :where (= orgid $s1)]
	      (car x)))

   (let ((-compare-fn (lambda (a b) (string= (car a) b))))
     (-difference
      (emacsql db [:select [orgid] :from headlines :where (= fname $s1)]
	       (buffer-file-name))
      (org-map-entries (lambda () (org-id-get-create)))))))
#+END_SRC

#+RESULTS:
: prune-db-headlines

Next, we update existing headlines.

#+BEGIN_SRC emacs-lisp
(emacsql db [:update headlines :set [(= position 10) (= fname "tree")]  :where (= orgid "9D16D2DE-81D8-4F15-A41E-210180D61E23")])
#+END_SRC

#+RESULTS:
** Update entries in the database
   :PROPERTIES:
   :ID:       3CD1DB93-2DE2-4850-A7A1-CBE864E8422C
   :END:

#+BEGIN_SRC emacs-lisp
(defun update-db (orgid)
  (save-excursion
    (org-id-goto orgid)
    (eval  `(emacsql db [:update headlines
				 :set [(= position $s1)
				       (= level $s2)
				       (= reduced-level $s3)
				       (= TODO $s4)
				       (= priority $s5)
				       (= title $s6)
				       (= tags $s7)
				       (= content $s8)
				       (= fname $s9)]
				 :where (= orgid ,orgid)]
		     (point)
		     ,@(org-heading-components)
		     (buffer-substring
		      (org-entry-beginning-position)
		      (org-entry-end-position))
		     (buffer-file-name)))))

(mapc
 (lambda (x) (update-db (car x)))
 (emacsql db [:select [orgid] :from headlines :where (= fname $s1)] (buffer-file-name)))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
update-db
#+END_SRC

#+BEGIN_SRC emacs-lisp
(emacsql db [:select [orgid, fname] :from headlines])
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("9D16D2DE-81D8-4F15-A41E-210180D61E23" "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org"))
#+END_SRC

** Add the new headlines
   :PROPERTIES:
   :ID:       4D59ACCC-4DCD-4643-ABDF-6E548E54005F
   :END:
Finally, let's add new headlines.

Here are the ones in the buffer that aren't in the database.

#+BEGIN_SRC emacs-lisp
(defun db-insert-headline (orgid)
  (emacsql db [:insert :into headlines
		       :values $v1]
	   (db-headline orgid)))


(mapc
 'db-insert-headline
 (let ((-compare-fn (lambda (b a) (string= (car a) b))))
   (-difference
    (org-map-entries (lambda () (org-id-get-create)))
    (emacsql db [:select [orgid] :from headlines :where (= fname $s1)]
	     (buffer-file-name))
    )))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(emacsql db [:select [orgid] :from headlines :where (= fname $s1)] (buffer-file-name))
#+END_SRC

#+RESULTS:
| 9D16D2DE-81D8-4F15-A41E-210180D61E23 |
| 09C5EB9B-121A-45E9-B05F-24A8AA9B5585 |
| 3CD1DB93-2DE2-4850-A7A1-CBE864E8422C |
| 4D59ACCC-4DCD-4643-ABDF-6E548E54005F |
| F390E6CD-57DD-43A6-ADBD-AB917E243A90 |
| 001717E6-7B28-4FA8-BC30-DDAE8CB6AC38 |

** Putting it all together
   :PROPERTIES:
   :ID:       D5B6F281-6CCE-49BA-BBDA-EB6D1B45633B
   :END:

#+BEGIN_SRC emacs-lisp
(require 'emacsql)

(when (file-exists-p "org.sqlite") (delete-file "org.sqlite"))
(setq db (emacsql-sqlite "org.sqlite"))

(emacsql db [:create :virtual :table headlines :using fts4
			   ([(id integer :primary-key)
			     (orgid :unique)
			     fname
			     (position integer)
			     level
			     reduced-level
			     TODO
			     priority
			     title
			     tags
			     content])])
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
db
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'org-db)
(db-reset)
(db-async-update-file)
(db-update-file)

;(remove-hook 'after-save-hook 'db-update-file)
#+END_SRC

#+RESULTS:
: #<process emacs>

pine

** DONE Content hl
   CLOSED: [2015-11-27 Fri 18:18]
   :PROPERTIES:
   :ID:       6593D170-4714-444C-8C33-D30A0CBEC137
   :END:

what? Funny
 pine tree

** TODO query the db
   :PROPERTIES:
   :ID:       8D6DCD04-7952-425C-AE20-D17DA2ED8E70
   :END:

#+BEGIN_SRC sqlite
select title,position from headlines where headlines match '"Funny"';
#+END_SRC

#+RESULTS:
: """Content hl""",9109
: """query the db""",9263
: """Pyparsing meets Emacs to find chemical formulas""",503763


This matches almost anything in the headlines table containing alloy, in a tag, headline or content.
#+BEGIN_SRC emacs-lisp
(emacsql db [:select [title position-link] :from headlines :where (match headlines "alloy")])
#+END_SRC

#+RESULTS:
| query the db                                             | (org-open-link-from-string "[[id:8D6DCD04-7952-425C-AE20-D17DA2ED8E70]]") |
| Priority                                                 | (org-open-link-from-string "[[id:B0436A91-6B4F-4B0A-A9C1-E770C7C1337F]]") |
| Altmetrics meet my publications                          | (org-open-link-from-string "[[id:36E056EB-05EE-4382-9646-B3D5B110EA69]]") |
| Getting VASP output from vasprun.xml in Python and Emacs | (org-open-link-from-string "[[id:911077BA-93C7-42ED-A5F9-30049C4EB194]]") |
| Getting a Scopus EID from a DOI                          | (org-open-link-from-string "[[id:5E2032BB-1E74-4427-AFBA-59790A848789]]") |
| Get information for all documents                        | (org-open-link-from-string "[[id:0B4E5C59-5A5E-4851-94D2-3DC2614E2131]]") |
| The orcid api and generating a bibtex file from it       | (org-open-link-from-string "[[id:7E82C2D9-A5D1-49B8-86F7-8A54753368B7]]") |
| A new approach to extracting bibtex file from org        | (org-open-link-from-string "[[id:D36B82BB-75E8-47DA-A4DE-A13C47427B3A]]") |


To be specific to tags, we can do this:
#+BEGIN_SRC emacs-lisp
(emacsql db [:select [title position-link] :from headlines :where (match tags "alloy")])
#+END_SRC

#+RESULTS:
| Priority | (org-open-link-from-string "[[id:B0436A91-6B4F-4B0A-A9C1-E770C7C1337F]]") |

Funny

Or, on TODO state:
#+BEGIN_SRC emacs-lisp
(emacsql db [:select [title position-link] :from headlines :where (= TODO "TODO")])
#+END_SRC

*** [#A] Priority			   :alloy:
    :PROPERTIES:
    :ID:       B0436A91-6B4F-4B0A-A9C1-E770C7C1337F
    :END:
Priorities are stored as characters.
#+BEGIN_SRC emacs-lisp
?B
#+END_SRC

#+RESULTS:
: 66

We use the character syntax to search on priority.
#+BEGIN_SRC emacs-lisp
(emacsql db [:select [title position-link] :from headlines :where (= priority ?B)])
#+END_SRC

#+RESULTS:
| indexing headlines | (org-open-link-from-string "[[id:9D16D2DE-81D8-4F15-A41E-210180D61E23]]") |

#+BEGIN_SRC emacs-lisp
(emacsql db [:select [title position-link] :from headlines :where (= priority ?A)])
#+END_SRC

#+RESULTS:
| Priority | [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org")(goto-char 9673))][link]] |


#+BEGIN_SRC sqlite
SELECT title, '"[[elisp:(goto-char "' || position || '")]]"' FROM headlines WHERE priority = 67;
#+END_SRC

#+RESULTS:
: """table""","""[[elisp:(goto-char ""10583"")]]"""
: """tags""","""[[elisp:(goto-char ""8514"")]]"""

*** [#C] tags
    :PROPERTIES:
    :ID:       037A7785-F5C7-4AD6-9C56-35A5CD38B886
    :END:
#+BEGIN_SRC emacs-lisp
(emacsql db [:select :distinct [tags] :from headlines])
#+END_SRC

#+RESULTS:
| :tag1:tag2:   |
| nil           |
| :alloy:       |
| :schema:tag1: |
| :test:        |
| :ARCHIVE:     |
| :noexport:    |
| :slide:       |
| :chemistry:   |
| :physics:     |
| :math:        |
| :biology:     |
| :engineering: |

#+BEGIN_SRC emacs-lisp
(emacsql db [:select [fname position-link tags] :from headlines :where (match tags "tag1 tag2")])
#+END_SRC

#+RESULTS:
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org | [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org")(goto-char 1))]] | :tag1:tag2: |

*** Distinct filenames
    :PROPERTIES:
    :ID:       90FDC418-5B11-4435-8FD9-6C01FEB64160
    :END:
(db-update-file)
#+BEGIN_SRC emacs-lisp
(emacsql db [:select :distinct [fname] :from headlines])
#+END_SRC

#+RESULTS:
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org |


** new headline
   :PROPERTIES:
   :ID:       C8CB3819-251F-4FF1-826F-1DDC790FC269
   :END:
* TODO A voting system for org-mode headlines
  :PROPERTIES:
  :ID:       A5019007-826E-476B-86DA-82C3F93F7666
  :END:

Over on [[http://stackoverflow.com/questions/27937446/how-to-vote-for-a-heading-in-org-mode][Stack Overflow]] someone wanted a system to "vote" for headlines. Basically they have a lot of headlines, and they want a +1 feature that will set a VOTES property on a headline. Then, they could filter the headlines by some voting criteria. Org-mode is made for that kind of thing, but we have to implement it ourselves. We just need to define a function that sets the property. The only subtle points in this are that properties are defined as strings, and we have to put a string in the property. That means we have to convert the string to a number, increment it, and convert it back to a string. We also add an org-mode speed command to + so when our cursor is at the beginning of the headline, we just press + to increment the VOTES property.

#+BEGIN_SRC emacs-lisp
(defun plusone ()
  "Increase the VOTES property in an org-heading by one. Create
the property if needed."
  (interactive)
  (org-entry-put
   (point)
   "VOTES"
   (format "%s" (+ 1 (string-to-number
		      (or
		       (org-entry-get (point) "VOTES")
		       "0"))))))

(add-to-list 'org-speed-commands-user '("+" . (plusone)))
#+END_SRC

#+RESULTS:
| + | quote | plusone |

Now some test headlines. We can use the agenda to filter headlines. Here is the agenda command that is equivalent to the key sequence "C-c a < m". Type in VOTES>2, for example, to see headlines that have more than two votes.

#+BEGIN_SRC emacs-lisp
(org-agenda nil "m" "<")
#+END_SRC

** heading 1
   :PROPERTIES:
   :VOTES:    2
   :ID:       B218A030-D9A5-4C29-9404-CEFA3EE58F1B
   :END:
** heading 2
   :PROPERTIES:
   :VOTES:    5
   :ID:       0A502790-4B83-42D8-A253-E3F75C34C57E
   :END:
** heading 3
   :PROPERTIES:
   :VOTES:    1
   :ID:       68C57AF3-BFBC-474B-953C-1294B6D1B2CB
   :END:
* TODO enumerate and zip in emacs lisp using the loop
  :PROPERTIES:
  :ID:       2DFF679A-F7E8-4432-B76A-0ED12A2983DD
  :END:
here are hand-rolled functions.

#+BEGIN_SRC emacs-lisp :results output
(defun enumerate (lst)
  (loop for i from 0
	for el in lst
	collect (cons i el)))

(loop for (i . el) in (enumerate '(a b c d))
      do (princ (format "%s: %s\n" i el)))
#+END_SRC
#+RESULTS:
: 0: a
: 1: b
: 2: c
: 3: d


#+BEGIN_SRC emacs-lisp
(-annotate
#+END_SRC


#+BEGIN_SRC emacs-lisp :results output
(defun zip (&rest args)
  (unless (memq 'nil args)
    (cons (mapcar 'car args)
	  (apply 'zip (mapcar 'cdr args)))))

(loop for (i j k) in (zip '(a b c) '(1 2 3) '(5 6 7))
  do (princ (format "-%s--%s--%s\n" i j k)))
#+END_SRC
#+RESULTS:
: -a--1--5
: -b--2--6
: -c--3--7

dash provides a zip function
#+BEGIN_SRC emacs-lisp
(require 'dash)
(-zip '(a b c) '(1 2 3) '(5 6 7))
#+END_SRC
#+RESULTS:
| a | 1 | 5 |
| b | 2 | 6 |
| c | 3 | 7 |

* TODO Using org-mode files as databases
  :PROPERTIES:
  :ID:       86584694-09BC-4FE2-9863-A3E0061D3C30
  :END:

Below are subheadings that contain data, properties and tags. Here, we use this entry as a database to summarize data.

#+BEGIN_SRC emacs-lisp
(let* ((total-units 0)
      (units)
      (course)
      (courses (org-map-entries (lambda ()
				  (setq units (string-to-number (org-entry-get (point) "UNITS"))
					total-units (+ total-units units)
					course (nth 4 (org-heading-components)))
				  `(,course  ,units ,(org-entry-get (point) "SEMESTER")))
				"chemistry|biology|physics|math" 'tree nil)))
  (add-to-list 'courses `(nil "Total units"  ,total-units) t))
#+END_SRC

#+RESULTS:
| 09-105 |           9 |  1 |
| 09-106 |           9 |  2 |
| 33-105 |          12 |  1 |
| 33-106 |          12 |  3 |
| 21-120 |           9 |  1 |
| 21-122 |           9 |  2 |
| 21-259 |           9 |  3 |
| 03-232 |           9 |  5 |
|    nil | Total units | 78 |

How about classes with less than 12 units?

#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil)
#+END_SRC

#+RESULTS:
| Using org-mode files as databases | nil |
|                            09-105 |   9 |
|                            09-106 |   9 |
|                            21-120 |   9 |
|                            21-122 |   9 |
|                            21-259 |   9 |
|                            03-232 |   9 |

I am surprised by the nil entry above. I would have thought an entry with out a property should not be counted. That suggests some list pruning is in order. There is a remove-if-not macro in the cl (common-lisp) library.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(remove-if-not
  (lambda (arg) (nth 1 arg))
    (org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil))
#+END_SRC

#+RESULTS:
| 09-105 | 9 |
| 09-106 | 9 |
| 21-120 | 9 |
| 21-122 | 9 |
| 21-259 | 9 |
| 03-232 | 9 |

** 09-105							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :ID:       E32A66DE-5C3E-4D17-B8B4-5550DD20A35D
   :END:
** 09-106							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :ID:       D5FE8430-412D-4206-BFF7-01E269A68B23
   :END:
** 33-105							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :ID:       8CE29FB6-CF81-4CBE-AE6D-AFCA52750FBE
   :END:
** 33-106							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 3
   :ID:       FB3979A2-1B8D-4FBC-B6D3-581EE29A7F52
   :END:
** 21-120							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :ID:       47379344-8F12-4AF3-822C-921644868CD5
   :END:
** 21-122							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :ID:       051805CC-EA47-4B2E-AC87-99233C9648F8
   :END:
** 21-259							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 3
   :ID:       6FF40249-00BD-45FA-A7DD-3989B2B84792
   :END:
** 03-232							    :biology:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 5
   :ID:       7E74D451-ABC1-41E3-B404-63F41C03C9B4
   :END:
** 06-100							:engineering:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :ID:       05D4A4C7-33F9-4A03-AF3C-56C84B31ECBD
   :END:
* TODO coupling org-mode and code	    :test:
  DEADLINE: <2015-10-20 Tue>
  :PROPERTIES:
  :TEST:     tree
  :ID:       2FD9A4E4-74F9-43E7-B42F-8DF4F979C668
  :END:

This is a generic idea that I am using org-headlines as containers for data, and frequently want some way to interact with collections, to add new headlines, etc... I find it awkward to use org-entry-get all the time. I am thinking of a generic function that would return a data structure.

Here I work it out for a contact.

#+BEGIN_SRC emacs-lisp
(defclass Contact ()
  ((email :initarg :email
	  :documentation "The email address")
   (birthday :initarg :birthday
	     :documentation "An org-timestamp for the birthdate."))
  "A contact")

(defmethod get-email ((contact Contact))
  (oref contact email))

(let ((c (Contact nil :email "jkitchin@andrew.cmu.edu" :birthday [2015-10-20 Tue])))
  (oref c birthday))
#+END_SRC

#+RESULTS:
: [2015-10-20 Tue]


Here is a struct approach where we map over the headlines that have a BIRTHDAY property and make a struct out them.

#+BEGIN_SRC emacs-lisp
(cl-defstruct Contact name marker properties)

(let ((contacts (org-map-entries
		 (lambda ()
		   (make-Contact
		    :name (org-get-heading t t)
		    :marker (point-marker)
		    :properties (org-entry-properties (point) 'all)))
		 "BIRTHDAY<>\"\"")))
  (mapcar 'Contact-name contacts))
#+END_SRC

#+RESULTS:
| John | Jane |

Now, we convert a headline to a alist.

#+BEGIN_SRC emacs-lisp
(defun org-headline-to-alist ()
  (append
   (list
    (org-get-heading t t)
    (cons "MARKER" (point-marker)))
   (org-entry-properties (point) 'all)))

(org-headline-to-alist)
#+END_SRC

#+RESULTS:
| coupling org-mode and code | (MARKER . #<marker at 1409 in blog.org>) | (TODO . TODO) | (FILE . /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | (TAGS . :test:) | (ALLTAGS . :test:) | (BLOCKED . ) | (DEADLINE . 2015-10-20 Tue) | (TIMESTAMP_IA . 2015-10-20 Tue) | (TEST . tree) | (CATEGORY . blog) |

** John
   :PROPERTIES:
   :BIRTHDAY: [2012-10-20 Sat]
   :TYPE:    contact
   :ID:       953A197F-8FD2-4BA2-9E3F-09517FECB419
   :END:

** Jane
   :PROPERTIES:
   :BIRTHDAY: [2014-10-20 Mon]
   :TYPE:    contact
   :ID:       8EF9086D-F521-4341-BB06-C2167360B6B1
   :END:
* avy-goto-line with voice
doesn't work.
#+BEGIN_SRC emacs-lisp
(defun voice-char ()
  (let* ((chars (mapconcat
		 (lambda (x) (format "\"%s\"" (symbol-name x)))
		 '(a b c d e f g h i j k l m n o p q r s t u v w x y z)
		 ", "))
	 (script (format  "--Part 1:
tell application \"SpeechRecognitionServer\"
    --Part 2:
    set heardPhrase to listen for ¬
        {%s}
end tell
--Part 3:
heardPhrase" chars)))
    (do-applescript script)))



(defun vavy-goto-line (&optional arg)
  "Jump to a line start in current buffer.

When ARG is 1, jump to lines currently visible, with the option
to cancel to `goto-line' by entering a number.

When ARG is 4, negate the window scope determined by
`avy-all-windows'.

Otherwise, forward to `goto-line' with ARG."
  (interactive "p")
  (setq arg (or arg 1))
  (if (not (memq arg '(1 4)))
      (progn
        (goto-char (point-min))
        (forward-line (1- arg)))
    (avy-with vavy-goto-line
      (let* ((avy-handler-function
              (lambda (char)
                (if (or (< char ?0)
                        (> char ?9))
                    (avy-handler-default char)
                  (let ((line (voice-char)))
                    (when line
                      (avy-push-mark)
                      (save-restriction
                        (widen)
                        (goto-char (point-min))
                        (forward-line (1- (string-to-number line))))
                      (throw 'done 'exit))))))
             (r (avy--line (eq arg 4))))
        (unless (eq r t)
          (avy-action-goto r))))))
#+END_SRC

#+RESULTS:
: vavy-goto-line

#+BEGIN_SRC emacs-lisp

#+END_SRC

* Get voice input
#+BEGIN_SRC emacs-lisp
(do-applescript "tell application \"SpeechRecognitionServer\"
    set theResponse to listen for {\"good\", \"bad\"} with prompt \"How are you?\"
    if theResponse is \"good\" then
        say \"Wonderful sir… Is there anything you want me to do for you?\"
    else
        say \"Cheer up chap! Is there anything you want me to do for you?\"
    end if
end tell")


(do-applescript "say \"lah lah lah lah lah lah lah lah lah lah lah\" using \"Bad News\"")



#+END_SRC

#+BEGIN_SRC emacs-lisp
(do-applescript "--Part 1:
tell application \"SpeechRecognitionServer\"
    --Part 2:
    set heardPhrase to listen for ¬
        {\"One fish\", \"Two fish\", \"Red fish\", \"Blue fish\"}
end tell
--Part 3:
heardPhrase")
#+END_SRC

#+RESULTS:
: Red fish

#+BEGIN_SRC emacs-lisp
(let* ((opts '(("next" . forward-line)
	       ("previous" . previous-line)
	       ("forward" . forward-char)
	       ("back" . backward-char)
	       ("quit" . nil)))
       (listen-for (mapconcat
		    (lambda (x) (format "\"%s\"" (car x)))
		    opts
		    ", "))
       (result)
       (script (format  "--Part 1:
tell application \"SpeechRecognitionServer\"
    --Part 2:
    set heardPhrase to listen for ¬
        {%s}
end tell
--Part 3:
heardPhrase" listen-for)))
  (while (not (string= "q" (setq result (do-applescript script))))
    (funcall (cdr (assoc result opts)))))


#+END_SRC

#+RESULTS:

* Mendeley Desktop

#+BEGIN_SRC emacs-lisp
(let ((url-request-method "POST")
      (url-mime-accept-string "application/vnd.mendeley.wordProcessorApi+json; version=1.0")
      (url-request-data (json-encode-alist
			 `((citationEditorHint . "hintText")))))
  (with-current-buffer (url-retrieve-synchronously
			"http://localhost:50002/run?command=/citation/choose/interactive&method=POST")
    (buffer-string)))
#+END_SRC

#+RESULTS:
: HTTP/1.1 404 Not Found
: Content-Length:34
: Connection:keep-alive
:
: Mendeley could not find that page.

* Adaptive completion


http://stackoverflow.com/questions/35797548/how-do-i-change-the-candidates-for-ido-completing-read-based-on-the-input

[[help:completing-read]]

[[help:completion-boundaries]]

[[info:(elisp)]]

#+BEGIN_SRC emacs-lisp
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Programmed-Completion.html
(defun myc (string pred action)
  (let ((completions (if (oddp (string-to-number (substring string -1)))
			 '("1" "3" "5" "7" "9")
		       '("0" "2" "4" "6" "8"))))
    (cond
     ((null action)
      ;;try-completion This specifies a try-completion operation. The function
      ;; should return t if the specified string is a unique and exact match; if
      ;; there is more than one match, it should return the common substring of
      ;; all matches (if the string is an exact match for one completion
      ;; alternative but also matches other longer alternatives, the return value
      ;; is the string); if there are no matches, it should return nil.
      string)

     ((eq 't action)
      ;; This specifies an all-completions operation. The function should return a
      ;; list of all possible completions of the specified string.
      completions)

     ((eq 'lambda action)
      ;; lambda This specifies a test-completion operation. The function should
      ;; return t if the specified string is an exact match for some completion
      ;; alternative; nil otherwise.
      (unless (zerop (length string))
	nil))

     ((and (consp action) (eq 'boundaries (car-safe action)))
      ;; (boundaries . suffix) This specifies a completion-boundaries operation.
      ;; The function should return (boundaries start . end), where start is the
      ;; position of the beginning boundary in the specified string, and end is
      ;; the position of the end boundary in suffix.
      ;; boundaries are the whole string.
      (cons 0 (length (cdr action))))

     ((eq 'metadata action)
      ;; metadata This specifies a request for information about the state of the
      ;; current completion. The return value should have the form (metadata .
      ;; alist), where alist is an alist whose elements are described below.
      '(metadata (category . string)))

     ;; Anything else...
     (t
      nil))))

(completing-read "N: " 'myc)

#+END_SRC

#+RESULTS:
: 123

* Custom colorization of org-mode links

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type "todo"
 (lambda (path) (message-box path)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun colorize-todo-links (&rest _)
  (save-match-data
    (let ((s (match-string 0))
	  (beg (match-beginning 0))
	  (end (match-end 0)))
      (message "%s %s\n" s (string= "todo:" (substring s 0 5)))
      (when (or (string= "todo:" (substring s 0 5))
		(string= "todo:" (substring s 2 7)))
	(add-text-properties
	 beg end
	 `(face (:foreground "red")))))))

(advice-add 'org-activate-plain-links :after 'colorize-todo-links)
(advice-add 'org-activate-bracket-links :after 'colorize-todo-links)

;;(advice-remove 'org-activate-plain-links 'colorize-todo-links)
#+END_SRC

#+RESULTS:

[[todo:ttees]]

a   [[todo:tree]]  and plain todo:for-now.
    cite:2006-acs-style-guide

and a file:link and a  [[todo:tree]]  and some text cite:2011-mater-genom  todo:test we need stuff.

[[todo:test]]  test  todo:tree .

[[cite:2006-acs-style-guide][test]]


#+BEGIN_SRC emacs-lisp
(org-element-map (org-element-parse-buffer) 'headline
  (lambda (hline) (org-element-property :raw-value hline)))
#+END_SRC
#+RESULTS:
| Custom colorization of org-mode links |

* uncoloring [[file:test.org]] in headlines
** a headline with a file:
http://emacs.stackexchange.com/questions/19568/can-i-hack-org-mode-to-not-visually-modify-links-in-headers?rq=1

file:test.org

#+BEGIN_SRC emacs-lisp
(defun uncolorize-heading-plain-links (&rest _)
  (save-match-data
    (let ((s (match-string 0))
	  (path (match-string 1))
	  (beg (match-beginning 0))
	  (end (match-end 0))
	  (map (make-sparse-keymap)))
      (message "%s" path)
      (when (and (org-on-heading-p) (string-match org-plain-link-re s))
	(define-key map [mouse-1]
	  (lambda ()
	    (interactive)
	    (org-open-at-point-global)))
	(set-text-properties
	 beg end
	 `(face ,(get-text-property (line-beginning-position) 'face)
		mouse-face 'highlight
		local-map ,map))))))

(defun uncolorize-heading-bracket-links (&rest _)
  (save-match-data
    (let ((s (match-string 0))
	  (path (match-string 1))
	  (desc (match-string 2))
	  (beg (match-beginning 0))
	  (end (match-end 0))
	  (map (make-sparse-keymap)))
      (message "%s" path)
      (when (and (string-match org-bracket-link-regexp s) (org-on-heading-p))
	(define-key map [mouse-1]
	  (lambda ()
	    (interactive)
	    (org-open-at-point-global)))
	(set-text-properties
	 beg end
	 `(face ,(get-text-property (line-beginning-position) 'face)
		mouse-face 'highlight
		local-map ,map
		display ,(if desc (substring-no-properties desc 1 -1)
			   (substring-no-properties path))))))))

(advice-add 'org-activate-plain-links :after 'uncolorize-heading-plain-links)
(advice-add 'org-activate-bracket-links :after 'uncolorize-heading-bracket-links)


;; (advice-add 'org-activate-bracket-links :after 'uncolorize-heading-bracket-links)


;;(advice-remove 'org-activate-bracket-links 'uncolorize-heading-bracket-links)

#+END_SRC
#+RESULTS:

** hl with [[file:test.org]] in it

** hl with [[file:test.org][desc]] in it.
* Making org links with descriptions helpful in org-ref
  :PROPERTIES:
  :categories: orgref,emacs,orgmode
  :END:
I came across this question on Emacs StackExchange: http://emacs.stackexchange.com/questions/18644/org-mode-customize-link-display on how to make descriptive links in org-ref more helpful. The problem is that org-mode makes the citation part invisible, and only shows the description, which org-ref uses for pre/post text. There is a partial solution on stack exchange, which I have adapted here to make these special links visible so you can see the key and the pre/post text.

Basically, we just undo the invisibility after the link has been activated, and then add the color back in a function that advises the activate link function. Here is the solution I have put into org-ref.

An important detail:
1. It was important to save the match data, because it is reused in subsequent font-lock functions in org-mode. The match-data gets changed by the string-match function.
#+BEGIN_SRC emacs-lisp
(defun org-ref-make-org-link-cite-key-visible (&rest _)
  "Make the org-ref cite link visible in descriptive links."

  (save-match-data
    (let ((s (match-string 1))
	  (beg (match-beginning 0))
	  (end (match-end 0))
	  (cite-re (format "^\\(%s:\\)"
			   (regexp-opt (-sort
					(lambda (a b)
					  (> (length a) (length b)))
					org-ref-cite-types))))
	  cite-type)

      (when (and s (string-match cite-re s))
	(setq cite-type (match-string 1 s))
	(remove-text-properties beg end
				'(invisible))
	(add-text-properties
	 beg end
	 `(face (:foreground ,org-ref-cite-color)))))))

(advice-add 'org-activate-bracket-links :after #'org-ref-make-org-link-cite-key-visible)
#+END_SRC

#+RESULTS:


 [[cite:2006-acs-style-guide][Page 5]]


cite:2006-acs-style-guide,2007-basic-resear-needs,2010-reprod-resear

* Autoload languages in org-mode

You normally have to "register" languages in org-mode in the variable `org-babel-load-languages'. Here, we advise org-babel-execute-src-block to check for the language, make sure it is loaded, and if not load it. Basically we just need to get the language type, check if it is in org-babel-load-languages, add it if not and then load the languages.

#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around load-language nil activate)
  "Load language if needed"
  (let ((language (org-element-property :language (org-element-at-point))))
    (unless (cdr (assoc (intern language) org-babel-load-languages))
      (add-to-list 'org-babel-load-languages (cons (intern language) t))
      (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
    ad-do-it))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages nil)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
print(88)
#+END_SRC

#+RESULTS:
: 88

#+BEGIN_SRC gnuplot :file test.png
set key left box
set samples 50
set style data points

plot [-10:10] sin(x),atan(x),cos(atan(x))
#+END_SRC

#+RESULTS:
[[file:test.png]]


* A python version of CaPPA
The idea here is to replicate the Melpa code in Python and some static blog framework like Nikola to build the preprint. This would allow a bibtex entry to be the recipe, and allow me to use more sophisticated template engines to render the pages.

#+BEGIN_SRC bibtex :tangle kitchingroup-57.bib
@article{kitchingroup-57,
  author =	 {Kitchin, John R.},
  title =	 {Examples of Effective Data Sharing in Scientific
  Publishing},
  journal =	 {ACS Catalysis},
  volume =	 5,
  number =	 6,
  pages =	 {3894-3899},
  year =	 2015,
  doi =		 {10.1021/acscatal.5b00538},
  url =		 { https://doi.org/10.1021/acscatal.5b00538 },
  eprint =	 { https://doi.org/10.1021/acscatal.5b00538 },
  fetcher = {github},
  repo = {KitchinHUB/kitchingroup-57},
  files = {README.org, manuscript.org, manuscript.pdf, supporting-information.org}
  }

#+END_SRC

#+BEGIN_SRC python
from bibtexparser.bparser import BibTexParser

with open('kitchingroup-57.bib', 'r') as f:
    bp = BibTexParser(f.read())
    entries = bp.get_entry_list()
print entries
#+END_SRC

#+RESULTS:
: [{u'files': u'README.org, manuscript.org, manuscript.pdf, supporting-information.org', u'repo': u'KitchinHUB/kitchingroup-57', u'doi': u'10.1021/acscatal.5b00538', u'title': u'Examples of Effective Data Sharing in Scientific Publishing', u'journal': u'ACS Catalysis', u'author': u'Kitchin, John R.', u'number': u'6', 'ENTRYTYPE': u'article', u'volume': u'5', u'fetcher': u'github', u'link': u'https://doi.org/10.1021/acscatal.5b00538', u'year': u'2015', u'eprint': u'https://doi.org/10.1021/acscatal.5b00538', 'ID': 'kitchin-2015-examp-effec', u'pages': u'3894-3899'}]

One function I need is to take a bibtex entry and return a reasonably formatted string.

#+BEGIN_SRC python
from bibtexparser.bparser import BibTexParser



# * normalize author names

#+END_SRC

#+RESULTS:
#+begin_example
Akhade, Sneha A. and Kitchin, John R., Effects of Strain, d-Band Filling, and Oxidation State on the
Bulk Electronic Structure of Cubic 3d Perovskites, The Journal of Chemical Physics, 135(10), 104702-6, (2011).

Akhade, Sneha and Kitchin, John R., Effects of Strain, d-Band Filling, and Oxidation State on the
Surface Electronic Structure and Reactivity of 3d Perovskite
Surfaces, J. Chem. Phys., 137, 084703, (2012). https://doi.org/10.1063/1.4746117

Alesi, W. R., Gray, M. and John R. Kitchin, \ce{CO2} Adsorption on Supported Molecular Amidine Systems on
Activated Carbon, ChemSusChem, 3(8), 948-956, (2010). https://doi.org/10.1002/cssc.201000056

Alesi, W. Richard and Kitchin, John R., Evaluation of a Primary Amine-Functionalized Ion-Exchange
Resin for \ce{CO_2} Capture, Industrial \& Engineering Chemistry Research, 51(19), 6907-6915, (2012). https://doi.org/10.1021/ie300452c

Boes, J. R., Kondratyuk, P., Yin, C., Miller, J. B., Gellman, A. J. and John R. Kitchin, Core Level Shifts in {Cu-Pd} Alloys As a Function of Bulk
Composition and Structure, Surface Science, 640, 127-132, (2015). https://doi.org/10.1016/j.susc.2015.02.011

Boes, J. R., Gumuslu, G., Miller, J. B., Gellman, A. J. and John R. Kitchin, Estimating Bulk-Composition-Dependent \ce{H2} Adsorption
Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111) Surfaces, ACS Catalysis, 5, 1020-1026, (2015). https://doi.org/10.1021/cs501585k

Boes, J. R., Gumuslu, G., Miller, J. B., Gellman, A. J. and John R. Kitchin, Supporting Information: Estimating Bulk-Composition-Dependent
\ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
Surfaces, ACS Catalysis, 5, 1020-1026, (2015). https://doi.org/10.1021/cs501585k

Calle-Vallejo, F., Inoglu, N. G., Su, H. a. M., Man, I. C., Koper, M. T. M., Kitchin, J. R. and Rossmeisl, Jan, Number of Outer Electrons As Descriptor for Adsorption
Processes on Transition Metals and Their Oxides, Chemical Science, 4, 1245-1249, (2013). https://doi.org/10.1039/C2SC21601A

Chao, R., Kitchin, J., Gerdes, K., Sabolsky, E. and Salvador, Paul, Preparation of Mesoporous \ce{La_{0.8}Sr_{0.2}MnO3}
Infiltrated Coatings in Porous {SOFC} Cathodes Using
Evaporation-Induced Self-Assembly Methods, ECS Transactions, 35(1), 2387-2399, (2011). https://doi.org/10.1149/1.3570235

Chao, R., Munprom, R., Petrova, R. a. G., Kitchin, J. R. and Salvador, Paul A., Structure and Relative Thermal Stability of Mesoporous
({La},{Sr}){Mn}O$_3$ Powders Prepared Using
Evaporation-Induced Self-Assembly Methods, Journal of the American Ceramic Society, None, 2339-2346, (2012). https://doi.org/10.1111/j.1551-2916.2012.05236.x

Curnan, Matthew T. and Kitchin, John R., Effects of Concentration, Crystal Structure, Magnetism, and
Electronic Structure Method on First-Principles Oxygen Vacancy
Formation Energy Trends in Perovskites, The Journal of Physical Chemistry C, 118(49), 28776-28790, (2014). https://doi.org/10.1021/jp507957n

Demeter, E. L., Hilburg, S. L., Collins, N. R. W. a. T. J. and John R. Kitchin, Electrocatalytic Oxygen Evolution With an Immobilized {TAML}
Activator, J. Am. Chem. Soc., 136(15), 5603-5606, (2014). https://doi.org/10.1021/ja5015986

Gumuslu, G., Kondratyuk, P., Boes, J. R., Miller, B. M. a. J. B., Kitchin, J. R. and A. J. Gellman, Correlation of Electronic Structure With Catalytic Activity:
\ce{H2}-\ce{D2} Exchange Across \ce{Cu_{x}Pd_{1-x}}
Composition Space, ACS Catalysis, 5(5), 3137-3147, (2015). https://doi.org/10.1021/cs501586t

Hallenbeck, Alexander P. and Kitchin, John R., Effects of \ce{O_2} and \ce{SO_2} on the Capture Capacity of a
Primary-Amine Based Polymeric \ce{CO_2} Sorbent, Industrial \& Engineering Chemistry Research, 52(31), 10788-10794, (2013). https://doi.org/10.1021/ie400582a

Han, J. W., Kitchin, J. R. and Sholl, D. S., Step Decoration of Chiral Metal Surfaces, Journal of Chemical Physics, 130(12), 124710, (2009). https://doi.org/10.1063/1.3096964

Inoglu, N. and Kitchin, J. R., Atomistic Thermodynamics Study of the Adsorption and the
Effects of Water-Gas Shift Reactants on Cu Catalysts Under
Reaction Conditions, Journal of Catalysis, 261(2), 188-194, (2009). https://doi.org/10.1016/j.jcat.2008.11.020

Inoglu, N. and Kitchin, J. R., Sulphur Poisoning of Water-Gas Shift Catalysts: {S}ite
Blocking and Electronic Structure Modification, Molecular Simulation, 35(10-11), 936-941, (2009). https://doi.org/10.1080/08927020902833129

Nilay {\.I}no{\u{g}}lu and John R. Kitchin, New Solid-State Table: Estimating {d}-Band Characteristics for
Transition Metal Atoms, Molecular Simulation, 36(7-8), 633-638, (2010). https://doi.org/10.1080/08927022.2010.481794

Inoglu, N. and Kitchin, J. R., Simple Model Explaining and Predicting Coverage-Dependent
Atomic Adsorption Energies on Transition Metal Surfaces, Physical Review B, 82(4), 045414, (2010). https://doi.org/10.1103/PhysRevB.82.045414

Inoglu, Nilay and Kitchin, John R., Identification of Sulfur-Tolerant Bimetallic Surfaces Using
{DFT} Parametrized Models and Atomistic Thermodynamics, ACS Catalysis, None, 399--407, (2011). https://doi.org/10.1021/cs200039t

Khan, N. A.,  Kitchin, J. R.,  Schwartz, V.,  Murillo, L. E.,  Bulanin, K. M. and  Chen,  J. G., Novel Catalytic Properties of Bimetallic Surface Nanostructures, in ACS Symposium Series, Nanotechnology in Catalysis, ACS (2003). https://doi.org/10.1007/978-1-4419-9048-8_2

John R. Kitchin, Molybdenum nanoclusters on titanium dioxide single crystal surfaces, University of Delaware (None). Masters thesis.

Kitchin, J. R., Khan, N. A., Barteau, M. A., Chen, J. G. A. Y. and Madey, T. E., Elucidation of the Active Surface and Origin of the Weak
Metal-Hydrogen Bond on {Ni}/{Pt}(111) Bimetallic Surfaces: {A}
Surface Science and Density Functional Theory Study, Surface Science, 544(2-3), 295-308, (2003). https://doi.org/10.1016/j.susc.2003.09.007

Kitchin, J. R., Barteau, M. A. and Chen, J. G. G., A Comparison of Gold and Molybdenum Nanoparticles on
\ce{TiO_2}(110) 1 $\times$ 2 Reconstructed Single Crystal
Surfaces, Surface Science, 526(3), 323-331, (2003). https://doi.org/10.1016/s0039-6028(02)02679-1

Kitchin, J. R., N{\o}rskov, J. K. and Barteau, M. A. and
Chen, J.  G., Modification of the Surface Electronic and Chemical Properties
of {Pt}(111) By Subsurface 3d Transition Metals, Journal of Chemical Physics, 120(21), 10240-10246, (2004). https://doi.org/10.1063/1.1737365

Kitchin, J. R., N{\o}rskov, J. K. and Barteau, M. A. and
Chen, J.  G., Role of Strain and Ligand Effects in the Modification of the
Electronic and Chemical Properties of Bimetallic Surfaces, Physical Review Letters, 93(15), 156801, (2004). https://doi.org/10.1103/PhysRevLett.93.156801

John R. Kitchin, Tuning the electronic and chemical properties
of metals: bimetallics and transition metal
carbides, University of Delaware (None). PhD thesis.

Kitchin, J. R., N{\o}rskov, J. K. and Barteau, M. A. and
Chen, J.  G. G., Trends in the Chemical Properties of Early Transition Metal
Carbide Surfaces: {A} Density Functional Study, Catalysis Today, 105(1), 66-73, (2005). https://doi.org/10.1016/j.cattod.2005.04.008

Kitchin, J. R., Reuter, K. and Scheffler, M., Alloy Surface Segregation in Reactive Environments:
{F}irst-Principles Atomistic Thermodynamics Study of
\ce{Ag_3Pd}(111) in Oxygen Atmospheres, Physical Review B, 77(7), 075437, (2008). https://doi.org/10.1103/PhysRevB.77.075437

Kitchin, J. R. and  Miller, S. D.  And  Sholl, D. S., Density functional theory studies of alloys in heterogeneous catalysis, in Chemical Modelling, The Royal Society of Chemistry (2008). https://doi.org/10.1039/B608782P

Kitchin, J. R., Correlations in Coverage-Dependent Atomic Adsorption Energies
on {Pd}(111), Physical Review B, 79(20), 205412, (2009). https://doi.org/10.1103/PhysRevB.79.205412

Kitchin, John, Preface: {T}rends in Computational Catalysis, Topics in Catalysis, 55(5), 227-228, (2012). https://doi.org/10.1007/s11244-012-9808-0

John R. Kitchin, Data Sharing in Surface Science, Surface Science, N/A, in press, (2015). https://doi.org/10.1016/j.susc.2015.05.007

Kitchin, John R., Examples of Effective Data Sharing in Scientific Publishing, ACS Catalysis, 5(6), 3894-3899, (2015). https://doi.org/10.1021/acscatal.5b00538

Landon, J. and Kitchin, J. R., Electrochemical Concentration of Carbon Dioxide From an
Oxygen/carbon Dioxide Containing Gas Stream, Journal of the Electrochemical Society, 157(8), B1149-B1153, (2010). https://doi.org/10.1149/1.3432440

Landon, J., Demeter, E., Keturakis, N. {. a. C., Wachs, I. E., Frenkel, R. V. a. A. I. and John R. Kitchin, Spectroscopic Characterization of Mixed {Fe}-{Ni} Oxide
Electrocatalysts for the Oxygen Evolution Reaction in Alkaline
Electrolytes, ACS Catalysis, 2(8), 1793-1801, (2012). https://doi.org/10.1021/cs3002644

Lee, Anita S. and Kitchin, John R., Chemical and Molecular Descriptors for the Reactivity of
Amines With \ce{CO_2}, Industrial \& Engineering Chemistry Research, 51(42), 13609-13618, (2012). https://doi.org/10.1021/ie301419q

Lee, A. S., Eslick, J. C., Miller, D. C. and John
R. Kitchin, Comparisons of Amine Solvents for Post-Combustion \ce{CO2}
Capture: A Multi-Objective Analysis Approach, International Journal of Greenhouse Gas Control, 18, 68-74, (2013). https://doi.org/10.1016/j.ijggc.2013.06.020

Man, I. C., Su, H. Y., Calle-Vallejo, F., Hansen, H. A. A. M., Inoglu, N. G., Kitchin, J., Jaramillo, T. F., N{\o}rskov, J. K. and Rossmeisl, J., Universality in Oxygen Evolution Electrocatalysis on Oxide
Surfaces, Chem{C}at{C}hem, 3(7), 1159-1165, (2011). https://doi.org/10.1002/cctc.201000397

Mao, J. X., Lee, A. S., Kitchin, J. R. a. N., Luebke, D. R. and Damodaran, Krishnan, Interactions in 1-ethyl-3-methyl Imidazolium Tetracyanoborate
Ion Pair: {S}pectroscopic and Density Functional Study, Journal of Molecular Structure, 1038(0), 12-18, (2013). https://doi.org/10.1016/j.molstruc.2013.01.046

McCormick, J. R., Kitchin, J. R. and Barteau, M. A. and
Chen, J. G., A Four-Point Probe Correlation of Oxygen Sensitivity To
Changes in Surface Resistivity of \ce{TiO_2}(001) and
{Pd}-modified \ce{TiO_2}(001), Surface Science, 545(1-2), L741-L746, (2003). https://doi.org/10.1016/j.susc.2003.08.041

Mehta, P., Salvador, P. A. and John R. Kitchin, Identifying Potential \ce{BO2} Oxide Polymorphs for Epitaxial
Growth Candidates, ACS Appl. Mater. Interfaces, 6(5), 3630-3639, (2015). https://doi.org/10.1021/am4059149

Mhadeshwar, A. B., Kitchin, J. R. and Barteau, M. A. and
Vlachos, D. G., The Role of Adsorbate-Adsorbate Interactions in the Rate
Controlling Step and the Most Abundant Reaction Intermediate
of \ce{NH_3} Decomposition on {Ru}, Catalysis Letters, 96(1-2), 13-22, (2004).

Michael, J. D., Demeter, E. L., Fan, S. M. I. a. Q., Boes, J. R. and John R. Kitchin, Alkaline Electrolyte and Fe Impurity Effects on the
Performance and Active-Phase Structure of {NiOOH} Thin Films
for {OER} Catalysis Applications, J. Phys. Chem. C, 119(21), 11475-11481, (2015). https://doi.org/10.1021/acs.jpcc.5b02458

Miller, S. D. and Kitchin, J. R., Relating the Coverage Dependence of Oxygen Adsorption on {Au}
and {Pt} Fcc(111) Surfaces Through Adsorbate-Induced Surface
Electronic Structure Effects, Surface Science, 603(5), 794-801, (2009). https://doi.org/10.1016/j.susc.2009.01.021

Miller, Spencer D. and Kitchin, John R., Relating the Coverage Dependence of Oxygen Adsorption on {Au}
and {Pt} fcc(1 1 1) Surfaces Through Adsorbate-Induced Surface
Electronic Structure Effects, Surface Science, 603(5), 794-801, (2009). https://doi.org/10.1016/j.susc.2009.01.021

Spencer D. Miller and John R. Kitchin, Uncertainty and Figure Selection for {DFT} Based Cluster
Expansions for Oxygen Adsorption on {Au} and {Pt} (111)
Surfaces, Molecular Simulation, 35(10-11), 920-927, (2009). https://doi.org/10.1080/08927020902833137

Miller, S. D., Inoglu, N. and John R. Kitchin, Configurational Correlations in the Coverage Dependent
Adsorption Energies of Oxygen Atoms on Late Transition Metal
fcc(111) Surfaces, J. Chem. Phys., 134(10), 104709, (2011). https://doi.org/10.1063/1.3561287

Miller, S., Dsilva, C. and John R. Kitchin, None, in Coverage dependent adsorption properties of atomic adsorbates
on late transition metal surfaces, Royal Society of Chemistry (RSC) (2012). https://doi.org/10.1039/9781849734776-00083

Miller, S. D., Pushkarev, V. V., Gellman, A. J. and John R. Kitchin, Simulating Temperature Programmed Desorption of Oxygen on
{P}t(111) Using {DFT} Derived Coverage Dependent Desorption
Barriers, Topics in Catalysis, 57(1-4), 106-117, (2014). https://doi.org/10.1007/s11244-013-0166-3

N{\o}rskov, J. K., Rossmeisl, J., Logadottir, A. a. L., Kitchin, J. R., Bligaard, T. and Jonsson, H., Origin of the Overpotential for Oxygen Reduction At a
Fuel-Cell Cathode, Journal of Physical Chemistry B, 108(46), 17886-17892, (2004). https://doi.org/10.1021/jp047349j

N{\o}rskov, J. K., Bligaard, T., Logadottir, A. a. K., Chen, J. G. and Pandelov, S., Trends in the Exchange Current for Hydrogen Evolution, Journal of the Electrochemical Society, 152(3), J23-J26, (2005). https://doi.org/10.1149/1.1856988

N{\o}rskov, J. K., Bligaard, T., Logadottir, A. a. K., Chen, J. G., Pandelov, S. and Stimming, U., Response To "comment on '{T}rends in the Exchange Current for
Hydrogen Evolution' {J. Electrochem. Soc., 152, J23 (2005)}", Journal of the Electrochemical Society, 153(12), L33-L33, (2006). https://doi.org/10.1149/1.2358292

John Kitchin, org-ref, John Kitchin, org-ref, org-ref is an Emacs-lisp library for citations and
cross-references in org-mode., http://github.com/jkitchin/org-ref

Pennline, H. W., Granite, E. J., Kitchin, D. R. L. a. J. R., Landon, J. and Lisa M. Weiland, Separation of \ce{CO2} From Flue Gas Using Electrochemical
Cells, Fuel, 89(6), 1307-1314, (2010). https://doi.org/10.1016/j.fuel.2009.11.036

Rubin, E. S., Mantripragada, H., Marks, A. a. V. and Kitchin, John, The Outlook for Improved Carbon Capture Technology, Progress in Energy and Combustion Science, 38, 630-671, (2012). https://doi.org/10.1016/j.pecs.2012.03.003

Shultz, D. A., Boal, A. K., Driscoll, D. J., Kitchin, J. R. and Tew, G. N., Preparation and Characterization of a Bis-Semiquinone: {A}
Bidentate Dianion Biradical, Journal of Organic Chemistry, 60(12), 3578-3579, (1995).

Shultz, D. A., Boal, A. K., Driscoll, D. J., Farmer, G. T., Kitchin, J. R., Miller, D. B. and Tew, G. N., Preparation of Paramagnetic Ligands for Coordination-Complexes
and Networks With Interesting Magnetic Properties, Molecular Crystals and Liquid Crystals Science and Technology
Section a-Molecular Crystals and Liquid Crystals, 305, 303-310, (1997).

Song, I. K., Kitchin, J. R. and Barteau, M. A., \ce{h_3pw_{12}o_{40}}-functionalized Tip for Scanning
Tunneling Microscopy, Proceedings of the National Academy of Sciences of the United
States of America, 99, 6471-6475, (2002). https://doi.org/10.1073/pnas.072514399

Thompson, R. L., Albenze, E., Shi, W. a. H., Damodaran, K., Lee, A. a. K., Luebke, D. R. and Nulwala, Hunaid, \ce{CO2} Reactive Ionic Liquids: {E}ffects of Functional
Groups on the Anion and Its Influence on the Physical
Properties, RSC Adv., 4, 12748-12755, (2014). https://doi.org/10.1039/C3RA47097K

Tierney, H. L., Baber, A. E., Kitchin, J. R. and Sykes, E.  C. H., Hydrogen Dissociation and Spillover on Individual Isolated
Palladium Atoms, Physical Review Letters, 103(24), 246102, (2009). https://doi.org/10.1103/PhysRevLett.103.246102

Watkins, J. D., Siefert, N. S., Myers, X. Z. a. C. R., Kitchin, J. R., Hopkinson, D. P. and Hunaid B. Nulwala, The Redox Mediated Separation of Carbon Dioxide From Flue Gas, Energy \& Fuels, nil(nil), 151001141454005, (2015). https://doi.org/10.1021/acs.energyfuels.5b01807

Zhongnan Xu and John R. Kitchin, Probing the Coverage Dependence of Site and Adsorbate
Configurational Correlations on (111) Surfaces of Late
Transition Metals, J. Phys. Chem. C, 118(44), 25597-25602, (2014). https://doi.org/10.1021/jp508805h

Zhongnan Xu and John R. Kitchin, Relating the Electronic Structure and Reactivity of the 3d
Transition Metal Monoxide Surfaces, Catalysis Communications, 52, 60-64, (2014). https://doi.org/10.1016/j.catcom.2013.10.028

Xu, Z., Joshi, Y. V. and Raman, Sumathy and
Kitchin, John R., Accurate Electronic and Chemical Properties of 3d Transition
Metal Oxides Using a Calculated Linear Response {U} and a {DFT
+ U(V)} Method, The Journal of Chemical Physics, 142(14), 144701, (2015). https://doi.org/10.1063/1.4916823

Xu, Z., Rossmeisl, J. and Kitchin, John R., A Linear Response {DFT}+{U} Study of Trends in the Oxygen
Evolution Activity of Transition Metal Rutile Dioxides, The Journal of Physical Chemistry C, 119(9), 4827-4833, (2015). https://doi.org/10.1021/jp511426q

Zhongnan Xu and John R. Kitchin, Relationships Between the Surface Electronic and Chemical
Properties of Doped 4d and 5d Late Transition Metal Dioxides, The Journal of Chemical Physics, 142(10), 104703, (2015). https://doi.org/10.1063/1.4914093

Zhongnan Xu and John R Kitchin, Tuning Oxide Activity Through Modification of the Crystal and
Electronic Structure: From Strain To Potential Polymorphs, Phys. Chem. Chem. Phys., 17, 28943-28949, (2015). https://doi.org/10.1039/c5cp04840k

Zhongnan Xu and Jan Rossmeisl and John R. Kitchin, Supporting data for: A linear response, {DFT+U} study of trends
in the oxygen evolution activity of transition metal rutile
dioxides. doi:10.5281/zenodo.12635, 10.5281/zenodo.12635, DESC0004031, early-career,, Supporting data for: A linear response, {DFT+U} study of trends
in the oxygen evolution activity of transition metal rutile
dioxides. doi:10.5281/zenodo.12635, Zhongnan Xu and Jan Rossmeisl and John R. Kitchin, https://zenodo.org/record/12635, 2015

Hari Thirumalai and John R. Kitchin, The Role of Vdw Interactions in Coverage Dependent Adsorption
Energies of Atomic Adsorbates on Pt(111) and Pd(111), Surface Science, None, -, (2015). https://doi.org/10.1016/j.susc.2015.10.001

Hallenbeck, A. P., Egbebi, A., Hopkinson, K. P. R. a. D., Anna, S. L. and John R. Kitchin, Comparative Microfluidic Screening of Amino Acid Salt
Solutions for Post-Combustion \ce{CO2} Capture, International Journal of Greenhouse Gas Control, 43, 189 - 197, (2015). https://doi.org/10.1016/j.ijggc.2015.10.026

Matthew Curnan and John R. Kitchin, Investigating the Energetic Ordering of Stable and Metastable
TiO$_2$ Polymorphs Using DFT+U and Hybrid Functionals, The Journal of Physical Chemistry C, 119, None, (2015). https://doi.org/10.1021/acs.jpcc.5b05338

John Kitchin, Org-mode is awesome, John Kitchin, Org-mode is awesome, Last accessed Tue Jan  5 06:26:15 2016, https://www.youtube.com/watch?v=fgizHHd7nOo

John Kitchin, Emacs + org-mode + python in reproducible research, John Kitchin, Emacs + org-mode + python in reproducible research, Last accessed Tue Jan  5 06:26:49 2016, https://www.youtube.com/watch?v=1-dUkyn_fZA

John Kitchin, The Kitchin Research Group Blog, John Kitchin, The Kitchin Research Group Blog, Last accessed Tue Jan  5 06:35:28 2016, http://kitchingroup.cheme.cmu.edu/

Boes, J. R., Groenenboom, M. C. and John A. Keith
and John R. Kitchin, Neural Network and Reaxff Comparison for {Au} Properties, Accepted 1/2016, Int. J. Quantum Chemistry, None, None, (2016).

#+end_example



* set deadline to last workday of month
  DEADLINE: <2016-01-29 Fri>

#+BEGIN_SRC emacs-lisp
(calendar-current-date)
#+END_SRC

#+RESULTS:
| 1 | 24 | 2016 |


#+BEGIN_SRC emacs-lisp
(defun last-working-day-deadline ()
  (interactive)
  (let* ((date (calendar-current-date))
	 (day (calendar-extract-day date))
	 (month (calendar-extract-month date))
	 (year (calendar-extract-year date))
	 (lastday (calendar-last-day-of-month month year)))
    ;; workdays have "names" of 1 2 3 4 or 5
    (while (not (memq (calendar-day-of-week (list month lastday year)) '(1 2 3 4 5)))
      (decf lastday))
    (org-deadline nil (format "%s-%s-%s" year month lastday))))

#+END_SRC

#+RESULTS:
: last-working-day-deadline

* context aware key binding
[[elfeed:entry-id:http://planet.emacsen.org/atom.xml|http://endlessparentheses.com/define-context-aware-keys-in-emacs|http://endlessparentheses.com/define-context-aware-keys-in-emacs.html?source%3Drss][Endless Parentheses: Define context-aware keys in Emacs]]

#+BEGIN_SRC emacs-lisp
(defun endless/round-quotes (italicize)
  "Insert “” and leave point in the middle.
With prefix argument ITALICIZE, insert /“”/ instead (meant
for org-mode)."
  (interactive "P")
  (if (looking-at "”[/=_\\*]?")
      (goto-char (match-end 0))
    (when italicize
      (if (derived-mode-p 'markdown-mode)
          (insert "__")
        (insert "//"))
      (forward-char -1))
    (insert "“”")
    (forward-char -1)))
#+END_SRC

#+RESULTS:
: endless/round-quotes


Then, we define the same key as before, but instead of just passing the command we use a menu-item bound to nil. The fact that it’s a menu-item is irrelevant here, it behaves exactly like a key bound to nil (i.e., an empty keybind). However, this allows us to setup
a filter that changes the keybind to endless/round-quotes if we’re not inside an org-src-block.


#+BEGIN_SRC emacs-lisp
(define-key org-mode-map "\""
  '(menu-item "maybe-round-quotes" nil
              :filter (lambda (&optional _)
                        (unless (org-in-src-block-p)
                          #'endless/round-quotes))))
; "regular quotes inside src blocks"
#+END_SRC

#+RESULTS:
| menu-item | maybe-round-quotes | nil | :filter | (lambda (&optional _) (unless (org-in-src-block-p) (function endless/round-quotes))) |

  “fancy quotes outside src-blocks”
* mu4e template

#+BEGIN_SRC emacs-lisp
;; Function to return first name of email recipient
;; Used by yasnippet
;; Based closely on
;; http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html
(defun my-yas-get-first-name-from-to-field ()
  (let ((rlt "NAME") str rlt2)
    (save-excursion
      (goto-char (point-min))
      ;; first line in email could be some hidden line containing NO to field
      (setq str (buffer-substring-no-properties (point-min) (point-max))))
    ;; take name from TO field
    (when (string-match "^To: \"?\\([^ ,]+\\)" str)
      (setq rlt (match-string 1 str)))
    ;;get name in FROM field if available
    (when (string-match "^\\([^ ,\n]+\\).+writes:$" str)
      (progn (setq rlt2 (match-string 1 str))
             ;;prefer name in FROM field if TO field has "@"
             (when (string-match "@" rlt)
               (setq rlt rlt2))
             ))
    (message "rlt=%s" rlt)
    rlt))
#+END_SRC

#+RESULTS:
: my-yas-get-first-name-from-to-field

* Testing font lock with anchored text

http://emacs.stackexchange.com/questions/19179/how-can-i-highlight-different-keywords-according-to-a-suffix

(font-lock-add-keywords nil
  '(("\\(constant\\):'" (1 font-lock-constant-face t)
     ("\\(variable\\)[,']"
      (save-excursion (search-forward-regexp "\\(variable,\\)*variable'"))
      nil
      (1 font-lock-variable-name-face t))))
  'append)

   :constant:'variable,variable'

 constant:'


http://emacs.stackexchange.com/questions/19182/how-to-highlight-specific-keywords-inside-strings-quotes

(re-search-forward "[^:]ref:\\([[:alnum:]]\\)\\{2,\\}")

* Popup menus				:ref:test:
https://lists.gnu.org/archive/html/help-gnu-emacs/2003-10/msg00401.html

test ref:test

#+BEGIN_SRC emacs-lisp
(defun bold-word-at-point ()
  (interactive)
  (save-excursion
    (backward-word)
    (insert "*")
    (forward-word)
    (insert "*")))

(defun italicize-word-at-point ()
  (interactive)
  (save-excursion
    (backward-word)
    (insert "/")
    (forward-word)
    (insert "/")))

(defvar markup-popup-menu
  (let ((menu (make-sparse-keymap "Markup")))
    (define-key menu [bold-word-at-point] (cons "Bold" 'bold-word-at-point))
    (define-key menu [italicize-word-at-point] (cons "Italics" 'italicize-word-at-point))
    menu))

(defun markup-popup-command ()		; event
  "Run the command selected from `markup-popup-menu'."
  (interactive)				; "e"
  (let ((event (cadr last-input-event)))
    (save-excursion
      (goto-char (nth 1 event))
      (call-interactively
       (or (car (x-popup-menu t markup-popup-menu))
	   'ignore)))))

(global-set-key [s-mouse-3] 'markup-popup-command)
#+END_SRC

#+RESULTS:
: *markup*-*popup*-/command/

*test* test /test/ test


#+BEGIN_SRC emacs-lisp
(defvar right-popup-menu
  (let ((menu (make-sparse-keymap "Commands")))
    (define-key menu [dabbrev-expand] (cons "Complete word" 'dabbrev-expand))
    (define-key menu [undo] (cons "Undo" 'undo))
    (define-key menu [grep] (cons "Search files" 'grep))
    (define-key menu [redo] (cons "Redo" 'redo))
    (define-key menu [yank] (cons "Paste" 'yank))
    (define-key menu [goto-line] (cons "Goto line" 'goto-line))
    (define-key menu [copy-region-as-kill] (cons "Copy" 'copy-region-as-kill))
    menu))

(defun right-popup-command ()           ; event
  "Run the command selected from `right-popup-menu'."
  (interactive)	; "e"

  (let ((event (cadr last-input-event)))
;    (message-box "%S" event)
    (goto-char (nth 1 event))
    (message-box "%S"(thing-at-point 'word))
    )
  (call-interactively
   (or (car (x-popup-menu t right-popup-menu))
       'ignore)))

(global-set-key [s-mouse-3] 'right-popup-command)
#+END_SRC

#+RESULTS:
: right-popup-command
 ref:test
* a gilgamesh link
(setq temporary-file-directory "/tmp")
file:/jkitchin@techela.cheme.cmu.edu:test.org

gilgamesh:jmax

gilgamesh:dft-book

* Undo abbrevs with...undo

#+BEGIN_SRC emacs-lisp

(defadvice undo-tree-undo (around undo-abbrev-expansion nil activate)
 "Make undo unexpand an abbrev if it was the second to last thing that was done"
 (if (and last-abbrev-text
	  (= (point) (+ last-abbrev-location
		   (length (symbol-value last-abbrev))
		   1)))
     (unexpand-abbrev)
   ad-do-it))
#+END_SRC

#+RESULTS:
: undo-tree-undo


This function works, but I cannot rebind the key for some reason.
#+BEGIN_SRC emacs-lisp
(defun undo-abbrev-expansion-or-undo (arg)
  "Undo function.
If point is one char past an abbrev expansion, undo it, otherwise
undo the last command."
  (interactive "P")
  (if (and last-abbrev-text
	   (= (point) (+ last-abbrev-location
			 (length (symbol-value last-abbrev))
			 1)))
      (unexpand-abbrev)
    (message-box "%s %s %s" (point) (+ last-abbrev-location
				       (length (symbol-value last-abbrev))
				       1)
		 (symbol-value last-abbrev)
		 )
    (undo-tree-undo)))
(global-unset-key (kbd "C-/"))
(global-set-key (kbd "C-/")  'undo-abbrev-expansion-or-undo)
#+END_SRC

#+RESULTS:
: undo-abbrev-expansion-or-undo

teh" the

* spell checking efficiently

You see a misspelling and you should type a key then to correct previous mistake with flyspell-check-previous-highlighted-word.  I have this bound to to super-s. It seems good.

bda speling

M-sS opens a hydra for spell-checking

* Repetitious update of a src block

This is the block to run periodically.
#+name: time-string
#+BEGIN_SRC sh
date
top -o "cpu" -ncols 4 -l 1| head -n 15
#+END_SRC

#+RESULTS: time-string
#+begin_example
Sun Jan  3 17:28:27 EST 2016
Processes: 225 total, 2 running, 3 stuck, 220 sleeping, 1110 threads
2016/01/03 17:28:27
Load Avg: 1.20, 1.51, 1.55
CPU usage: 5.0% user, 22.50% sys, 72.50% idle
SharedLibs: 14M resident, 12M data, 0B linkedit.
MemRegions: 57263 total, 3092M resident, 72M private, 450M shared.
PhysMem: 6508M used (1098M wired), 1246M unused.
VM: 588G vsize, 1067M framework vsize, 6471076(0) swapins, 6831574(0) swapouts.
Networks: packets: 190809878/201G in, 277243826/231G out.
Disks: 11873268/180G read, 10075469/265G written.

PID    COMMAND          %CPU TIME
96378  com.apple.InputM 0.0  00:00.26
96376  AppleSpell       0.0  00:00.68
96015  head             0.0  00:00.00
#+end_example

This function will update that block. We increment a counter and cancel the timer when it is exceeded.
#+BEGIN_SRC emacs-lisp
(defun update-src-block (fname src-name N)
  "Update the src-block named SRC-NAME in the file FNAME upto N times."
  (if (> *counter* N)
      (progn (cancel-timer *timer*)
	     (message-box "Done with timer"))
    (save-excursion
      (with-current-buffer  (find-file-noselect fname)
	(org-babel-goto-named-src-block src-name)
	(org-babel-execute-src-block)
	(incf *counter*)))))
#+END_SRC

#+RESULTS:
: update-src-block

We use a global var for the counter and timer.
#+BEGIN_SRC emacs-lisp
(setq *counter* 0)
(setq *timer* (run-with-timer
	       nil 5
	       'update-src-block
	       "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org"
	       "time-string"
	       5))
#+END_SRC

#+RESULTS:
: [nil 22153 41074 708648 5 update-src-block ("/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" "time-string" 5) nil 0]

* reusing tables

#+NAME: upper_air
#+BEGIN_SRC python :results value
return [[":m", ":degree",":meter/second", ":degC", ":millibar"],
        None,
        [1545.0, 175.0, 12.36, 15.40001, 850.0],
        [3162.0, 265.0, 6.69, 4.8, 700.0]]

#+END_SRC

#+RESULTS: upper_air
|     :m | :degree | :meter/second |    :degC | :millibar |
|--------+---------+---------------+----------+-----------|
| 1545.0 |   175.0 |         12.36 | 15.40001 |     850.0 |
| 3162.0 |   265.0 |          6.69 |      4.8 |     700.0 |

#+BEGIN_SRC python :results value  :var data=upper_air
import numpy as np

arr = np.array(data)
p = arr[:,4]
return p
#+END_SRC

#+RESULTS:
| 850 | 700 |

* Filtering subsets of a bibtex file	  :bibtex:
  :PROPERTIES:
  :ID:       D5F70690-C4B6-44D1-926E-E393CFE6110C
  :END:

I guess this is basically what bibtex-map-entries does.
#+BEGIN_SRC emacs-lisp :results output
(defun filter-bibtex (bibfile &rest keys)
  "keys are pairs of :field regexp"
  (set-buffer (find-file-noselect bibfile))
  (goto-char (point-min))
  (let ((results '()))
    (bibtex-map-entries
     (lambda (key start end)
       (let ((entry (bibtex-parse-entry))
	     (temp-keys keys))
	 (when
	     (catch 'nomatch
	       (while temp-keys
		 (let ((field (replace-regexp-in-string "^:" "" (symbol-name (car temp-keys))))
		       (regex (cadr temp-keys)))
		   (setq temp-keys (cddr temp-keys))
		   (unless (string-match-p
			    (format "%s" regex) ; use format to get a string
			    (org-ref-reftex-get-bib-field field entry))
		     (throw 'nomatch nil))))
	       t)
	   (add-to-list 'results key)))))
    results))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(filter-bibtex "../../Dropbox/bibliography/references.bib" :author "gellman" :year 2014)
#+END_SRC

#+RESULTS:
| miller-2014-simul-temper |



* Finding and handling duplicate bibtex entries :bibtex:
  :PROPERTIES:
  :ID:       1590FA44-91F3-4093-99C8-82726353DDDB
  :END:
Duplicate bibtex entries in your bibtex file is a problem. Finding them is tricky because minor spelling differences, differences in capitalization, etc... make it difficult to use code to find duplicates. I find it good practice to keep your bibtex file sorted, so that duplicates tend to be near each other, and hence easier to spot. But with a large number of entries, this is still tedious to do.

I have been trying to learn more about the bibtex.el library, so I am going to use this opportunity to write some code for duplicate detection. The idea is to go through each entry, generate a key for it, and see if the key has already been generated. bibtex comes with bibtex-generate-autokey for generating keys automatically.

Here is my bibtex autokey setup. This is a reasonable balance (for me) of almost always generating new keys that are not too long, and with enough information to often tell which reference it is. Every once in a while there are title/author/year combinations that are close enough that the same key is generated, but it is not too frequent.

#+BEGIN_SRC emacs-lisp
;; variables that control bibtex key format for auto-generation
;; I want firstauthor-year-title-words
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

So, we will just map over our entries looking for places where the same key is generated. We will save markers to these, and generate a clickable link to jump to the places where we suspect duplicates. We will temporarily redefine the key algorithm to make longer, less likely to be the same, keys.

#+BEGIN_SRC emacs-lisp :results output org raw
(let ((bibtex-autokey-year-length 4)
      (bibtex-autokey-names nil)
      (bibtex-autokey-name-year-separator "-")
      (bibtex-autokey-year-title-separator "-")
      (bibtex-autokey-titleword-separator "-")
      (bibtex-autokey-titlewords nil)
      (bibtex-autokey-titlewords-stretch nil)
      (bibtex-autokey-titleword-length nil))
  (dolist (pd (with-current-buffer (find-file-noselect  "~/Dropbox/bibliography/references.bib")
		(let ((possible-duplicates '())
		      (found '()))
		  (bibtex-map-entries
		   (lambda (key start end)
		     (let ((akey (bibtex-generate-autokey)))
                       (unless (not (string= "" akey)) (setq akey key))
		       (if (assoc akey found)
			   (add-to-list
			    'possible-duplicates
			    (list (cons akey (cdr (assoc akey found)))
				  (cons akey (point-marker))))
			 (add-to-list 'found (cons akey (point-marker)))))))
		  possible-duplicates)))
    (princ (format "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][1. %S]] [[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][%S]]\n"
		   (marker-buffer (cdr (nth 0 pd)))
		   (marker-position (cdr (nth 0 pd)))
		   (car (nth 0 pd))
		   (marker-buffer (cdr (nth 1 pd)))
		   (marker-position (cdr (nth 1 pd)))
		   (car (nth 1 pd))))))
#+END_SRC

#+RESULTS:
[[elisp:(progn (switch-to-buffer "references.bib")(goto-char 339249))][1. "jayaramanhillier-2001-construction-reactivity-mapping-platinum-catalyst-gradient-using-scanning-electrochemical-microscope"]] [[elisp:(progn (switch-to-buffer "references.bib")(goto-char 339881))]["jayaramanhillier-2001-construction-reactivity-mapping-platinum-catalyst-gradient-using-scanning-electrochemical-microscope"]]

* A new approach to extracting bibtex file from org :bibtex:
  :PROPERTIES:
  :ID:       D36B82BB-75E8-47DA-A4DE-A13C47427B3A
  :END:

org-ref has a function org-ref-extract-bibtex-entries that uses reftex to build a bibliography from an exported LaTeX file. I have learned a lot since I wrote that code, and in this post illustrate how to avoid the lengthy export process, and use mostly org-mode and built in bibtex functions to extract a bibtex file from org-ref citations.

This paragraph contains a single citation cite:goedecker-2004-minim. A
multicitation cite:kitchin-2002-molyb,kitchin-2004-tunin-the and some articles
cite:xu-2015-linear-respon,boes-2015-estim-bulk-si.

To extract the bibtex entries, we get all the unique keys in the buffer that we have cited.

#+BEGIN_SRC emacs-lisp
(defun get-cite-keys ()
  "Return list of cite keys in current buffer."
  (let ((all-keys '()))
    (org-element-map (org-element-parse-buffer) 'link
      (lambda (link)
	(when (-contains?
	       org-ref-cite-types
	       (org-element-property :type link))
	  (let* ((path (org-element-property :path link))
		 (keys (split-string path ",")))
	    (mapc (lambda (key) (add-to-list 'all-keys key)) keys)))))
    all-keys))

(get-cite-keys)
#+END_SRC
#+RESULTS:
| boes-2015-estim-bulk-si | xu-2015-linear-respon | kitchin-2004-tunin-the | kitchin-2002-molyb | goedecker-2004-minim |

Next we get data structures for each entry in the bibtex files. We will use this to construct the new bibtex file. Here is an example of an a-list we can use. Note, we use add-to-list here, so duplicate keys will be problematic; the second entry will not be included. Since you don't have duplicate entries (right ;) this won't be a big problem.

#+BEGIN_SRC emacs-lisp
(defun get-bibtex-entry-a-list ()
  "Return a-list of (key . entry-string) from files from
`org-ref-find-bibliography'."
  (let ((entries '()))
     (loop for bib-file in (org-ref-find-bibliography)
	   do
	   (with-current-buffer
	     (find-file-noselect bib-file)
	     (bibtex-map-entries
	      (lambda (key start end)
		(add-to-list 'entries (cons key (buffer-substring start end)))))))
     entries))

(cdr (assoc "boes-2015-estim-bulk-si" (get-bibtex-entry-a-list)))
#+END_SRC

#+RESULTS:
#+begin_example
@article{boes-2015-estim-bulk-si,
  author =	 {Jacob R. Boes and Gamze Gumuslu and James B. Miller and Andrew
                  J. Gellman and John R. Kitchin},
  title =	 {Supporting Information: Estimating Bulk-Composition-Dependent
                  \ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
                  Surfaces},
  keywords =	 {orgmode},
  journal =	 {ACS Catalysis},
  volume =	 5,
  pages =	 {1020-1026},
  year =	 2015,
  doi =		 {10.1021/cs501585k},
  url =
                  {http://pubs.acs.org/doi/suppl/10.1021/cs501585k/suppl_file/cs501585k_si_001.pdf},
}
#+end_example

Now, we just put these together to get an entry for each key in the current file:

#+BEGIN_SRC emacs-lisp
(let ((entries (get-bibtex-entry-a-list)))
  (mapconcat
   'identity
   (mapcar
    (lambda (key)
      (cdr (assoc key entries)))
    (get-cite-keys))
   "\n\n"))
#+END_SRC

#+RESULTS:
#+begin_example
@article{boes-2015-estim-bulk-si,
  author =	 {Jacob R. Boes and Gamze Gumuslu and James B. Miller and Andrew
                  J. Gellman and John R. Kitchin},
  title =	 {Supporting Information: Estimating Bulk-Composition-Dependent
                  \ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
                  Surfaces},
  keywords =	 {orgmode},
  journal =	 {ACS Catalysis},
  volume =	 5,
  pages =	 {1020-1026},
  year =	 2015,
  doi =		 {10.1021/cs501585k},
  url =
                  {http://pubs.acs.org/doi/suppl/10.1021/cs501585k/suppl_file/cs501585k_si_001.pdf},
}

@article{xu-2015-linear-respon,
  author =	 {Xu, Zhongnan and Rossmeisl, Jan and Kitchin, John R.},
  title =	 {A Linear Response {DFT}+{U} Study of Trends in the Oxygen
                  Evolution Activity of Transition Metal Rutile Dioxides},
  keywords =	 {DESC0004031, early-career, orgmode, },
  journal =	 {The Journal of Physical Chemistry C},
  volume =	 119,
  number =	 9,
  pages =	 {4827-4833},
  year =	 2015,
  doi =		 {10.1021/jp511426q},
  url =		 { https://doi.org/10.1021/jp511426q },
  eprint =	 { https://doi.org/10.1021/jp511426q },
}

@phdthesis{kitchin-2004-tunin-the,
  Author =	 {John R. Kitchin},
  Title =	 {Tuning the electronic and chemical properties
of metals: bimetallics and transition metal
carbides},
  School =	 {University of Delaware},
  Year =	 2004}

@MastersThesis{kitchin-2002-molyb,
  author =	 {John R. Kitchin},
  title =	 {Molybdenum nanoclusters on titanium dioxide single crystal surfaces},
  school =	 {University of Delaware},
  year =	 2002}

@article{goedecker-2004-minim,
  author =	 {Stefan Goedecker},
  title =	 {Minima Hopping: An Efficient Search Method for the Global
                  Minimum of the Potential Energy Surface of Complex Molecular
                  Systems},
  journal =	 {J. Chem. Phys.},
  volume =	 120,
  number =	 21,
  pages =	 9911,
  year =	 2004,
  doi =		 {10.1063/1.1724816},
  url =		 {https://doi.org/10.1063/1.1724816},
  date_added =	 {Sat Mar 21 09:58:27 2015},
}
#+end_example

Well, that looks like it. All that is left is writing that string to a file.

#+BEGIN_SRC emacs-lisp
(defun org-ref-create-bib-file-from-org (bib-file)
  "Copy cited references to BIB-FILE."
  (interactive (list (ido-read-file-name "Bib file: " "." nil nil "references.bib")))
  (let ((all-entries (get-bibtex-entry-a-list))
	(content))
    (setq content
	  (mapconcat
	   'identity
	   (mapcar
	    (lambda (key)
	      (cdr (assoc key all-entries)))
	    (get-cite-keys))
	   "\n\n"))
    (with-temp-file bib-file
      (insert content)))
  (find-file bib-file))
#+END_SRC
#+RESULTS:
: org-ref-create-bib-file-from-org

* Copy the bibtex entry for a link to a new file :bibtex:
  :PROPERTIES:
  :ID:       87BD9341-E7FD-4B9B-883F-C0967D8530D9
  :END:
Sometimes I am reading a document with citations from org-ref in it, and I want to copy the bibtex entry for that link from the file it is in to a new file. Right now, I have to click on the link, open the entry, copy the file, open the new file, and paste it. Here we develop a function that does all that.

Some functions will help us with this. First, org-ref-open-citation-at-point will open the bibtex file with the point in the entry. Second, bibtex-copy-entry-as-kill will copy the entry to the bibtex-entry-kill-ring. Finally bibtex-yank will put the entry in the new file we select. We should try not to add entries if there is already a key present in the file.

A subtlety is the function should not take an argument, so it can work in our cite menu, but it needs an interactive file selection to say where the entry is copied to.

#+BEGIN_SRC emacs-lisp
(defun org-ref-copy-entry-at-point-to-file ()
  "Copy the bibtex entry for the citation at point to NEW-FILE.
Prompt for NEW-FILE includes bib files in org-ref-default-bibliography, and bib files in current working directory. You can also specify a new file."
  (interactive)
  (let ((new-file (ido-completing-read
		   "Copy to bibfile: "
		   (append org-ref-default-bibliography
			   (f-entries "." (lambda (f) (f-ext? f "bib"))))))
	(key (org-ref-get-bibtex-key-under-cursor)))
    (save-window-excursion
      (org-ref-open-citation-at-point)
      (bibtex-copy-entry-as-kill))

    (let ((bibtex-files (list (file-truename new-file))))
      (if (assoc key (bibtex-global-key-alist))
	  (message "That key already exists in %s" new-file)
	;; add to file
	(save-window-excursion
	  (find-file new-file)
	  (goto-char (point-max))
          ;; make sure we are at the beginning of a line.
	  (unless (looking-at "^") (insert "\n\n"))
	  (bibtex-yank)
	  (save-buffer))))))
#+END_SRC

#+RESULTS:
: #<marker at 1038 in blog.org>

#+BEGIN_SRC emacs-lisp
(add-to-list
'org-ref-user-cite-menu-funcs
       '("y" "Copy entry to file" org-ref-copy-entry-at-point-to-file) t)
#+END_SRC

We might also want to copy a short summary to the clipboard, so we could readily paste it somewhere. Here is one way to do it. You might prefer (bibtex-copy-summary-as-kill) instead.

#+BEGIN_SRC emacs-lisp
(defun org-ref-copy-entry-as-summary ()
  "Copy the bibtex entry for the citation at point as a summary."
  (interactive)
    (save-window-excursion
      (org-ref-open-citation-at-point)
      (kill-new (org-ref-bib-citation))))
#+END_SRC
#+RESULTS:
: org-ref-copy-entry-as-summary

#+BEGIN_SRC emacs-lisp
(add-to-list
'org-ref-user-cite-menu-funcs
       '("s" "Copy summary" org-ref-copy-entry-as-summary) t)
#+END_SRC

Here is a citation to test these out on cite:mehta-2014-ident-poten.

They seem to work! These are built in to org-ref now, so if you update to the latest version they should work for you too.

* Updating a bibtex entry using its doi	  :bibtex:
  :PROPERTIES:
  :categories: bibtex
  :ID:       25D61EEA-2AE0-4647-9661-648FBA980729
  :END:
The next step is to use this to update an entry. Presumably ASAP articles will have their metadata updated in the future. It would be great to be able to run a command on an entry and update it. To do that, we need a convenient function to set a bibtex field. There is a function to get a field, but not to set a field. This next block is the closest thing I have come up with that sets a field

#+BEGIN_SRC emacs-lisp
(defun bibtex-set-field (field value)
  "set field to value in bibtex file. create field if it does not exist"
  (interactive "sfield: \nsvalue: ")
  (bibtex-beginning-of-entry)
  (let ((found))
    (if (setq found (bibtex-search-forward-field field t))
	;; we found a field
	(progn
	  (goto-char (car (cdr found)))
	  (when value
	    (bibtex-kill-field)
	    (bibtex-make-field field)
	    (backward-char)
	    (insert value)))
      ;; make a new field
      (message "new field being made")
      (bibtex-beginning-of-entry)
      (forward-line) (beginning-of-line)
      (bibtex-next-field nil)
      (forward-char)
      (bibtex-make-field field)
      (backward-char)
      (insert value))))
#+END_SRC

#+RESULTS:
: bibtex-set-field

Now, we want a function to update a bibtex entry. The function will get the doi from the entry, then retrieve the json data, and then update each field. We need to get the keys in the json results, and then map each key to a field in a bibtex entry. Here we go.

#+BEGIN_SRC emacs-lisp
(require 'json)

;; adapted from https://github.com/mon-key/mon-systems-cl/blob/master/plist.lisp
(defun plist-get-keys (plist)
   "return keys in a plist"
  (loop
   for key in results by #'cddr collect key))

(defun update-bibtex-entry-from-doi (doi)
  "update fields in a bibtex entry from the doi."
  (interactive (list (or (bibtex-autokey-get-field "doi") (read-string "DOI: "))))
  (let* ((url-request-method "GET")
	(url-mime-accept-string "application/citeproc+json")
	(json-object-type 'plist)
	(results (with-current-buffer
		    (url-retrieve-synchronously
		     (concat "https://doi.org/" doi))
		  (json-read-from-string
		   (buffer-substring url-http-end-of-headers (point-max)))))
	(type (plist-get results :type))
	(author (mapconcat
		(lambda (x) (concat (plist-get x :given)
				    " " (plist-get x :family)))
		(plist-get results :author) " and "))
	(title (plist-get results :title))
	(journal (plist-get results :container-title))
	(year (format "%s"
		       (elt
			(elt
			 (plist-get
			  (plist-get results :issued) :date-parts) 0) 0)))

	(volume (plist-get results :volume))
	(number (or (plist-get results :issue) ""))
	(pages (or (plist-get results :page) ""))
	(month (format "%s"
			(elt
			 (elt
			  (plist-get
			   (plist-get results :issued) :date-parts) 0) 1)))
	(url (or (plist-get results :URL) ""))
	(doi (plist-get results :DOI))
	(annote (format "%s" results)))

    ;; map the json fields to bibtex fields
    (setq mapping '((:author . (bibtex-set-field "author" author))
		    (:title . (bibtex-set-field "title" title))
		    (:container-title . (bibtex-set-field "journal" journal))
		    (:issued . (progn
				 (bibtex-set-field "year" year)
				 (bibtex-set-field "month" month)))
		    (:volume . (bibtex-set-field "volume" volume))
		    (:issue . (bibtex-set-field "issue" issue))
		    (:page . (bibtex-set-field "pages" pages))
		    (:DOI . (bibtex-set-field "doi" doi))
		    (:URL . (bibtex-set-field "url" url))))

    ;; now we have code to run for each entry. we map over them and evaluate the code
    (mapcar
     (lambda (key)
       (eval (cdr (assoc key mapping))))
     (plist-get-keys results)))

  ; reclean entry, but keep existing key. check if it exists
  (if (bibtex-key-in-head)
      (org-ref-clean-bibtex-entry t)
    (org-ref-clean-bibtex-entry)))
#+END_SRC

#+RESULTS:
: update-bibtex-entry-from-doi

* Sorting the fields of a bibtex entry with emacs-lisp :bibtex:
  :PROPERTIES:
  :ID:       39F9147F-8FFE-450E-BDC6-778F4FC622FA
  :END:

We need two lists. The list that defines the order I want, and the rest of them.

#+BEGIN_SRC emacs-lisp :results value
(find-file "sort.bib")
(goto-char (point-min))

(defun org-ref-sort-bibtex-entry ()
  "sort fields of entry in standard order and downcase them"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((master '("author" "title" "journal" "volume" "issue" "pages" "year" "doi" "url"))
	 (entry (bibtex-parse-entry))
	 (entry-fields)
	 (other-fields)
	 (type (cdr (assoc "=type=" entry)))
	 (key (cdr (assoc "=key=" entry))))

    ;; these are the fields we want to order that are in this entry
    (setq entry-fields (mapcar (lambda (x) (car x)) entry))
    ;; we do not want to reenter these fields
    (setq entry-fields (remove "=key=" entry-fields))
    (setq entry-fields (remove "=type=" entry-fields))

    ;;these are the other fields in the entry
    (setq other-fields (remove-if-not (lambda(x) (not (member x master))) entry-fields))

    (cond
     ;; right now we only resort articles
     ((string= type "article")
      (bibtex-kill-entry)
      (insert
       (concat "@article{" key ",\n"
	       (mapconcat
		(lambda (field)
		  (when (member field entry-fields)
		    (format "%s = %s," (downcase field) (cdr (assoc field entry))))) master "\n")
	       (mapconcat
		(lambda (field)
		  (format "%s = %s," (downcase field) (cdr (assoc field entry)))) other-fields "\n")
	       "\n}"))
      (bibtex-clean-entry)
       ))))

(org-ref-sort-bibtex-entry)
#+END_SRC

#+RESULTS:
#+begin_example
@article{conesa-2010-relev-disper,
author = {Conesa, Jose\'{e} C.},
title = {The Relevance of Dispersion Interactions for the
                  Stability of Oxide Phases},
journal = {The Journal of Physical Chemistry C},
volume = 114,

pages = {22718-22726},
year = 2010,

pdf = {[[file:bibtex-pdfs/conesa-2010-relev-disper.pdf]]},
org-notes = {[[file:~/Dropbox/bibliography/notes.org::conesa-2010-relev-disper]]},
number = 51,
doi = {10.1021/jp109105g},
url = {http://pubs.acs.org/doi/abs/10.1021/jp109105g},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/jp109105g},
}
#+end_example

* Parsing a bibtex file into a data structure :bibtex:
  :PROPERTIES:
  :ID:       2CE56437-7FC5-4DC3-B9FA-9A1E63548339
  :END:

I need to parse a bibtex file and get a data structure I can use later. I want an a-list of (key . plist), where the plist will contain data about each bibtex entry, such as the file the key is in, and the entry string.

The idea is to do this once, to avoid re-searching a file all the time. Here is how I would use this idea.

#+BEGIN_SRC emacs-lisp
(setq results '())

(defun parse-bibtex-file (file)
  "parse bibtex file and add to data structure"
  (with-current-buffer (find-file-noselect file)
    (bibtex-map-entries
     (lambda (key start end)
       (add-to-list 'results
		    `(,key . (,@(loop for (field . value) in
				      (bibtex-parse-entry t)
				      append (list (intern (concat ":" field))
						   value))
			      :entry ,(buffer-substring start end)
			      :file ,file
			      :marker ,(set-marker
					(point-marker)
					start
					(current-buffer))))
		    t)))))

(let ((bibfiles '("~/Dropbox/bibliography/references.bib")))
  (mapcar 'parse-bibtex-file bibfiles))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(cdr (assoc  "kitchin-2015-examp" results))
#+END_SRC

#+RESULTS:
| :=type= | article | :=key= | kitchin-2015-examp | :author | Kitchin, John R. | :title | Examples of Effective Data Sharing in Scientific Publishing | :journal | ACS Catalysis | :volume | 5 | :number | 6 | :pages | 3894-3899 | :year | 2015 | :doi | 10.1021/acscatal.5b00538 | :url | https://doi.org/10.1021/acscatal.5b00538 | :keywords | DESC0004031, early-career, orgmode, Data sharing | :eprint | https://doi.org/10.1021/acscatal.5b00538 | :entry | @article{kitchin-2015-examp,\n  author =\n {Kitchin, John R.},\n  title =\n {Examples of Effective Data Sharing in Scientific Publishing},\n  journal =\n {ACS Catalysis},\n  volume =\n {5},\n  number =\n {6},\n  pages =\n {3894-3899},\n  year =\n 2015,\n  doi =\n\n {10.1021/acscatal.5b00538},\n  url =\n\n { https://doi.org/10.1021/acscatal.5b00538 },\n  keywords =\n {DESC0004031, early-career, orgmode, Data sharing },\n  eprint =\n { https://doi.org/10.1021/acscatal.5b00538 },\n} | :file | ~/Dropbox/bibliography/references.bib | :marker | #<marker at 397229 in references.bib> |

#+BEGIN_SRC emacs-lisp
;; now see what we got
(let ((marker (plist-get
	       (cdr (assoc "kitchin-2015-examp" results))
	       ':marker)))
  (switch-to-buffer (marker-buffer marker))
  (goto-char marker))
#+END_SRC
#+RESULTS:
: #<marker at 397229 in references.bib>

* Merging bibtex files			  :bibtex:
  :PROPERTIES:
  :ID:       B818F493-3F07-4511-A59E-68E569D71222
  :END:

Add entries of f2 to f1 if they are not already there

#+BEGIN_SRC emacs-lisp
(let (d1 d2)
  (find-file "../../Dropbox/bibliography/references.bib")
  (bibtex-map-entries
   (lambda (key start end)
     (add-to-list 'd1 (cons key (buffer-substring start end)))))

  (find-file "/Users/jkitchin/Dropbox/CMU/proposals/@archive/2015/DOE-alloys/doe-alloys.bib")
  (bibtex-map-entries
   (lambda (key start end)
     (add-to-list 'd2 (cons key (buffer-substring start end)))))

  (pop-to-buffer "new-entries")
  (insert (mapconcat 'identity
		     (loop for new-key in
			   (-difference (mapcar 'car d2) (mapcar  'car d1))
			   collect
			   (cdr (assoc new-key d2)))
		     "\n")))
#+END_SRC

#+RESULTS:
#+begin_example
@article{zhao-2006-comput-approac,
  author =	 {Zhao, J.-C.},
  title =	 {Computational Approaches As Effective Tools in the Study of
                  Phase Diagrams and Composition-Structure-Property
                  Relationships},
  journal =	 {Progress in Materials Science},
  volume =	 51,
  pages =	 {557-631},
  year =	 2006,
  type =	 {Journal Article},
}
#+end_example

* Save all open bibtex files		  :bibtex:
  :PROPERTIES:
  :ID:       609FF1D3-61C2-4FD8-8921-3318C2C37FBE
  :END:


#+BEGIN_SRC emacs-lisp
(loop for buffer in (buffer-list)
  do
  (set-buffer buffer)
  (when (and (buffer-file-name) (f-ext? (buffer-file-name) "bib"))
    (save-buffer)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(loop for buffer being the buffers
      do
      (with-current-buffer buffer
	(when (and (buffer-file-name) (f-ext? (buffer-file-name) "bib"))
	  (save-buffer))))
#+END_SRC

#+RESULTS:

* Converting Endnote libraries to bibtex files :bibtex:
  :PROPERTIES:
  :categories: bibtex
  :ID:       2A4F1DCF-D5CB-43B0-9B1D-FE0F7821DA4D
  :END:
I have had a need lately to convert Endnote libraries into bibtex files. Endnote has a BibTeX-Export style that will export your library. One issue with that style is it expects you to have a label in each entry. If you are a normal Endnote user, you do not have labels on any entry. There is no need for them. I also found that for entries with no label, there is no comma in the entry header, which causes Emacs to think the entry is syntactically incorrect. I fixed up the style to prevent that from happening. You can get a copy of the style [[C:\Users\jkitchin\Documents\EndNote\Styles\BibTeX-Export-kitchin.ens][here]].

Now, if you load that style, you can export a library to a
file. Endnote insists on making it a text file. We need to rename the
file, then we need to create keys for each entry. Normally, I would do
that with =bibtex-clean-entry=, which mostly works by hand. However, the bibtex entries are not correct yet, because they have no keys. We will add simple numeric keys, and then map over each entry to add proper keys.

#+BEGIN_SRC python
from bibtexparser.bparser import BibTexParser
from bibtexparser.customization import convert_to_unicode
import textwrap

def format_bibtex_entry(entry):
    # field, format, wrap or not
    field_order = [(u'author', '{{{0}}},\n', True),
                   (u'title', '{{{0}}},\n', True),
                   (u'journal','"{0}",\n', True),
                   (u'volume','{{{0}}},\n', True),
                   (u'number', '{{{0}}},\n', True),
                   (u'pages', '{{{0}}},\n', True),
                   (u'year', '{0},\n', True),
                   (u'doi','{{{0}}},\n', False),
                   (u'url','{{\url{{{0}}}}},\n', False),
                   (u'link','{{\url{{{0}}}}},\n', False)]

    keys = set(entry.keys())

    extra_fields = keys.difference([f[0] for f in field_order])
    # we do not want these in our entry
    extra_fields.remove('type')
    extra_fields.remove('id')

    # Now build up our entry string
    s = '@{type}{{{id},\n'.format(type=entry['type'].upper(),
                                  id=entry['id'])

    for field, fmt, wrap in field_order:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = fmt.format(entry[field])
            s3 = '{0:17s}{1}'.format(s1, s2)
            if wrap:
                # fill seems to remove trailing '\n'
                s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    for field in extra_fields:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = entry[field]
            s3 = '{0:17s}{{{1}}}'.format(s1, s2)
            s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    s += '}\n\n'
    return s


import os
if os.path.exists('ternary-alloys-exported.bib'):
    os.unlink('ternary-alloys-exported.bib')

# get the entries
with open('ternary-alloys.bib', 'r') as bibfile:
    bp = BibTexParser(bibfile)
    entries = bp.get_entry_list()


for i, entry in enumerate(entries):
    # set key to a simple number
    entry['id'] = i
    with open('ternary-alloys-exported.bib', 'a') as f:
        f.write(format_bibtex_entry(entry))
#+END_SRC

#+RESULTS:


Ok, finally, our goal is consistency with Emacs. Now the entries are syntactically correct, and we can clean each entry. This block runs through each entry and replaces the numeric key with a key formatted our way. Unfortunately you still have to press enter for each entry.

#+BEGIN_SRC emacs-lisp
(find-file "ternary-alloys-exported.bib")
(bibtex-map-entries (lambda (entry start end)
(condition-case ex
    (bibtex-clean-entry t nil)
  ('error (message (format "Caught exception: [%s]" ex))))))
#+END_SRC

#+RESULTS:


[[./ternary-alloys-exported.bib]]

* Formatting bibtex entries		  :bibtex:

#+name: an-entry
#+BEGIN_EXAMPLE
@article{hallenbeck-2013-effec-o2,
  author =	 "Hallenbeck, Alexander P. and Kitchin, John R.",
  title =	 {Effects of O2 and SO2 on the capture capacity of a
                  primary-amine based polymeric CO2 sorbent},
  keywords =	 {RUA, orgmode},
  journal =	 "Industrial \& Engineering Chemistry Research",
  pages =	 "10788-10794",
  year =	 2013,
  volume =	 52,
  number =	 31,
  doi =		 "10.1021/ie400582a",
  url =		 "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
  eprint =	 "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp :var bentry=an-entry :results code
(with-temp-buffer
  (insert bentry)
  (bibtex-beginning-of-entry)
  (bibtex-parse-entry))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("=type=" . "article")
 ("=key=" . "hallenbeck-2013-effec-o2")
 ("author" . "\"Hallenbeck, Alexander P. and Kitchin, John R.\"")
 ("title" . "{Effects of O2 and SO2 on the capture capacity of a\n                  primary-amine based polymeric CO2 sorbent}")
 ("keywords" . "{RUA, orgmode}")
 ("journal" . "\"Industrial \\& Engineering Chemistry Research\"")
 ("pages" . "\"10788-10794\"")
 ("year" . "2013")
 ("volume" . "52")
 ("number" . "31")
 ("doi" . "\"10.1021/ie400582a\"")
 ("url" . "\"http://pubs.acs.org/doi/abs/10.1021/ie400582a\"")
 ("eprint" . "\"http://pubs.acs.org/doi/pdf/10.1021/ie400582a\""))
#+END_SRC

First, we need to take an author string, and parse it into a list of cons cells containing first and last names. Authors are separated by "and" in bibtex. The names are either "Lastname, Firstname" or "First Name LastName". For now, we do not handle von names.

#+BEGIN_SRC emacs-lisp
(defun parse-authors (author-string)
  "Return cons list of (firstname . lastname)
Does not handle von names."
  (mapcar
   (lambda (author)
     (cond
      ;; Lastname, Firstname
      ((string-match "," author)
       (let ((fields (split-string author "," t " ")))
	 (cons (car (last fields)) (mapconcat 'identity (butlast fields) " "))))
      ;; Firstname Initial Lastname
      (t
       (let ((fields (split-string author " " t " ")))
	 (cons (mapconcat 'identity (butlast fields) " ")
	       (car (last fields)))))))
   (split-string author-string " and ")))

(loop for au in '("Kitchin, J. R."
		  "Hallenbeck, Alexander and Kitchin, J. R."
		  "Alexander Hallenbeck and John R. Kitchin")
      collect (list au (parse-authors au)))
#+END_SRC

#+RESULTS:
| Kitchin, J. R.                           | ((J. R. . Kitchin))                            |
| Hallenbeck, Alexander and Kitchin, J. R. | ((Alexander . Hallenbeck) (J. R. . Kitchin))   |
| Alexander Hallenbeck and John R. Kitchin | ((Alexander . Hallenbeck) (John R. . Kitchin)) |

Now, we want a function that will take an author string, and
#+BEGIN_SRC emacs-lisp
(defvar last-author-joiner " and "
  "How to join the last author to other others.
Some values that make sense are
\" and \" \", \" \" & \"")

(defun format-author-initials (author-string)
  "Kitchin, John R. -> J. R. Kitchin"
  (let ((authors (mapcar
		  (lambda (author)
		    (concat
		     (let ((fname (car author)))
		       (mapconcat
			(lambda (initial)
			  (format "%s." initial))
			(mapcar
			 (lambda (x)
			   (substring x 0 1))
			 (split-string fname " "))
			" "))
		     " "
		     (cdr author)))
		  (parse-authors author-string))))
    (concat
     (mapconcat
      'identity
      (butlast authors)
      ", ")
     (when (> (length authors) 1)
       last-author-joiner)
     (car (last authors)))))


(loop for au in '("John Robert Kitchin"
		  "Kitchin, John Robert"
		  "Alexander Hallenbeck and Jake Boes and John R. Kitchin"
		  "Hallenbeck, Alexander P. and Kitchin, John R.")
      collect (list au (format-author-initials au)))
#+END_SRC

#+RESULTS:
| John Robert Kitchin                                    | J. R. Kitchin                            |
| Kitchin, John Robert                                   | J. R. Kitchin                            |
| Alexander Hallenbeck and Jake Boes and John R. Kitchin | A. Hallenbeck, J. Boes and J. R. Kitchin |
| Hallenbeck, Alexander P. and Kitchin, John R.          | A. P. Hallenbeck and J. R. Kitchin       |

For really long author lists, you might want to truncate them. We do not handle that here.

Now, a function to take an entry, and format it for a specific backend.

#+BEGIN_SRC emacs-lisp
(defun harvard-article (entry backend)
  (cond
   ((eq backend 'ascii)
    (list
     ;; in-text citation
     (format
      "(%s %s)"
      (let ((lnames (mapcar
		     'cdr
		     (parse-authors (cdr (assoc "author" entry))))))
	(concat
	 (mapconcat
	  'identity
	  lnames
	  ", ")))
      (cdr (assoc "year" entry)))
     ;; bibliography citation
     (s-format
      "${author}, '${title}', ${journal}, ${volume}${number} pp. ${pages}."
      'aget
      `(("author" . ,(format-author-initials
		      (cdr (assoc "author" entry))))
	("journal" . ,(cdr (assoc "journal" entry)))
	("title" . ,(replace-regexp-in-string
		     "[[:space:]]+" " "
		     (replace-regexp-in-string
		      "\n+" ""
		      (cdr (assoc "title" entry)))))
	("volume" . ,(format
		      "vol. %s,"
		      (cdr (assoc "volume" entry))))
	("number" . ,(if (cdr (assoc "number" entry))
			 (format " no. %s," (cdr (assoc "number" entry)))
		       ", "))
	("pages" . ,(cdr (assoc "pages" entry)))))))))
#+END_SRC

#+RESULTS:
: harvard-article


#+BEGIN_SRC emacs-lisp  :var bentry=an-entry
(let ((entry (with-temp-buffer
	       (insert bentry)
	       (bibtex-beginning-of-entry)
	       (bibtex-parse-entry t))))
  (harvard-article entry 'ascii))
#+END_SRC

#+RESULTS:
| (Hallenbeck, Kitchin 2013) | A. P. Hallenbeck and J. R. Kitchin, 'Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent', Industrial \& Engineering Chemistry Research, vol. 52, no. 31, pp. 10788-10794. |

Clearly this cannot work in isolation, as we need the citation-number for in-text, and the bibliography.
#+BEGIN_SRC emacs-lisp
(defun unsrt-article (entry backend)
  (cond
   ((eq backend 'html)
    (list
     ;; in-text citation
     (format
      "<sup>%s</sup>" "number")
     ;; bibliography citation
     (s-format
      "${author}, <i>${title}</i>, ${journal}, <b>${volume}</b>${number}, ${pages} ${year}."
      'aget
      `(("author" . ,(format-author-initials
		      (cdr (assoc "author" entry))))
	("journal" . ,(cdr (assoc "journal" entry)))
	("title" . ,(replace-regexp-in-string
		     "[[:space:]]+" " "
		     (replace-regexp-in-string
		      "\n+" ""
		      (cdr (assoc "title" entry)))))
	("volume" . ,(cdr (assoc "volume" entry)))
	("number" . ,(if (cdr (assoc "number" entry))
			 (format "(%s)" (cdr (assoc "number" entry)))
		       " "))
	("pages" . ,(cdr (assoc "pages" entry)))
	("year" . ,(format "(%s)" (cdr (assoc "year" entry))))))))))
#+END_SRC

#+RESULTS:
: unsrt-article

#+BEGIN_SRC emacs-lisp  :var bentry=an-entry :results html
(let ((entry (with-temp-buffer
	       (insert bentry)
	       (bibtex-beginning-of-entry)
	       (bibtex-parse-entry t))))
  (unsrt-article entry 'html))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
(<sup>number</sup> A. P. Hallenbeck and J. R. Kitchin, <i>Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent</i>, Industrial \& Engineering Chemistry Research, <b>52</b>(31), 10788-10794 (2013).)
#+END_HTML

** A function based approach

The gist here is we have a function for each field in an entry that returns a formatted string for a particular backend.

#+BEGIN_SRC emacs-lisp
(defvar last-author-joiner " and "
  "How to join the last author to other others.
Some values that make sense are
\" and \" \", \" \" & \"")

(defun format-author-initials (author-string)
  "Kitchin, John R. -> J. R. Kitchin"
  (let ((authors (mapcar
		  (lambda (author)
		    (concat
		     (let ((fname (car author)))
		       (mapconcat
			(lambda (initial)
			  (format "%s." initial))
			(mapcar
			 (lambda (x)
			   (substring x 0 1))
			 (split-string fname " "))
			" "))
		     " "
		     (cdr author)))
		  (parse-authors author-string))))
    (concat
     (mapconcat
      'identity
      (butlast authors)
      ", ")
     (when (> (length authors) 1)
       last-author-joiner)
     (car (last authors)))))

(defun author (entry backend)
  "This function would handle initials, et al, etc..."
  (concat
   (format-author-initials
    (cdr (assoc "author" entry)))
   ", "))

(defun journal (entry backend)
  (concat
   (cdr (assoc "journal" entry))
   ", "))

(defun title (entry backend)
  (concat
   (replace-regexp-in-string
    "[[:space:]]+" " "
    (replace-regexp-in-string
     "\n+" ""
     (cdr (assoc "title" entry))))
   ", "))

(defun volume (entry backend)
  (cdr (assoc "volume" entry)))

(defun number (entry backend)
  (if (cdr (assoc "number" entry))
      (format "(%s), " (cdr (assoc "number" entry)))
    ", "))

(defun pages (entry backend)
  "This function would have to consider page ranges, and use an EID if pages are missing."
  (concat
   (cdr (assoc "pages" entry))
   " "))

(defun year (entry backend)
  (format "(%s)." (cdr (assoc "year" entry))))
#+END_SRC
#+RESULTS:
: year

Now, we just concatenate them together.
#+BEGIN_SRC emacs-lisp
(defun unsrt-article-entry (entry &optional backend)
  (mapconcat
   (lambda (element)
     (funcall element entry backend))
   '(author journal volume number pages year)
   ""))
#+END_SRC

#+RESULTS:
: unsrt-article-entry

#+BEGIN_SRC emacs-lisp  :var bentry=an-entry
(let ((entry (with-temp-buffer
	       (insert bentry)
	       (bibtex-beginning-of-entry)
	       (bibtex-parse-entry t))))
  (unsrt-article-entry entry))
#+END_SRC
#+RESULTS:
: A. P. Hallenbeck and J. R. Kitchin, Industrial \& Engineering Chemistry Research, 52(31), 10788-10794 (2013).

We still need:
1. List of cites

for each cite, calculate replacement texts and entries, sorted appropriately.

* Automating version control on org files
  :PROPERTIES:
  :ID:       AFD07DE1-DF20-46F0-AB7E-2D8058CE7D8A
  :END:
  I came across this [[http://erikclarke.net/2014/10/21/keeping-a-lab-notebook-with-org-mode-git-papers-and-pandoc-part-ii/][post]] on keeping a lab notebook in org-mode and git. One interesting feature in the post is a lab-notebook minor mode that automates version control by adding a function to the after-save-hook. I am testing it out here.

#+BEGIN_SRC emacs-lisp
(defun ensure-in-vc-or-checkin ()
  (interactive)
  (if (file-exists-p (format "%s" (buffer-file-name)))
      (progn (vc-next-action nil) (message "Committed"))
    (ding) (message "File not checked in.")))

;; i set this to nil at some point for performance reasons
(setq vc-handled-backends '(Git))

(add-hook 'after-save-hook 'ensure-in-vc-or-checkin nil 'make-it-local)
#+END_SRC

#+RESULTS:
| ensure-in-vc-or-checkin | t |

#+BEGIN_SRC emacs-lisp
(remove-hook 'after-save-hook 'ensure-in-vc-or-checkin)
#+END_SRC

#+RESULTS:

Now, when I save this file, I am prompted for a commit message, then I press C-c C-c to commit it.

If we make a new file: file:new-file.org I do not get quite what I would have expected. The file is added, but not committed. The second save prompts for a commit message.

So, what should happen? I think you should only be prompted for a commit message when you want one. I often save to avoid losing work, but I wouldn't always want to write a commit message for that. Also, if the file is new, I want it added /and/ committed. Probably, you should commit when a buffer is killed.

It turns out there are a lot of helpful vc commands built into Emacs.

| C-x v l | Show log            |                          |
| C-x v i | add file            | vc-register              |
| C-x v = | diff current file   |                          |
| C-x v G | ignore file         | vc-ignore                |
| C-x v v | next logical action | (vc-next-action VERBOSE) |
|         |                     | vc-create-repo           |
|         |                     | vc-git-grep              |
|         |                     |                          |

vc-dir

vc-diff

We can get some idea of the state of the vc directory like this
#+BEGIN_SRC emacs-lisp
(vc-deduce-fileset nil t 'state-model-only-files)
#+END_SRC

#+RESULTS:
| Git | (/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | (/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | edited | implicit |

Checking if the current buffer is under vc:
#+BEGIN_SRC emacs-lisp
(vc-registered (buffer-file-name)) ;; return non-nil if file is registered
#+END_SRC

#+RESULTS:
: t


* advise a proxy

#+BEGIN_SRC emacs-lisp
(doi-utils-get-pdf-url "10.1021/acscatal.5b00538")
#+END_SRC

#+RESULTS:
: http://pubs.acs.org/doi/pdf/10.1021/acscatal.5b00538

Add proxy to get http://pubs.acs.org.proxy.library.nd.edu/doi/10.1021/acscatal.5b01755

.proxy.library.nd.edu

#+BEGIN_SRC emacs-lisp
(defun my-pdf-proxy (orig-fun &rest args)
  (let* ((pdf-url (apply orig-fun args))
	 (url-struct (url-generic-parse-url pdf-url)))
    (setf (url-host url-struct)
	  (concat (url-host url-struct) ".proxy.library.nd.edu"))
    (url-recreate-url url-struct)))

(advice-add 'doi-utils-get-pdf-url :around #'my-pdf-proxy)

(doi-utils-get-pdf-url "10.1021/acscatal.5b00538")

;(advice-remove 'doi-utils-get-pdf-url #'my-pdf-proxy)
#+END_SRC

#+RESULTS:
: http://pubs.acs.org.proxy.library.nd.edu/doi/pdf/10.1021/acscatal.5b00538

* Kitchingroup videos
** Youtube videos
   :PROPERTIES:
   :ID:       6C0CA0A2-8DB2-4EE0-A963-A906E9ABD5DA
   :END:
https://www.youtube.com/analytics?o=U

#+BEGIN_HTML
<script src="https://apis.google.com/js/platform.js"></script>

<div class="g-ytsubscribe" data-channelid="UCQp2VLAOlvq142YN3JO3y8w" data-layout="full" data-count="default"></div>
#+END_HTML
- Reproducible Research at Scipy 2013
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/1-dUkyn_fZA" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- org-mode is awesome
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/fgizHHd7nOo" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- A Success Story in Using Python in a Graduate Chemical Engineering Course at Scipy 2014
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/IsSMs-4GlT8" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- Teaching with Emacs + org-mode
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/cRUCiF2MwP4" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- The org-ref show
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/JyvpSVl4_dg" frameborder="0" allowfullscreen></iframe>
#+END_HTML



bibliography:~/Dropbox/bibliography/references.bib
* Advent of code
** day 1 http://adventofcode.com/day/1

#+BEGIN_SRC emacs-lisp
(defun floor (directions)
  (let ((count 0))
    (loop for char across directions
	  do
	  (if (string= (char-to-string char) "(")
	      (setq count (+ 1 count))
	    (setq count (- count 1))))
    count))

(floor "((((()(()(((((((()))(((()((((()())(())()(((()((((((()((()(()(((()(()((())))()((()()())))))))))()((((((())((()))(((((()(((((((((()()))((()(())()((())((()(()))((()))()))()(((((()(((()()))()())((()((((())()())()((((())()(()(()(((()(())(()(())(((((((())()()(((())(()(()(()(())))(()((((())((()))(((()(()()(((((()()(()(((()(((((())()))()((()(()))()((()((((())((((())(()(((())()()(()()()()()(())((((())((())(()()))()((((())))((((()())()((((())((()())((())(())(((((()((((()(((()((((())(()(((()()))()))((((((()((())()())))(((()(()))(()()(()(((()(()))((()()()())((()()()(((())())()())())())((()))(()(()))(((((()(()(())((()(())(())()((((()())()))((((())(())((())())((((()(((())(())((()()((((()((((((()(())()()(()(()()((((()))(())()())()))(())))(())))())()()(())(()))()((()(()(())()()))(()())))))(()))(()()))(())(((((()(()(()()((())()())))))((())())((())(()(())((()))(())(((()((((((((()()()(()))()()(((()))()((()()(())(())())()(()(())))(((((()(())(())(()))))())()))(()))()(()(((((((()((((())))())())())())()((((((((((((((()()((((((()()()())())()())())())(())(())))())((()())((()(()))))))()))))))))))))))))())((())((())()()))))))(((()((()(()()))((())(()()))()()())))(())))))))(()(((())))())()())))()()(())()))()(()))())((()()))))(()))))()))(()()(())))))))()(((()))))()(()))(())())))))()))((()))((()))())(())))))))))((((())()))()))()))())(())()()(())))())))(()())()))((()()(())))(())((((((()(())((()(((()(()()(())))()))))))()))()(()((()))()(()))(()(((())((((())())(())(()))))))))())))))))())())))))())))))()()(((())()(()))))))))())))))(())()()()))()))()))(()(())()()())())))))))())()(()(()))))()()()))))())(()))))()()))))()())))))(((())()()))(()))))))))))()()))))()()()))))(()())())()()())()(()))))()(()))(())))))))(((((())(())())()()))()()))(())))))()(()))))(())(()()))()())()))()))()))()))))())()()))())())))(()))(()))))))())()(((())()))))))))()))()())))())))())))()))))))))))()()))(()()))))))(())()(()))))())(()))))(()))))(()())))))())())()()))))())()))))))))(()))))()))))))()(()())))))))()))())))())))())))())))))))())(()()))))))(()())())))()())()))))))))))))))())))()(())))()))())()()(())(()()))(())))())()())(()(()(()))))())))))))))))())(()))()))()))))(())()())()())))))))))))()()))))))))))))())())))))(()())))))))))))())(())))()))))))))())())(()))()))(())))()))()()(())()))))))()((((())()))())())))))()))()))))((()())()))))())))(())))))))))))))))))()))))()()())()))()()))))())()))((()())))())))(()))(()())))))))()))()))))(())))))))(())))))())()()(()))())()))()()))))())()()))))())()))())))))))(()))))()())()))))))))(()))())))(()))()))))(())()))())())(())())())))))))((((())))))()))()))()())()(())))()))()))()())(()())()()(()())()))))())())))))(()))()))))())(()()(())))))(())()()((())())))))(())(())))))))())))))))))()(())))))))()())())())()(()))))))))(()))))))))())()()))()(()))))))()))))))())))))))(())))()()(())()())))))(((())))()((())()))())))(()()))())(())())))()(((()())))))()(()()())))()()(()()(()()))())()(()()()))())()()))()())(()))))())))))())))(())()()))))(()))))(())(()))(())))))()()))()))))())()))()()(())())))((()))())()))))))()()))))((()(()))))()()))))))())))))())(()((()())))))))))))()())())))()))(()))))))(()))(())()())))(()))))))))())()()()()))))(()())))))))((())))()))(()))(())(())()())()))))))))(())))())))(()))()()))(()()))(()))())))()(())))())((()((()(())))((())))()))))((((())())()())))(())))()))))))())(()()((())))())()(()())))))(()())()))())))))))((())())))))))(()(()))())()()(()()(((()(((()())))))()))))))()(())(()()((()()(())()()))())()())()))()())())())))))))(((())))))))()()))))))(((())()))(()()))(()()))))(()(()()((((())()())((()()))))(()(())))))()((()()()())()()((()((()()))(()))(((()()()))(((())))()(((())()))))))((()(())())))(()())(((((()(()))(()((()))(()())()))))(()(()))()(()))(())(((())(()()))))()()))(((()))))(()()()()))())))((()()()(())()))()))))()()))()))))))((((((()()()))))())((()()(((()))))(()(())(()()())())())))()(((()()))(())((())))(()))(()()()())((())())())(()))))()))()((()(())()(()()(())(()))(())()))(())(()))))(())(())())(()()(()((()()((())))((()))()((())))(((()()()()((((()))(()()))()()()(((())((())())(()()(()()()))()((())(())()))())(((()()(())))()((()()())()())(()(())())(((())(())())((())(())()(((()()))(())))((())(()())())(())((()()()((((((())))((()(((((())()))()))(())(()()))()))(())()()))(())((()()())()()(()))())()((())))()((()()())((((()())((())())())((()((()))()))((())((()()(()((()()(((())(()()))))((()((())()(((())(()((())())((())(()((((((())())()(()())()(())(((())((((((()(())(()((()()()((()()(()()()())))()()(((((()()))()((((((()))()(()(()(()(((()())((()))())()((()))(())))()))()()))())()()))())((((())(()(()))(((((((())(((()(((((()(((()()((((())(((())())))(()()()(()(()))()))((((((()))((()(((()(())((()((((()((((((())(((((())))(((()(()))))(((()(((())()((())(()((()))(((()()(((())((((()(()(((((()))(((()(((((((()(()()()(()(()(()()())(())(((((()(())())()())(()(()(()))()(()()()())(()()(()((()))()((())())()(()))((())(()))()(()))()(((()(()(()((((((()()()()())()(((((()()(((()()()((()(((((()))((((((((()()()(((((()))))))(()()()(())(()))(()()))))(())()))(((((()(((((()()(()(()())(((()))((((()((()(()(()((()(()((())))()(((()((()))((()))(((((((((()((()((()(())))()((((()((()()))((())(((()(((((()()(()(()()((()(()()()(((((((())())()())))))((((()()(()))()))(()((())()(()(((((((((()()(((()(()())(()((()())((())())((((()(((()(((()((((()((()((((()(()((((((())((((((((((((()()(()()((((((((((((((()((()()))()((((((((((((())((((()(()())((()(()(()))()(((((()()(((()()))()())(())((()(((((()((())(((((()((()(((((()))()()((((())()((((())(((((((((()(())(()(())))())(()((())(((())(())(())())(()(()(())()()((()((())()(((()(((((()(())))()(((()((())))((()()()(((()(((()((()(()(())(()((()())(()(()(((()(((((((((())(()((((()()))(()((((()()()()(((()((((((((()(()()((((((()(()()(()((()((((((((((()()(((((((()())(())))(((()()))(((((()((()()())(()()((((())((()((((()))))(())((()(()()(((()(()(((()((((()(((((()))())())(()((())()))(((()())((())((())((((()((()((((((())(()((((()()))((((((())()(()))((()(((())((((((((((()()(((((()(((((()((()()()((((())))(()))()((()(())()()((()((((((((((()((())(())(((((()(()(()()))((((()((((()()((()(((()(((((((((()(()((()((()))((((((()(((())()()((()(((((((()())))()()(()((()((()()(((()(()()()()((((()((())((((()(((((((((()(((()()(((()(()(((()(((()((())()(()((()(()(()(()))()(((()))(()((((()((())((((())((((((())(()))(()((((())((()(()((((((((()()((((((()(()(()()()(())((()((()()(((()(((((((()()((()(((((((()))(((((()(((()(()()()(()(((()((()()((())(()(((((((((()(()((()((((((()()((())()))(((((()((())()())()(((((((((((()))((((()()()()())(()()(()(()()))()))(()))(()(((()()))())(()(()))()()((())(()())()())()(()))()))(()()(()((((((())((()(((((((((((()(())()((()(()((()((()(()((()((((((((((()()())((())()(())))((())()())()(((((()(()())((((()((()(())(()))(((())()((()))(((((())(()))()()(()))(((())((((()((((()(())))(((((((()))))())()())(())((())()(()()((()(()))()(()()(()()((()())((())((()()))((((()))()()))(()()(())()()(((((()(())((()((((()))()))(()())())(((()()(()()))(())))))(()))((())(((((()((((()))()((((()))()((())(((())))(((()())))((()(()()((")
#+END_SRC

#+RESULTS:
: 74

#+BEGIN_SRC emacs-lisp
(defun basement (directions)
  (let ((count 0))
    (loop for i from 1
	  for char across directions
	  do
	  (if (string= (char-to-string char) "(")
	      (setq count (+ 1 count))
	    (setq count (- count 1)))
	  until (= count -1)
	  finally return i)))

(basement "((((()(()(((((((()))(((()((((()())(())()(((()((((((()((()(()(((()(()((())))()((()()())))))))))()((((((())((()))(((((()(((((((((()()))((()(())()((())((()(()))((()))()))()(((((()(((()()))()())((()((((())()())()((((())()(()(()(((()(())(()(())(((((((())()()(((())(()(()(()(())))(()((((())((()))(((()(()()(((((()()(()(((()(((((())()))()((()(()))()((()((((())((((())(()(((())()()(()()()()()(())((((())((())(()()))()((((())))((((()())()((((())((()())((())(())(((((()((((()(((()((((())(()(((()()))()))((((((()((())()())))(((()(()))(()()(()(((()(()))((()()()())((()()()(((())())()())())())((()))(()(()))(((((()(()(())((()(())(())()((((()())()))((((())(())((())())((((()(((())(())((()()((((()((((((()(())()()(()(()()((((()))(())()())()))(())))(())))())()()(())(()))()((()(()(())()()))(()())))))(()))(()()))(())(((((()(()(()()((())()())))))((())())((())(()(())((()))(())(((()((((((((()()()(()))()()(((()))()((()()(())(())())()(()(())))(((((()(())(())(()))))())()))(()))()(()(((((((()((((())))())())())())()((((((((((((((()()((((((()()()())())()())())())(())(())))())((()())((()(()))))))()))))))))))))))))())((())((())()()))))))(((()((()(()()))((())(()()))()()())))(())))))))(()(((())))())()())))()()(())()))()(()))())((()()))))(()))))()))(()()(())))))))()(((()))))()(()))(())())))))()))((()))((()))())(())))))))))((((())()))()))()))())(())()()(())))())))(()())()))((()()(())))(())((((((()(())((()(((()(()()(())))()))))))()))()(()((()))()(()))(()(((())((((())())(())(()))))))))())))))))())())))))())))))()()(((())()(()))))))))())))))(())()()()))()))()))(()(())()()())())))))))())()(()(()))))()()()))))())(()))))()()))))()())))))(((())()()))(()))))))))))()()))))()()()))))(()())())()()())()(()))))()(()))(())))))))(((((())(())())()()))()()))(())))))()(()))))(())(()()))()())()))()))()))()))))())()()))())())))(()))(()))))))())()(((())()))))))))()))()())))())))())))()))))))))))()()))(()()))))))(())()(()))))())(()))))(()))))(()())))))())())()()))))())()))))))))(()))))()))))))()(()())))))))()))())))())))())))())))))))())(()()))))))(()())())))()())()))))))))))))))())))()(())))()))())()()(())(()()))(())))())()())(()(()(()))))())))))))))))())(()))()))()))))(())()())()())))))))))))()()))))))))))))())())))))(()())))))))))))())(())))()))))))))())())(()))()))(())))()))()()(())()))))))()((((())()))())())))))()))()))))((()())()))))())))(())))))))))))))))))()))))()()())()))()()))))())()))((()())))())))(()))(()())))))))()))()))))(())))))))(())))))())()()(()))())()))()()))))())()()))))())()))())))))))(()))))()())()))))))))(()))())))(()))()))))(())()))())())(())())())))))))((((())))))()))()))()())()(())))()))()))()())(()())()()(()())()))))())())))))(()))()))))())(()()(())))))(())()()((())())))))(())(())))))))())))))))))()(())))))))()())())())()(()))))))))(()))))))))())()()))()(()))))))()))))))())))))))(())))()()(())()())))))(((())))()((())()))())))(()()))())(())())))()(((()())))))()(()()())))()()(()()(()()))())()(()()()))())()()))()())(()))))())))))())))(())()()))))(()))))(())(()))(())))))()()))()))))())()))()()(())())))((()))())()))))))()()))))((()(()))))()()))))))())))))())(()((()())))))))))))()())())))()))(()))))))(()))(())()())))(()))))))))())()()()()))))(()())))))))((())))()))(()))(())(())()())()))))))))(())))())))(()))()()))(()()))(()))())))()(())))())((()((()(())))((())))()))))((((())())()())))(())))()))))))())(()()((())))())()(()())))))(()())()))())))))))((())())))))))(()(()))())()()(()()(((()(((()())))))()))))))()(())(()()((()()(())()()))())()())()))()())())())))))))(((())))))))()()))))))(((())()))(()()))(()()))))(()(()()((((())()())((()()))))(()(())))))()((()()()())()()((()((()()))(()))(((()()()))(((())))()(((())()))))))((()(())())))(()())(((((()(()))(()((()))(()())()))))(()(()))()(()))(())(((())(()()))))()()))(((()))))(()()()()))())))((()()()(())()))()))))()()))()))))))((((((()()()))))())((()()(((()))))(()(())(()()())())())))()(((()()))(())((())))(()))(()()()())((())())())(()))))()))()((()(())()(()()(())(()))(())()))(())(()))))(())(())())(()()(()((()()((())))((()))()((())))(((()()()()((((()))(()()))()()()(((())((())())(()()(()()()))()((())(())()))())(((()()(())))()((()()())()())(()(())())(((())(())())((())(())()(((()()))(())))((())(()())())(())((()()()((((((())))((()(((((())()))()))(())(()()))()))(())()()))(())((()()())()()(()))())()((())))()((()()())((((()())((())())())((()((()))()))((())((()()(()((()()(((())(()()))))((()((())()(((())(()((())())((())(()((((((())())()(()())()(())(((())((((((()(())(()((()()()((()()(()()()())))()()(((((()()))()((((((()))()(()(()(()(((()())((()))())()((()))(())))()))()()))())()()))())((((())(()(()))(((((((())(((()(((((()(((()()((((())(((())())))(()()()(()(()))()))((((((()))((()(((()(())((()((((()((((((())(((((())))(((()(()))))(((()(((())()((())(()((()))(((()()(((())((((()(()(((((()))(((()(((((((()(()()()(()(()(()()())(())(((((()(())())()())(()(()(()))()(()()()())(()()(()((()))()((())())()(()))((())(()))()(()))()(((()(()(()((((((()()()()())()(((((()()(((()()()((()(((((()))((((((((()()()(((((()))))))(()()()(())(()))(()()))))(())()))(((((()(((((()()(()(()())(((()))((((()((()(()(()((()(()((())))()(((()((()))((()))(((((((((()((()((()(())))()((((()((()()))((())(((()(((((()()(()(()()((()(()()()(((((((())())()())))))((((()()(()))()))(()((())()(()(((((((((()()(((()(()())(()((()())((())())((((()(((()(((()((((()((()((((()(()((((((())((((((((((((()()(()()((((((((((((((()((()()))()((((((((((((())((((()(()())((()(()(()))()(((((()()(((()()))()())(())((()(((((()((())(((((()((()(((((()))()()((((())()((((())(((((((((()(())(()(())))())(()((())(((())(())(())())(()(()(())()()((()((())()(((()(((((()(())))()(((()((())))((()()()(((()(((()((()(()(())(()((()())(()(()(((()(((((((((())(()((((()()))(()((((()()()()(((()((((((((()(()()((((((()(()()(()((()((((((((((()()(((((((()())(())))(((()()))(((((()((()()())(()()((((())((()((((()))))(())((()(()()(((()(()(((()((((()(((((()))())())(()((())()))(((()())((())((())((((()((()((((((())(()((((()()))((((((())()(()))((()(((())((((((((((()()(((((()(((((()((()()()((((())))(()))()((()(())()()((()((((((((((()((())(())(((((()(()(()()))((((()((((()()((()(((()(((((((((()(()((()((()))((((((()(((())()()((()(((((((()())))()()(()((()((()()(((()(()()()()((((()((())((((()(((((((((()(((()()(((()(()(((()(((()((())()(()((()(()(()(()))()(((()))(()((((()((())((((())((((((())(()))(()((((())((()(()((((((((()()((((((()(()(()()()(())((()((()()(((()(((((((()()((()(((((((()))(((((()(((()(()()()(()(((()((()()((())(()(((((((((()(()((()((((((()()((())()))(((((()((())()())()(((((((((((()))((((()()()()())(()()(()(()()))()))(()))(()(((()()))())(()(()))()()((())(()())()())()(()))()))(()()(()((((((())((()(((((((((((()(())()((()(()((()((()(()((()((((((((((()()())((())()(())))((())()())()(((((()(()())((((()((()(())(()))(((())()((()))(((((())(()))()()(()))(((())((((()((((()(())))(((((((()))))())()())(())((())()(()()((()(()))()(()()(()()((()())((())((()()))((((()))()()))(()()(())()()(((((()(())((()((((()))()))(()())())(((()()(()()))(())))))(()))((())(((((()((((()))()((((()))()((())(((())))(((()())))((()(()()((")
#+END_SRC

#+RESULTS:
: 1795

** Day 2

#+BEGIN_SRC emacs-lisp
(defun paper-area (s)
  "s is LxWxH"
  (destructuring-bind (L W H)
      (mapcar 'string-to-int (split-string s "x"))

    (let ((areas (list (* L W)
		       (* W H)
		       (* H L))))

      (+  (apply '+ (mapcar (lambda (x) (* 2 x)) areas)) (-min areas)))))

(loop for s in (split-string
			  "4x23x21
22x29x19
11x4x11
8x10x5
24x18x16
11x25x22
2x13x20
24x15x14
14x22x2
30x7x3
30x22x25
29x9x9
29x29x26
14x3x16
1x10x26
29x2x30
30x10x25
10x26x20
1x2x18
25x18x5
21x3x24
2x5x7
22x11x21
11x8x8
16x18x2
13x3x8
1x16x19
19x16x12
21x15x1
29x9x4
27x10x8
2x7x27
2x20x23
24x11x5
2x8x27
10x28x10
24x11x10
19x2x12
27x5x10
1x14x25
5x14x30
15x26x12
23x20x22
5x12x1
9x26x9
23x25x5
28x16x19
17x23x17
2x27x20
18x27x13
16x7x18
22x7x29
17x28x6
9x22x17
10x5x6
14x2x12
25x5x6
26x9x10
19x21x6
19x4x27
23x16x14
21x17x29
24x18x10
7x19x6
14x15x10
9x10x19
20x18x4
11x14x8
30x15x9
25x12x24
3x12x5
12x21x28
8x23x10
18x26x8
17x1x8
2x29x15
3x13x28
23x20x11
27x25x6
19x21x3
30x22x27
28x24x4
26x18x21
11x7x16
22x27x6
27x5x26
4x10x4
4x2x27
2x3x26
26x29x19
30x26x24
8x25x12
16x17x5
13x2x3
1x30x22
20x9x1
24x26x19
26x18x1
18x29x24
1x6x9
20x27x2
3x22x21
4x16x8
29x18x16
7x16x23
13x8x14
19x25x10
23x29x6
23x21x1
22x26x10
14x4x2
18x29x17
9x4x18
7x22x9
19x5x26
27x29x19
7x13x14
19x10x1
6x22x3
12x21x5
24x20x12
28x2x11
16x18x23
2x13x25
11x7x17
27x21x4
2x10x25
22x16x17
23x22x15
17x13x13
23x24x26
27x18x24
24x7x28
30x12x15
14x28x19
2x15x29
12x13x5
17x22x21
27x10x27
17x6x25
22x2x1
1x10x9
9x7x2
30x28x3
28x11x10
8x23x15
23x4x20
12x5x4
13x17x14
28x11x2
21x11x29
10x23x22
27x23x14
7x15x23
20x2x13
8x21x4
10x20x11
23x28x11
21x22x25
23x11x17
2x29x10
28x16x5
30x26x10
17x24x16
26x27x25
14x13x25
22x27x5
24x15x12
5x21x25
4x27x1
25x4x10
15x13x1
21x23x7
8x3x4
10x5x7
9x13x30
2x2x30
26x4x29
5x14x14
2x27x9
22x16x1
4x23x5
13x7x26
2x12x10
12x7x22
26x30x26
28x16x28
15x19x11
4x18x1
20x14x24
6x10x22
9x20x3
14x9x27
26x17x9
10x30x28
6x3x29
4x16x28
8x24x11
23x10x1
11x7x7
29x6x15
13x25x12
29x14x3
26x22x21
8x3x11
27x13x25
27x6x2
8x11x7
25x12x9
24x30x12
13x1x30
25x23x16
9x13x29
29x26x16
11x15x9
11x23x6
15x27x28
27x24x21
6x24x1
25x25x5
11x1x26
21x4x24
10x5x12
4x30x13
24x22x5
26x7x21
23x3x17
22x18x2
25x1x14
23x25x30
8x7x7
30x19x8
17x6x15
2x11x20
8x3x22
23x14x26
8x22x25
27x1x2
10x26x2
28x30x7
5x30x7
27x16x30
28x29x1
8x25x18
20x12x29
9x19x9
7x25x15
25x18x18
11x8x2
4x20x6
18x5x20
2x3x29
25x26x22
18x25x26
9x12x16
18x7x27
17x20x9
6x29x26
17x7x19
21x7x5
29x15x12
22x4x1
11x12x11
26x30x4
12x24x13
13x8x3
26x25x3
21x26x10
14x9x26
20x1x7
11x12x3
12x11x4
11x15x30
17x6x25
20x22x3
1x16x17
11x5x20
12x12x7
2x14x10
14x27x3
14x16x18
21x28x24
14x20x1
29x14x1
10x10x9
25x23x4
17x15x14
9x20x26
16x2x17
13x28x25
16x1x11
19x16x8
20x21x2
27x9x22
24x18x3
23x30x6
4x18x3
30x15x8
27x20x19
28x29x26
2x21x18
1x23x30
1x9x12
4x11x30
1x28x4
17x10x10
12x14x6
8x9x24
8x3x3
29x8x20
26x29x2
29x25x25
11x17x23
6x30x21
13x18x29
2x10x8
29x29x27
27x15x15
16x17x30
3x3x22
21x12x6
22x1x5
30x8x20
6x28x13
11x2x23
14x18x27
6x26x13
10x24x24
4x24x6
20x8x3
23x11x5
29x5x24
14x15x22
21x17x13
10x10x8
1x11x23
21x19x24
19x9x13
21x26x28
25x11x28
2x17x1
18x9x8
5x21x6
12x5x2
23x8x15
30x16x24
7x9x27
16x30x7
2x21x28
5x10x6
8x7x1
28x13x5
11x5x14
26x22x29
23x15x13
14x2x16
22x21x9
4x20x3
18x17x19
12x7x9
6x12x25
3x30x27
8x19x22
1x9x27
23x20x12
14x7x29
9x12x12
30x2x6
15x7x16
19x13x18
11x8x13
16x5x3
19x26x24
26x8x21
21x20x7
15x1x25
29x15x21
22x17x7
16x17x10
6x12x24
8x13x27
30x25x14
25x7x10
15x2x2
18x15x19
18x13x24
19x30x1
17x1x3
26x21x15
10x10x18
9x16x6
29x7x30
11x10x30
6x11x2
7x29x23
13x2x30
25x27x13
5x15x21
4x8x30
15x27x11
27x1x6
2x24x11
16x20x19
25x28x20
6x8x4
27x16x11
1x5x27
12x19x26
18x24x14
4x25x17
24x24x26
28x3x18
8x20x28
22x7x21
24x5x28
23x30x29
25x16x27
28x10x30
9x2x4
30x2x23
21x9x23
27x4x26
2x23x16
24x26x30
26x1x30
10x4x28
11x29x12
28x13x30
24x10x28
8x12x12
19x27x11
11x28x7
14x6x3
6x27x5
6x17x14
24x24x17
18x23x14
17x5x7
11x4x23
5x1x17
26x15x24
3x9x24
5x3x15
5x20x19
5x21x2
13x5x30
19x6x24
19x17x6
23x7x13
28x23x13
9x1x6
15x12x16
21x19x9
25x5x5
9x7x9
6x5x8
3x11x18
23x25x11
25x4x6
4x27x1
4x3x3
30x11x5
9x17x12
15x6x24
10x22x15
29x27x9
20x21x11
18x10x5
11x2x2
9x8x8
1x26x21
11x11x16
2x18x30
29x27x24
27x8x18
19x3x17
30x21x26
25x13x25
20x22x1
10x1x12
11x17x15
29x11x30
17x30x27
21x22x17
13x6x22
22x16x12
27x18x19
4x13x6
27x29x10
3x23x10
26x16x24
18x26x20
11x28x16
21x6x15
9x26x17
8x15x8
3x7x10
2x28x8
1x2x24
7x8x9
19x4x22
11x20x9
12x22x16
26x8x19
13x28x24
4x10x16
12x8x10
14x24x24
19x19x28
29x1x15
10x5x14
20x19x23
10x7x12
1x7x13
5x12x13
25x21x8
22x28x8
7x9x4
3x20x15
15x27x19
18x24x12
16x10x16
22x19x8
15x4x3
9x30x25
1x1x6
24x4x25
13x18x29
10x2x8
21x1x17
29x14x22
17x29x11
10x27x16
25x16x15
14x2x17
12x27x3
14x17x25
24x4x1
18x28x18
9x14x26
28x24x17
1x26x12
2x18x20
12x19x22
19x25x20
5x17x27
17x29x16
29x19x11
16x2x4
23x24x1
19x18x3
28x14x6
18x5x23
9x24x12
15x4x6
15x7x24
22x15x8
22x1x22
6x4x22
26x1x30
8x21x27
7x1x11
9x8x18
20x27x12
26x23x20
26x22x30
24x3x16
8x24x28
13x28x5
4x29x23
22x5x8
20x22x3
9x9x17
28x3x30
10x13x10
10x25x13
9x20x3
1x21x25
24x21x15
21x5x14
13x8x20
29x17x3
5x17x28
16x12x7
23x1x24
4x24x29
23x25x14
8x27x2
23x11x13
13x4x5
24x1x26
21x1x23
10x12x12
21x29x25
27x25x30
24x23x4
1x30x23
29x28x14
4x11x30
9x25x10
17x11x6
14x29x30
23x5x5
25x18x21
8x7x1
27x11x3
5x10x8
11x1x11
16x17x26
15x22x19
16x9x6
18x13x27
26x4x22
1x20x21
6x14x29
11x7x6
1x23x7
12x19x13
18x21x25
15x17x20
23x8x9
15x9x26
9x12x9
12x13x14
27x26x7
11x19x22
16x12x21
10x30x28
21x2x7
12x9x18
7x17x14
13x17x17
3x21x10
30x9x15
2x8x15
15x12x10
23x26x9
29x30x10
30x22x17
17x26x30
27x26x20
17x28x17
30x12x16
7x23x15
30x15x19
13x19x10
22x10x4
17x23x10
2x28x18
27x21x28
24x26x5
6x23x25
17x4x16
14x1x13
23x21x11
14x15x30
26x13x10
30x19x25
26x6x26
9x16x29
15x2x24
13x3x20
23x12x30
22x23x23
8x21x2
18x28x5
21x27x14
29x28x23
12x30x28
17x16x3
5x19x11
28x22x22
1x4x28
10x10x14
18x15x7
18x11x1
12x7x16
10x22x24
27x25x6
19x29x25
10x1x26
26x27x30
4x23x19
24x19x4
21x11x14
4x13x27
9x1x11
16x20x8
4x3x11
1x16x12
14x6x30
8x1x10
11x18x7
29x28x30
4x21x8
3x21x4
6x1x5
26x18x3
28x27x27
17x3x12
6x1x22
23x12x28
12x13x2
11x2x13
7x1x28
27x6x25
14x14x3
14x11x20
2x27x7
22x24x23
7x15x20
30x6x17
20x23x25
18x16x27
2x9x6
9x18x19
20x11x22
11x16x19
14x29x23
14x9x20
8x10x12
18x17x6
28x7x16
12x19x28
5x3x16
1x25x10
4x14x10
9x6x3
15x27x28
13x26x14
21x8x25
29x10x20
14x26x30
25x13x28
1x15x23
6x20x21
18x2x1
22x25x16
23x25x17
2x14x21
14x25x16
12x17x6
19x29x15
25x9x6
19x17x13
24x22x5
19x4x13
10x18x6
6x25x6
23x24x20
8x22x13
25x10x29
5x12x25
20x5x11
7x16x29
29x24x22
28x20x1
10x27x10
6x9x27
26x15x30
26x3x19
20x11x3
26x1x29
6x23x4
6x13x21
9x23x25
15x1x10
29x12x13
7x8x24
29x30x27
3x29x19
14x16x17
4x8x27
26x17x8
10x27x17
11x28x17
17x16x27
1x8x22
6x30x16
7x30x22
20x12x3
18x10x2
20x21x26
11x1x17
9x15x15
19x14x30
24x22x20
11x26x23
14x3x23
1x28x29
29x20x4
1x4x20
12x26x8
14x11x14
14x19x13
15x13x24
16x7x26
11x20x11
5x24x26
24x25x7
21x3x14
24x29x20
7x12x1
16x17x4
29x16x21
28x8x17
11x30x25
1x26x23
25x19x28
30x24x5
26x29x15
4x25x23
14x25x19
29x10x7
29x29x28
19x13x24
21x28x5
8x15x24
1x10x12
2x26x6
14x14x4
10x16x27
9x17x25
25x8x7
1x9x28
10x8x17
4x12x1
17x26x29
23x12x26
2x21x22
18x23x13
1x14x5
25x27x26
4x30x30
5x13x2
17x9x6
28x18x28
7x30x2
28x22x17
14x15x14
10x14x19
6x15x22
27x4x17
28x21x6
19x29x26
6x17x17
20x13x16
25x4x1
2x9x5
30x3x1
24x21x2
14x19x12
22x5x23
14x4x21
10x2x17
3x14x10
17x5x3
22x17x13
5x19x3
29x22x6
12x28x3
9x21x25
10x2x14
13x26x7
18x23x2
9x14x17
21x3x13
13x23x9
1x20x4
11x4x1
19x5x30
9x9x29
26x29x14
1x4x10
7x27x30
8x3x23
1x27x27
7x27x27
1x26x16
29x16x14
18x6x12
24x24x24
26x2x19
15x17x4
11x7x14
14x19x10
9x10x1
14x17x9
20x19x13
25x20x8
24x20x21
26x30x2
24x2x10
28x4x13
27x17x11
15x3x8
11x29x10
26x15x16
4x28x22
7x5x22
10x28x9
6x28x13
10x5x6
20x12x6
25x30x30
17x16x14
14x20x3
16x10x8
9x28x14
16x12x12
11x13x25
21x16x28
10x3x18
5x9x20
17x23x5
3x13x16
29x30x17
2x2x8
15x8x30
20x1x16
23x10x29
4x5x4
6x18x12
26x10x22
21x10x17
26x12x29
7x20x21
18x9x15
10x23x20
20x1x27
10x10x3
25x12x23
30x11x15
16x22x3
22x10x11
15x10x20
2x20x17
20x20x1
24x16x4
23x27x7
7x27x22
24x16x8
20x11x25
30x28x11
21x6x24
15x2x9
16x30x24
21x27x9
7x19x8
24x13x28
12x26x28
16x21x11
25x5x13
23x3x17
23x1x17
4x17x18
17x13x18
25x12x19
17x4x19
4x21x26
6x28x1
23x22x15
6x23x12
21x17x9
30x4x23
2x19x21
28x24x7
19x24x14
13x20x26
19x24x29
8x26x3
16x12x14
17x4x21
8x4x20
13x27x17
9x21x1
29x25x6
7x9x26
13x25x5
6x9x21
12x10x11
30x28x21
15x6x2
8x18x19
26x20x24
26x17x14
27x8x1
19x19x18
25x24x27
14x29x15
22x26x1
14x17x9
2x6x23
29x7x5
14x16x19
14x21x18
10x15x23
21x29x14
20x29x30
23x11x5" "\n") sum (paper-area s))
#+END_SRC

#+RESULTS:
: 1598415

#+BEGIN_SRC emacs-lisp
(defun ribbon-length (s)
  "s is LxWxH"
  (destructuring-bind (L W H)
      (sort (mapcar 'string-to-int (split-string s "x")) '<)
    (+ (* 2 L) (* 2 W) (* L W H))))


(loop for s in (split-string
			  "4x23x21
22x29x19
11x4x11
8x10x5
24x18x16
11x25x22
2x13x20
24x15x14
14x22x2
30x7x3
30x22x25
29x9x9
29x29x26
14x3x16
1x10x26
29x2x30
30x10x25
10x26x20
1x2x18
25x18x5
21x3x24
2x5x7
22x11x21
11x8x8
16x18x2
13x3x8
1x16x19
19x16x12
21x15x1
29x9x4
27x10x8
2x7x27
2x20x23
24x11x5
2x8x27
10x28x10
24x11x10
19x2x12
27x5x10
1x14x25
5x14x30
15x26x12
23x20x22
5x12x1
9x26x9
23x25x5
28x16x19
17x23x17
2x27x20
18x27x13
16x7x18
22x7x29
17x28x6
9x22x17
10x5x6
14x2x12
25x5x6
26x9x10
19x21x6
19x4x27
23x16x14
21x17x29
24x18x10
7x19x6
14x15x10
9x10x19
20x18x4
11x14x8
30x15x9
25x12x24
3x12x5
12x21x28
8x23x10
18x26x8
17x1x8
2x29x15
3x13x28
23x20x11
27x25x6
19x21x3
30x22x27
28x24x4
26x18x21
11x7x16
22x27x6
27x5x26
4x10x4
4x2x27
2x3x26
26x29x19
30x26x24
8x25x12
16x17x5
13x2x3
1x30x22
20x9x1
24x26x19
26x18x1
18x29x24
1x6x9
20x27x2
3x22x21
4x16x8
29x18x16
7x16x23
13x8x14
19x25x10
23x29x6
23x21x1
22x26x10
14x4x2
18x29x17
9x4x18
7x22x9
19x5x26
27x29x19
7x13x14
19x10x1
6x22x3
12x21x5
24x20x12
28x2x11
16x18x23
2x13x25
11x7x17
27x21x4
2x10x25
22x16x17
23x22x15
17x13x13
23x24x26
27x18x24
24x7x28
30x12x15
14x28x19
2x15x29
12x13x5
17x22x21
27x10x27
17x6x25
22x2x1
1x10x9
9x7x2
30x28x3
28x11x10
8x23x15
23x4x20
12x5x4
13x17x14
28x11x2
21x11x29
10x23x22
27x23x14
7x15x23
20x2x13
8x21x4
10x20x11
23x28x11
21x22x25
23x11x17
2x29x10
28x16x5
30x26x10
17x24x16
26x27x25
14x13x25
22x27x5
24x15x12
5x21x25
4x27x1
25x4x10
15x13x1
21x23x7
8x3x4
10x5x7
9x13x30
2x2x30
26x4x29
5x14x14
2x27x9
22x16x1
4x23x5
13x7x26
2x12x10
12x7x22
26x30x26
28x16x28
15x19x11
4x18x1
20x14x24
6x10x22
9x20x3
14x9x27
26x17x9
10x30x28
6x3x29
4x16x28
8x24x11
23x10x1
11x7x7
29x6x15
13x25x12
29x14x3
26x22x21
8x3x11
27x13x25
27x6x2
8x11x7
25x12x9
24x30x12
13x1x30
25x23x16
9x13x29
29x26x16
11x15x9
11x23x6
15x27x28
27x24x21
6x24x1
25x25x5
11x1x26
21x4x24
10x5x12
4x30x13
24x22x5
26x7x21
23x3x17
22x18x2
25x1x14
23x25x30
8x7x7
30x19x8
17x6x15
2x11x20
8x3x22
23x14x26
8x22x25
27x1x2
10x26x2
28x30x7
5x30x7
27x16x30
28x29x1
8x25x18
20x12x29
9x19x9
7x25x15
25x18x18
11x8x2
4x20x6
18x5x20
2x3x29
25x26x22
18x25x26
9x12x16
18x7x27
17x20x9
6x29x26
17x7x19
21x7x5
29x15x12
22x4x1
11x12x11
26x30x4
12x24x13
13x8x3
26x25x3
21x26x10
14x9x26
20x1x7
11x12x3
12x11x4
11x15x30
17x6x25
20x22x3
1x16x17
11x5x20
12x12x7
2x14x10
14x27x3
14x16x18
21x28x24
14x20x1
29x14x1
10x10x9
25x23x4
17x15x14
9x20x26
16x2x17
13x28x25
16x1x11
19x16x8
20x21x2
27x9x22
24x18x3
23x30x6
4x18x3
30x15x8
27x20x19
28x29x26
2x21x18
1x23x30
1x9x12
4x11x30
1x28x4
17x10x10
12x14x6
8x9x24
8x3x3
29x8x20
26x29x2
29x25x25
11x17x23
6x30x21
13x18x29
2x10x8
29x29x27
27x15x15
16x17x30
3x3x22
21x12x6
22x1x5
30x8x20
6x28x13
11x2x23
14x18x27
6x26x13
10x24x24
4x24x6
20x8x3
23x11x5
29x5x24
14x15x22
21x17x13
10x10x8
1x11x23
21x19x24
19x9x13
21x26x28
25x11x28
2x17x1
18x9x8
5x21x6
12x5x2
23x8x15
30x16x24
7x9x27
16x30x7
2x21x28
5x10x6
8x7x1
28x13x5
11x5x14
26x22x29
23x15x13
14x2x16
22x21x9
4x20x3
18x17x19
12x7x9
6x12x25
3x30x27
8x19x22
1x9x27
23x20x12
14x7x29
9x12x12
30x2x6
15x7x16
19x13x18
11x8x13
16x5x3
19x26x24
26x8x21
21x20x7
15x1x25
29x15x21
22x17x7
16x17x10
6x12x24
8x13x27
30x25x14
25x7x10
15x2x2
18x15x19
18x13x24
19x30x1
17x1x3
26x21x15
10x10x18
9x16x6
29x7x30
11x10x30
6x11x2
7x29x23
13x2x30
25x27x13
5x15x21
4x8x30
15x27x11
27x1x6
2x24x11
16x20x19
25x28x20
6x8x4
27x16x11
1x5x27
12x19x26
18x24x14
4x25x17
24x24x26
28x3x18
8x20x28
22x7x21
24x5x28
23x30x29
25x16x27
28x10x30
9x2x4
30x2x23
21x9x23
27x4x26
2x23x16
24x26x30
26x1x30
10x4x28
11x29x12
28x13x30
24x10x28
8x12x12
19x27x11
11x28x7
14x6x3
6x27x5
6x17x14
24x24x17
18x23x14
17x5x7
11x4x23
5x1x17
26x15x24
3x9x24
5x3x15
5x20x19
5x21x2
13x5x30
19x6x24
19x17x6
23x7x13
28x23x13
9x1x6
15x12x16
21x19x9
25x5x5
9x7x9
6x5x8
3x11x18
23x25x11
25x4x6
4x27x1
4x3x3
30x11x5
9x17x12
15x6x24
10x22x15
29x27x9
20x21x11
18x10x5
11x2x2
9x8x8
1x26x21
11x11x16
2x18x30
29x27x24
27x8x18
19x3x17
30x21x26
25x13x25
20x22x1
10x1x12
11x17x15
29x11x30
17x30x27
21x22x17
13x6x22
22x16x12
27x18x19
4x13x6
27x29x10
3x23x10
26x16x24
18x26x20
11x28x16
21x6x15
9x26x17
8x15x8
3x7x10
2x28x8
1x2x24
7x8x9
19x4x22
11x20x9
12x22x16
26x8x19
13x28x24
4x10x16
12x8x10
14x24x24
19x19x28
29x1x15
10x5x14
20x19x23
10x7x12
1x7x13
5x12x13
25x21x8
22x28x8
7x9x4
3x20x15
15x27x19
18x24x12
16x10x16
22x19x8
15x4x3
9x30x25
1x1x6
24x4x25
13x18x29
10x2x8
21x1x17
29x14x22
17x29x11
10x27x16
25x16x15
14x2x17
12x27x3
14x17x25
24x4x1
18x28x18
9x14x26
28x24x17
1x26x12
2x18x20
12x19x22
19x25x20
5x17x27
17x29x16
29x19x11
16x2x4
23x24x1
19x18x3
28x14x6
18x5x23
9x24x12
15x4x6
15x7x24
22x15x8
22x1x22
6x4x22
26x1x30
8x21x27
7x1x11
9x8x18
20x27x12
26x23x20
26x22x30
24x3x16
8x24x28
13x28x5
4x29x23
22x5x8
20x22x3
9x9x17
28x3x30
10x13x10
10x25x13
9x20x3
1x21x25
24x21x15
21x5x14
13x8x20
29x17x3
5x17x28
16x12x7
23x1x24
4x24x29
23x25x14
8x27x2
23x11x13
13x4x5
24x1x26
21x1x23
10x12x12
21x29x25
27x25x30
24x23x4
1x30x23
29x28x14
4x11x30
9x25x10
17x11x6
14x29x30
23x5x5
25x18x21
8x7x1
27x11x3
5x10x8
11x1x11
16x17x26
15x22x19
16x9x6
18x13x27
26x4x22
1x20x21
6x14x29
11x7x6
1x23x7
12x19x13
18x21x25
15x17x20
23x8x9
15x9x26
9x12x9
12x13x14
27x26x7
11x19x22
16x12x21
10x30x28
21x2x7
12x9x18
7x17x14
13x17x17
3x21x10
30x9x15
2x8x15
15x12x10
23x26x9
29x30x10
30x22x17
17x26x30
27x26x20
17x28x17
30x12x16
7x23x15
30x15x19
13x19x10
22x10x4
17x23x10
2x28x18
27x21x28
24x26x5
6x23x25
17x4x16
14x1x13
23x21x11
14x15x30
26x13x10
30x19x25
26x6x26
9x16x29
15x2x24
13x3x20
23x12x30
22x23x23
8x21x2
18x28x5
21x27x14
29x28x23
12x30x28
17x16x3
5x19x11
28x22x22
1x4x28
10x10x14
18x15x7
18x11x1
12x7x16
10x22x24
27x25x6
19x29x25
10x1x26
26x27x30
4x23x19
24x19x4
21x11x14
4x13x27
9x1x11
16x20x8
4x3x11
1x16x12
14x6x30
8x1x10
11x18x7
29x28x30
4x21x8
3x21x4
6x1x5
26x18x3
28x27x27
17x3x12
6x1x22
23x12x28
12x13x2
11x2x13
7x1x28
27x6x25
14x14x3
14x11x20
2x27x7
22x24x23
7x15x20
30x6x17
20x23x25
18x16x27
2x9x6
9x18x19
20x11x22
11x16x19
14x29x23
14x9x20
8x10x12
18x17x6
28x7x16
12x19x28
5x3x16
1x25x10
4x14x10
9x6x3
15x27x28
13x26x14
21x8x25
29x10x20
14x26x30
25x13x28
1x15x23
6x20x21
18x2x1
22x25x16
23x25x17
2x14x21
14x25x16
12x17x6
19x29x15
25x9x6
19x17x13
24x22x5
19x4x13
10x18x6
6x25x6
23x24x20
8x22x13
25x10x29
5x12x25
20x5x11
7x16x29
29x24x22
28x20x1
10x27x10
6x9x27
26x15x30
26x3x19
20x11x3
26x1x29
6x23x4
6x13x21
9x23x25
15x1x10
29x12x13
7x8x24
29x30x27
3x29x19
14x16x17
4x8x27
26x17x8
10x27x17
11x28x17
17x16x27
1x8x22
6x30x16
7x30x22
20x12x3
18x10x2
20x21x26
11x1x17
9x15x15
19x14x30
24x22x20
11x26x23
14x3x23
1x28x29
29x20x4
1x4x20
12x26x8
14x11x14
14x19x13
15x13x24
16x7x26
11x20x11
5x24x26
24x25x7
21x3x14
24x29x20
7x12x1
16x17x4
29x16x21
28x8x17
11x30x25
1x26x23
25x19x28
30x24x5
26x29x15
4x25x23
14x25x19
29x10x7
29x29x28
19x13x24
21x28x5
8x15x24
1x10x12
2x26x6
14x14x4
10x16x27
9x17x25
25x8x7
1x9x28
10x8x17
4x12x1
17x26x29
23x12x26
2x21x22
18x23x13
1x14x5
25x27x26
4x30x30
5x13x2
17x9x6
28x18x28
7x30x2
28x22x17
14x15x14
10x14x19
6x15x22
27x4x17
28x21x6
19x29x26
6x17x17
20x13x16
25x4x1
2x9x5
30x3x1
24x21x2
14x19x12
22x5x23
14x4x21
10x2x17
3x14x10
17x5x3
22x17x13
5x19x3
29x22x6
12x28x3
9x21x25
10x2x14
13x26x7
18x23x2
9x14x17
21x3x13
13x23x9
1x20x4
11x4x1
19x5x30
9x9x29
26x29x14
1x4x10
7x27x30
8x3x23
1x27x27
7x27x27
1x26x16
29x16x14
18x6x12
24x24x24
26x2x19
15x17x4
11x7x14
14x19x10
9x10x1
14x17x9
20x19x13
25x20x8
24x20x21
26x30x2
24x2x10
28x4x13
27x17x11
15x3x8
11x29x10
26x15x16
4x28x22
7x5x22
10x28x9
6x28x13
10x5x6
20x12x6
25x30x30
17x16x14
14x20x3
16x10x8
9x28x14
16x12x12
11x13x25
21x16x28
10x3x18
5x9x20
17x23x5
3x13x16
29x30x17
2x2x8
15x8x30
20x1x16
23x10x29
4x5x4
6x18x12
26x10x22
21x10x17
26x12x29
7x20x21
18x9x15
10x23x20
20x1x27
10x10x3
25x12x23
30x11x15
16x22x3
22x10x11
15x10x20
2x20x17
20x20x1
24x16x4
23x27x7
7x27x22
24x16x8
20x11x25
30x28x11
21x6x24
15x2x9
16x30x24
21x27x9
7x19x8
24x13x28
12x26x28
16x21x11
25x5x13
23x3x17
23x1x17
4x17x18
17x13x18
25x12x19
17x4x19
4x21x26
6x28x1
23x22x15
6x23x12
21x17x9
30x4x23
2x19x21
28x24x7
19x24x14
13x20x26
19x24x29
8x26x3
16x12x14
17x4x21
8x4x20
13x27x17
9x21x1
29x25x6
7x9x26
13x25x5
6x9x21
12x10x11
30x28x21
15x6x2
8x18x19
26x20x24
26x17x14
27x8x1
19x19x18
25x24x27
14x29x15
22x26x1
14x17x9
2x6x23
29x7x5
14x16x19
14x21x18
10x15x23
21x29x14
20x29x30
23x11x5" "\n") sum (ribbon-length s))

#+END_SRC

#+RESULTS:
: 3812909

** day 3
We start at 0,0
^ adds one to the first
v substracts one from the fist
> adds one to second
< subtracts one from second

Keep list of (i . j)
#+BEGIN_SRC emacs-lisp
(let ((houses '(((0 . 0) . 1))))
(assoc '(0 . 0) houses))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(let ((houses '(((0 . 0) . 1)))
      (i 0)
      (j 0)
      house
      cont)
  (loop for char across "v>v<vvv<<vv^v<v>vv>v<<<^^^^^<<^<vv>^>v^>^>^>^>^><vvvv<^>^<<^><<<^vvvv>^>^><^v^><^<>^^>^vvv^<vv>>^>^^<>><>^>vvv>>^vv>^<><>^<v^>^>^><vv^vv^>><<^><<v>><>^<^>>vvv>v>>>v<<^<><^<v<>v>^^v^^^<^v^^>>><^>^>v<>^<>>^>^^v^><v<v>>><>v<v^v>^v<>>^><v>^<>v^>^<>^v^^^v^^>>vv<<^^><^<vvv>^>^^<^>>^^^^^v^<v>vv<>>v^v<^v^^<><^<^vv^><>><><>v>vvv^vv^^<<><<vvv><<^v^><v<>vvv^<^>vvvv^>^>>^v^<v^vv<^^v<>v>vv^<>><v<<<^v^<<><v<^<^<><^^^>^>>v>^>v^<>v><^<^<v^>^^vv<^^<>v^v^vv<>>>>v^v<>><^^v>vv^^>v^v>v<vv>>v>><v^v^v>vv>^^>^v><<vv^v^^vv<^v><^<<v<v^>vv^^^<v^>v>v^^^>><^^<v^<^>>v><vv<v^^>^^v>>v^^^<^^v>^v>><^<^<>>v<<^^vv>^^^v<^<^<v<v^^vv>^vv^>>v^><v>><<<>^vv^<^<>v^^<<<v<^>^><><v^^>>^^^<^vv<^^^>><^^v>^^v^<v^v^>^^<v>^<^v<^<<<<^<v^>v^<^^<>^^>^><<>>^v><>><^<v><^^^>>vv>^><vv>^^^^^v^vvv><><^<^>v>v^v^>^><><^<^><>v<<vv<^>><>^v^^v>^<<<>^v^>^<<v^vv<>v^<v^^vv><<v^<>>>^<v>vv>v>>>^<^>><vv<>>>>v<v>>>^v>v><>>vvv<^^><<^>^>v<^vvvv<v><vv<><^^^v^^^>v^v<>v<^^v>>><>v<v^>>v><v^>>^^<v<<<^<v<><^^v><<v^><<<<^vv<^<>^><vv<<<<^>>>^v>^v>vv>^v<>v>v<v><^>>v>>^>^><^<v^v^>^v<><><^^>^<vvvv^^<>^^^>vv^v^v>^v^^v^^v><v^<^<>><^<v>v>>vv<<v>>vvvv<vv><>>^v^>^>>v^v^<<<vv<><v<<>>>^v<<v>^^vv^><>v>^>v><<<<<<<^>^^v^<<^^>>vvv^<><>><>^^v<<vv><^^v<^^><vv>v^>>>v^v><v^v<^>v^><>v<<>v>^^v><<<<><^v^v>>^<>^<<>^<v<<>>v<<>><^<<<<^v>^<^v>v>vv<v<v<<>^>v<^<<>v^<vvvv^>v>><<v><v<>v>v>>v^vvv^^>>>v^<^<<^^<<<><v>v^<<v<<<>v<^^<><v<v^^<v>^>v>>v<>^>^^>>^v<<>v^^^>>>^vv<^v<v>^>v>^><>v^^<>^^v^^vv^<^>^<<>><<^>^v>>><<<vvvv><<><v<^v^v<vvv^<><<^<vv><v^v^v^>v>v^<vvv^><^><^<vv><>>v^>^^^<>><v^<^^^<>v<<v<^v>>>^>>v^><<>vvv><^>>v><v><>v>>^>v><<><<>^<>^^^vv><v^>v^^>>^>^<^v<v<^^<^vvvv>v<v>^>v^>^><^<vvvv><^><><<v<>v<v^><^<v^>^v^^<<<<^><^^<^><>>^v<<^<<^vv>v>>v<^<^vv>><v<vv>v<v<v>^v<>^>v<>^v<<<v>>^^v>>><vvv>v^>^v^v>^^^v<vvvv>><^>vvv^<vv^^vv><<<>v<>v>^<vvv^<^<v<v<^vv^^>>vv^<^^v^><^^^^^v<^<v<^>>>vv^v^>^<v>^<><v^<^v>>><^v^<<v<<v<>v>^v<v^v>>^^v<<v<v<<>>>vv>>^v>>^<<<<^><<<><^^>>v<>^vvvv>v^^^>^^^>^<vvvv><^^v<v<>v<^v^v<<v^^^v^<v<^v>v^^<>^>^<^v>vv<v^vv<^<<>v><<^><><^^v<<><^^><>^v>^<><<^<^^<<>vv<>^^<<^>><<<>>vvv>^>v^^v^><<^>v>^>^<^<<>v<^>vv^v^v<>vv<<v>vv<vv><^>v^<>^vv^v^<v<^>>>>v^v><^<><<>vv^<vvv^>>vvv^>v>>><^^vv<vvvv>v<^<^>>^^>^^vv>>><^v<>^v^<<>v^^^<v>^>>^<^<v>>^v<^^^<v>^v>^>>v<vv>>^<v^<<>>^>>><v>v^<<^<v>>^<<^^<>v<^v<^<>v^v>^^v<vvvv>^vv>vvv>v^<^>><v^^vv<<<^>vvvv<>>^^<>v^<><>v<^<>v<>^>v<>vv<v^v>>v<v<^<v^^v^vv^vvv><^^>v>><>>^<^^<>>^>^<v^>>vvv^v><v>>^>^>v><><<><vv^v>v<>^v<^vv^^^<>^^<<^^^v<>><v<^<^<^<^^><v^v<^>v^>vvvv>^^v^>^<v<^^^>>^<<vv^<><><^^^^<<>^<><v>vv^<><^>^^<>v^<>>>v><>vvvvv>v>v^^>^<<vvvv<>vv>>v<<^<>^^^v^<><>>^<<<v<v<>>>><><v>v<v<>>^>^^^^vv^^<<><^^<<vv<^<>v>vv<v<><<<^<<v<<<<>v<>>^<^>^>><v>v>><^^<>><<<><<><v^^v<<><^<^v<v^><^^v<<>><<<<^>v^<v>><v^><v<vvv>v^v^<v><<>>v<><<v>^<>><>>^><>v^v>v<<>v<>v^^><<>>>v<<>>>>^>v>><v<<>>>vv>v>^<^^^<>v<v>^<^^v^vvv^>vv>^<v><vvvv>^<<>vvv<<<vv>^^<^>^>>v>v<<<<<>^^vv^>>v>^<^<v^v^>^v>>v>^v<><>^<^>v>v<<<^^^v>^<<<>vvv^v^^>^>>^>v>v<>^^><>>v>^>v<<<^^^v^<v^vv>><><^<^<><vvv<v^>>^v>vv<^v<<^vv>v^<<v>v>v>^v^>^v<<^v^vv>v<v>^<<><v^>>v<>><v<<<^v<<>vvv^<vv<vvv<<>^vv^^v><^>v^vv<<v^<<^^^<^<>^^<<>v<><<v>^><>^<><<v<v^^>vv<>^<v<^<vvv>vv>v><^^v<>><^v^v><><>><v<v>vv<>>><v^^v<>><<^>>><^^^vvv<<<vv<<^v<<<>><<vv>>>>v<<<<<vv><><v>v^^<<^vv^<vv<>>vv>^<>^v^^<>^^^vv>v^^<v<><v>v<v>>^v<v<>>^<v^^><>v^^^>v^^v<vv><^>v^v^<>v>v<v<^^>>v<^^vv^v<^^^^vv<<><<^>>^^<<v^^<<^>v^>>^^^><^^>^v^v>^<<v<vv<<<v<^^^>^>>^v<>^<^>v>^>^v^<^^^<^vv<v><^^>>v<v>^>^v^>>>>^v>^^<<^<v^v<^<<v<<^><^^<v^<><v>v^<<v^^<><<>>><vv<<><>^<>>>v<<v^^^v^^<<<vv<<^<^<^vv^<><><<^^<^^>v^>^<v<>>v^v<><<v>^^v>^<^<vvv<v>v^v>>>^^<^<v^>^vv<<<v<<>^><><^<>v>>>v<v^<>v>><^^^v^^^v<^^<vv^^^>v>v<>>^^<><>v>^<v<>^>>>><>v>^v>^vv^v<vv<<^^>><v<>^>^^<v<^>^<vvv>><>^<<>>><<<><>^^<<<v<>v^>v>v<v>^^^>^>^v<<>v>vv>><<<v>^^<v><vv<<v^^>^>>^><^>v<^<^v>><^^>v<vv^^><><>^><<><>v^>v<><^^>><>^<^^v<^<<v>><v><<<^^<<v<^vv^v<>><>>>^>v<vvv^>^<><v^><^<<^vv<^v^v^v<>v^^v>v^<^>^vv^>>><<>v^vv^<>^v^><<v^v<v>v^<><>>v^v^><>v^vvv^^^<<^<<v<<v<^vv^>>v^v>^^<v<>><>v>>v^<>^>v>^>><<>v^v><^v>v>>><v<v><^<^^>vv<v><^>^<^>^^v><><v<^^v<<><^<<v^<v<<><^^vvv^v>^>^<>>vv>v^^v^^vv<^^>><v^^vv><^v>v^<<v<^v>vvv<>>^v><<>^v<<<>^><^vv><<^^<v^>v<<v>^vv<>^v>>>><<<<^^<^v>^<^^<^<^^>>^^v>^^^^v^^^<<>^^vv<<v^^><v>><^<<><>^>v<>>v^^^>^v^^v^<v^v>v>>>>>^v>^>^^<vvv^^<v^<<<v<<>v>><^^^v<<^^<v>>^<^<^><^<<v^v><<vv<^<>>v>v>^v<><<v>^>vv^v<v>v><^<v>><>^<vv<v^^^^v<^^>><<^^>v>v>^^^<>v>^v^^>vv^vv<^^>><>^>^<>v>><>^v<<v>v>^><^^^v^<vv><<^v^>v^>vv>v^<>v><vv><^v>v<><v^v^v<^v<>^v<v^<<><<v>>^v><v>^^<>vvv^>^<<v^>><^>><^<>^v<v<v<^vvv<><<^v^<v>><<<v>^<^<v>v>^vv^v>v<^^vv<<vvv^<v>><>vv^>v<<>v<vvvv>>v>^^>>><<<^>^vv>><v>^^^>v<^vv<>v<<<v<<<<v>>>>^<^^^^>v<^^<><v>v>v<v^>vv^>v>v<^>^v^<>v>>vvv>^^><^vvv>><>>>^<<^<v<>>>v^^><v<v>>^><>v<^^v^<<v><>^<>>><^v^v>>>^vvvv^<><<<v<^>>v>^v^<v<v<<^<<v^vv^v>v<v<>>v<v^<<<><v^>><^<<^>^^><v>v<^v^<^>v>^<<v>v^<>v^<>vv^<>^>^>v^>^vv<>^^<<>>v<>^v<><v^><><<<vv>v>v^>vv^><<<<v>^v<><>^^<vv>v^^v^^^<v<^^><v^v<>><v<vv>^<>>><vv<^v<<>>^><>>v<v^v^>>>v<<>v<<<<<<<^v<<^^^v<^v<>v^^<<<^<>>v^vv<v>^<^^<^^<<^>vv><^<^^v<<<^><^v<^><>v<vv^>^v^^>>><<vv^^v><^<<^<>>^>>^<<<<v^vv<>>>v>^v>><>v>>v>><>v>><^^><v>^^vv<^^<^>vv><<^>><<><v>^vvv><^v^>vvv^>>^<><^>^<<>>v^v>v<<>^>>^>v<^^<^<<>^^v<vvvvv^^^<^<>^^v>v<>^<^^<<v>v^^vvv^^v>^vv<v^>^<>v<^v^>^<v><v<<<^v<v<v^^<vvv>vv<<vv>v^<<v<^<vv><^>^><^^<^^<<v^^<v^v<v^^^^>^>vv^<>^<>^>^^<^v><<<^>vv^vv>v^v<>^^v^<^^^vvv^><v^<v^^<v<>v^<><>v>vv<^v^>>^v<^^vv>vv>^>><<<<v^^<^><>^><>>v<>>v>^v<^vv>^^>^<^<<v^>>v^v<^^v<vv<^<><^^>^^<>^^^<vv<v<<^^>^>^vv<^>><^<vvv^<>>vv^><v>v^>^vv>^>v^^<>>^v<>>v<^>^v>vv^<vv<^^>>^<v>>>>vvv>vv>^><^v<<<>^^v>v^v<^^^v^^>^><<^^>^<v>><^^^^^<v<vv<v<^<>^^<^v<^>>vv>>^v^vv<>><>^>>>^<v>^^^^><^<<<v<>^v<><vvv^<^^>vv^>>v<vvvv><v^v><^vv<^v<><vvv<vv>v<>^v^<<>>>>v^^>^vv<<vvv<^^><v><><<>v^v<^<^>><vv>^^><^>^><<><v<^v^><^<><>vv>>>>^><<^^^<^v^>^>^^>^<^><v><^^<^^<>><><v>><<<>^>^^v<>^<<<v>>vv>^>>^>^<>>vv<^^vv<>v<>^^>^v<v^^^^v<>^<v>v^v>^^^<v>v<<<^vv^><>^<v>>^^vv>v^<<^><>>vv^^^^^>v>>v<<<>^<vvv<<><><^v<^v<^>^<>^vvv>^>v><<<vv<>v>vv<v<<v>^<^^>v^v>^<^v^<<vvv^^<>^v<<^>^<><>^^<>>^^<^v^<^<v<><<^><v<>v^^>v^v^^^<^v<<^v>^>>^^^^^><<<vv^>>v^><v^^vv><>v^^<^v<^<v^^><<v>v^^^><^^^><<<<<>^<<^<>>v<<v^v^^v<<>^<vv>>><^^^<>>>>vvv>v<>>>v^v^v<^<<^>^<<>v>>^>^^><^><<^v^^<^<>v^v>vv<>>>>>>v<<><v^<v<>>^^>v<<<>^<<v><^><<^v>vv>>>><><>v^<^v><v^<<<<^v><^>v>>^^^v<^>>^>>v<<^<<>vvv>>^v<>>^v><<<^v^v<><v>^vvv<v<v>^^^<><vv^<<>vvv<v<^^v^^><v<^v<^v^<v<^>^^^>>v>^<v^>>^<><<><vv<>vv>^v^>>^<<v<^^v>v<v<vvv>><><<><vvvvv<^v<^>^^><>^<<>^v<<>>v^vv<<>^^v^v^v><^>v>v<^<<^<^>vv>^v<<^>^>>v^<<v^>v^^v^^<v^v>>><vv><<<>^v>><><v<vv<^>v<>><^v>^^v<<<<^v^vv<<<<><><^<^<^v><<^^v^<<<<<^^><^^>vv<v<^<v>v<^><><v<>vvv^<vv>v^>^>^^^v<<^<^^>vv<v^v^v>^vv^><^v^<<>v<^^>^vv<<>^<<><^>v^<<^<>v><><>v<<^^><^^^v>>v>^vv<v^>>^v^^<><<<<<^>^v^<^<^^>^vv<^>v^^v^<>v<><v>v^v>vvv><><<><>vv<vvv^v>^^>^^^<><^>^^^>v<vvvv<>vv<v<v^^>><>v<>>v^>v^^vv^>v>>><v<<<<v<^v>><^^>^v^v<v^v^^^vvv>>>vv<^>><<<^>><^<^>^<^>^>>v^<^<>^<^^<><vvv^^<>^<>>><<v>^<^<v<<><^<<^><^^>vv<>^^><v^v<vv<^<vvv<<^>v^>>v>>>v<<^vv^<><>>>^^<^v^>>^>>><<v<<^<vv><^<>^>>^v>>><^^^<<<vv<<v<v>^vv><><<>^^^<>^<vv^<^<<v>^^><vv>><>>>^>vv>^<^<>>^<^^><v>v^><v>vv><><>>><><<^^v<<^v<v>vv<><><<^v>^v<>^<^^^v^>^<^><^v>v>^v<>><^^v^^^^^<><v<>>vvv<v^^<>v>>>>^<<><^v>vv>>^^><<><><^^^<^<^<<^v>^^^><v>>>>><<v<v>v^^^<>>v<vv<^<>v^^^v<><^>v>><<><>v<^><<>>><>v>^<>>^>v^v<<<<>^<v^vv^>vv<<><v^vv<v<v<<>>>>>vv<><>^<^v>vv^<<v<^v^^<<^<<^^v^>>><<>^<>><^>>><v<>><<>^^>><<<^^^^^v>>^<<>>vvvv<^v<v^^<^>^vv<vv<>v<<<^><>>>>vv^<^v>v<^<>^v>>^<^^v^>>><>^^<^v>>v<<>vv<vvvv<>vv>^><>v^<>^<<^vv<v^^v<vvvv><^>>^v^>^^<<<^>>^^>^<^^<^<<<v^<^^v<<vv^<<^^^vv><v<vv^>v^^v<v>^^<^v<^>>><<>vv<<^><<v^v^^^v<vv>^>vv<^>>^<v<>vv>>>^>>><<v<^<>^<<<>>^<<>><^<<^^^>>v^^>v<<<>v>v>v<v<^>^<>>>^vvv><<^^<<><v<><^<v<vvv>v>>>>vv^^v<v<^<^><v>^v<<v<vv>>v>v<<<<><<>vv<><^^^<>>v<v<vvv><v^<vv^>>><v^^<>>>^^<><^<^v^><vv>>^^v>^<<v^>v>^^>^v^<v<^<v^v><>>v^^<^v^^<<>^^>v^^>><<<<^<^^v>^^v>v<<vv^^vv>^>v^<v<v><>vv>>^<v^v^<v<^>^v>v^^>vvvvv<v><<>vv>vvvvvv>>v>>^^^<v>vv^^><<v>>v^^^^v>vv>v<^v>>>>^>^><v^>^<v<vv>v>^>><v>><<>>^vv<vv^^<^^>>>>><><<^<v<><<v>^><^vv^v>>>>>v>^>^<vv>^v^>v<^v^<^<<vv<<>v<>>^vv<<>^v^v>><><<>>v^^<<>^^<v><>v<<^^<^^>^^>^<^><>>v<>>^^<^>><<<v<>>>^v^>v>v<<^^<<^>v<v^>>v^^v^^<<>^v>v><v^>v<^^>^<vv><vv^<>v<><^<<<vv<<v>v<^<<<<^^>v^v^^><<><^^^<v>v^^>>>vvv><>vv<>>^^v^v<<^>v^^v^>vv>^<<v<^<v^>^^<<v<^^>^v^^<^^v<<>>vv<^>>^><><>v>>v<>^<v^^><<>>>"
	do
	;; get next coordinate
	(cond
	 ((string= "^" (char-to-string char))
	  (setq i (+ i 1)))
	 ((string= "v" (char-to-string char))
	  (setq i (- i 1)))
	 ((string= ">" (char-to-string char))
	  (setq j (+ j 1)))
	 ((string= "<" (char-to-string char))
	  (setq j (- j 1)))
	 (t (message-box "%S" (char-to-string char)) nil))
	(setq house (cons i j))
	(if (assoc house houses)
	      (setf (cdr (assoc house houses))
		    (+ (cdr (assoc house houses)) 1))
	  (add-to-list 'houses (cons (cons i j) 1))))
  ;; now count houses
  (length houses))

#+END_SRC

#+RESULTS:
: 2572

*** part 2

#+BEGIN_SRC emacs-lisp
(let ((houses '(((0 . 0) . 2)))
      (i 0)
      (j 0)
      (k 0)
      (l 0)
      house
      cont)
  (loop for I from 0 for char across "v>v<vvv<<vv^v<v>vv>v<<<^^^^^<<^<vv>^>v^>^>^>^>^><vvvv<^>^<<^><<<^vvvv>^>^><^v^><^<>^^>^vvv^<vv>>^>^^<>><>^>vvv>>^vv>^<><>^<v^>^>^><vv^vv^>><<^><<v>><>^<^>>vvv>v>>>v<<^<><^<v<>v>^^v^^^<^v^^>>><^>^>v<>^<>>^>^^v^><v<v>>><>v<v^v>^v<>>^><v>^<>v^>^<>^v^^^v^^>>vv<<^^><^<vvv>^>^^<^>>^^^^^v^<v>vv<>>v^v<^v^^<><^<^vv^><>><><>v>vvv^vv^^<<><<vvv><<^v^><v<>vvv^<^>vvvv^>^>>^v^<v^vv<^^v<>v>vv^<>><v<<<^v^<<><v<^<^<><^^^>^>>v>^>v^<>v><^<^<v^>^^vv<^^<>v^v^vv<>>>>v^v<>><^^v>vv^^>v^v>v<vv>>v>><v^v^v>vv>^^>^v><<vv^v^^vv<^v><^<<v<v^>vv^^^<v^>v>v^^^>><^^<v^<^>>v><vv<v^^>^^v>>v^^^<^^v>^v>><^<^<>>v<<^^vv>^^^v<^<^<v<v^^vv>^vv^>>v^><v>><<<>^vv^<^<>v^^<<<v<^>^><><v^^>>^^^<^vv<^^^>><^^v>^^v^<v^v^>^^<v>^<^v<^<<<<^<v^>v^<^^<>^^>^><<>>^v><>><^<v><^^^>>vv>^><vv>^^^^^v^vvv><><^<^>v>v^v^>^><><^<^><>v<<vv<^>><>^v^^v>^<<<>^v^>^<<v^vv<>v^<v^^vv><<v^<>>>^<v>vv>v>>>^<^>><vv<>>>>v<v>>>^v>v><>>vvv<^^><<^>^>v<^vvvv<v><vv<><^^^v^^^>v^v<>v<^^v>>><>v<v^>>v><v^>>^^<v<<<^<v<><^^v><<v^><<<<^vv<^<>^><vv<<<<^>>>^v>^v>vv>^v<>v>v<v><^>>v>>^>^><^<v^v^>^v<><><^^>^<vvvv^^<>^^^>vv^v^v>^v^^v^^v><v^<^<>><^<v>v>>vv<<v>>vvvv<vv><>>^v^>^>>v^v^<<<vv<><v<<>>>^v<<v>^^vv^><>v>^>v><<<<<<<^>^^v^<<^^>>vvv^<><>><>^^v<<vv><^^v<^^><vv>v^>>>v^v><v^v<^>v^><>v<<>v>^^v><<<<><^v^v>>^<>^<<>^<v<<>>v<<>><^<<<<^v>^<^v>v>vv<v<v<<>^>v<^<<>v^<vvvv^>v>><<v><v<>v>v>>v^vvv^^>>>v^<^<<^^<<<><v>v^<<v<<<>v<^^<><v<v^^<v>^>v>>v<>^>^^>>^v<<>v^^^>>>^vv<^v<v>^>v>^><>v^^<>^^v^^vv^<^>^<<>><<^>^v>>><<<vvvv><<><v<^v^v<vvv^<><<^<vv><v^v^v^>v>v^<vvv^><^><^<vv><>>v^>^^^<>><v^<^^^<>v<<v<^v>>>^>>v^><<>vvv><^>>v><v><>v>>^>v><<><<>^<>^^^vv><v^>v^^>>^>^<^v<v<^^<^vvvv>v<v>^>v^>^><^<vvvv><^><><<v<>v<v^><^<v^>^v^^<<<<^><^^<^><>>^v<<^<<^vv>v>>v<^<^vv>><v<vv>v<v<v>^v<>^>v<>^v<<<v>>^^v>>><vvv>v^>^v^v>^^^v<vvvv>><^>vvv^<vv^^vv><<<>v<>v>^<vvv^<^<v<v<^vv^^>>vv^<^^v^><^^^^^v<^<v<^>>>vv^v^>^<v>^<><v^<^v>>><^v^<<v<<v<>v>^v<v^v>>^^v<<v<v<<>>>vv>>^v>>^<<<<^><<<><^^>>v<>^vvvv>v^^^>^^^>^<vvvv><^^v<v<>v<^v^v<<v^^^v^<v<^v>v^^<>^>^<^v>vv<v^vv<^<<>v><<^><><^^v<<><^^><>^v>^<><<^<^^<<>vv<>^^<<^>><<<>>vvv>^>v^^v^><<^>v>^>^<^<<>v<^>vv^v^v<>vv<<v>vv<vv><^>v^<>^vv^v^<v<^>>>>v^v><^<><<>vv^<vvv^>>vvv^>v>>><^^vv<vvvv>v<^<^>>^^>^^vv>>><^v<>^v^<<>v^^^<v>^>>^<^<v>>^v<^^^<v>^v>^>>v<vv>>^<v^<<>>^>>><v>v^<<^<v>>^<<^^<>v<^v<^<>v^v>^^v<vvvv>^vv>vvv>v^<^>><v^^vv<<<^>vvvv<>>^^<>v^<><>v<^<>v<>^>v<>vv<v^v>>v<v<^<v^^v^vv^vvv><^^>v>><>>^<^^<>>^>^<v^>>vvv^v><v>>^>^>v><><<><vv^v>v<>^v<^vv^^^<>^^<<^^^v<>><v<^<^<^<^^><v^v<^>v^>vvvv>^^v^>^<v<^^^>>^<<vv^<><><^^^^<<>^<><v>vv^<><^>^^<>v^<>>>v><>vvvvv>v>v^^>^<<vvvv<>vv>>v<<^<>^^^v^<><>>^<<<v<v<>>>><><v>v<v<>>^>^^^^vv^^<<><^^<<vv<^<>v>vv<v<><<<^<<v<<<<>v<>>^<^>^>><v>v>><^^<>><<<><<><v^^v<<><^<^v<v^><^^v<<>><<<<^>v^<v>><v^><v<vvv>v^v^<v><<>>v<><<v>^<>><>>^><>v^v>v<<>v<>v^^><<>>>v<<>>>>^>v>><v<<>>>vv>v>^<^^^<>v<v>^<^^v^vvv^>vv>^<v><vvvv>^<<>vvv<<<vv>^^<^>^>>v>v<<<<<>^^vv^>>v>^<^<v^v^>^v>>v>^v<><>^<^>v>v<<<^^^v>^<<<>vvv^v^^>^>>^>v>v<>^^><>>v>^>v<<<^^^v^<v^vv>><><^<^<><vvv<v^>>^v>vv<^v<<^vv>v^<<v>v>v>^v^>^v<<^v^vv>v<v>^<<><v^>>v<>><v<<<^v<<>vvv^<vv<vvv<<>^vv^^v><^>v^vv<<v^<<^^^<^<>^^<<>v<><<v>^><>^<><<v<v^^>vv<>^<v<^<vvv>vv>v><^^v<>><^v^v><><>><v<v>vv<>>><v^^v<>><<^>>><^^^vvv<<<vv<<^v<<<>><<vv>>>>v<<<<<vv><><v>v^^<<^vv^<vv<>>vv>^<>^v^^<>^^^vv>v^^<v<><v>v<v>>^v<v<>>^<v^^><>v^^^>v^^v<vv><^>v^v^<>v>v<v<^^>>v<^^vv^v<^^^^vv<<><<^>>^^<<v^^<<^>v^>>^^^><^^>^v^v>^<<v<vv<<<v<^^^>^>>^v<>^<^>v>^>^v^<^^^<^vv<v><^^>>v<v>^>^v^>>>>^v>^^<<^<v^v<^<<v<<^><^^<v^<><v>v^<<v^^<><<>>><vv<<><>^<>>>v<<v^^^v^^<<<vv<<^<^<^vv^<><><<^^<^^>v^>^<v<>>v^v<><<v>^^v>^<^<vvv<v>v^v>>>^^<^<v^>^vv<<<v<<>^><><^<>v>>>v<v^<>v>><^^^v^^^v<^^<vv^^^>v>v<>>^^<><>v>^<v<>^>>>><>v>^v>^vv^v<vv<<^^>><v<>^>^^<v<^>^<vvv>><>^<<>>><<<><>^^<<<v<>v^>v>v<v>^^^>^>^v<<>v>vv>><<<v>^^<v><vv<<v^^>^>>^><^>v<^<^v>><^^>v<vv^^><><>^><<><>v^>v<><^^>><>^<^^v<^<<v>><v><<<^^<<v<^vv^v<>><>>>^>v<vvv^>^<><v^><^<<^vv<^v^v^v<>v^^v>v^<^>^vv^>>><<>v^vv^<>^v^><<v^v<v>v^<><>>v^v^><>v^vvv^^^<<^<<v<<v<^vv^>>v^v>^^<v<>><>v>>v^<>^>v>^>><<>v^v><^v>v>>><v<v><^<^^>vv<v><^>^<^>^^v><><v<^^v<<><^<<v^<v<<><^^vvv^v>^>^<>>vv>v^^v^^vv<^^>><v^^vv><^v>v^<<v<^v>vvv<>>^v><<>^v<<<>^><^vv><<^^<v^>v<<v>^vv<>^v>>>><<<<^^<^v>^<^^<^<^^>>^^v>^^^^v^^^<<>^^vv<<v^^><v>><^<<><>^>v<>>v^^^>^v^^v^<v^v>v>>>>>^v>^>^^<vvv^^<v^<<<v<<>v>><^^^v<<^^<v>>^<^<^><^<<v^v><<vv<^<>>v>v>^v<><<v>^>vv^v<v>v><^<v>><>^<vv<v^^^^v<^^>><<^^>v>v>^^^<>v>^v^^>vv^vv<^^>><>^>^<>v>><>^v<<v>v>^><^^^v^<vv><<^v^>v^>vv>v^<>v><vv><^v>v<><v^v^v<^v<>^v<v^<<><<v>>^v><v>^^<>vvv^>^<<v^>><^>><^<>^v<v<v<^vvv<><<^v^<v>><<<v>^<^<v>v>^vv^v>v<^^vv<<vvv^<v>><>vv^>v<<>v<vvvv>>v>^^>>><<<^>^vv>><v>^^^>v<^vv<>v<<<v<<<<v>>>>^<^^^^>v<^^<><v>v>v<v^>vv^>v>v<^>^v^<>v>>vvv>^^><^vvv>><>>>^<<^<v<>>>v^^><v<v>>^><>v<^^v^<<v><>^<>>><^v^v>>>^vvvv^<><<<v<^>>v>^v^<v<v<<^<<v^vv^v>v<v<>>v<v^<<<><v^>><^<<^>^^><v>v<^v^<^>v>^<<v>v^<>v^<>vv^<>^>^>v^>^vv<>^^<<>>v<>^v<><v^><><<<vv>v>v^>vv^><<<<v>^v<><>^^<vv>v^^v^^^<v<^^><v^v<>><v<vv>^<>>><vv<^v<<>>^><>>v<v^v^>>>v<<>v<<<<<<<^v<<^^^v<^v<>v^^<<<^<>>v^vv<v>^<^^<^^<<^>vv><^<^^v<<<^><^v<^><>v<vv^>^v^^>>><<vv^^v><^<<^<>>^>>^<<<<v^vv<>>>v>^v>><>v>>v>><>v>><^^><v>^^vv<^^<^>vv><<^>><<><v>^vvv><^v^>vvv^>>^<><^>^<<>>v^v>v<<>^>>^>v<^^<^<<>^^v<vvvvv^^^<^<>^^v>v<>^<^^<<v>v^^vvv^^v>^vv<v^>^<>v<^v^>^<v><v<<<^v<v<v^^<vvv>vv<<vv>v^<<v<^<vv><^>^><^^<^^<<v^^<v^v<v^^^^>^>vv^<>^<>^>^^<^v><<<^>vv^vv>v^v<>^^v^<^^^vvv^><v^<v^^<v<>v^<><>v>vv<^v^>>^v<^^vv>vv>^>><<<<v^^<^><>^><>>v<>>v>^v<^vv>^^>^<^<<v^>>v^v<^^v<vv<^<><^^>^^<>^^^<vv<v<<^^>^>^vv<^>><^<vvv^<>>vv^><v>v^>^vv>^>v^^<>>^v<>>v<^>^v>vv^<vv<^^>>^<v>>>>vvv>vv>^><^v<<<>^^v>v^v<^^^v^^>^><<^^>^<v>><^^^^^<v<vv<v<^<>^^<^v<^>>vv>>^v^vv<>><>^>>>^<v>^^^^><^<<<v<>^v<><vvv^<^^>vv^>>v<vvvv><v^v><^vv<^v<><vvv<vv>v<>^v^<<>>>>v^^>^vv<<vvv<^^><v><><<>v^v<^<^>><vv>^^><^>^><<><v<^v^><^<><>vv>>>>^><<^^^<^v^>^>^^>^<^><v><^^<^^<>><><v>><<<>^>^^v<>^<<<v>>vv>^>>^>^<>>vv<^^vv<>v<>^^>^v<v^^^^v<>^<v>v^v>^^^<v>v<<<^vv^><>^<v>>^^vv>v^<<^><>>vv^^^^^>v>>v<<<>^<vvv<<><><^v<^v<^>^<>^vvv>^>v><<<vv<>v>vv<v<<v>^<^^>v^v>^<^v^<<vvv^^<>^v<<^>^<><>^^<>>^^<^v^<^<v<><<^><v<>v^^>v^v^^^<^v<<^v>^>>^^^^^><<<vv^>>v^><v^^vv><>v^^<^v<^<v^^><<v>v^^^><^^^><<<<<>^<<^<>>v<<v^v^^v<<>^<vv>>><^^^<>>>>vvv>v<>>>v^v^v<^<<^>^<<>v>>^>^^><^><<^v^^<^<>v^v>vv<>>>>>>v<<><v^<v<>>^^>v<<<>^<<v><^><<^v>vv>>>><><>v^<^v><v^<<<<^v><^>v>>^^^v<^>>^>>v<<^<<>vvv>>^v<>>^v><<<^v^v<><v>^vvv<v<v>^^^<><vv^<<>vvv<v<^^v^^><v<^v<^v^<v<^>^^^>>v>^<v^>>^<><<><vv<>vv>^v^>>^<<v<^^v>v<v<vvv>><><<><vvvvv<^v<^>^^><>^<<>^v<<>>v^vv<<>^^v^v^v><^>v>v<^<<^<^>vv>^v<<^>^>>v^<<v^>v^^v^^<v^v>>><vv><<<>^v>><><v<vv<^>v<>><^v>^^v<<<<^v^vv<<<<><><^<^<^v><<^^v^<<<<<^^><^^>vv<v<^<v>v<^><><v<>vvv^<vv>v^>^>^^^v<<^<^^>vv<v^v^v>^vv^><^v^<<>v<^^>^vv<<>^<<><^>v^<<^<>v><><>v<<^^><^^^v>>v>^vv<v^>>^v^^<><<<<<^>^v^<^<^^>^vv<^>v^^v^<>v<><v>v^v>vvv><><<><>vv<vvv^v>^^>^^^<><^>^^^>v<vvvv<>vv<v<v^^>><>v<>>v^>v^^vv^>v>>><v<<<<v<^v>><^^>^v^v<v^v^^^vvv>>>vv<^>><<<^>><^<^>^<^>^>>v^<^<>^<^^<><vvv^^<>^<>>><<v>^<^<v<<><^<<^><^^>vv<>^^><v^v<vv<^<vvv<<^>v^>>v>>>v<<^vv^<><>>>^^<^v^>>^>>><<v<<^<vv><^<>^>>^v>>><^^^<<<vv<<v<v>^vv><><<>^^^<>^<vv^<^<<v>^^><vv>><>>>^>vv>^<^<>>^<^^><v>v^><v>vv><><>>><><<^^v<<^v<v>vv<><><<^v>^v<>^<^^^v^>^<^><^v>v>^v<>><^^v^^^^^<><v<>>vvv<v^^<>v>>>>^<<><^v>vv>>^^><<><><^^^<^<^<<^v>^^^><v>>>>><<v<v>v^^^<>>v<vv<^<>v^^^v<><^>v>><<><>v<^><<>>><>v>^<>>^>v^v<<<<>^<v^vv^>vv<<><v^vv<v<v<<>>>>>vv<><>^<^v>vv^<<v<^v^^<<^<<^^v^>>><<>^<>><^>>><v<>><<>^^>><<<^^^^^v>>^<<>>vvvv<^v<v^^<^>^vv<vv<>v<<<^><>>>>vv^<^v>v<^<>^v>>^<^^v^>>><>^^<^v>>v<<>vv<vvvv<>vv>^><>v^<>^<<^vv<v^^v<vvvv><^>>^v^>^^<<<^>>^^>^<^^<^<<<v^<^^v<<vv^<<^^^vv><v<vv^>v^^v<v>^^<^v<^>>><<>vv<<^><<v^v^^^v<vv>^>vv<^>>^<v<>vv>>>^>>><<v<^<>^<<<>>^<<>><^<<^^^>>v^^>v<<<>v>v>v<v<^>^<>>>^vvv><<^^<<><v<><^<v<vvv>v>>>>vv^^v<v<^<^><v>^v<<v<vv>>v>v<<<<><<>vv<><^^^<>>v<v<vvv><v^<vv^>>><v^^<>>>^^<><^<^v^><vv>>^^v>^<<v^>v>^^>^v^<v<^<v^v><>>v^^<^v^^<<>^^>v^^>><<<<^<^^v>^^v>v<<vv^^vv>^>v^<v<v><>vv>>^<v^v^<v<^>^v>v^^>vvvvv<v><<>vv>vvvvvv>>v>>^^^<v>vv^^><<v>>v^^^^v>vv>v<^v>>>>^>^><v^>^<v<vv>v>^>><v>><<>>^vv<vv^^<^^>>>>><><<^<v<><<v>^><^vv^v>>>>>v>^>^<vv>^v^>v<^v^<^<<vv<<>v<>>^vv<<>^v^v>><><<>>v^^<<>^^<v><>v<<^^<^^>^^>^<^><>>v<>>^^<^>><<<v<>>>^v^>v>v<<^^<<^>v<v^>>v^^v^^<<>^v>v><v^>v<^^>^<vv><vv^<>v<><^<<<vv<<v>v<^<<<<^^>v^v^^><<><^^^<v>v^^>>>vvv><>vv<>>^^v^v<<^>v^^v^>vv>^<<v<^<v^>^^<<v<^^>^v^^<^^v<<>>vv<^>>^><><>v>>v<>^<v^^><<>>>"
	do
	;; get next coordinate
	(cond
	 ((string= "^" (char-to-string char))
	  (if (evenp I)
	      (setq i (+ i 1))
	    (setq k (+ k 1))))
	 ((string= "v" (char-to-string char))
	  (if (evenp I)
	      (setq i (- i 1))
	    (setq k (- k 1))))
	 ((string= ">" (char-to-string char))
	  (if (evenp I)
	      (setq j (+ j 1))
	    (setq l (+ l 1))))
	 ((string= "<" (char-to-string char))
	  (if (evenp I)
	      (setq j (- j 1))
	    (setq l (- l 1))))
	 (t (message-box "%S" (char-to-string char)) nil))
	(if (evenp I)
	    (setq house (cons i j))
	  (setq house (cons k l)))
	(if (assoc house houses)
	    (setf (cdr (assoc house houses))
		  (+ (cdr (assoc house houses)) 1))
	  (add-to-list 'houses `(cons ,house 1))))
  ;; now count houses
  (length houses))
#+END_SRC

#+RESULTS:
: 2631

** Day 4


#+BEGIN_SRC emacs-lisp
(loop for i from 0 to 2000000
      until (string= "00000" (substring (md5 (format "ckczppom%s" i)) 0 5))
      finally return i)
#+END_SRC

#+RESULTS:
: 117946

#+BEGIN_SRC emacs-lisp
(loop for i from 0 to 20000000
      until (string= "000000" (substring (md5 (format "ckczppom%s" i)) 0 6))
      finally return i)
#+END_SRC

#+RESULTS:
: 3938038

** Day 5

#+BEGIN_SRC emacs-lisp
(defun nice-string-p (s)
  (and
   (not (string-match "\\(ab\\)\\|\\(cd\\)\\|\\(pq\\)\\|\\(xy\\)" s))
   (string-match "\\([a-z]\\)\\1" s)
   (>= (s-count-matches "[aeiou]" s) 3)))


(nice-string-p "haegwjzuvuyypxyu")

(loop for s in (split-string "rthkunfaakmwmush
qxlnvjguikqcyfzt
sleaoasjspnjctqt
lactpmehuhmzwfjl
bvggvrdgjcspkkyj
nwaceixfiasuzyoz
hsapdhrxlqoiumqw
lsitcmhlehasgejo
hksifrqlsiqkzyex
dfwuxtexmnvjyxqc
iawwfwylyrcbxwak
mamtkmvvaeeifnve
qiqtuihvsaeebjkd
skerkykytazvbupg
kgnxaylpgbdzedoo
plzkdktirhmumcuf
pexcckdvsrahvbop
jpocepxixeqjpigq
vnsvxizubavwrhtc
lqveclebkwnajppk
ikbzllevuwxscogb
xvfmkozbxzfuezjt
ukeazxczeejwoxli
tvtnlwcmhuezwney
hoamfvwwcarfuqro
wkvnmvqllphnsbnf
kiggbamoppmfhmlf
ughbudqakuskbiik
avccmveveqwhnjdx
llhqxueawluwmygt
mgkgxnkunzbvakiz
fwjbwmfxhkzmwtsq
kzmtudrtznhutukg
gtvnosbfetqiftmf
aoifrnnzufvhcwuy
cldmefgeuwlbxpof
xdqfinwotmffynqz
pajfvqhtlbhmyxai
jkacnevnrxpgxqal
esxqayxzvortsqgz
glfoarwvkzgybqlz
xdjcnevwhdfsnmma
jyjktscromovdchb
pvguwmhdvfxvapmz
iheglsjvxmkzgdbu
lwjioxdbyhqnwekv
zcoguugygkwizryj
ogvnripxxfeqpxdh
hkvajhsbfnzsygbm
cnjqeykecopwabpq
wojjtbcjinoiuhsj
kpwpvgxbyzczdzjq
wrvhylisemlewgzk
uiezkmnhilfzahtm
mucteynnuxpxzmvt
zaiwbgxefusfhmst
apptbogpxivjwink
qryboarjtwjhjgjb
irehxupgyseaahzd
fobstqxguyubggoh
ysriumfghtxtfxwe
auchdmasvfeliptw
mztuhefcrnknyrdl
tyjmkhihbwabjtaa
yquzkdtgsljkaebw
almvdvofjtkyzbmd
emqftiuqqpdwwbrv
hrrhmqfpepvbawvw
atrkgykycvgxbpyb
dhthetnealksbdan
zzqafhgicubptiyo
qdtaieaziwhbttnw
kyskgapdgqrtrefw
edwzlpqztpydmdlr
awszjnlmvlyqsuvl
kcrtmtshtsgixvcp
jtaskgkijivbbkri
mmggfwapsetemiuj
itagrrnjbnmhgppd
uqmbezechbrpbnqq
nnyimvtascflpzsa
knqeimypkdttyudj
vgoiyvtvegwyxjjd
qubzdxsbecktzrho
zehojtvktsbbxijb
xepmjrekwcgoxyoh
bnptxnocbpbqbyeq
sfvynsywscbnymos
dsltfbpcmffbluba
kncrlzlmkikylppa
siwudrvmildgaozv
jhhefbvbvneqzvtc
lqjgztxitbuccqbp
himmwlbhjqednltt
vwognchyertnnfil
eejakhapkbodrntf
qxuijkkhhlskgrba
aankpfxxicfpllog
vuxykvljyqexfhrn
epgygflbxlbwybzq
zuxmwvetmvcszayc
xttwhfqmemgtjnkf
hftwldmivyfunfvl
bejlyxfamzliilrj
zkehazcxyyvtrxti
dsgafehmcfpycvgz
igremmqdojqdvwmb
swnjzvmhcslvkmiw
fchzbfbmtqtxmaef
xwjmyyrlznxrcytq
brwcwzpcvbwdrthl
fvrlridacsiojdmb
mhsturxdlmtxozvy
usxvqyrwywdyvjvz
gwazuslvmarfpnzm
rgkbudaqsnolbcqo
dpxvlbtavdhdedkj
nnqmjzejhodyfgyd
ozoazxkfhujgtzvy
psdgvhzdiwnuaxpl
tznkilxpogbzgijz
wnpytcseirtborhh
lhauurlfsmagfges
oqfbzixnlywkzwwy
yoehapoyjpakziom
vtjftdcsfdzbmtrn
zcshfnodiwixcwqj
wapbxpaxgjvtntkm
qfyypkyvblrtaenh
bsxhbxkovgukhcza
kitdmvpiwzdonoyy
slkbhxmehzavbdsf
dovzjouqkzkcmbkl
qpbigdcqkfnfkxvq
eaiaquhnesvtcdsv
mhbezlhqojdsuryj
dqprkkzxlghkoccx
xqepmorryeivhrhm
frwmrjpezwmjflvf
gjpfgwghodfslwlf
fzyvajisdjbhfthq
pvzxkxdscdbilrdb
mtaxmqcnagmplvnm
rlyafujuuydrqwnc
gvqvrcxwyohufehq
lmrkircgfrfusmfd
ovlpnkxcpimyaspb
xhyjremmqhdqywju
pxfczlhpzbypfarm
utjhprzhtggausyp
utzkkzlnyskjtlqh
cecbcnxpazvkedic
xwvoaggihrbhmijq
krredhmtwlfmyagw
lwfhxgbknhwudkzw
vyczyvuxzmhxmdmn
swcoaosyieqekwxx
waohmlfdftjphpqw
gaclbbfqtiqasijg
ybcyaxhluxmiiagp
xgtxadsytgaznndw
wzqhtjqpaihyxksm
fdwltsowtcsmsyhm
rpoelfbsararhfja
tswgdacgnlhzwcvz
xjgbhdlxllgeigor
ksgthvrewhesuvke
whgooqirdjwsfhgi
toztqrxzavxmjewp
hbkayxxahipxnrtl
lazimkmdnhrtflcu
ndoudnupbotwqgmr
niwuwyhnudxmnnlk
hlmihzlrpnrtwekr
wzkttdudlgbvhqnc
rfyzzgytifkqlxjx
skddrtwxcyvhmjtb
mljspkvjxbuyhari
xwkhozaoancnwaud
nookruxkdffeymdz
oiqfvpxmcplyfgoa
qoxggshmrjlzarex
lsroezewzkrwdchx
nkoonmvdydgzspcl
lygxeqztdqklabov
jempjyzupwboieye
hpdaqkhjiddzybly
cvcizjlnzdjfjlbh
vaaddsbkcgdjhbkj
pjxmtxoyrkmpnenf
ujqdvyqnkbusxlps
miyvzkzqploqaceb
gapcsbkulicvlnmo
xqpcyriqhjhaeqlj
ipumdjwlldzqhmgh
swdstecnzttmehxe
ucmqordmzgioclle
aywgqhmqlrzcxmqx
ptkgyitqanvjocjn
wcesxtmzbzqedgfl
rnetcouciqdesloe
chpnkwfdjikqxwms
onpyrjowcuzdtzfg
tydnqwaqwkskcycz
dhamguhmkjzzeduy
oecllwyrlvsyeeuf
gsukajpoewxhqzft
sgdnffdixtxidkih
pqqzjxzydcvwwkmw
wnjltltufkgnrtgm
hylaicyfrqwolnaq
ovfnugjjwyfjunkm
xknyzsebmqodvhcl
uwfmrjzjvvzoaraw
zaldjvlcnqbessds
zphvjuctrsksouvz
ceqbneqjwyshgyge
wmelhaoylbyxcson
nghuescieaujhgkj
dhjmflwwnskrdpph
exvanqpoofjgiubf
aidkmnongrzjhsvn
mdbtkyjzpthewycc
izctbwnzorqwcqwz
hrvludvulaopcbrv
mrsjyjmjmbxyqbnz
sjdqrffsybmijezd
geozfiuqmentvlci
duzieldieeomrmcg
ehkbsecgugsulotm
cymnfvxkxeatztuq
bacrjsgrnbtmtmdl
kbarcowlijtzvhfb
uwietqeuupewbjav
ypenynjeuhpshdxw
fwwqvpgzquczqgso
wjegagwkzhmxqmdi
vocvrudgxdljwhcz
nnytqwspstuwiqep
axapfrlcanzgkpjs
lklrjiszochmmepj
gxadfpwiovjzsnpi
qidsjxzgwoqdrfie
wgszciclvsdxxoej
kwewlmzxruoojlaq
ywhahockhioribnz
ucbqdveieawzucef
mdyyzmfoaxmzddfv
hsxnabxyqfzceijv
vivruyvbrtaqeebr
jxfeweptjtgvmcjc
mmypqxmpurhculwd
mpiaphksvctnryli
xqzqnuxmuzylkkun
fndmtefjxxcygtji
dnorqlldvzqprird
nutokyajmjpwjaqu
vlupfperqyqkjcaj
dgihjeokrphkpdnk
nvbdyrlheqzixuku
mhrkntnxvsmvrpka
kvhkyanlhhymwljf
fhipumtegqfgeqqw
vpfjgveycdefuabu
kzincljffncylcsf
tsezxymwmjtyegqw
wxhcdrqedkdcwxli
ueihvxviirnooomi
kfelyctfvwyovlyh
horzapuapgtvzizz
iiqkdpmfvhwwzmtj
rsaclclupiicstff
quwkkhrafypkaoum
gyrgkgmwqfkeudfe
noydhbqacwptyfmy
efwwuipzgtkwffhf
suyojcitomdxsduh
lbcxnsykojkufkml
zpglsvoutvzkgdep
usgrufyvgsbsmbpr
katrrwuhwvunjqor
btngwrpcxoyfbgbc
bxjscjdiowjrkpns
nwxvnfrnlkgqxvhf
ikhyqkvljucgdlag
xibnxsjopmxvflkl
mzplumcfivqcjqnz
jqflcxoxzlbwlxry
fcscvmfepdxrshxe
wlpffwunffklzbuc
emvrlqajjgwzfmle
rhaheurtzrfoqkyq
ifuuhpxmadaysfsx
ncyfvleyzqntpcoo
zeogmyaqccmtvokd
jqppbzebppdnpurn
xixarswxsiwjzgni
ezruwzajsoombphs
hmiqfeizyprielxf
jnaoxljnftymsfey
extgzrxzovlsixnf
yhyfmovvlrwoezsv
ffnybaolppuzpjym
pqowimdiusccaagn
jgceiosiihpjsmnu
hkoexeaopebktngx
njhzuvsygymejqav
yjkgcclgtvushcfk
gmbjxhnkkxlihups
pdlwysadiebsidjz
omrwmgzulfoaqros
ofvvgdezwvcffdcy
otytpuklhxcpxhgd
eyfaosxdauumvlux
mvdthjfstrlqlyuo
mdgdchgnlxaxspdm
bakjezmhbwqxzevd
msakswaphdwaodhg
vjcqscgdbnsxdllh
jjywaovewbuzreoj
nqvplhwacylifvwk
lpwmpixbxysmsign
flcvbpxrchcpbgcb
qjpkeuenenwawlok
bnqkflfmdmntctya
fzsgzpoqixvpsneq
icwfdisutoilejld
relchofohnkwbumi
aljalgdaqwhzhfwr
cahkvnwnbwhodpqs
dnrzeunxiattlvdm
nsmkhlrpwlunppjs
mqqsexlwfqnogwub
tfavelkqrtndpait
ooguafrnmprfxcnz
ntynkiordzxtwrqa
rkkyzlxekqqlkvym
ofxcivdnwcmgfnme
ywotqwbrqxlrnobh
nrbbiypwhrqihvev
flqsjixxtydheufs
lcfrfzypstrqctja
hyzbuzawuzjrynny
exfbywcnstebnvmq
vydzwnbmcihvqrnj
qmwqaaylinzrdmiw
lpxpztpvfggspeun
lhxmqqbracsuyrfm
zgkwsrabaseidbrw
yjlmbhbqsqgszsun
mqfzqtbxtuteabtd
izomzdmcqmfrevwd
iqijrlqurdwrkoln
fxhqzpgoxxjkkhql
oulwontmgrjeopnk
edaigfydjexvzzvj
vjhybiklxpxjqpwc
ypxfbfnpbmqmwtte
xzvcsgasztrxdzud
rpulqmobptfarboo
palacmdijxzzykrf
jmllwukplufohiby
dnswayomusiekfmy
sxbrjqtqgzzwhcfo
lylvndsgbnbqiejm
jaxxhoulxnxnaenr
nblissutfazbcpwn
zmlsjszzldvbiacr
kewojtlchfkclqwk
eqvfjasddggvfame
yibzqlvxtraxpdon
dgnbxsbmdrtyvaac
uoxrcxfimhgtxqhy
xfdxalrwcwudlviq
xmtbdklqptoswpwl
zezyopzdztdjerfl
xuzluhjsqvhytgbc
qdjtmeckispmgzki
phakupesplzmmmvc
gpuoqfffumzszybn
bhywxqkrrlwuebbw
ibvwgoyvelzenkzl
ncohvvbmiekbaksa
fzuvqzvxvdbeirrp
lshtzniokucwojjd
punrduvlnrulkium
gnfpikidnfobrrme
vxkvweekmnvkzgyl
rhydssudkcjlqgxn
cjtqvlaahohcgumo
jwzmfyinsfwecgcb
blpeseqhlzfilpuf
jvtpjkyokzcvagon
qjomincbcobjczpe
ugsyzkzgdhxtmsfz
hleaqgwzqjwajcra
coumfghptpnxvvov
hqpnbupnzwpdvgqd
cpouyodqxgviasem
lljvxeyozckifhfd
huqtnvutdyfgwtwa
yenlveuynmlmmymu
ojdyufkomxiwjmbf
spjzgvcwvzgffjkk
vxykmjhyvmhyssbp
tazdeqggfcjfvwwn
uumwcngwcytvpufx
avovuzkrevloneop
owczrtbnrvjfemkt
hzpugcanaxyvaokj
iishlodnxvjtgzyn
qosdonclrnxirham
eonqlnwevahydddg
ryqmnuikftlxuoqy
whqepbcwabzbthha
vekisvnwhgpyemxr
lrwxzoamnvpnlhap
ywepvqthnorfswjv
evqwvsoazmwyypjy
bgwoojddubppmjxf
jypkfrthzgtyeddi
tynabbhfjzkrqsju
adxstbfqheuqbcuk
gqwqiocdyqoiblrx
ybuddlyuskdlegxv
luwynbsmpgyeqsbr
ltyqgqoyljibqndo
jaedpajzphfybajh
epglnrxofptsqvmy
zjdpxkngfkstxbxh
ekegphcwanoickfu
cqvhuucvejqirvfs
uqudnnqumsqcgefo
qnzunermlnpcfflo
ovyxaniqaawzfuxx
djekxcezjowdhopq
bwtwbmdehrhpjnlk
nilsnlacerweikfa
hyrigsrmsrzcyaus
gvmdmgddduylmxic
ewzovdblhmjgjwsk
ojjfsknlonzguzlq
yjgfruvpjvlvrvvq
cyoryodwyhzwprbv
crsjclrurcquqgut
sjhfhobwtojxcmem
ibxfjudilmdeksea
uqbhdbjoeupyhbcz
uqbxigzxuxgmjgnw
jashafmtzrhswirg
dexiolovaucyooka
czjbwwnlwcoqnoiu
ojigosazigfhttjc
zfiqtgrqbmftknzn
dlzbmvmolssbqlzl
sgmchcurrutdtsmw
scdwjqsdohcdrwry
cgtdvecqwplpprxn
iiplenflfczaktwi
wmgnwfxfcjhyeiqg
giihshowtcatecvl
nqhzfincclumvkaz
kxstpzgdfvepionc
agbhxcijxjxerxyi
hmgfqevgdyvisyvs
tthakmvpowpvhtao
ottalcghygpaafbo
aplvozayycremgqg
dbjxlnaouxqtdpfz
peeyallzjsdvpalc
ndtdjyboixuyhfox
llabnbcobexfoldn
cweuvfnfyumbjvxr
ewkhhepaosalnvkk
pivyiwsiqpwhagyx
auzsnwdcerfttawt
grbfrekupciuzkrt
byfwzadtzrbndluf
lluypxjeljzquptk
pskwsnhqanemtfou
sxvrtqqjdjkfhhrm
ulsmqgmshvijyeqh
qigofesfhekoftkf
zhatniakqtqcxyqa
uuczvylgnxkenqee
mlitvtuxknihmisc
srrtrxdvcokpyfmz
osispuucklxcfkeb
vqhazlaulmnpipql
umkiueljberqhdig
knvpbkbvgoqzwprp
nbsocqikhuvsbloj
wjnpepjkzkednqbm
agbhmytsofuyqcor
gvogzhkkpxyfecko
ardafguxifeipxcn
yiajcskbgykyzzkw
sejunbydztyibnpq
dqrgfggwcnxeiygy
xnqqwilzfbhcweel
jjtifhlvmyfxajqi
gwszrpgpmbpiwhek
kydzftzgcidiohfd
efprvslgkhboujic
kecjdfwqimkzuynx
rildnxnexlvrvxts
dlnhjbqjrzpfgjlk
qluoxmzyhkbyvhub
crydevvrjfmsypbi
dosaftwumofnjvix
pwsqxrfwigeffvef
nzyfmnpwqyygjvfx
iccbckrkxlwjsjat
bmputypderxzrwab
bhuakynbwnlreixb
qmrzfyqjiwaawvvk
juvtixbkwyludftn
zapmjxmuvhuqlfol
paiwrqjhpjavuivm
tsepfbiqhhkbyriz
jpprewufiogxoygk
mmapyxbsugcsngef
pduhmgnepnpsshnh
aetndoqjvqyjrwut
fnfvlorhwpkkemhz
gedfidpwvoeazztl
beclvhospgtowaue
wsclsvthxustmczm
tjbxhnpniuikijhe
rhetyhvfcemponeg
mavonujurprbeexi
argbrpomztrdyasa
bzvtffbtygjxmkvh
maqyqkhsqgzfzvve
seeirbiynilkhfcr
wxmanwnozfrlxhwr
dieulypsobhuvswb
nxevassztkpnvxtb
jclxuynjsrezvlcy
xlolzyvgmwjsbmyf
tguzoeybelluxwxc
fkchoysvdoaasykz
cyynwbfcqpqapldf
rhifmzpddjykktuy
ndvufsyusbxcsotm
txutnzvdsorrixgg
qjoczhukbliojneu
ufhwujotncovjjsz
kclsgsdwcrxsycbr
yscwmlrdaueniiic
nxhivrovpkgsmugb
fdxqfyvwwvgeuqkv
femtamfylysohmpr
amsyzslvyxsoribh
nhmqxncwsonhgbcz
uomqsvcbpthlmcue
kxtfapcqrnjkkslj
xtieihonlfubeync
adpcjqxgydulchgj
cjynnzsmmujsxxpd
neeapmzweidordog
szoivgqyqwnyjsnk
uwgrtzaqezgphdcu
ptpgttqxocjwxohi
fhltebsizfwzpgpf
emmsazsidspkhgnh
dxcprkbcjeqxqzgn
tpxzqwxbzwigdtlt
afsmksnmzustfqyt
xyehnftstacyfpit
vcrfqumhjcmnurlw
rrznpjzcjgnugoch
gbxnzkwsjmepvgzk
jwobshgwerborffm
zmuvfkhohoznmifs
buyuwgynbtujtura
bevncenmpxfyzwtf
hqqtcrhzfsrcutjh
kbpzshllpiowepgc
alspewedcukgtvso
xvsvzzdcgjuvutrw
pmwulqraatlbuski
abuzsiinbueowpqn
oedruzahyfuchijk
avhcuhqqjuqkesoq
azqgplkzsawkvnhb
rjyoydogkzohhcvx
aezxwucqvqxuqotb
kxobnsjvzvenyhbu
nnjoiilshoavzwly
aijttlxjrqwaewgk
cvsaujkqfoixarsw
zngtoacpxcsplgal
qhkxliqtokvepcdv
aixihrtdmxkfvcqw
owbgdgdymxhhnoum
tajsagmruwzuakkd
ckrfduwmsodeuebj
alfdhuijuwyufnne
xpchlkijwuftgmnm
rwcrvgphistiihlg
xdaksnorrnkihreq
akeschycpnyyuiug
rgputhzsvngfuovz
lerknhznuxzdhvre
mqiqmyladulbkzve
csnmupielbbpyops
kwgrwgmhfzjbwxxz
npwtvbslvlxvtjsd
zxleuskblzjfmxgf
hexvporkmherrtrn
rhtdhcagicfndmbm
qhnzyuswqwoobuzz
dpvanjuofrbueoza
kjcqujmnhkjdmrrf
gholddsspmxtpybg
jihlvyqdyzkshfsi
zuviqmuqqfmtneur
kzexjowatvkohrtx
wgijnfhibsiruvnl
zevkrkmhsxmicijb
khxrcteqourjvoxa
ylpxlkcnenbxxtta
zrfsvctbojjkpvtw
nlzbudxibnmcrxbt
cqnscphbicqmyrex
ywvdohheukipshcw
riwatbvjqstubssf
idlztqqaxzjiyllu
sdpdgzemlqtizgxn
rjtbovqlgcgojyjx
fnfrfwujmjwdrbdr
osnppzzmrpxmdhtj
ljhwngclvydkwyoe
chwqkrkzrvjwarat
jmydkwpibkvmqlgs
zvhfmbxnlxtujpcz
jsnhsphowlqupqwj
fzhkkbpasthopdev
jerntjdsspdstyhf
gctwmaywbyrzwdxz
xemeaiuzlctijykr
xulrqevtbhplmgxc
yfejfizzsycecqpu
gboxrvvxyzcowtzm
lpvhcxtchwvpgaxp
wdiwucbdyxwnjdqf
qgwoqazzjlvnjrwj
prtlnkakjfqcjngn
fagvxsvjpuvqxniz
xacmxveueaakfbsm
ginvtonnfbnugkpz
qpvggsppewfzvwin
reoqnlzruyyfraxa
kolwtqhifjbbuzor
vrkcywvdhdprztww
ngdvyfmvjqhbzbxt
rooxeoilqzqjunmp
efxmdprtogtxgyqs
qrhjuqndgurcmwgu
ouitjprueefafzpl
kirdwcksqrbwbchp
fpumsmogojuywezo
lgjrgykywugzjees
xigioqcpjabpbdas
ewkhuprpqzikmeop
fgrgxsqeducigxvr
bclkursnqkzmjihl
jozidniwvnqhvsbc
oghcilcyozrmmpta
xbgmaungzcpasapi
iqowypfiayzbcvhv
opdehgwdgkocrgkf
zfzvdjeinlegcjba
vhakxvlcayuzukap
xyradgyiebpevnwe
eamhtflgedwyshkn
igteqdgchjeulfth
kwsfkigxzpbgdxod
vapnpsbdboiewpzp
wbuqhjsngxpqshen
vxxilouxuytitwgm
cpnwlkwnkeanqnet
wdmbtqvvlowftvgb
wjtmcecpyqzwpbqg
jnxmoxdhvsphcdeg
wabxfxpotoywwodn
mwbsoxzlqpqobvvh
coktshbyzjkxnwlt
rzhnggpslwzvyqrp
dgzuqbzarbutlkfx
wunajaiiwgijfvjh
uotdbcgmsvbsfqlb
kxdtlgmqbccjqldb
ngmjzjwvwbegehfr
cvpsabqfpyygwncs
wqluvqlhdhskgmzj
rbveperybfntcfxs
fbmoypqdyyvqyknz
zxpgzwnvmuvkbgov
yexcyzhyrpluxfbj
ltqaihhstpzgyiou
munhsdsfkjebdicd
plecvjctydfbanep
kjrxnnlqrpcieuwx
zbcdtcqakhobuscf
kgovoohchranhmsh
llxufffkyvuxcmfx
tgaswqyzqopfvxtw
kojcqjkdpzvbtjtv
xggdlkmkrsygzcfk
vvitpsnjtdqwyzhh
gcqjuwytlhxsecci
vbsghygcsokphnrg
vejqximdopiztjjm
hudqtwmwkviiuslp
vwswfvpcwwpxlyry
gxmfiehdxptweweq
qjmekjdcedfasopf
pqyxdxtryfnihphf
felnavctjjojdlgp
hbimufguekgdxdac
dhxhtnqgfczywxlr
pssottpdjxkejjrh
edieanguabapxyig
sciinanyqblrbzbb
irxpsorkpcpahiqi
qsxecaykkmtfisei
ivfwlvxlbnrzixff
hqxzzfulfxpmivcw
vvbpaepmhmvqykdg
cetgicjasozykgje
wuetifzdarhwmhji
gaozwhpoickokgby
eldnodziomvdfbuv
favpaqktqaqgixtv
twbcobsayaecyxvu
lzyzjihydpfjgqev
wnurwckqgufskuoh
fxogtycnnmcbgvqz
aetositiahrhzidz
dyklsmlyvgcmtswr
ykaxtdkjqevtttbx
kfmnceyxyhiczzjm
nnizopcndipffpko
yjmznhzyfinpmvkb
sljegcvvbnjhhwdd
zmkeadxlwhfahpwg
rwvcogvegcohcrmx
aguqwrfymwbpscau
vlusytjagzvsnbwe
smvzhburcgvqtklh
rfuprvjkhazrcxpv
megqlnoqmymcrclc
gvldhkewtmlwqvqv
awynhvtyziemnjoa
voprnvtnzspfvpeh
dhlguqwmunbbekih
goayirdhnjrfuiqi
eoghydfykxdslohz
chpippjykogxpbxq
hqbycjweqczwjwgf
pvefsrvwumrlvhmt
eghwdovaynmctktk
crwkxoucibumzawc
bzbtahvhkdigvvtj
bnbptgihhfubxhho
ddqmbwyfmfnjjaro
gvtswqyzazihctif
vmqctjpgadxztqqb
dgnndowtpeooaqqf
sxdvctfdtalufxty
ylgeexosibsmmckw
sxplpyskbpqnojvw
coarhxtsvrontyeg
fyoaurggjupvzvlv
jlyrkqsiwuggvjem
uwbsjoxonreuucyi
gihuqvwxovbgokes
dxzaaxupbcgnxcwf
gidrgmvyrlqqslve
csflmlvqmonoywpx
jkxkpixlythlacnk
ejkarcdkdslldugv
dbzmsusevohhjkmr
cbrqzualjpdtworc
kpgidqlmcbpfmmwu
zwghjuofexfowqam
ncdlxmcrsmsocetz
kfprzqacefifjkbd
swwzivrxulkhvldc
wgqejhigbjwunscp
rsstnwcyybfauqxu
qhngfxyhdqopyfgk
zrndpyyejsmqsiaj
xxknxwpvafxiwwjc
mmaahwgoiwbxloem
tabacndyodmpuovp
yriwomauudscvdce
duvyscvfidmtcugl
mgipxnqlfpjdilge
imeeqcdetjuhfjnw
dvkutrdofpulqkyh
jefvtlktxegpmbya
iyzudqgpvlzjfydh
giohapxnpaqayryd
qheqdprmnqlpztls
rdxhijmzegxkotoq
hdnmaspumdwnrcdz
wafpbgehbuzdgsnc
tbtrfztsferdmhsy
vusndcyjngtkrtmk
ilqblestzxebcifh
urfgjbjgzlrfsdlv
aptcdvpsqwleqttn
bigczjvzokvfofiw
zjnjeufonyqgkbpx
trcdebioegfqrrdi
jrdvdriujlmbqewt
jqrcmuxpwurdhaue
yjlermsgruublkly
zwarvgszuqeesuwq
xthhhqzwvqiyctvs
mzwwaxnbdxhajyyv
nclsozlqrjvqifyi
gcnyqmhezcqvksqw
deuakiskeuwdfxwp
tclkbhqqcydlgrrl
qbpndlfjayowkcrx
apjhkutpoiegnxfx
oaupiimsplsvcsie
sdmxrufyhztxzgmt
ukfoinnlbqrgzdeh
azosvwtcipqzckns
mydyeqsimocdikzn
itfmfjrclmglcrkc
swknpgysfscdrnop
shyyuvvldmqheuiv
tljrjohwhhekyhle
dayinwzuvzimvzjw
qgylixuuervyylur
klqqaiemurawmaaz
hdmzgtxxjabplxvf
xiivzelzdjjtkhnj
ktgplkzblgxwrnvo
gvbpyofzodnknytd
lqhlmnmhakqeffqw
ltzdbngrcxwuxecy
obxnfjeebvovjcjz
zexpwallpocrxpvp
tjpkkmcqbbkxaiak
qiedfixxgvciblih
qcxkhghosuslbyih
gnsfidwhzaxjufgm
xrghwgvyjakkzidw
tftftwedtecglavz
wquqczzkzqrlfngr
twibtkijpvzbsfro
bmplypdsvzuhrjxp
zanrfmestvqpwbuh
zonrhfqowyimcukm
kpvajjfmqpbhrjma
kujzluicngigjbtp
iusguantsrwxdjal
kwxeuylcnszswahw
visdhnkobxnemldu
rogeadmmaicwtabl
pxqycifbgevqudvs
osaiozyvlyddylqr
vffjxrolrpuxcatx
jbmsetccdrywssjd
qgxyhjfpbfifmvgc
npejgalglldxjdhs
mbbtqgmttastrlck
whapaqwdtpkropek
dulbdboxazfyjgkg
xaymnudlozbykgow
lebvqmxeaymkkfoy
bmicnfuubkregouj
dieatyxxxlvhneoj
yglaapcsnsbuvrva
bbpjaslqpzqcwkpk
xehuznbayagrbhnd
ikqmeovaurmqfuvr
ylyokwuzxltvxmgv
hqtfinrkllhqtoiz
pjmhtigznoaejifx
fqdbmowkjtmvvrmx
uvqtqfoulvzozfxv
rpajajukuxtchrjd
sznucejifktvxdre
ufvibsmoushmjbne
xirdqoshngthfvax
iafpkddchsgdqmzl
vmualmlduipvykzh
fnmuahmblwyceejb
ilsaapnswfoymiov
lenvylifraahaclv
cukqxlipuyxedqfh
zgwecslpniqvtvuz
cdcdfpsxuyrhsmag
dszjinhantnxgqra
ioimwotsgnjeacgt
dqcymnvjystbynhp
yibaudyfefbfgunx
cabslcvunjavqkbf
goymzvmgkvlsmugf
zxteiitpthzskjjx
agnxcnaqhjhlurzs
cvmgyxhhnykuxbmb
cgqmjexydmvgwxpp
sygjajofieojiuna
clpvxbrbjvqfbzvu
cbntswqynsdqnhyv
bztpbtwbefiotkfa
pnxccbgajvhyeybu
asyzrvgzumtuissa
facjyblvcqqginxa
rvwnucnbsvberxuv
ghrbeykzrxclasie
ekujtselepgjtaql
krtrzsmduhsifyiw
ticjswvsnyrwhpnt
clmjhsftkfjzwyke
lbxlcixxcztddlam
xhfeekmxgbloguri
azxqwlucwhahtvep
kitdjrwmockhksow
keznwwcusgbtvfrs
ljvzxoywcofgwajj
vebjnhnkcfzbhrcw
eqfcxkavstxcuels
ldattkyawjrvcido
bsqqeilshcwtqyil
foqqsxahfiozcqrw
liswfmuhzfbyzjhf
sulbdcyzmolapfbs
zuggzkelwxjpsgxb
betioxrgtnhpivcw
xmtbixstdipibhgs
ttvurgqmulryyaji
viobnljznzppfmxw
qlzabfopydtxrlet
tusvydegfxhaxolk
thoufvvfjferxhwp
cfyyzppfarjiilbs
jwmhxtgafkkgseqs
pqwuuaxbeklodwpt
vndyveahdiwgkjyx
ssrjgasfhdouwyoh
thbavfcisgvvyekf
yjdvxmubvqadgypa
tlbmcxaelkouhsvu
bonohfnlboxiezzr
rktlxcbkhewyvcjl
rsmoutcbcssodvsc
qszdratuxcrhsvoh
eypyfahpuzqwzwhi
yhkrleqmqlmwdnio
vpnvxusvmngsobmq
hkzyhopvxrsimzys
dblriiwnrvnhxykl
xkriqxkrprjwpncs
rcymltrbszhyhqti
mzbvneplsnpiztzn
vkqtnptgbqefvfoc
nwdtfiaozkcjtlax
crximadpvdaccrsm
lrbajafxwwnxvbei
rbexzesrytpwwmjf
stxwjarildpnzfpg
btamaihdivrhhrrv
acqbucebpaulpotl
dkjhzghxxtxgdpvm
rsbzwsnvlpqzyjir
mizypbwvpgqoiams
nvrslorjpqaasudn
wvexcpzmconqkbvk
rfwfumhjwzrvdzam
eaghdaqorkhdsmth
gtuntmpqaivosewh
nzlsmdgjrigghrmy
dhuvxwobpzbuwjgk
kkcuvbezftvkhebf
aeediumxyljbuyqu
rfkpqeekjezejtjc
wkzasuyckmgwddwy
eixpkpdhsjmynxhi
elrlnndorggmmhmx
ayxwhkxahljoxggy
mtzvvwmwexkberaw
evpktriyydxvdhpx
otznecuqsfagruls
vrdykpyebzyblnut
cnriedolerlhbqjy
uajaprnrrkvggqgx
xdlxuguloojvskjq
mfifrjamczjncuym
otmgvsykuuxrluky
oiuroieurpyejuvm" "\n")
      if (nice-string-p s)
      sum 1)

#+END_SRC

#+RESULTS:
: 258


#+BEGIN_SRC emacs-lisp
(defun nice-string-p (s)
  (and
   (string-match "\\([a-z][a-z]\\).*\\1" s)
   (string-match "\\([a-z]\\).\\1" s)))


(nice-string-p "qjhvhtzxzqqjkmpb")

(loop for s in (split-string "rthkunfaakmwmush
qxlnvjguikqcyfzt
sleaoasjspnjctqt
lactpmehuhmzwfjl
bvggvrdgjcspkkyj
nwaceixfiasuzyoz
hsapdhrxlqoiumqw
lsitcmhlehasgejo
hksifrqlsiqkzyex
dfwuxtexmnvjyxqc
iawwfwylyrcbxwak
mamtkmvvaeeifnve
qiqtuihvsaeebjkd
skerkykytazvbupg
kgnxaylpgbdzedoo
plzkdktirhmumcuf
pexcckdvsrahvbop
jpocepxixeqjpigq
vnsvxizubavwrhtc
lqveclebkwnajppk
ikbzllevuwxscogb
xvfmkozbxzfuezjt
ukeazxczeejwoxli
tvtnlwcmhuezwney
hoamfvwwcarfuqro
wkvnmvqllphnsbnf
kiggbamoppmfhmlf
ughbudqakuskbiik
avccmveveqwhnjdx
llhqxueawluwmygt
mgkgxnkunzbvakiz
fwjbwmfxhkzmwtsq
kzmtudrtznhutukg
gtvnosbfetqiftmf
aoifrnnzufvhcwuy
cldmefgeuwlbxpof
xdqfinwotmffynqz
pajfvqhtlbhmyxai
jkacnevnrxpgxqal
esxqayxzvortsqgz
glfoarwvkzgybqlz
xdjcnevwhdfsnmma
jyjktscromovdchb
pvguwmhdvfxvapmz
iheglsjvxmkzgdbu
lwjioxdbyhqnwekv
zcoguugygkwizryj
ogvnripxxfeqpxdh
hkvajhsbfnzsygbm
cnjqeykecopwabpq
wojjtbcjinoiuhsj
kpwpvgxbyzczdzjq
wrvhylisemlewgzk
uiezkmnhilfzahtm
mucteynnuxpxzmvt
zaiwbgxefusfhmst
apptbogpxivjwink
qryboarjtwjhjgjb
irehxupgyseaahzd
fobstqxguyubggoh
ysriumfghtxtfxwe
auchdmasvfeliptw
mztuhefcrnknyrdl
tyjmkhihbwabjtaa
yquzkdtgsljkaebw
almvdvofjtkyzbmd
emqftiuqqpdwwbrv
hrrhmqfpepvbawvw
atrkgykycvgxbpyb
dhthetnealksbdan
zzqafhgicubptiyo
qdtaieaziwhbttnw
kyskgapdgqrtrefw
edwzlpqztpydmdlr
awszjnlmvlyqsuvl
kcrtmtshtsgixvcp
jtaskgkijivbbkri
mmggfwapsetemiuj
itagrrnjbnmhgppd
uqmbezechbrpbnqq
nnyimvtascflpzsa
knqeimypkdttyudj
vgoiyvtvegwyxjjd
qubzdxsbecktzrho
zehojtvktsbbxijb
xepmjrekwcgoxyoh
bnptxnocbpbqbyeq
sfvynsywscbnymos
dsltfbpcmffbluba
kncrlzlmkikylppa
siwudrvmildgaozv
jhhefbvbvneqzvtc
lqjgztxitbuccqbp
himmwlbhjqednltt
vwognchyertnnfil
eejakhapkbodrntf
qxuijkkhhlskgrba
aankpfxxicfpllog
vuxykvljyqexfhrn
epgygflbxlbwybzq
zuxmwvetmvcszayc
xttwhfqmemgtjnkf
hftwldmivyfunfvl
bejlyxfamzliilrj
zkehazcxyyvtrxti
dsgafehmcfpycvgz
igremmqdojqdvwmb
swnjzvmhcslvkmiw
fchzbfbmtqtxmaef
xwjmyyrlznxrcytq
brwcwzpcvbwdrthl
fvrlridacsiojdmb
mhsturxdlmtxozvy
usxvqyrwywdyvjvz
gwazuslvmarfpnzm
rgkbudaqsnolbcqo
dpxvlbtavdhdedkj
nnqmjzejhodyfgyd
ozoazxkfhujgtzvy
psdgvhzdiwnuaxpl
tznkilxpogbzgijz
wnpytcseirtborhh
lhauurlfsmagfges
oqfbzixnlywkzwwy
yoehapoyjpakziom
vtjftdcsfdzbmtrn
zcshfnodiwixcwqj
wapbxpaxgjvtntkm
qfyypkyvblrtaenh
bsxhbxkovgukhcza
kitdmvpiwzdonoyy
slkbhxmehzavbdsf
dovzjouqkzkcmbkl
qpbigdcqkfnfkxvq
eaiaquhnesvtcdsv
mhbezlhqojdsuryj
dqprkkzxlghkoccx
xqepmorryeivhrhm
frwmrjpezwmjflvf
gjpfgwghodfslwlf
fzyvajisdjbhfthq
pvzxkxdscdbilrdb
mtaxmqcnagmplvnm
rlyafujuuydrqwnc
gvqvrcxwyohufehq
lmrkircgfrfusmfd
ovlpnkxcpimyaspb
xhyjremmqhdqywju
pxfczlhpzbypfarm
utjhprzhtggausyp
utzkkzlnyskjtlqh
cecbcnxpazvkedic
xwvoaggihrbhmijq
krredhmtwlfmyagw
lwfhxgbknhwudkzw
vyczyvuxzmhxmdmn
swcoaosyieqekwxx
waohmlfdftjphpqw
gaclbbfqtiqasijg
ybcyaxhluxmiiagp
xgtxadsytgaznndw
wzqhtjqpaihyxksm
fdwltsowtcsmsyhm
rpoelfbsararhfja
tswgdacgnlhzwcvz
xjgbhdlxllgeigor
ksgthvrewhesuvke
whgooqirdjwsfhgi
toztqrxzavxmjewp
hbkayxxahipxnrtl
lazimkmdnhrtflcu
ndoudnupbotwqgmr
niwuwyhnudxmnnlk
hlmihzlrpnrtwekr
wzkttdudlgbvhqnc
rfyzzgytifkqlxjx
skddrtwxcyvhmjtb
mljspkvjxbuyhari
xwkhozaoancnwaud
nookruxkdffeymdz
oiqfvpxmcplyfgoa
qoxggshmrjlzarex
lsroezewzkrwdchx
nkoonmvdydgzspcl
lygxeqztdqklabov
jempjyzupwboieye
hpdaqkhjiddzybly
cvcizjlnzdjfjlbh
vaaddsbkcgdjhbkj
pjxmtxoyrkmpnenf
ujqdvyqnkbusxlps
miyvzkzqploqaceb
gapcsbkulicvlnmo
xqpcyriqhjhaeqlj
ipumdjwlldzqhmgh
swdstecnzttmehxe
ucmqordmzgioclle
aywgqhmqlrzcxmqx
ptkgyitqanvjocjn
wcesxtmzbzqedgfl
rnetcouciqdesloe
chpnkwfdjikqxwms
onpyrjowcuzdtzfg
tydnqwaqwkskcycz
dhamguhmkjzzeduy
oecllwyrlvsyeeuf
gsukajpoewxhqzft
sgdnffdixtxidkih
pqqzjxzydcvwwkmw
wnjltltufkgnrtgm
hylaicyfrqwolnaq
ovfnugjjwyfjunkm
xknyzsebmqodvhcl
uwfmrjzjvvzoaraw
zaldjvlcnqbessds
zphvjuctrsksouvz
ceqbneqjwyshgyge
wmelhaoylbyxcson
nghuescieaujhgkj
dhjmflwwnskrdpph
exvanqpoofjgiubf
aidkmnongrzjhsvn
mdbtkyjzpthewycc
izctbwnzorqwcqwz
hrvludvulaopcbrv
mrsjyjmjmbxyqbnz
sjdqrffsybmijezd
geozfiuqmentvlci
duzieldieeomrmcg
ehkbsecgugsulotm
cymnfvxkxeatztuq
bacrjsgrnbtmtmdl
kbarcowlijtzvhfb
uwietqeuupewbjav
ypenynjeuhpshdxw
fwwqvpgzquczqgso
wjegagwkzhmxqmdi
vocvrudgxdljwhcz
nnytqwspstuwiqep
axapfrlcanzgkpjs
lklrjiszochmmepj
gxadfpwiovjzsnpi
qidsjxzgwoqdrfie
wgszciclvsdxxoej
kwewlmzxruoojlaq
ywhahockhioribnz
ucbqdveieawzucef
mdyyzmfoaxmzddfv
hsxnabxyqfzceijv
vivruyvbrtaqeebr
jxfeweptjtgvmcjc
mmypqxmpurhculwd
mpiaphksvctnryli
xqzqnuxmuzylkkun
fndmtefjxxcygtji
dnorqlldvzqprird
nutokyajmjpwjaqu
vlupfperqyqkjcaj
dgihjeokrphkpdnk
nvbdyrlheqzixuku
mhrkntnxvsmvrpka
kvhkyanlhhymwljf
fhipumtegqfgeqqw
vpfjgveycdefuabu
kzincljffncylcsf
tsezxymwmjtyegqw
wxhcdrqedkdcwxli
ueihvxviirnooomi
kfelyctfvwyovlyh
horzapuapgtvzizz
iiqkdpmfvhwwzmtj
rsaclclupiicstff
quwkkhrafypkaoum
gyrgkgmwqfkeudfe
noydhbqacwptyfmy
efwwuipzgtkwffhf
suyojcitomdxsduh
lbcxnsykojkufkml
zpglsvoutvzkgdep
usgrufyvgsbsmbpr
katrrwuhwvunjqor
btngwrpcxoyfbgbc
bxjscjdiowjrkpns
nwxvnfrnlkgqxvhf
ikhyqkvljucgdlag
xibnxsjopmxvflkl
mzplumcfivqcjqnz
jqflcxoxzlbwlxry
fcscvmfepdxrshxe
wlpffwunffklzbuc
emvrlqajjgwzfmle
rhaheurtzrfoqkyq
ifuuhpxmadaysfsx
ncyfvleyzqntpcoo
zeogmyaqccmtvokd
jqppbzebppdnpurn
xixarswxsiwjzgni
ezruwzajsoombphs
hmiqfeizyprielxf
jnaoxljnftymsfey
extgzrxzovlsixnf
yhyfmovvlrwoezsv
ffnybaolppuzpjym
pqowimdiusccaagn
jgceiosiihpjsmnu
hkoexeaopebktngx
njhzuvsygymejqav
yjkgcclgtvushcfk
gmbjxhnkkxlihups
pdlwysadiebsidjz
omrwmgzulfoaqros
ofvvgdezwvcffdcy
otytpuklhxcpxhgd
eyfaosxdauumvlux
mvdthjfstrlqlyuo
mdgdchgnlxaxspdm
bakjezmhbwqxzevd
msakswaphdwaodhg
vjcqscgdbnsxdllh
jjywaovewbuzreoj
nqvplhwacylifvwk
lpwmpixbxysmsign
flcvbpxrchcpbgcb
qjpkeuenenwawlok
bnqkflfmdmntctya
fzsgzpoqixvpsneq
icwfdisutoilejld
relchofohnkwbumi
aljalgdaqwhzhfwr
cahkvnwnbwhodpqs
dnrzeunxiattlvdm
nsmkhlrpwlunppjs
mqqsexlwfqnogwub
tfavelkqrtndpait
ooguafrnmprfxcnz
ntynkiordzxtwrqa
rkkyzlxekqqlkvym
ofxcivdnwcmgfnme
ywotqwbrqxlrnobh
nrbbiypwhrqihvev
flqsjixxtydheufs
lcfrfzypstrqctja
hyzbuzawuzjrynny
exfbywcnstebnvmq
vydzwnbmcihvqrnj
qmwqaaylinzrdmiw
lpxpztpvfggspeun
lhxmqqbracsuyrfm
zgkwsrabaseidbrw
yjlmbhbqsqgszsun
mqfzqtbxtuteabtd
izomzdmcqmfrevwd
iqijrlqurdwrkoln
fxhqzpgoxxjkkhql
oulwontmgrjeopnk
edaigfydjexvzzvj
vjhybiklxpxjqpwc
ypxfbfnpbmqmwtte
xzvcsgasztrxdzud
rpulqmobptfarboo
palacmdijxzzykrf
jmllwukplufohiby
dnswayomusiekfmy
sxbrjqtqgzzwhcfo
lylvndsgbnbqiejm
jaxxhoulxnxnaenr
nblissutfazbcpwn
zmlsjszzldvbiacr
kewojtlchfkclqwk
eqvfjasddggvfame
yibzqlvxtraxpdon
dgnbxsbmdrtyvaac
uoxrcxfimhgtxqhy
xfdxalrwcwudlviq
xmtbdklqptoswpwl
zezyopzdztdjerfl
xuzluhjsqvhytgbc
qdjtmeckispmgzki
phakupesplzmmmvc
gpuoqfffumzszybn
bhywxqkrrlwuebbw
ibvwgoyvelzenkzl
ncohvvbmiekbaksa
fzuvqzvxvdbeirrp
lshtzniokucwojjd
punrduvlnrulkium
gnfpikidnfobrrme
vxkvweekmnvkzgyl
rhydssudkcjlqgxn
cjtqvlaahohcgumo
jwzmfyinsfwecgcb
blpeseqhlzfilpuf
jvtpjkyokzcvagon
qjomincbcobjczpe
ugsyzkzgdhxtmsfz
hleaqgwzqjwajcra
coumfghptpnxvvov
hqpnbupnzwpdvgqd
cpouyodqxgviasem
lljvxeyozckifhfd
huqtnvutdyfgwtwa
yenlveuynmlmmymu
ojdyufkomxiwjmbf
spjzgvcwvzgffjkk
vxykmjhyvmhyssbp
tazdeqggfcjfvwwn
uumwcngwcytvpufx
avovuzkrevloneop
owczrtbnrvjfemkt
hzpugcanaxyvaokj
iishlodnxvjtgzyn
qosdonclrnxirham
eonqlnwevahydddg
ryqmnuikftlxuoqy
whqepbcwabzbthha
vekisvnwhgpyemxr
lrwxzoamnvpnlhap
ywepvqthnorfswjv
evqwvsoazmwyypjy
bgwoojddubppmjxf
jypkfrthzgtyeddi
tynabbhfjzkrqsju
adxstbfqheuqbcuk
gqwqiocdyqoiblrx
ybuddlyuskdlegxv
luwynbsmpgyeqsbr
ltyqgqoyljibqndo
jaedpajzphfybajh
epglnrxofptsqvmy
zjdpxkngfkstxbxh
ekegphcwanoickfu
cqvhuucvejqirvfs
uqudnnqumsqcgefo
qnzunermlnpcfflo
ovyxaniqaawzfuxx
djekxcezjowdhopq
bwtwbmdehrhpjnlk
nilsnlacerweikfa
hyrigsrmsrzcyaus
gvmdmgddduylmxic
ewzovdblhmjgjwsk
ojjfsknlonzguzlq
yjgfruvpjvlvrvvq
cyoryodwyhzwprbv
crsjclrurcquqgut
sjhfhobwtojxcmem
ibxfjudilmdeksea
uqbhdbjoeupyhbcz
uqbxigzxuxgmjgnw
jashafmtzrhswirg
dexiolovaucyooka
czjbwwnlwcoqnoiu
ojigosazigfhttjc
zfiqtgrqbmftknzn
dlzbmvmolssbqlzl
sgmchcurrutdtsmw
scdwjqsdohcdrwry
cgtdvecqwplpprxn
iiplenflfczaktwi
wmgnwfxfcjhyeiqg
giihshowtcatecvl
nqhzfincclumvkaz
kxstpzgdfvepionc
agbhxcijxjxerxyi
hmgfqevgdyvisyvs
tthakmvpowpvhtao
ottalcghygpaafbo
aplvozayycremgqg
dbjxlnaouxqtdpfz
peeyallzjsdvpalc
ndtdjyboixuyhfox
llabnbcobexfoldn
cweuvfnfyumbjvxr
ewkhhepaosalnvkk
pivyiwsiqpwhagyx
auzsnwdcerfttawt
grbfrekupciuzkrt
byfwzadtzrbndluf
lluypxjeljzquptk
pskwsnhqanemtfou
sxvrtqqjdjkfhhrm
ulsmqgmshvijyeqh
qigofesfhekoftkf
zhatniakqtqcxyqa
uuczvylgnxkenqee
mlitvtuxknihmisc
srrtrxdvcokpyfmz
osispuucklxcfkeb
vqhazlaulmnpipql
umkiueljberqhdig
knvpbkbvgoqzwprp
nbsocqikhuvsbloj
wjnpepjkzkednqbm
agbhmytsofuyqcor
gvogzhkkpxyfecko
ardafguxifeipxcn
yiajcskbgykyzzkw
sejunbydztyibnpq
dqrgfggwcnxeiygy
xnqqwilzfbhcweel
jjtifhlvmyfxajqi
gwszrpgpmbpiwhek
kydzftzgcidiohfd
efprvslgkhboujic
kecjdfwqimkzuynx
rildnxnexlvrvxts
dlnhjbqjrzpfgjlk
qluoxmzyhkbyvhub
crydevvrjfmsypbi
dosaftwumofnjvix
pwsqxrfwigeffvef
nzyfmnpwqyygjvfx
iccbckrkxlwjsjat
bmputypderxzrwab
bhuakynbwnlreixb
qmrzfyqjiwaawvvk
juvtixbkwyludftn
zapmjxmuvhuqlfol
paiwrqjhpjavuivm
tsepfbiqhhkbyriz
jpprewufiogxoygk
mmapyxbsugcsngef
pduhmgnepnpsshnh
aetndoqjvqyjrwut
fnfvlorhwpkkemhz
gedfidpwvoeazztl
beclvhospgtowaue
wsclsvthxustmczm
tjbxhnpniuikijhe
rhetyhvfcemponeg
mavonujurprbeexi
argbrpomztrdyasa
bzvtffbtygjxmkvh
maqyqkhsqgzfzvve
seeirbiynilkhfcr
wxmanwnozfrlxhwr
dieulypsobhuvswb
nxevassztkpnvxtb
jclxuynjsrezvlcy
xlolzyvgmwjsbmyf
tguzoeybelluxwxc
fkchoysvdoaasykz
cyynwbfcqpqapldf
rhifmzpddjykktuy
ndvufsyusbxcsotm
txutnzvdsorrixgg
qjoczhukbliojneu
ufhwujotncovjjsz
kclsgsdwcrxsycbr
yscwmlrdaueniiic
nxhivrovpkgsmugb
fdxqfyvwwvgeuqkv
femtamfylysohmpr
amsyzslvyxsoribh
nhmqxncwsonhgbcz
uomqsvcbpthlmcue
kxtfapcqrnjkkslj
xtieihonlfubeync
adpcjqxgydulchgj
cjynnzsmmujsxxpd
neeapmzweidordog
szoivgqyqwnyjsnk
uwgrtzaqezgphdcu
ptpgttqxocjwxohi
fhltebsizfwzpgpf
emmsazsidspkhgnh
dxcprkbcjeqxqzgn
tpxzqwxbzwigdtlt
afsmksnmzustfqyt
xyehnftstacyfpit
vcrfqumhjcmnurlw
rrznpjzcjgnugoch
gbxnzkwsjmepvgzk
jwobshgwerborffm
zmuvfkhohoznmifs
buyuwgynbtujtura
bevncenmpxfyzwtf
hqqtcrhzfsrcutjh
kbpzshllpiowepgc
alspewedcukgtvso
xvsvzzdcgjuvutrw
pmwulqraatlbuski
abuzsiinbueowpqn
oedruzahyfuchijk
avhcuhqqjuqkesoq
azqgplkzsawkvnhb
rjyoydogkzohhcvx
aezxwucqvqxuqotb
kxobnsjvzvenyhbu
nnjoiilshoavzwly
aijttlxjrqwaewgk
cvsaujkqfoixarsw
zngtoacpxcsplgal
qhkxliqtokvepcdv
aixihrtdmxkfvcqw
owbgdgdymxhhnoum
tajsagmruwzuakkd
ckrfduwmsodeuebj
alfdhuijuwyufnne
xpchlkijwuftgmnm
rwcrvgphistiihlg
xdaksnorrnkihreq
akeschycpnyyuiug
rgputhzsvngfuovz
lerknhznuxzdhvre
mqiqmyladulbkzve
csnmupielbbpyops
kwgrwgmhfzjbwxxz
npwtvbslvlxvtjsd
zxleuskblzjfmxgf
hexvporkmherrtrn
rhtdhcagicfndmbm
qhnzyuswqwoobuzz
dpvanjuofrbueoza
kjcqujmnhkjdmrrf
gholddsspmxtpybg
jihlvyqdyzkshfsi
zuviqmuqqfmtneur
kzexjowatvkohrtx
wgijnfhibsiruvnl
zevkrkmhsxmicijb
khxrcteqourjvoxa
ylpxlkcnenbxxtta
zrfsvctbojjkpvtw
nlzbudxibnmcrxbt
cqnscphbicqmyrex
ywvdohheukipshcw
riwatbvjqstubssf
idlztqqaxzjiyllu
sdpdgzemlqtizgxn
rjtbovqlgcgojyjx
fnfrfwujmjwdrbdr
osnppzzmrpxmdhtj
ljhwngclvydkwyoe
chwqkrkzrvjwarat
jmydkwpibkvmqlgs
zvhfmbxnlxtujpcz
jsnhsphowlqupqwj
fzhkkbpasthopdev
jerntjdsspdstyhf
gctwmaywbyrzwdxz
xemeaiuzlctijykr
xulrqevtbhplmgxc
yfejfizzsycecqpu
gboxrvvxyzcowtzm
lpvhcxtchwvpgaxp
wdiwucbdyxwnjdqf
qgwoqazzjlvnjrwj
prtlnkakjfqcjngn
fagvxsvjpuvqxniz
xacmxveueaakfbsm
ginvtonnfbnugkpz
qpvggsppewfzvwin
reoqnlzruyyfraxa
kolwtqhifjbbuzor
vrkcywvdhdprztww
ngdvyfmvjqhbzbxt
rooxeoilqzqjunmp
efxmdprtogtxgyqs
qrhjuqndgurcmwgu
ouitjprueefafzpl
kirdwcksqrbwbchp
fpumsmogojuywezo
lgjrgykywugzjees
xigioqcpjabpbdas
ewkhuprpqzikmeop
fgrgxsqeducigxvr
bclkursnqkzmjihl
jozidniwvnqhvsbc
oghcilcyozrmmpta
xbgmaungzcpasapi
iqowypfiayzbcvhv
opdehgwdgkocrgkf
zfzvdjeinlegcjba
vhakxvlcayuzukap
xyradgyiebpevnwe
eamhtflgedwyshkn
igteqdgchjeulfth
kwsfkigxzpbgdxod
vapnpsbdboiewpzp
wbuqhjsngxpqshen
vxxilouxuytitwgm
cpnwlkwnkeanqnet
wdmbtqvvlowftvgb
wjtmcecpyqzwpbqg
jnxmoxdhvsphcdeg
wabxfxpotoywwodn
mwbsoxzlqpqobvvh
coktshbyzjkxnwlt
rzhnggpslwzvyqrp
dgzuqbzarbutlkfx
wunajaiiwgijfvjh
uotdbcgmsvbsfqlb
kxdtlgmqbccjqldb
ngmjzjwvwbegehfr
cvpsabqfpyygwncs
wqluvqlhdhskgmzj
rbveperybfntcfxs
fbmoypqdyyvqyknz
zxpgzwnvmuvkbgov
yexcyzhyrpluxfbj
ltqaihhstpzgyiou
munhsdsfkjebdicd
plecvjctydfbanep
kjrxnnlqrpcieuwx
zbcdtcqakhobuscf
kgovoohchranhmsh
llxufffkyvuxcmfx
tgaswqyzqopfvxtw
kojcqjkdpzvbtjtv
xggdlkmkrsygzcfk
vvitpsnjtdqwyzhh
gcqjuwytlhxsecci
vbsghygcsokphnrg
vejqximdopiztjjm
hudqtwmwkviiuslp
vwswfvpcwwpxlyry
gxmfiehdxptweweq
qjmekjdcedfasopf
pqyxdxtryfnihphf
felnavctjjojdlgp
hbimufguekgdxdac
dhxhtnqgfczywxlr
pssottpdjxkejjrh
edieanguabapxyig
sciinanyqblrbzbb
irxpsorkpcpahiqi
qsxecaykkmtfisei
ivfwlvxlbnrzixff
hqxzzfulfxpmivcw
vvbpaepmhmvqykdg
cetgicjasozykgje
wuetifzdarhwmhji
gaozwhpoickokgby
eldnodziomvdfbuv
favpaqktqaqgixtv
twbcobsayaecyxvu
lzyzjihydpfjgqev
wnurwckqgufskuoh
fxogtycnnmcbgvqz
aetositiahrhzidz
dyklsmlyvgcmtswr
ykaxtdkjqevtttbx
kfmnceyxyhiczzjm
nnizopcndipffpko
yjmznhzyfinpmvkb
sljegcvvbnjhhwdd
zmkeadxlwhfahpwg
rwvcogvegcohcrmx
aguqwrfymwbpscau
vlusytjagzvsnbwe
smvzhburcgvqtklh
rfuprvjkhazrcxpv
megqlnoqmymcrclc
gvldhkewtmlwqvqv
awynhvtyziemnjoa
voprnvtnzspfvpeh
dhlguqwmunbbekih
goayirdhnjrfuiqi
eoghydfykxdslohz
chpippjykogxpbxq
hqbycjweqczwjwgf
pvefsrvwumrlvhmt
eghwdovaynmctktk
crwkxoucibumzawc
bzbtahvhkdigvvtj
bnbptgihhfubxhho
ddqmbwyfmfnjjaro
gvtswqyzazihctif
vmqctjpgadxztqqb
dgnndowtpeooaqqf
sxdvctfdtalufxty
ylgeexosibsmmckw
sxplpyskbpqnojvw
coarhxtsvrontyeg
fyoaurggjupvzvlv
jlyrkqsiwuggvjem
uwbsjoxonreuucyi
gihuqvwxovbgokes
dxzaaxupbcgnxcwf
gidrgmvyrlqqslve
csflmlvqmonoywpx
jkxkpixlythlacnk
ejkarcdkdslldugv
dbzmsusevohhjkmr
cbrqzualjpdtworc
kpgidqlmcbpfmmwu
zwghjuofexfowqam
ncdlxmcrsmsocetz
kfprzqacefifjkbd
swwzivrxulkhvldc
wgqejhigbjwunscp
rsstnwcyybfauqxu
qhngfxyhdqopyfgk
zrndpyyejsmqsiaj
xxknxwpvafxiwwjc
mmaahwgoiwbxloem
tabacndyodmpuovp
yriwomauudscvdce
duvyscvfidmtcugl
mgipxnqlfpjdilge
imeeqcdetjuhfjnw
dvkutrdofpulqkyh
jefvtlktxegpmbya
iyzudqgpvlzjfydh
giohapxnpaqayryd
qheqdprmnqlpztls
rdxhijmzegxkotoq
hdnmaspumdwnrcdz
wafpbgehbuzdgsnc
tbtrfztsferdmhsy
vusndcyjngtkrtmk
ilqblestzxebcifh
urfgjbjgzlrfsdlv
aptcdvpsqwleqttn
bigczjvzokvfofiw
zjnjeufonyqgkbpx
trcdebioegfqrrdi
jrdvdriujlmbqewt
jqrcmuxpwurdhaue
yjlermsgruublkly
zwarvgszuqeesuwq
xthhhqzwvqiyctvs
mzwwaxnbdxhajyyv
nclsozlqrjvqifyi
gcnyqmhezcqvksqw
deuakiskeuwdfxwp
tclkbhqqcydlgrrl
qbpndlfjayowkcrx
apjhkutpoiegnxfx
oaupiimsplsvcsie
sdmxrufyhztxzgmt
ukfoinnlbqrgzdeh
azosvwtcipqzckns
mydyeqsimocdikzn
itfmfjrclmglcrkc
swknpgysfscdrnop
shyyuvvldmqheuiv
tljrjohwhhekyhle
dayinwzuvzimvzjw
qgylixuuervyylur
klqqaiemurawmaaz
hdmzgtxxjabplxvf
xiivzelzdjjtkhnj
ktgplkzblgxwrnvo
gvbpyofzodnknytd
lqhlmnmhakqeffqw
ltzdbngrcxwuxecy
obxnfjeebvovjcjz
zexpwallpocrxpvp
tjpkkmcqbbkxaiak
qiedfixxgvciblih
qcxkhghosuslbyih
gnsfidwhzaxjufgm
xrghwgvyjakkzidw
tftftwedtecglavz
wquqczzkzqrlfngr
twibtkijpvzbsfro
bmplypdsvzuhrjxp
zanrfmestvqpwbuh
zonrhfqowyimcukm
kpvajjfmqpbhrjma
kujzluicngigjbtp
iusguantsrwxdjal
kwxeuylcnszswahw
visdhnkobxnemldu
rogeadmmaicwtabl
pxqycifbgevqudvs
osaiozyvlyddylqr
vffjxrolrpuxcatx
jbmsetccdrywssjd
qgxyhjfpbfifmvgc
npejgalglldxjdhs
mbbtqgmttastrlck
whapaqwdtpkropek
dulbdboxazfyjgkg
xaymnudlozbykgow
lebvqmxeaymkkfoy
bmicnfuubkregouj
dieatyxxxlvhneoj
yglaapcsnsbuvrva
bbpjaslqpzqcwkpk
xehuznbayagrbhnd
ikqmeovaurmqfuvr
ylyokwuzxltvxmgv
hqtfinrkllhqtoiz
pjmhtigznoaejifx
fqdbmowkjtmvvrmx
uvqtqfoulvzozfxv
rpajajukuxtchrjd
sznucejifktvxdre
ufvibsmoushmjbne
xirdqoshngthfvax
iafpkddchsgdqmzl
vmualmlduipvykzh
fnmuahmblwyceejb
ilsaapnswfoymiov
lenvylifraahaclv
cukqxlipuyxedqfh
zgwecslpniqvtvuz
cdcdfpsxuyrhsmag
dszjinhantnxgqra
ioimwotsgnjeacgt
dqcymnvjystbynhp
yibaudyfefbfgunx
cabslcvunjavqkbf
goymzvmgkvlsmugf
zxteiitpthzskjjx
agnxcnaqhjhlurzs
cvmgyxhhnykuxbmb
cgqmjexydmvgwxpp
sygjajofieojiuna
clpvxbrbjvqfbzvu
cbntswqynsdqnhyv
bztpbtwbefiotkfa
pnxccbgajvhyeybu
asyzrvgzumtuissa
facjyblvcqqginxa
rvwnucnbsvberxuv
ghrbeykzrxclasie
ekujtselepgjtaql
krtrzsmduhsifyiw
ticjswvsnyrwhpnt
clmjhsftkfjzwyke
lbxlcixxcztddlam
xhfeekmxgbloguri
azxqwlucwhahtvep
kitdjrwmockhksow
keznwwcusgbtvfrs
ljvzxoywcofgwajj
vebjnhnkcfzbhrcw
eqfcxkavstxcuels
ldattkyawjrvcido
bsqqeilshcwtqyil
foqqsxahfiozcqrw
liswfmuhzfbyzjhf
sulbdcyzmolapfbs
zuggzkelwxjpsgxb
betioxrgtnhpivcw
xmtbixstdipibhgs
ttvurgqmulryyaji
viobnljznzppfmxw
qlzabfopydtxrlet
tusvydegfxhaxolk
thoufvvfjferxhwp
cfyyzppfarjiilbs
jwmhxtgafkkgseqs
pqwuuaxbeklodwpt
vndyveahdiwgkjyx
ssrjgasfhdouwyoh
thbavfcisgvvyekf
yjdvxmubvqadgypa
tlbmcxaelkouhsvu
bonohfnlboxiezzr
rktlxcbkhewyvcjl
rsmoutcbcssodvsc
qszdratuxcrhsvoh
eypyfahpuzqwzwhi
yhkrleqmqlmwdnio
vpnvxusvmngsobmq
hkzyhopvxrsimzys
dblriiwnrvnhxykl
xkriqxkrprjwpncs
rcymltrbszhyhqti
mzbvneplsnpiztzn
vkqtnptgbqefvfoc
nwdtfiaozkcjtlax
crximadpvdaccrsm
lrbajafxwwnxvbei
rbexzesrytpwwmjf
stxwjarildpnzfpg
btamaihdivrhhrrv
acqbucebpaulpotl
dkjhzghxxtxgdpvm
rsbzwsnvlpqzyjir
mizypbwvpgqoiams
nvrslorjpqaasudn
wvexcpzmconqkbvk
rfwfumhjwzrvdzam
eaghdaqorkhdsmth
gtuntmpqaivosewh
nzlsmdgjrigghrmy
dhuvxwobpzbuwjgk
kkcuvbezftvkhebf
aeediumxyljbuyqu
rfkpqeekjezejtjc
wkzasuyckmgwddwy
eixpkpdhsjmynxhi
elrlnndorggmmhmx
ayxwhkxahljoxggy
mtzvvwmwexkberaw
evpktriyydxvdhpx
otznecuqsfagruls
vrdykpyebzyblnut
cnriedolerlhbqjy
uajaprnrrkvggqgx
xdlxuguloojvskjq
mfifrjamczjncuym
otmgvsykuuxrluky
oiuroieurpyejuvm" "\n")
      if (nice-string-p s)
      sum 1)

#+END_SRC

#+RESULTS:
: 53

** Day 6

#+BEGIN_SRC emacs-lisp
(defun tup-to-ind (col row)
 (+ (* 1000 row) col))


(- (tup-to-ind 499 499) (tup-to-ind 500 500))

(defun parse-s (s)
  "turn on
  turn off
  toggle"
  (string-match "\\(\\(?:turn on\\)\\|\\(?:turn off\\)\\|\\(?:toggle\\)\\) \\([0-9]+\\),\\([0-9]+\\) through \\([0-9]+\\),\\([0-9]+\\)" s)
  (list (match-string 1 s)
	(string-to-int (match-string 2 s))
	(string-to-int (match-string 3 s))
	(string-to-int (match-string 4 s))
	(string-to-int (match-string 5 s))))


(let ((lights (make-vector 1000000 0)))

  (loop for s in (split-string "turn off 660,55 through 986,197
turn off 341,304 through 638,850
turn off 199,133 through 461,193
toggle 322,558 through 977,958
toggle 537,781 through 687,941
turn on 226,196 through 599,390
turn on 240,129 through 703,297
turn on 317,329 through 451,798
turn on 957,736 through 977,890
turn on 263,530 through 559,664
turn on 158,270 through 243,802
toggle 223,39 through 454,511
toggle 544,218 through 979,872
turn on 313,306 through 363,621
toggle 173,401 through 496,407
toggle 333,60 through 748,159
turn off 87,577 through 484,608
turn on 809,648 through 826,999
toggle 352,432 through 628,550
turn off 197,408 through 579,569
turn off 1,629 through 802,633
turn off 61,44 through 567,111
toggle 880,25 through 903,973
turn on 347,123 through 864,746
toggle 728,877 through 996,975
turn on 121,895 through 349,906
turn on 888,547 through 931,628
toggle 398,782 through 834,882
turn on 966,850 through 989,953
turn off 891,543 through 914,991
toggle 908,77 through 916,117
turn on 576,900 through 943,934
turn off 580,170 through 963,206
turn on 184,638 through 192,944
toggle 940,147 through 978,730
turn off 854,56 through 965,591
toggle 717,172 through 947,995
toggle 426,987 through 705,998
turn on 987,157 through 992,278
toggle 995,774 through 997,784
turn off 796,96 through 845,182
turn off 451,87 through 711,655
turn off 380,93 through 968,676
turn on 263,468 through 343,534
turn on 917,936 through 928,959
toggle 478,7 through 573,148
turn off 428,339 through 603,624
turn off 400,880 through 914,953
toggle 679,428 through 752,779
turn off 697,981 through 709,986
toggle 482,566 through 505,725
turn off 956,368 through 993,516
toggle 735,823 through 783,883
turn off 48,487 through 892,496
turn off 116,680 through 564,819
turn on 633,865 through 729,930
turn off 314,618 through 571,922
toggle 138,166 through 936,266
turn on 444,732 through 664,960
turn off 109,337 through 972,497
turn off 51,432 through 77,996
turn off 259,297 through 366,744
toggle 801,130 through 917,544
toggle 767,982 through 847,996
turn on 216,507 through 863,885
turn off 61,441 through 465,731
turn on 849,970 through 944,987
toggle 845,76 through 852,951
toggle 732,615 through 851,936
toggle 251,128 through 454,778
turn on 324,429 through 352,539
toggle 52,450 through 932,863
turn off 449,379 through 789,490
turn on 317,319 through 936,449
toggle 887,670 through 957,838
toggle 671,613 through 856,664
turn off 186,648 through 985,991
turn off 471,689 through 731,717
toggle 91,331 through 750,758
toggle 201,73 through 956,524
toggle 82,614 through 520,686
toggle 84,287 through 467,734
turn off 132,367 through 208,838
toggle 558,684 through 663,920
turn on 237,952 through 265,997
turn on 694,713 through 714,754
turn on 632,523 through 862,827
turn on 918,780 through 948,916
turn on 349,586 through 663,976
toggle 231,29 through 257,589
toggle 886,428 through 902,993
turn on 106,353 through 236,374
turn on 734,577 through 759,684
turn off 347,843 through 696,912
turn on 286,699 through 964,883
turn on 605,875 through 960,987
turn off 328,286 through 869,461
turn off 472,569 through 980,848
toggle 673,573 through 702,884
turn off 398,284 through 738,332
turn on 158,50 through 284,411
turn off 390,284 through 585,663
turn on 156,579 through 646,581
turn on 875,493 through 989,980
toggle 486,391 through 924,539
turn on 236,722 through 272,964
toggle 228,282 through 470,581
toggle 584,389 through 750,761
turn off 899,516 through 900,925
turn on 105,229 through 822,846
turn off 253,77 through 371,877
turn on 826,987 through 906,992
turn off 13,152 through 615,931
turn on 835,320 through 942,399
turn on 463,504 through 536,720
toggle 746,942 through 786,998
turn off 867,333 through 965,403
turn on 591,477 through 743,692
turn off 403,437 through 508,908
turn on 26,723 through 368,814
turn on 409,485 through 799,809
turn on 115,630 through 704,705
turn off 228,183 through 317,220
toggle 300,649 through 382,842
turn off 495,365 through 745,562
turn on 698,346 through 744,873
turn on 822,932 through 951,934
toggle 805,30 through 925,421
toggle 441,152 through 653,274
toggle 160,81 through 257,587
turn off 350,781 through 532,917
toggle 40,583 through 348,636
turn on 280,306 through 483,395
toggle 392,936 through 880,955
toggle 496,591 through 851,934
turn off 780,887 through 946,994
turn off 205,735 through 281,863
toggle 100,876 through 937,915
turn on 392,393 through 702,878
turn on 956,374 through 976,636
toggle 478,262 through 894,775
turn off 279,65 through 451,677
turn on 397,541 through 809,847
turn on 444,291 through 451,586
toggle 721,408 through 861,598
turn on 275,365 through 609,382
turn on 736,24 through 839,72
turn off 86,492 through 582,712
turn on 676,676 through 709,703
turn off 105,710 through 374,817
toggle 328,748 through 845,757
toggle 335,79 through 394,326
toggle 193,157 through 633,885
turn on 227,48 through 769,743
toggle 148,333 through 614,568
toggle 22,30 through 436,263
toggle 547,447 through 688,969
toggle 576,621 through 987,740
turn on 711,334 through 799,515
turn on 541,448 through 654,951
toggle 792,199 through 798,990
turn on 89,956 through 609,960
toggle 724,433 through 929,630
toggle 144,895 through 201,916
toggle 226,730 through 632,871
turn off 760,819 through 828,974
toggle 887,180 through 940,310
toggle 222,327 through 805,590
turn off 630,824 through 885,963
turn on 940,740 through 954,946
turn on 193,373 through 779,515
toggle 304,955 through 469,975
turn off 405,480 through 546,960
turn on 662,123 through 690,669
turn off 615,238 through 750,714
turn on 423,220 through 930,353
turn on 329,769 through 358,970
toggle 590,151 through 704,722
turn off 884,539 through 894,671
toggle 449,241 through 984,549
toggle 449,260 through 496,464
turn off 306,448 through 602,924
turn on 286,805 through 555,901
toggle 722,177 through 922,298
toggle 491,554 through 723,753
turn on 80,849 through 174,996
turn off 296,561 through 530,856
toggle 653,10 through 972,284
toggle 529,236 through 672,614
toggle 791,598 through 989,695
turn on 19,45 through 575,757
toggle 111,55 through 880,871
turn off 197,897 through 943,982
turn on 912,336 through 977,605
toggle 101,221 through 537,450
turn on 101,104 through 969,447
toggle 71,527 through 587,717
toggle 336,445 through 593,889
toggle 214,179 through 575,699
turn on 86,313 through 96,674
toggle 566,427 through 906,888
turn off 641,597 through 850,845
turn on 606,524 through 883,704
turn on 835,775 through 867,887
toggle 547,301 through 897,515
toggle 289,930 through 413,979
turn on 361,122 through 457,226
turn on 162,187 through 374,746
turn on 348,461 through 454,675
turn off 966,532 through 985,537
turn on 172,354 through 630,606
turn off 501,880 through 680,993
turn off 8,70 through 566,592
toggle 433,73 through 690,651
toggle 840,798 through 902,971
toggle 822,204 through 893,760
turn off 453,496 through 649,795
turn off 969,549 through 990,942
turn off 789,28 through 930,267
toggle 880,98 through 932,434
toggle 568,674 through 669,753
turn on 686,228 through 903,271
turn on 263,995 through 478,999
toggle 534,675 through 687,955
turn off 342,434 through 592,986
toggle 404,768 through 677,867
toggle 126,723 through 978,987
toggle 749,675 through 978,959
turn off 445,330 through 446,885
turn off 463,205 through 924,815
turn off 417,430 through 915,472
turn on 544,990 through 912,999
turn off 201,255 through 834,789
turn off 261,142 through 537,862
turn off 562,934 through 832,984
turn off 459,978 through 691,980
turn off 73,911 through 971,972
turn on 560,448 through 723,810
turn on 204,630 through 217,854
turn off 91,259 through 611,607
turn on 877,32 through 978,815
turn off 950,438 through 974,746
toggle 426,30 through 609,917
toggle 696,37 through 859,201
toggle 242,417 through 682,572
turn off 388,401 through 979,528
turn off 79,345 through 848,685
turn off 98,91 through 800,434
toggle 650,700 through 972,843
turn off 530,450 through 538,926
turn on 428,559 through 962,909
turn on 78,138 through 92,940
toggle 194,117 through 867,157
toggle 785,355 through 860,617
turn off 379,441 through 935,708
turn off 605,133 through 644,911
toggle 10,963 through 484,975
turn off 359,988 through 525,991
turn off 509,138 through 787,411
toggle 556,467 through 562,773
turn on 119,486 through 246,900
turn on 445,561 through 794,673
turn off 598,681 through 978,921
turn off 974,230 through 995,641
turn off 760,75 through 800,275
toggle 441,215 through 528,680
turn off 701,636 through 928,877
turn on 165,753 through 202,780
toggle 501,412 through 998,516
toggle 161,105 through 657,395
turn on 113,340 through 472,972
toggle 384,994 through 663,999
turn on 969,994 through 983,997
turn on 519,600 through 750,615
turn off 363,899 through 948,935
turn on 271,845 through 454,882
turn off 376,528 through 779,640
toggle 767,98 through 854,853
toggle 107,322 through 378,688
turn off 235,899 through 818,932
turn on 445,611 through 532,705
toggle 629,387 through 814,577
toggle 112,414 through 387,421
toggle 319,184 through 382,203
turn on 627,796 through 973,940
toggle 602,45 through 763,151
turn off 441,375 through 974,545
toggle 871,952 through 989,998
turn on 717,272 through 850,817
toggle 475,711 through 921,882
toggle 66,191 through 757,481
turn off 50,197 through 733,656
toggle 83,575 through 915,728
turn on 777,812 through 837,912
turn on 20,984 through 571,994
turn off 446,432 through 458,648
turn on 715,871 through 722,890
toggle 424,675 through 740,862
toggle 580,592 through 671,900
toggle 296,687 through 906,775" "\n")
        do
	(destructuring-bind (action a b c d)
	    (parse-s s)
	  (loop for x from a to c
		do
		(loop for y from b to d
		      do
		      (cond
		       ((string= action "turn on")
			(setf (aref lights (tup-to-ind y x)) 1))

		       ((string= action "turn off")
			(setf (aref lights (tup-to-ind y x)) 0))

		       ((string= action "toggle")
			(if (= 0 (aref lights (tup-to-ind y x)))
			    (setf (aref lights (tup-to-ind y x)) 1)
			  (setf (aref lights (tup-to-ind y x)) 0))))))))
  (loop for light across lights sum light))

#+END_SRC

#+RESULTS:
: 400410

*** part 2

#+BEGIN_SRC emacs-lisp
(defun tup-to-ind (col row)
 (+ (* 1000 row) col))


(- (tup-to-ind 499 499) (tup-to-ind 500 500))

(defun parse-s (s)
  "turn on
  turn off
  toggle"
  (string-match "\\(\\(?:turn on\\)\\|\\(?:turn off\\)\\|\\(?:toggle\\)\\) \\([0-9]+\\),\\([0-9]+\\) through \\([0-9]+\\),\\([0-9]+\\)" s)
  (list (match-string 1 s)
	(string-to-int (match-string 2 s))
	(string-to-int (match-string 3 s))
	(string-to-int (match-string 4 s))
	(string-to-int (match-string 5 s))))


(let ((lights (make-vector 1000000 0)))

  (loop for s in (split-string "turn off 660,55 through 986,197
turn off 341,304 through 638,850
turn off 199,133 through 461,193
toggle 322,558 through 977,958
toggle 537,781 through 687,941
turn on 226,196 through 599,390
turn on 240,129 through 703,297
turn on 317,329 through 451,798
turn on 957,736 through 977,890
turn on 263,530 through 559,664
turn on 158,270 through 243,802
toggle 223,39 through 454,511
toggle 544,218 through 979,872
turn on 313,306 through 363,621
toggle 173,401 through 496,407
toggle 333,60 through 748,159
turn off 87,577 through 484,608
turn on 809,648 through 826,999
toggle 352,432 through 628,550
turn off 197,408 through 579,569
turn off 1,629 through 802,633
turn off 61,44 through 567,111
toggle 880,25 through 903,973
turn on 347,123 through 864,746
toggle 728,877 through 996,975
turn on 121,895 through 349,906
turn on 888,547 through 931,628
toggle 398,782 through 834,882
turn on 966,850 through 989,953
turn off 891,543 through 914,991
toggle 908,77 through 916,117
turn on 576,900 through 943,934
turn off 580,170 through 963,206
turn on 184,638 through 192,944
toggle 940,147 through 978,730
turn off 854,56 through 965,591
toggle 717,172 through 947,995
toggle 426,987 through 705,998
turn on 987,157 through 992,278
toggle 995,774 through 997,784
turn off 796,96 through 845,182
turn off 451,87 through 711,655
turn off 380,93 through 968,676
turn on 263,468 through 343,534
turn on 917,936 through 928,959
toggle 478,7 through 573,148
turn off 428,339 through 603,624
turn off 400,880 through 914,953
toggle 679,428 through 752,779
turn off 697,981 through 709,986
toggle 482,566 through 505,725
turn off 956,368 through 993,516
toggle 735,823 through 783,883
turn off 48,487 through 892,496
turn off 116,680 through 564,819
turn on 633,865 through 729,930
turn off 314,618 through 571,922
toggle 138,166 through 936,266
turn on 444,732 through 664,960
turn off 109,337 through 972,497
turn off 51,432 through 77,996
turn off 259,297 through 366,744
toggle 801,130 through 917,544
toggle 767,982 through 847,996
turn on 216,507 through 863,885
turn off 61,441 through 465,731
turn on 849,970 through 944,987
toggle 845,76 through 852,951
toggle 732,615 through 851,936
toggle 251,128 through 454,778
turn on 324,429 through 352,539
toggle 52,450 through 932,863
turn off 449,379 through 789,490
turn on 317,319 through 936,449
toggle 887,670 through 957,838
toggle 671,613 through 856,664
turn off 186,648 through 985,991
turn off 471,689 through 731,717
toggle 91,331 through 750,758
toggle 201,73 through 956,524
toggle 82,614 through 520,686
toggle 84,287 through 467,734
turn off 132,367 through 208,838
toggle 558,684 through 663,920
turn on 237,952 through 265,997
turn on 694,713 through 714,754
turn on 632,523 through 862,827
turn on 918,780 through 948,916
turn on 349,586 through 663,976
toggle 231,29 through 257,589
toggle 886,428 through 902,993
turn on 106,353 through 236,374
turn on 734,577 through 759,684
turn off 347,843 through 696,912
turn on 286,699 through 964,883
turn on 605,875 through 960,987
turn off 328,286 through 869,461
turn off 472,569 through 980,848
toggle 673,573 through 702,884
turn off 398,284 through 738,332
turn on 158,50 through 284,411
turn off 390,284 through 585,663
turn on 156,579 through 646,581
turn on 875,493 through 989,980
toggle 486,391 through 924,539
turn on 236,722 through 272,964
toggle 228,282 through 470,581
toggle 584,389 through 750,761
turn off 899,516 through 900,925
turn on 105,229 through 822,846
turn off 253,77 through 371,877
turn on 826,987 through 906,992
turn off 13,152 through 615,931
turn on 835,320 through 942,399
turn on 463,504 through 536,720
toggle 746,942 through 786,998
turn off 867,333 through 965,403
turn on 591,477 through 743,692
turn off 403,437 through 508,908
turn on 26,723 through 368,814
turn on 409,485 through 799,809
turn on 115,630 through 704,705
turn off 228,183 through 317,220
toggle 300,649 through 382,842
turn off 495,365 through 745,562
turn on 698,346 through 744,873
turn on 822,932 through 951,934
toggle 805,30 through 925,421
toggle 441,152 through 653,274
toggle 160,81 through 257,587
turn off 350,781 through 532,917
toggle 40,583 through 348,636
turn on 280,306 through 483,395
toggle 392,936 through 880,955
toggle 496,591 through 851,934
turn off 780,887 through 946,994
turn off 205,735 through 281,863
toggle 100,876 through 937,915
turn on 392,393 through 702,878
turn on 956,374 through 976,636
toggle 478,262 through 894,775
turn off 279,65 through 451,677
turn on 397,541 through 809,847
turn on 444,291 through 451,586
toggle 721,408 through 861,598
turn on 275,365 through 609,382
turn on 736,24 through 839,72
turn off 86,492 through 582,712
turn on 676,676 through 709,703
turn off 105,710 through 374,817
toggle 328,748 through 845,757
toggle 335,79 through 394,326
toggle 193,157 through 633,885
turn on 227,48 through 769,743
toggle 148,333 through 614,568
toggle 22,30 through 436,263
toggle 547,447 through 688,969
toggle 576,621 through 987,740
turn on 711,334 through 799,515
turn on 541,448 through 654,951
toggle 792,199 through 798,990
turn on 89,956 through 609,960
toggle 724,433 through 929,630
toggle 144,895 through 201,916
toggle 226,730 through 632,871
turn off 760,819 through 828,974
toggle 887,180 through 940,310
toggle 222,327 through 805,590
turn off 630,824 through 885,963
turn on 940,740 through 954,946
turn on 193,373 through 779,515
toggle 304,955 through 469,975
turn off 405,480 through 546,960
turn on 662,123 through 690,669
turn off 615,238 through 750,714
turn on 423,220 through 930,353
turn on 329,769 through 358,970
toggle 590,151 through 704,722
turn off 884,539 through 894,671
toggle 449,241 through 984,549
toggle 449,260 through 496,464
turn off 306,448 through 602,924
turn on 286,805 through 555,901
toggle 722,177 through 922,298
toggle 491,554 through 723,753
turn on 80,849 through 174,996
turn off 296,561 through 530,856
toggle 653,10 through 972,284
toggle 529,236 through 672,614
toggle 791,598 through 989,695
turn on 19,45 through 575,757
toggle 111,55 through 880,871
turn off 197,897 through 943,982
turn on 912,336 through 977,605
toggle 101,221 through 537,450
turn on 101,104 through 969,447
toggle 71,527 through 587,717
toggle 336,445 through 593,889
toggle 214,179 through 575,699
turn on 86,313 through 96,674
toggle 566,427 through 906,888
turn off 641,597 through 850,845
turn on 606,524 through 883,704
turn on 835,775 through 867,887
toggle 547,301 through 897,515
toggle 289,930 through 413,979
turn on 361,122 through 457,226
turn on 162,187 through 374,746
turn on 348,461 through 454,675
turn off 966,532 through 985,537
turn on 172,354 through 630,606
turn off 501,880 through 680,993
turn off 8,70 through 566,592
toggle 433,73 through 690,651
toggle 840,798 through 902,971
toggle 822,204 through 893,760
turn off 453,496 through 649,795
turn off 969,549 through 990,942
turn off 789,28 through 930,267
toggle 880,98 through 932,434
toggle 568,674 through 669,753
turn on 686,228 through 903,271
turn on 263,995 through 478,999
toggle 534,675 through 687,955
turn off 342,434 through 592,986
toggle 404,768 through 677,867
toggle 126,723 through 978,987
toggle 749,675 through 978,959
turn off 445,330 through 446,885
turn off 463,205 through 924,815
turn off 417,430 through 915,472
turn on 544,990 through 912,999
turn off 201,255 through 834,789
turn off 261,142 through 537,862
turn off 562,934 through 832,984
turn off 459,978 through 691,980
turn off 73,911 through 971,972
turn on 560,448 through 723,810
turn on 204,630 through 217,854
turn off 91,259 through 611,607
turn on 877,32 through 978,815
turn off 950,438 through 974,746
toggle 426,30 through 609,917
toggle 696,37 through 859,201
toggle 242,417 through 682,572
turn off 388,401 through 979,528
turn off 79,345 through 848,685
turn off 98,91 through 800,434
toggle 650,700 through 972,843
turn off 530,450 through 538,926
turn on 428,559 through 962,909
turn on 78,138 through 92,940
toggle 194,117 through 867,157
toggle 785,355 through 860,617
turn off 379,441 through 935,708
turn off 605,133 through 644,911
toggle 10,963 through 484,975
turn off 359,988 through 525,991
turn off 509,138 through 787,411
toggle 556,467 through 562,773
turn on 119,486 through 246,900
turn on 445,561 through 794,673
turn off 598,681 through 978,921
turn off 974,230 through 995,641
turn off 760,75 through 800,275
toggle 441,215 through 528,680
turn off 701,636 through 928,877
turn on 165,753 through 202,780
toggle 501,412 through 998,516
toggle 161,105 through 657,395
turn on 113,340 through 472,972
toggle 384,994 through 663,999
turn on 969,994 through 983,997
turn on 519,600 through 750,615
turn off 363,899 through 948,935
turn on 271,845 through 454,882
turn off 376,528 through 779,640
toggle 767,98 through 854,853
toggle 107,322 through 378,688
turn off 235,899 through 818,932
turn on 445,611 through 532,705
toggle 629,387 through 814,577
toggle 112,414 through 387,421
toggle 319,184 through 382,203
turn on 627,796 through 973,940
toggle 602,45 through 763,151
turn off 441,375 through 974,545
toggle 871,952 through 989,998
turn on 717,272 through 850,817
toggle 475,711 through 921,882
toggle 66,191 through 757,481
turn off 50,197 through 733,656
toggle 83,575 through 915,728
turn on 777,812 through 837,912
turn on 20,984 through 571,994
turn off 446,432 through 458,648
turn on 715,871 through 722,890
toggle 424,675 through 740,862
toggle 580,592 through 671,900
toggle 296,687 through 906,775" "\n")
        do
	(destructuring-bind (action a b c d)
	    (parse-s s)
	  (loop for x from a to c
		do
		(loop for y from b to d
		      do
		      (cond
		       ((string= action "turn on")
			(setf (aref lights (tup-to-ind y x)) (+ (aref lights (tup-to-ind y x)) 1)))

		       ((string= action "turn off")
			(setf (aref lights (tup-to-ind y x)) (max 0 (- (aref lights (tup-to-ind y x)) 1))))

		       ((string= action "toggle")
			(setf (aref lights (tup-to-ind y x)) (+ (aref lights (tup-to-ind y x)) 2))))))))
  (loop for light across lights sum light))
#+END_SRC
#+RESULTS:
: 15343601
** Day 6

#+BEGIN_SRC emacs-lisp
(let* ((x 123)
       (y 456)
       (d (logand x y))
       (e (logior x y))
       (f (ash x 2))
       (g (ash y -2))
       (h (+ 65536 (lognot x)))
       (i (+ 65536 (lognot y))))
  (list d e f g h i x y)
  )

#+END_SRC

#+RESULTS:
| 72 | 507 | 492 | 114 | 65412 | 65079 | 123 | 456 |

1. Split on ->
   a. (nth 1) is what gets set
   b. (nth 0) is the command.

2. split (nth 0) on " ".
   a. len=1, numeric

   b. len=2, starts with NOT

   c. len=3, label operator label

#+BEGIN_SRC emacs-lisp
(setq nodes '())

(defun parse-cmd (s)
  (let* ((fields (split-string s "->" t " "))
	 (endpt (nth 1 fields))
	 (command (nth 0 fields))
	 (cmd-parts (split-string command " " t " "))
	 output)
    ;(message-box "%S" cmd-parts)
    (cond
     ((= 1 (length cmd-parts))
      (setq output (string-to-number (nth 0 cmd-parts)))
      (add-to-list 'nodes `(,endpt . ,output)))

     ((and (string= "NOT" (car cmd-parts))
	   (= 2 (length cmd-parts)))
      (setq output (+ 65536 (lognot (cdr (assoc (nth 1 cmd-parts) nodes)))))
      (add-to-list 'nodes (cons endpt output)))

     ((= 3 (length cmd-parts))
      (let ((op (nth 1 cmd-parts))
	    arg1 arg2 result)
	(setq result
	      (cond
	       ((string= "AND" op)
		(setq arg1 (cdr (assoc (nth 0 cmd-parts) nodes)))
		(setq arg2 (cdr (assoc (nth 2 cmd-parts) nodes)))
		(logand arg1 arg2))
	       ((string= "OR" op)
		(setq arg1 (cdr (assoc (nth 0 cmd-parts) nodes)))
		(setq arg2 (cdr (assoc (nth 2 cmd-parts) nodes)))
		(logior arg1 arg2))
	       ((string= "LSHIFT" op)
		(setq arg1 (cdr (assoc (nth 0 cmd-parts) nodes)))
		(setq arg2 (string-to-int (nth 2 cmd-parts)))
		(ash arg1 arg2))
	       ((string= "RSHIFT" op)
		(setq arg1 (cdr (assoc (nth 0 cmd-parts) nodes)))
		(setq arg2 (string-to-int (nth 2 cmd-parts)))
		(ash arg1 (* -1 arg2)))))
	(add-to-list 'nodes (cons endpt result)))))))


(loop for cmd in (split-string "lf AND lq -> ls
iu RSHIFT 1 -> jn
bo OR bu -> bv
gj RSHIFT 1 -> hc
et RSHIFT 2 -> eu
bv AND bx -> by
is OR it -> iu
b OR n -> o
gf OR ge -> gg
NOT kt -> ku
ea AND eb -> ed
kl OR kr -> ks
hi AND hk -> hl
au AND av -> ax
lf RSHIFT 2 -> lg
dd RSHIFT 3 -> df
eu AND fa -> fc
df AND dg -> di
ip LSHIFT 15 -> it
NOT el -> em
et OR fe -> ff
fj LSHIFT 15 -> fn
t OR s -> u
ly OR lz -> ma
ko AND kq -> kr
NOT fx -> fy
et RSHIFT 1 -> fm
eu OR fa -> fb
dd RSHIFT 2 -> de
NOT go -> gp
kb AND kd -> ke
hg OR hh -> hi
jm LSHIFT 1 -> kg
NOT cn -> co
jp RSHIFT 2 -> jq
jp RSHIFT 5 -> js
1 AND io -> ip
eo LSHIFT 15 -> es
1 AND jj -> jk
g AND i -> j
ci RSHIFT 3 -> ck
gn AND gp -> gq
fs AND fu -> fv
lj AND ll -> lm
jk LSHIFT 15 -> jo
iu RSHIFT 3 -> iw
NOT ii -> ij
1 AND cc -> cd
bn RSHIFT 3 -> bp
NOT gw -> gx
NOT ft -> fu
jn OR jo -> jp
iv OR jb -> jc
hv OR hu -> hw
19138 -> b
gj RSHIFT 5 -> gm
hq AND hs -> ht
dy RSHIFT 1 -> er
ao OR an -> ap
ld OR le -> lf
bk LSHIFT 1 -> ce
bz AND cb -> cc
bi LSHIFT 15 -> bm
il AND in -> io
af AND ah -> ai
as RSHIFT 1 -> bl
lf RSHIFT 3 -> lh
er OR es -> et
NOT ax -> ay
ci RSHIFT 1 -> db
et AND fe -> fg
lg OR lm -> ln
k AND m -> n
hz RSHIFT 2 -> ia
kh LSHIFT 1 -> lb
NOT ey -> ez
NOT di -> dj
dz OR ef -> eg
lx -> a
NOT iz -> ja
gz LSHIFT 15 -> hd
ce OR cd -> cf
fq AND fr -> ft
at AND az -> bb
ha OR gz -> hb
fp AND fv -> fx
NOT gb -> gc
ia AND ig -> ii
gl OR gm -> gn
0 -> c
NOT ca -> cb
bn RSHIFT 1 -> cg
c LSHIFT 1 -> t
iw OR ix -> iy
kg OR kf -> kh
dy OR ej -> ek
km AND kn -> kp
NOT fc -> fd
hz RSHIFT 3 -> ib
NOT dq -> dr
NOT fg -> fh
dy RSHIFT 2 -> dz
kk RSHIFT 2 -> kl
1 AND fi -> fj
NOT hr -> hs
jp RSHIFT 1 -> ki
bl OR bm -> bn
1 AND gy -> gz
gr AND gt -> gu
db OR dc -> dd
de OR dk -> dl
as RSHIFT 5 -> av
lf RSHIFT 5 -> li
hm AND ho -> hp
cg OR ch -> ci
gj AND gu -> gw
ge LSHIFT 15 -> gi
e OR f -> g
fp OR fv -> fw
fb AND fd -> fe
cd LSHIFT 15 -> ch
b RSHIFT 1 -> v
at OR az -> ba
bn RSHIFT 2 -> bo
lh AND li -> lk
dl AND dn -> do
eg AND ei -> ej
ex AND ez -> fa
NOT kp -> kq
NOT lk -> ll
x AND ai -> ak
jp OR ka -> kb
NOT jd -> je
iy AND ja -> jb
jp RSHIFT 3 -> jr
fo OR fz -> ga
df OR dg -> dh
gj RSHIFT 2 -> gk
gj OR gu -> gv
NOT jh -> ji
ap LSHIFT 1 -> bj
NOT ls -> lt
ir LSHIFT 1 -> jl
bn AND by -> ca
lv LSHIFT 15 -> lz
ba AND bc -> bd
cy LSHIFT 15 -> dc
ln AND lp -> lq
x RSHIFT 1 -> aq
gk OR gq -> gr
NOT kx -> ky
jg AND ji -> jj
bn OR by -> bz
fl LSHIFT 1 -> gf
bp OR bq -> br
he OR hp -> hq
et RSHIFT 5 -> ew
iu RSHIFT 2 -> iv
gl AND gm -> go
x OR ai -> aj
hc OR hd -> he
lg AND lm -> lo
lh OR li -> lj
da LSHIFT 1 -> du
fo RSHIFT 2 -> fp
gk AND gq -> gs
bj OR bi -> bk
lf OR lq -> lr
cj AND cp -> cr
hu LSHIFT 15 -> hy
1 AND bh -> bi
fo RSHIFT 3 -> fq
NOT lo -> lp
hw LSHIFT 1 -> iq
dd RSHIFT 1 -> dw
dt LSHIFT 15 -> dx
dy AND ej -> el
an LSHIFT 15 -> ar
aq OR ar -> as
1 AND r -> s
fw AND fy -> fz
NOT im -> in
et RSHIFT 3 -> ev
1 AND ds -> dt
ec AND ee -> ef
NOT ak -> al
jl OR jk -> jm
1 AND en -> eo
lb OR la -> lc
iu AND jf -> jh
iu RSHIFT 5 -> ix
bo AND bu -> bw
cz OR cy -> da
iv AND jb -> jd
iw AND ix -> iz
lf RSHIFT 1 -> ly
iu OR jf -> jg
NOT dm -> dn
lw OR lv -> lx
gg LSHIFT 1 -> ha
lr AND lt -> lu
fm OR fn -> fo
he RSHIFT 3 -> hg
aj AND al -> am
1 AND kz -> la
dy RSHIFT 5 -> eb
jc AND je -> jf
cm AND co -> cp
gv AND gx -> gy
ev OR ew -> ex
jp AND ka -> kc
fk OR fj -> fl
dy RSHIFT 3 -> ea
NOT bs -> bt
NOT ag -> ah
dz AND ef -> eh
cf LSHIFT 1 -> cz
NOT cv -> cw
1 AND cx -> cy
de AND dk -> dm
ck AND cl -> cn
x RSHIFT 5 -> aa
dv LSHIFT 1 -> ep
he RSHIFT 2 -> hf
NOT bw -> bx
ck OR cl -> cm
bp AND bq -> bs
as OR bd -> be
he AND hp -> hr
ev AND ew -> ey
1 AND lu -> lv
kk RSHIFT 3 -> km
b AND n -> p
NOT kc -> kd
lc LSHIFT 1 -> lw
km OR kn -> ko
id AND if -> ig
ih AND ij -> ik
jr AND js -> ju
ci RSHIFT 5 -> cl
hz RSHIFT 1 -> is
1 AND ke -> kf
NOT gs -> gt
aw AND ay -> az
x RSHIFT 2 -> y
ab AND ad -> ae
ff AND fh -> fi
ci AND ct -> cv
eq LSHIFT 1 -> fk
gj RSHIFT 3 -> gl
u LSHIFT 1 -> ao
NOT bb -> bc
NOT hj -> hk
kw AND ky -> kz
as AND bd -> bf
dw OR dx -> dy
br AND bt -> bu
kk AND kv -> kx
ep OR eo -> eq
he RSHIFT 1 -> hx
ki OR kj -> kk
NOT ju -> jv
ek AND em -> en
kk RSHIFT 5 -> kn
NOT eh -> ei
hx OR hy -> hz
ea OR eb -> ec
s LSHIFT 15 -> w
fo RSHIFT 1 -> gh
kk OR kv -> kw
bn RSHIFT 5 -> bq
NOT ed -> ee
1 AND ht -> hu
cu AND cw -> cx
b RSHIFT 5 -> f
kl AND kr -> kt
iq OR ip -> ir
ci RSHIFT 2 -> cj
cj OR cp -> cq
o AND q -> r
dd RSHIFT 5 -> dg
b RSHIFT 2 -> d
ks AND ku -> kv
b RSHIFT 3 -> e
d OR j -> k
NOT p -> q
NOT cr -> cs
du OR dt -> dv
kf LSHIFT 15 -> kj
NOT ac -> ad
fo RSHIFT 5 -> fr
hz OR ik -> il
jx AND jz -> ka
gh OR gi -> gj
kk RSHIFT 1 -> ld
hz RSHIFT 5 -> ic
as RSHIFT 2 -> at
NOT jy -> jz
1 AND am -> an
ci OR ct -> cu
hg AND hh -> hj
jq OR jw -> jx
v OR w -> x
la LSHIFT 15 -> le
dh AND dj -> dk
dp AND dr -> ds
jq AND jw -> jy
au OR av -> aw
NOT bf -> bg
z OR aa -> ab
ga AND gc -> gd
hz AND ik -> im
jt AND jv -> jw
z AND aa -> ac
jr OR js -> jt
hb LSHIFT 1 -> hv
hf OR hl -> hm
ib OR ic -> id
fq OR fr -> fs
cq AND cs -> ct
ia OR ig -> ih
dd OR do -> dp
d AND j -> l
ib AND ic -> ie
as RSHIFT 3 -> au
be AND bg -> bh
dd AND do -> dq
NOT l -> m
1 AND gd -> ge
y AND ae -> ag
fo AND fz -> gb
NOT ie -> if
e AND f -> h
x RSHIFT 3 -> z
y OR ae -> af
hf AND hl -> hn
NOT h -> i
NOT hn -> ho
he RSHIFT 5 -> hh" "\n")
 do
(message-box cmd)
(parse-cmd cmd))


(assoc "a" nodes)
#+END_SRC
#+RESULTS:

* Section links.

#+BEGIN_SRC python
print 'hello world'
#+END_SRC

#+RESULTS:
: hello world

#+BEGIN_SRC emacs-lisp
(setq org-latex-prefer-user-labels t)
#+END_SRC

#+RESULTS:
: t

#+BEGIN_EXAMPLE
I want reference to Section 1.1 from here (See [[sec:section-1]]).
#+END_EXAMPLE

Here's the code:
#+BEGIN_SRC emacs-lisp
;; Link types for targeting sections, tables, etc.
;; These assume that headlines with CUSTOM_ID defined will export using
;; that value as their \label keys.




; Sections:
(org-add-link-type
 "sec"
 (lambda (path)
   (org-open-link-from-string (format "[[#%s]]" path)))
 (lambda (path desc format)
   (cond
    ((eq format 'latex)
     (format "%s~\\ref{%s}" (or desc "Section") path)))))

; etc. etc.
#+END_SRC

In sec:test-section you can see it work.

** test section
   :PROPERTIES:
   :CUSTOM_ID: test-section
   :END:

* SBCL

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((lisp . t)))

(setq inferior-lisp-program "/usr/local/bin/sbcl")
(require 'slime)
(slime-setup)
(slime)
#+END_SRC

#+RESULTS:
: #<buffer *inferior-lisp*>

#+BEGIN_SRC lisp
(princ "hello world")
#+END_SRC

#+RESULTS:
: hello world

:

#+BEGIN_SRC lisp
(defun counter-class ()
 (let ((counter 0))
  (lambda () (setq counter (+ 1 counter)))))

(print (funcall (counter-class)))
(print (funcall (counter-class)))
#+END_SRC

#+RESULTS:
:
: 1
: 1

#+BEGIN_SRC lisp
(setq counter
 (let ((i 0))
  (lambda () (setq i (+ 1 i)))))

(print (funcall counter))
(print (funcall counter))
(print (funcall counter))
#+END_SRC

#+RESULTS:
:
: 1
: 2
: 3

* A quick example with Racket
  :PROPERTIES:
  :ID:       92A1A2C9-EF89-4AAC-AC15-D5F2DAC7A38F
  :END:

#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:racket (body params)
  (let* ((tangle (cdr (assoc :tangle params)))
         (script-file
          (if (string-equal tangle "no")
              (org-babel-temp-file "org-babel-" ".rkt")
            tangle)))
    (with-temp-file script-file
      (insert body))
    (let* ((pn (org-babel-process-file-name script-file))
           (cmd (format "racket -u %s" pn)))
      (message cmd)
      (shell-command-to-string cmd))))
#+END_SRC

#+RESULTS:
: org-babel-execute:racket

#+BEGIN_SRC racket
#lang racket
(printf "Hello world and John!")
#+END_SRC

#+RESULTS:
: Hello world and John!

It works!

Here is the total lispy way to write the code, i.e. without the #lang sugar at the top. The only downside I see is the extra indentation.
#+BEGIN_SRC racket
(module main racket
  (printf "Hello world and John!"))
#+END_SRC

#+RESULTS:
: Hello world and John!

#+BEGIN_SRC racket
#lang racket
;; Finds org-files in all subdirs
(for ([path (in-directory)]
      #:when (regexp-match? #rx"[.]org$" path))
  (printf "source file: ~a\n" path))
#+END_SRC

#+RESULTS:


** Scribble example
This does not work...
#+BEGIN_SRC racket
(module main scribble/base

@title{On the Cookie-Eating Habits of Mice}

If you give a mouse a cookie, he's going to ask for a
glass of milk.)
#+END_SRC
#+RESULTS:
: /var/folders/5q/lllv2yf95hg_n6h6kjttbmdw0000gn/T/babel-31544SRD/org-babel-3154419i.rkt:1:0: module: no #%module-begin binding in the module's language
:   in: (module main scribble/base @title (On the Cookie-Eating Habits of Mice) If you give a mouse a cookie (unquote he) (quote s) going to ask for a glass of milk.)
:   context...:
:    standard-module-name-resolver

* insert timestamp based on past stamp
[2015-11-30 Mon]


#+BEGIN_SRC emacs-lisp
(defun insert-ts+7 ()
  (interactive)
  (insert
   (concat "["
	   (save-excursion
	     (re-search-backward
	      (org-re-timestamp 'all))
	     (match-string 0)))
   "]")
  (org-timestamp-change 7 'day))

#+END_SRC

#+RESULTS:

[2015-12-07 Mon]   [2015-12-14 Mon]

* rerun all blocks
** Greeting

#+BEGIN_SRC sh
  echo "Hello $USER! Today is `date`"
#+END_SRC

#+RESULTS:
: Hello jkitchin! Today is Mon Nov 30 14:15:08 EST 2015

** Current directory

#+BEGIN_SRC sh
  pwd
#+END_SRC

#+RESULTS:
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog

** Rerun all src blocks

#+BEGIN_SRC emacs-lisp
(defun run-blocks ()
  (interactive)
  (save-excursion
    (org-element-map (org-element-parse-buffer) 'src-block
      (lambda (src-block)
	(goto-char (org-element-property :begin src-block))
	(org-babel-execute-src-block)))))


#+END_SRC

#+RESULTS:
: run-blocks


#+BEGIN_SRC emacs-lisp
(defun run-blocks-2 ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^#\\+BEGIN_SRC" nil t)
      (org-babel-execute-src-block))))

(current-time-string)
#+END_SRC
#+RESULTS:
: Mon Nov 30 14:15:08 2015

* Search sentence at point
  :PROPERTIES:
  :ID:       586FD7C7-09F0-4E9F-8852-7C3E901FB273
  :END:

We take the sentence at point, maybe do some analysis on it.

What about data mining and artifical intelligence?

#+BEGIN_SRC emacs-lisp
(defun sentence-at-point ()
  (interactive)
  (save-window-excursion
    (let ((sentence (thing-at-point 'sentence)))
      (when sentence
	(switch-to-buffer-other-window "*agent*")
	(erase-buffer)
	(insert sentence)))))

(defun sentence-google-suggest ()
  (interactive)
  (helm '(helm-source-google-suggest)
	(thing-at-point 'sentence)
	nil nil nil
	"*helm google*"))
#+END_SRC

#+RESULTS:
: sentence-google-suggest

#+BEGIN_SRC emacs-lisp
(helm-google-suggest-emacs-lisp)
#+END_SRC

#+RESULTS:
| emacs lisp if | emacs lisp tutorial | emacs lisp let | emacs lisp mode | emacs lisp print | emacs lisp reference | emacs lisp regex | emacs lisp if else | emacs lisp interactive | emacs lisp interpreter | (Search for 'helm googl' on Google . helm googl) |

* cisco chat
  :PROPERTIES:
  :ID:       802FAC52-FBCB-4EB0-931E-03FC09E77A34
  :END:

#+BEGIN_SRC emacs-lisp
(do-applescript
   (format "tell application \"Cisco Jabber\"
	activate
	tell application \"System Events\" to keystroke \"n\" using {shift down, command down}
	tell application \"System Events\" to keystroke \"%s\"

end tell" "biegler"))
#+END_SRC


#+BEGIN_SRC emacs-lisp
; http://macbiblioblog.blogspot.com/2014/12/key-codes-for-function-and-special-keys.html
(defun cisco-chat (query)

  (interactive "s? ")

  (do-applescript
   (format "tell application \"Cisco Jabber\"
	activate
	tell application \"System Events\" to keystroke \"n\" using {shift down, command down}
	tell application \"System Events\" to keystroke \"%s\"
        delay 3
        tell application \"System Events\" to key code 124 #right
tell application \"System Events\" to key code 36 #return
end tell" query)))

(cisco-chat "biegler")

(cisco-call "412-266-5017")
#+END_SRC

#+RESULTS:

* Backend dependent inline src export
  :PROPERTIES:
  :ID:       FC2B7B6C-A1E3-46F4-AED5-4EF488002899
  :END:

#+BEGIN_SRC emacs-lisp
(setq org-export-babel-evaluate 'inline-only)

(defun foo (arg1 arg2)
  (cond
   ((eq 'html org-export-current-backend)
    (format "@@html:<a href=\"http://some.place/%s\">%s</a>@@" arg1 arg2))
   (t
    (format "[[%s:%s][%s]]" arg1 arg2 arg2))))

(org-html-export-as-html nil nil nil t)
(with-current-buffer "*Org HTML Export*" (buffer-string))
#+END_SRC

#+RESULTS:
#+begin_example
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Backend dependent inline src export</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> org-export-babel-evaluate 'inline-only)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">foo</span> (arg1 arg2)
  (<span style="color: #0000FF;">cond</span>
   ((eq 'html org-export-current-backend)
    (format <span style="color: #008000;">"@@html:&lt;a href=\"http://some.place/%s\"&gt;%s&lt;/a&gt;@@"</span> arg1 arg2))
   (t
    (format <span style="color: #008000;">"[[%s:%s][%s]]"</span> arg1 arg2 arg2))))

(org-html-export-as-html nil nil nil t)
(<span style="color: #0000FF;">with-current-buffer</span> <span style="color: #008000;">"*Org HTML Export*"</span> (buffer-string))
</pre>
</div>

<pre class="example">
&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Backend dependent inline src export&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; org-export-babel-evaluate 'inline-only)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;foo&lt;/span&gt; (arg1 arg2)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq 'html org-export-current-backend)
    (format &lt;span style="color: #008000;"&gt;"&amp;lt;a href=\"http://some.place/%s\"&amp;gt;%s&amp;lt;/a&amp;gt;"&lt;/span&gt; arg1 arg2))
   (t
    (format &lt;span style="color: #008000;"&gt;"[[%s:%s][%s]]"&lt;/span&gt; arg1 arg2 arg2))))

(org-html-export-as-html nil nil nil t)
(&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"*Org HTML Export*"&lt;/span&gt; (buffer-string))
&lt;/pre&gt;
&lt;/div&gt;





&lt;p&gt;
&amp;lt;a href="&lt;a href="http://some.place/info"&gt;http://some.place/info&lt;/a&gt;"&amp;gt;org&amp;lt;/a&amp;gt; &lt;a href="org"&gt;org&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
It doesn't quite work that we get what we want. The html code gets escaped so the tags don't actually work.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</pre>





<p>
<a href="http://some.place/info">org</a> <a href="org">org</a>
</p>

<p>
It doesn't quite work that we get what we want. The html code gets escaped so the tags don't actually work.</p>
</div>
</div>
#+end_example





src_emacs-lisp[:results org]{(foo "info" "org")} #+BEGIN_SRC org
[[info:org][org]]#+END_SRC



It doesn't quite work that we get what we want. The html code gets escaped so the tags don't actually work.

* Asynchronous shell commands

#+BEGIN_SRC emacs-lisp
(defun org-babel-async-execute:sh ()
  "Execute the shell src-block at point asynchronously.
:var headers are supported.
:results output is all that is supported for output.

A new window will pop up showing you the output as it appears,
and the output in that window will be put in the RESULTS section
of the code block."
  (interactive)
  (let* ((current-file (buffer-file-name))
	 (uuid (org-id-uuid))
	 (code (org-element-property :value (org-element-context)))
	 (temporary-file-directory ".")
	 (tempfile (make-temp-file "sh-"))
	 (pbuffer (format "*%s*" uuid))
	 (varcmds (org-babel-variable-assignments:sh
		   (nth 2 (org-babel-get-src-block-info))))
	 process)

    ;; get rid of old results, and put a place-holder for the new results to
    ;; come.
    (org-babel-remove-result)

    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))

    ;; open the results buffer to see the results in.
    (switch-to-buffer-other-window pbuffer)

    ;; Create temp file containing the code.
    (with-temp-file tempfile
      ;; if there are :var headers insert them.
      (dolist (cmd varcmds)
	(insert cmd)
	(insert "\n"))
      (insert code))

    ;; run the code
    (setq process (start-process
		   uuid
		   pbuffer
		   "bash"
		   tempfile))

    ;; when the process is done, run this code to put the results in the
    ;; org-mode buffer.
    (set-process-sentinel
     process
     `(lambda (process event)
	(save-window-excursion
	  (save-excursion
	    (save-restriction
	      (with-current-buffer (find-file-noselect ,current-file)
		(goto-char (point-min))
		(re-search-forward ,uuid)
		(beginning-of-line)
		(kill-line)
		(insert
		 (mapconcat
		  (lambda (x)
		    (format ": %s" x))
		  (butlast (split-string
			    (with-current-buffer
				,pbuffer
			      (buffer-string))
			    "\n"))
		  "\n"))))))
	;; delete the results buffer then delete the tempfile.
	;; finally, delete the process.
	(when (get-buffer ,pbuffer)
	  (kill-buffer ,pbuffer)
	  (delete-window))
	(delete-file ,tempfile)
	(delete-process process)))))
#+END_SRC
#+RESULTS:
: org-babel-async-execute:sh

#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:sh (body params)
  "Execute a block of Shell commands with Babel.
This function is called by `org-babel-execute-src-block'."
  (let* ((session (org-babel-sh-initiate-session
		   (cdr (assoc :session params))))
	 (async (assoc :async params))
	 (stdin (let ((stdin (cdr (assoc :stdin params))))
                  (when stdin (org-babel-sh-var-to-string
                               (org-babel-ref-resolve stdin)))))
         (full-body (org-babel-expand-body:generic
		     body params (org-babel-variable-assignments:sh params))))
    (if async
	;; run asynchronously
	(org-babel-async-execute:sh)
      ;; else run regularly
      (org-babel-reassemble-table
       (org-babel-sh-evaluate session full-body params stdin)
       (org-babel-pick-name
	(cdr (assoc :colname-names params)) (cdr (assoc :colnames params)))
       (org-babel-pick-name
	(cdr (assoc :rowname-names params)) (cdr (assoc :rownames params)))))))'
#+END_SRC

#+RESULTS:
: org-babel-execute:sh

#+BEGIN_SRC sh :async :var="."
ls $data
#+END_SRC


#+BEGIN_SRC sh :session shtest
data=$(ls)
#+END_SRC
#+RESULTS:

#+BEGIN_SRC sh :session
$data
#+END_SRC
#+RESULTS:

* [[http://emacs-fu.blogspot.com/2009/05/getting-your-ip-address.html][emacs-fu: getting your ip-address]]
  :PROPERTIES:
  :ID:       C6C83773-FB4D-4B99-995A-103FA9BBE9ED
  :END:

#+BEGIN_SRC emacs-lisp
(defun get-ip-address (&optional dev)
  "get the IP-address for device DEV (default: eth0)"
  (let ((dev (if dev dev "eth0")))
    (format-network-address (car (network-interface-info dev)) t)))

(get-ip-address)

(format-network-address (car (network-interface-info "en0")) t)
#+END_SRC

#+RESULTS:
: 192.168.1.154

* unlatexifying strings in org-ref
  :PROPERTIES:
  :ID:       A67A0F6A-EEB3-430C-BB99-92646902292A
  :END:

cite:zou-2014-cobal-embed

#+BEGIN_SRC emacs-lisp
(find-file (car org-ref-default-bibliography))
(bibtex-search-entry "zhuo-2010-co2-induc")
(bibtex-set-dialect (parsebib-find-bibtex-dialect) t)
(let ((s (org-ref-bib-citation)))
(setq s (replace-regexp-in-string "  " " " s))
(loop for (pattern repl) in
      '(("{\\\\'i}" "í")
	("{\\\\ae}" "æ")
	("{\\\\'c}" "ć")
	("{\\\\'e}" "é")
	("{\\\\\"a}" "ä")
	("{\\\\`e}" "è")
	("{\\\\`a}" "à")
	("{\\\\'a}" "á")
	("{\\\\o}" "ø")
	("{\\\\\"e}" "ë")
	("{\\\\\"u}" "ü")
	("{\\\\~n}" "ñ")
	("{\\\\c{n}}" "ņ")
	("{\\\\~n}" "ñ")
	("{\\\\aa}" "å")
	("{\\\\\"o}" "ö")
	("{\\\\'A}" "Á")
	("{\\\\'i}" "í")
	("{\\\\'o}" "ó")
	("{\\\\'o}" "ó")
	("{\\\\'u}" "ú")
	("{\\\\'u}" "ú")
	("{\\\\v{s}}" "š")
	("{\\\\v s}" "š")
	("{\\\\v{r}}" "ř")
	("{\\\\.I}" "İ")
	("{\\\\u{g}}" "ğ")
	("$\\\\delta$" "δ")
	("{\\\\c{c}}" "ç")
	("{\\\\ss}" "ß")
	("$\\\\le$" "≤")
	("$\\\\ge$" "≥")
	("$<$" "<")
	("$\\\\theta$" "θ")
	("$\\\\mu$" "μ")
	("$\\\\rightarrow$" "→")
	("$\\\\leftrightharpoons$" "⇌")
	("$\\\\times$" "×")
	("$\\\\deg$" "°")
	("{\\\\c{s}}" "ş")
	("$\\\\gamma$" "γ")
	("$\\\\gamma$" "ɣ")
	("degC" "º")
	("$\\\\eta$" "η")
	("$\\\\mu$" "µ")
	("$\\\\alpha$" "α")
	("$\\\\beta$" "β")
	("$\\\\epsilon$" "ɛ")
	("\\textrm{VI}" "Ⅵ")
	("\\textrm{III}" "Ⅲ")
	("\\textrm{V}" "Ⅴ")
	("$\\\\lambda$" "λ")
	("$\\\\pi$" "π")
	("$\\\\infty$" "∞")
	("$\\\\chi$" "χ")
	("\\\\textasciitilde{}" "∼")
	("\\\\textemdash{}" "‑")
	("\\\\textbullet " "•")
	("\\\\textemdash{}" "‒"))
      do
      (setq s (replace-regexp-in-string pattern repl s)))
;(setq s (replace-regexp-in-string "{" "" s))
;(setq s (replace-regexp-in-string "}" "" s))
s)


#+END_SRC

#+RESULTS:
: Zhuo, Shengchi and Huang, Yongmin and Peng, Changjun and Liu, Honglai and Hu, Ying and Jiang, Jianwen, "\ce{CO2}-induced Microstructure Transition of Surfactant in Aqueous Solution: {I}nsight From Molecular Dynamics Simulation", The Journal of Physical Chemistry B, 114:6344-6349 (2010)

* splicing lists
  :PROPERTIES:
  :ID:       3E25D68D-A12D-41B5-A809-14313B81F48C
  :END:

#+BEGIN_SRC emacs-lisp
(let ((a '(1 2 3)))
  `(a b ,@a))
#+END_SRC

#+RESULTS:
| a | b | 1 | 2 | 3 |

whoa....
* alternative solutions to [[id:1B122428-E8FF-476B-B07B-79A7541003DC][Adding emacs command key-bindings and help functionality to org-mode]]
  :PROPERTIES:
  :ID:       66A21DB0-C857-4905-B053-25D52C5FC03E
  :END:
** font lock solution
   :PROPERTIES:
   :ID:       BADFF1BB-8212-4355-81EF-D4C9D573B5E1
   :END:

#+BEGIN_SRC emacs-lisp :results silent
(defvar elisp-symbol-keybinding-re "\\\\\\\\\\[\\([^]]*\\)]"
  "Regexp for an elisp command keybinding syntax.")

(defun match-next-keybinding (&optional limit)
  (when (re-search-forward elisp-symbol-keybinding-re limit t)
    (put-text-property (match-beginning 0) (match-end 0)
		       'face 'font-lock-constant-face)
    (put-text-property (match-beginning 0) (match-end 0)
		       'lisp-symbol t)
    (put-text-property
     (match-beginning 0) (match-end 0)
     'help-echo (lambda (window object position)
		  "Tooltip of the keybinding"
		  (save-excursion
		    (goto-char position)
		    (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
		      (string-match elisp-symbol-keybinding-re s)
		      (substitute-command-keys (match-string 0 s))))))))

(font-lock-add-keywords nil
 '((match-next-keybinding 0 'font-lock-constant-face)))

(defvar elisp-symbol-syntax-re "`\\([^']*\\)'"
  "Regexp for an `elisp' command syntax.")

;; make clickable syntax
(defun match-next-symbol (&optional limit)
  (when (re-search-forward elisp-symbol-syntax-re limit t)
    ;; set face
    (put-text-property (match-beginning 1) (match-end 1)
		       'face 'font-lock-constant-face)
    ;; add property
    (put-text-property (match-beginning 0) (match-end 0)
		       'lisp-symbol (match-string 1))
    ;; clickable text
    (let ((map (make-sparse-keymap)))
      (define-key map [mouse-1]
	(lambda ()
	  (interactive)
	  (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
	    (string-match elisp-symbol-syntax-re s)
	    (describe-function (intern (match-string 1 s))))))
      (put-text-property (match-beginning 0) (match-end 0)
			 'mouse-face 'highlight)
      (put-text-property (match-beginning 0) (match-end 0)
			 'local-map map))

    ;; tooltip
    (put-text-property
     (match-beginning 0) (match-end 0)
     'help-echo (lambda (window object position)
		  "Tooltip of the keybinding"
		  (save-excursion
		    (goto-char position)
		    (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
		      (string-match elisp-symbol-syntax-re s)
		      (save-window-excursion
			(describe-function (intern (match-string 1 s))))))))))

(font-lock-add-keywords nil
 '((match-next-symbol 0 'font-lock-constant-face)))
#+END_SRC



   `put-text-property'

** button-lock
   :PROPERTIES:
   :ID:       FE0230E9-3E49-4DE3-8EC6-9E3554DF0B65
   :END:
#+BEGIN_SRC emacs-lisp
(defvar elisp-symbol-keybinding-re "\\\\\\\\\\[\\([^]]*\\)]"
  "Regexp for an elisp command keybinding syntax.")

(defvar elisp-symbol-syntax-re "`\\([^']*\\)'"
  "Regexp for an elisp command syntax.")

;; make clickable syntax
(button-lock-set-button
 elisp-symbol-keybinding-re
 (lambda ()
   (interactive)
   (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
     (string-match elisp-symbol-keybinding-re s)
     (message (substitute-command-keys (match-string 0 s)))))
 :face font-lock-constant-face
 :help-echo (lambda (window object position)
		(save-excursion
		  (goto-char position)
		  (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
		    (string-match elisp-symbol-keybinding-re s)
		    (substitute-command-keys (match-string 0 s)))))
 :keyboard-binding (kbd "RET")
 :additional-property 'lisp-symbol)


(button-lock-set-button
 elisp-symbol-syntax-re
 (lambda ()
   (interactive)
   (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
     (string-match elisp-symbol-syntax-re s)
     (describe-function (intern (match-string 1 s)))))
 :face '((:background "Lightsteelblue1"))
 :help-echo "click for help"
 :keyboard-binding (kbd "RET")
 :additional-property 'lisp-symbol)


#+END_SRC

#+RESULTS:
| `\([^']*\)' | (0 (quote (face ((:background Lightsteelblue1)) keymap (keymap (13 lambda nil (interactive) (let ((s (get-surrounding-text-with-property (quote lisp-symbol)))) (string-match elisp-symbol-syntax-re s) (describe-function (intern (match-string 1 s))))) (mouse-1 lambda nil (interactive) (let ((s (get-surrounding-text-with-property (quote lisp-symbol)))) (string-match elisp-symbol-syntax-re s) (describe-function (intern (match-string 1 s)))))) button-lock t lisp-symbol t mouse-face button-lock-mouse-face help-echo click for help rear-nonsticky t)) append) |

* Modifying link export
  :PROPERTIES:
  :ID:       D802A2CD-8853-463A-A550-1CB9429F3A63
  :END:

#+BEGIN_SRC emacs-lisp
(setf (elt  (assoc "info" org-link-protocols) 2)
      (lambda (keyword desc format)
	(cond
	 ((eq format 'html)
	  (format
	   "<a href=\"https://www.gnu.org/software/emacs/manual/html_node/%s/%s.html\">%s</a>"
	   (car (s-split "#" keyword))
	   (car (last (s-split "#" keyword)))
	   keyword)))))
#+END_SRC


info:emacs#Packages


end


#+BEGIN_SRC emacs-lisp
(setf (elt  (assoc "ref" org-link-protocols) 2)
      (lambda (keyword desc format)
	(cond
	 ((eq format 'latex)
	  "\\vref{keyword}")
	 ((eq format 'html)
	  (format
	   "<a href=\"%s\">%s</a>"
	   keyword (or desc ""))))))
#+END_SRC
#+RESULTS:
| lambda | (keyword desc format) | (cond ((eq format (quote latex)) \vref{keyword}) ((eq format (quote html)) (format <a href="%s">%s</a> keyword (or desc )))) |

ref:test
* indirect buffer
  :PROPERTIES:
  :ID:       B05C65D2-9307-46A9-A2B8-7985932B5F55
  :END:

(clone-indirect-buffer-other-window (buffer-name) t)

#+BEGIN_SRC emacs-lisp
(defun edit-in-mode ()
  (interactive)
  (when (org-in-src-block-p)
    (message-box "%s"(org-element-context))
    (let* ((src-block (org-element-context))
	   (begin (org-element-property :begin src-block))
	   (end (org-element-property :end src-block))
	   (language (org-element-property :language src-block)))
      (clone-indirect-buffer-other-window (buffer-name) t)
      (narrow-to-region begin end)
      (funcall (intern (concat language "-mode"))))))
#+END_SRC

#+RESULTS:
: edit-in-mode

#+BEGIN_SRC python
import numpy as np
print np.array([6,7])

#+END_SRC

#+RESULTS:
: [6 7]

* Two-mode-mode
  :PROPERTIES:
  :ID:       21A02C9D-1225-4ECB-B653-755F71BA1C15
  :END:
This doesn't exactly work. I gather it is supposed to switch modes by detecting if you are between two markers.


http://emacswiki.org/emacs/MultipleModes

this example is broken
http://www.emacswiki.org/emacs/EmacsLispAndLaTeX

I modified this a little. It seems switching back and forth between org-mode is annoying, the buffer tends to get folded.
#+BEGIN_SRC emacs-lisp :tangle two-mode-mode.el
;;; two-mode-mode.el -- switches between tcl and sgml(html) modes
;; $Id: two-mode-mode.el,v 1.2 1999/10/18 14:29:02 davidw Exp $
;; two-mode-mode.el is Copyright David Welton <davidw@efn.org> 1999
;; two-mode-mode.el is free software under the terms of the GNU GPL

;; As I'm sure is painfully obvious, I don't know much about elisp,
;; but I thought it would be cool to do this mode, for mod_dtcl.  So
;; if you have any comments or suggestions, please email me!

;; These same concepts could be used to do a number of neat 2-mode
;; modes, for things like PHP, or anything else where you have a
;; couple of modes you'd like to use.

;; Use of 'psgml-mode' is highly recommended.  It is, of course, a
;; part of Debian GNU/Linux.

;; configure these:
(defvar two-mode-lmatch "#\\+BEGIN_SRC emacs-lisp")
(defvar two-mode-rmatch "#\\+END_SRC")

(defvar default-mode (list 'org-mode "org"))
(defvar second-mode (list 'emacs-lisp-mode "emacs-lisp"))
;; ----------------

(defun two-mode-mode-setup ()
  (add-hook 'post-command-hook 'two-mode-mode-update-mode nil t)
  (make-local-variable 'minor-mode-alist)
  (or (assq 'two-mode-mode minor-mode-alist)
      (setq minor-mode-alist
            (cons '(two-mode-mode " two-mode") minor-mode-alist))))

(defun two-mode-change-mode (to-mode)
  (if (string= to-mode major-mode)
      t
    (progn
      (if (string= to-mode (cadr second-mode))
          (funcall (car second-mode))
        (funcall (car default-mode)))
      (two-mode-mode-setup)
;      (if (eq font-lock-mode t)
;          (font-lock-fontify-buffer))
;	  (font-lock-fontify-buffer)
	  )))

(defun two-mode-mode-update-mode ()
  (let ((lm -1)
        (rm -1))
    (save-excursion
      (if (search-backward two-mode-lmatch nil t)
          (setq lm (point))
        (setq lm -1)))
    (save-excursion
      (if (search-backward two-mode-rmatch nil t)
          (setq rm (point))
        (setq rm -1)))
    (if (and (= lm -1) (= rm -1))
        (two-mode-change-mode (cadr default-mode))
      (if (>= lm rm)
          (two-mode-change-mode (cadr second-mode))
        (two-mode-change-mode (cadr default-mode))))))

(defun two-mode-mode ()
  (interactive)
  (funcall (car default-mode))
  (setq two-mode-mode t)
  (two-mode-mode-setup))

(provide 'two-mode-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(org-babel-tangle)
(load-file "two-mode-mode.el")
(two-mode-mode)
#+END_SRC

* Cycling through a list of files
  :PROPERTIES:
  :ID:       CC3CE20A-9FAF-4C9E-83EF-7F988A47CD6F
  :END:

#+BEGIN_SRC emacs-lisp
(setq my-files '("a.org" "b.org" "c.org"))

(defun my-next-file ()
 (interactive)
 (let ((f (pop my-files)))
   (add-to-list 'my-files f t)
   (find-file f)))

(defun my-previous-file ()
  (interactive)
  (let* ((r-my-files (reverse my-files))
	 (f (pop r-my-files)))
    (add-to-list 'r-my-files f t)
    (setq my-files (reverse r-my-files))
    (find-file f)))

(global-set-key (kbd "s-<right>") 'my-next-file)
(global-set-key (kbd "s-<left>") 'my-previous-file)
#+END_SRC

#+RESULTS:
: my-previous-file

* Using the python ast module to figure out what node a cursor is on
  :PROPERTIES:
  :ID:       76DB0878-A447-4793-A4B2-87E9DB6F04F6
  :END:

** [BROKEN] parser
   :PROPERTIES:
   :ID:       5FC46A42-B375-477D-BAA2-C7839D20F9E9
   :END:

#+BEGIN_SRC python
import parser

source = '''import numpy as np

def func(x):
    return x

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''

print(parser.expr(source))
#+END_SRC

#+RESULTS:

** symtable
   :PROPERTIES:
   :ID:       817344BE-3A2D-4F20-BAA9-102D2FFEE6C6
   :END:

we can get a list of identifiers and symbols like this.

#+BEGIN_SRC python
import symtable

source = '''import numpy as np

def func(x):
    return x

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))

a = 5'''

table = symtable.symtable(source, "string", "exec")
print('Symbols: ',table.get_symbols())
print('Identifiers: ',table.get_identifiers())

print(table.lookup('a'))

#+END_SRC

#+RESULTS:
: Symbols:  [<symbol 'np'>, <symbol 'func'>, <symbol 'a'>, <symbol 'print'>, <symbol 'b'>]
: Identifiers:  dict_keys(['np', 'func', 'a', 'print', 'b'])
: <symbol 'a'>

** jedi
   :PROPERTIES:
   :ID:       A57A139B-DF75-4BE9-BE2B-04381B26692D
   :END:
It looks like elpy just uses the doc property from jedi.
This little script

#+BEGIN_SRC emacs-lisp
(defun pydoc-at-point ()
  (interactive)
  (let* ((script (buffer-string))
	(line (line-number-at-pos))
	(column (current-column))
	(python-script (format "import jedi
s = jedi.Script(\"\"\"%s\"\"\", %s, %s)
gd = s.goto_definitions()
if len(gd) > 0:
    print(gd[0].raw_doc)
else:
    print('Could not determine anything.')"
			       script (or line 0) (or column 0)))
	(tfile (make-temp-file "py-")))
    (with-temp-file tfile
      (insert python-script))
    (prog1
	(message (s-trim (shell-command-to-string (format "python %s" tfile))))
      (delete-file tfile))))
#+END_SRC

#+RESULTS:
: pydoc-at-point


This eventually might lead to pydoc.

#+BEGIN_SRC emacs-lisp
(defun pydoc-at-point ()
  (interactive)
  (let* ((script (buffer-string))
	(line (line-number-at-pos))
	(column (current-column))
	(python-script (format "import jedi
s = jedi.Script(\"\"\"%s\"\"\", %s, %s)
gd = s.goto_definitions()
if len(gd) > 0:
    print(gd[0].full_name)
else:
    print('Could not determine anything.')"
			       script (or line 0) (or column 0)))
	(tfile (make-temp-file "py-")))
    (with-temp-file tfile
      (insert python-script))
    (prog1
	(message (s-trim (shell-command-to-string (format "python %s" tfile))))
      (delete-file tfile))))
#+END_SRC

#+RESULTS:
: pydoc-at-point


#+BEGIN_SRC python
import jedi
import pydoc

source = '''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''

script = jedi.Script(source, 6, 13)

print(dir(script),'\n')
print(script.usages()[0])
print(script.call_signatures()[0].params)
print(dir(script.call_signatures()[0]))

#+END_SRC

#+RESULTS:
: ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_analysis', '_evaluator', '_get_under_cursor_stmt', '_goto', '_grammar', '_orig_path', '_parsed_callback', '_parser', '_pos', '_prepare_goto', '_simple_complete', '_user_context', 'call_signatures', 'completions', 'goto_assignments', 'goto_definitions', 'path', 'source', 'source_path', 'usages']
:
: <Definition a = np.array([5, 6, 7])>
: [<_Param a>, <_Param b>, <_Param out=None>]
: ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_call_stmt', '_definition', '_evaluator', '_follow_statements_imports', '_index', '_key_name', '_mapping', '_module', '_name', '_path', '_tuple_mapping', 'bracket_start', 'call_name', 'column', 'defined_names', 'desc_with_module', 'description', 'doc', 'docstring', 'full_name', 'goto_assignments', 'in_builtin_module', 'index', 'is_definition', 'is_keyword', 'line', 'module', 'module_name', 'module_path', 'name', 'params', 'parent', 'raw_doc', 'start_pos', 'type']


#+BEGIN_SRC python
import jedi

source = '''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''

names = jedi.names(source)
print([x.name for x in names])
print([x.type for x in names])
ga = [x.goto_assignments() for x in names]
print(dir(ga[0][0]))
print(ga[1][0].docstring())

#+END_SRC

#+RESULTS:
: ['np', 'a', 'b']
: ['import', 'statement', 'statement']
: ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_definition', '_evaluator', '_follow_statements_imports', '_mapping', '_module', '_name', '_path', '_tuple_mapping', 'column', 'defined_names', 'desc_with_module', 'description', 'doc', 'docstring', 'full_name', 'goto_assignments', 'in_builtin_module', 'is_definition', 'is_keyword', 'line', 'module_name', 'module_path', 'name', 'params', 'parent', 'raw_doc', 'start_pos', 'type']
:




print('desc: ',[x.description for x in names])
print('XXX: ',[x.desc_with_module for x in names], '\n')
print(dir(names[0]))

#+BEGIN_SRC python
from ase import Atoms
a = Atoms([])
print(type(a))
#+END_SRC

#+RESULTS:
: <class 'ase.atoms.Atoms'>


#+BEGIN_SRC python
import jedi

source = '''from ase import Atom, Atoms

a = Atoms([])'''

s = jedi.Script(source, 3)
gd = s.goto_definitions()

print('name: ',gd[0].name)
print('module_name: ', gd[0].module_name)
print('module_path: ', gd[0].module_path)
print('line: ', gd[0].line)
print('full_name: ', gd[0].full_name)
print('parent: ', gd[0].parent().module_name)
#print('doc: ', gd[0].doc)
#print(dir(gd[0]))
g = gd[0]
print()
print('evaluator mods: ',g._evaluator.modules)
print('evm global names: ', g._evaluator.modules['ase.atoms'].global_names)
print('evm name: ', g._evaluator.modules['ase.atoms'].py__name__())
print('evm pkg: ', g._evaluator.modules['ase.atoms'].py__package__())
print('evm used names: ', g._evaluator.modules['ase'].used_names['ase'])
#print('evm name dicts: ', list(g._evaluator.modules['ase.atoms'].names_dicts([])))
print('evm pth: ', g._evaluator.modules['ase'].py__path__([]))
print(help(g._evaluator.modules['ase.atoms']))
#+END_SRC

#+RESULTS:
#+begin_example
name:  Atoms
module_name:  atoms
module_path:  /Users/jkitchin/Dropbox/python/ase/ase/atoms.py
line:  24
full_name:  atoms.Atoms
parent:  atoms

evaluator mods:  {'': <ModuleWrapper: <fast.FastModule: @1-3>>, 'ase.atoms': <ModuleWrapper: <fast.FastModule: atoms@4-1700>>, 'ase': <ModuleWrapper: <fast.FastModule: ase@4-20>>}
evm global names:  []
evm name:  ase.atoms
evm pkg:  ase
evm used names:  [<Name: ase@8,5>, <Name: ase@9,5>]
evm pth:  ['/Users/jkitchin/Dropbox/python/ase/ase']
Help on ModuleWrapper in module jedi.evaluate.representation object:

class ModuleWrapper(jedi._compatibility.HackClass)
 |  The top scope, which is always a module.
 |  Depending on the underlying parser this may be a full module or just a part
 |  of a module.
 |
 |  Method resolution order:
 |      ModuleWrapper
 |      jedi._compatibility.HackClass
 |      jedi.parser.tree.Module
 |      jedi.parser.tree.Scope
 |      jedi.parser.tree.BaseNode
 |      Wrapper
 |      jedi.parser.tree.Base
 |      jedi.parser.tree.DocstringMixin
 |      builtins.object
 |
 |  Methods defined here:
 |
 |  __getattr__(self, name)
 |
 |  __init__(self, evaluator, module)
 |      Initialize :class:`Module`.
 |
 |      :type path: str
 |      :arg  path: File path to this module.
 |
 |      .. todo:: Document `top_module`.
 |
 |  __repr__(self)
 |      Return repr(self).
 |
 |  names_dicts(self, search_global)
 |
 |  py__file__(self)
 |      In contrast to Python's __file__ can be None.
 |
 |  py__name__(self)
 |
 |  py__package__(self)
 |
 |  star_imports = wrapper(obj, *args, **kwargs)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  name
 |
 |  py__path__
 |      Not seen here, since it's a property. The callback actually uses a
 |      variable, so use it like::
 |
 |          foo.py__path__(sys_path)
 |
 |      In case of a package, this returns Python's __path__ attribute, which
 |      is a list of paths (strings).
 |      Raises an AttributeError if the module is not a package.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from jedi._compatibility.HackClass:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from jedi.parser.tree.Module:
 |
 |  error_statement_stacks
 |
 |  global_names
 |
 |  has_explicit_absolute_import
 |      Checks if imports in this module are explicitly absolute, i.e. there
 |      is a ``__future__`` import.
 |
 |  path
 |
 |  used_names
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes inherited from jedi.parser.tree.Module:
 |
 |  type = 'file_input'
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from jedi.parser.tree.Scope:
 |
 |  is_scope(self)
 |
 |  walk(self)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from jedi.parser.tree.Scope:
 |
 |  flows
 |
 |  imports
 |
 |  names_dict
 |
 |  returns
 |
 |  statements
 |
 |  subscopes
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from jedi.parser.tree.BaseNode:
 |
 |  first_leaf(self)
 |
 |  get_code(self)
 |
 |  get_statement_for_position lambda *args, **kwargs
 |
 |  move(self, line_offset, column_offset)
 |      Move the Node's start_pos.
 |
 |  name_for_position lambda *args, **kwargs
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from jedi.parser.tree.BaseNode:
 |
 |  children
 |
 |  end_pos
 |
 |  parent
 |
 |  start_pos
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from Wrapper:
 |
 |  is_class(self)
 |
 |  py__bool__(self)
 |      Since Wrapper is a super class for classes, functions and modules,
 |      the return value will always be true.
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from jedi.parser.tree.Base:
 |
 |  get_parent_scope(self, include_flows=False)
 |      Returns the underlying scope.
 |
 |  get_parent_until lambda *args, **kwargs
 |
 |  isinstance(self, *cls)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from jedi.parser.tree.DocstringMixin:
 |
 |  raw_doc
 |      Returns a cleaned version of the docstring token.

None
#+end_example

#+BEGIN_SRC python
import jedi

source = '''from ase import Atom, Atoms

a = Atoms([])'''

s = jedi.Script(source, 3)
gd = s.goto_definitions()
g = gd[0]

# this is the module we want the full path to.
module_name = g.name
module_mname = g.module_name
module_full_name = g.full_name

print('module name: ', module_name)
print('module mname: ', module_mname)
script_modules = g._evaluator.modules

# We ahve to iterate through all of these. It seems that the names are in a few of these places. The best logic I have so far is to take the shortest smod. In this case, "Atoms" is a name in the ase and ase.atoms dictionaries.

for smod in script_modules:
    # I am not sure what '' is, but it is definitely not what I want.
    if smod == '': continue
    if len(script_modules[smod].used_names[module_mname]) == 1:
        mw = script_modules[smod]
        print('mw: ', smod, mw.names_dict.items(), '\n')
        print(script_modules[smod].used_names[module_mname], '\n')
        break


print('{0}.{1}'.format(smod, g.full_name))

#+END_SRC

#+RESULTS:
: module name:  Atoms
: module mname:  atoms
: mw:  ase dict_items([('integer', [<Name: integer@18,33>]), ('Atom', [<Name: Atom@8,21>]), ('np', [<Name: np@6,16>, <Name: np@15,16>, <Name: np@18,30>]), ('register', [<Name: register@18,21>]), ('Atoms', [<Name: Atoms@9,22>]), ('version', [<Name: version@14,15>]), ('ase', [<Name: ase@8,5>, <Name: ase@9,5>]), ('LooseVersion', [<Name: LooseVersion@14,30>, <Name: LooseVersion@15,3>]), ('Integral', [<Name: Integral@18,12>]), ('__version__', [<Name: __version__@12,0>, <Name: __version__@15,19>]), ('distutils', [<Name: distutils@14,5>]), ('atoms', [<Name: atoms@9,9>]), ('numpy', [<Name: numpy@6,7>]), ('atom', [<Name: atom@8,9>]), ('numbers', [<Name: numbers@17,11>, <Name: numbers@18,4>, <Name: numbers@19,8>]), ('__all__', [<Name: __all__@11,0>])])
:
: [<Name: atoms@9,9>]
:
: ase.atoms.Atoms

#+BEGIN_SRC python
import jedi

source = '''import numpy as np

a = np.array([5])'''

s = jedi.Script(source, 3, 7)
gd = s.goto_definitions()
print(gd)
g = gd[0]

# this is the module we want the full path to.
module_name = g.name
module_mname = g.module_name
module_full_name = g.full_name

print('module name: ', module_name)
print('module mname: ', module_mname)
script_modules = g._evaluator.modules

# We have to iterate through all of these. It seems that the names are in a few of these places. The best logic I have so far is to take the shortest smod. In this case, "Atoms" is a name in the ase and ase.atoms dictionaries.

for smod in script_modules:
    print(smod)
    # I am not sure what '' is, but it is definitely not what I want.
    if smod == '': continue
    print(script_modules[smod].used_names[module_mname])
#    if len(script_modules[smod].used_names[module_mname]) == 1:
#        mw = script_modules[smod]
#        print('mw: ', smod, mw.names_dict.items(), '\n')
#        print(script_modules[smod].used_names[module_mname], '\n')
#        break


print('{0}.{1}'.format(smod, g.full_name))
#+END_SRC

#+RESULTS:

#+begin_example
[<Definition function array>]
module name:  array
module mname:  numpy.core.multiarray

numpy.matrixlib
numpy.lib.type_check
numpy.lib.utils
numpy.lib.financial
numpy.core
numpy.core.getlimits
numpy.core.records
numpy.core.umath
numpy.core.machar
numpy.lib.ufunclike
numpy.lib.function_base
numpy.core.multiarray
numpy.lib.npyio
numpy
numpy.matrixlib.defmatrix
numpy.lib._version
numpy.lib.twodim_base
numpy.lib.index_tricks
numpy.core.function_base
numpy.core.fromnumeric
numpy.lib.shape_base
numpy.lib.arraysetops
numpy.core.shape_base
numpy.core.memmap
numpy.lib.arraypad
numpy.lib.nanfunctions
numpy.core.numerictypes
numpy.lib
numpy.lib.polynomial
numpy.core.numeric
numpy.lib.arrayterator
numpy.lib.stride_tricks
numpy.lib.stride_tricks.numpy.core.multiarray.array
#+end_example


** asteroid

#+BEGIN_SRC python
from astroid import builder
astng = builder.parse('i = 1')
print(dir(astng))
print(list(astng.get_children()))
#assnode = astng['']
#print([(inf.value, type(inf.value)) for inf in assnode.infer()])
#+END_SRC

#+RESULTS:
: ['__class__', '__contains__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_absolute_import_activated', '_append_node', '_astroid_fields', '_delayed_assattr', '_explicit_inference', '_filter_stmts', '_fixed_source_line', '_future_imports', '_get_stream', '_globals', '_import_from_nodes', '_infer', '_infer_name', '_locals', '_repr_name', '_scope_lookup', 'absolute_import_activated', 'accept', 'add_local_node', 'as_string', 'block_range', 'body', 'bool_value', 'callable', 'child_sequence', 'close', 'col_offset', 'display_type', 'doc', 'eq', 'file', 'file_bytes', 'file_encoding', 'file_stream', 'frame', 'fromlineno', 'fully_defined', 'future_imports', 'get_children', 'getattr', 'globals', 'has_base', 'igetattr', 'ilookup', 'import_module', 'infer', 'infered', 'inferred', 'instanciate_class', 'is_function', 'is_statement', 'items', 'keys', 'last_child', 'lineno', 'locals', 'locate_child', 'lookup', 'name', 'nearest', 'next_sibling', 'nodes_of_class', 'optional_assign', 'package', 'parent', 'parent_of', 'path', 'previous_sibling', 'pure_python', 'pytype', 'qname', 'relative_to_absolute_name', 'repr_tree', 'root', 'scope', 'scope_attrs', 'scope_lookup', 'set_local', 'source_code', 'source_file', 'special_attributes', 'statement', 'stream', 'tolineno', 'values', 'wildcard_import_names']
: [<Assign() l.1 [] at 0x10100f7f0>]

** ast
   :PROPERTIES:
   :ID:       23E3E468-721C-43F6-83D7-DF2A1F512355
   :END:
I want to connect Emacs, org-mode and python to get help about the symbol a cursor is on. I am not sure this will work, but I am going to explore it here. First, I want to figure out what node of the ast.tree the cursor is on. Statements and expressions in the ast have a lineno and col_offset specified in them.

#+BEGIN_SRC python
import ast

tree = ast.parse('''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))''')

for node in ast.walk(tree):
    if isinstance(node, ast.expr) or isinstance(node, ast.stmt):
        a = (node.lineno, node.col_offset)
    else:
        a = ''

    print(str(a) + ast.dump(node) + '\n')
#+END_SRC

#+RESULTS:
#+begin_example
Module(body=[Import(names=[alias(name='numpy', asname='np')]), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[])), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[])], keywords=[]))])

(1, 0)Import(names=[alias(name='numpy', asname='np')])

(3, 0)Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[]))

(4, 0)Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[]))

(6, 0)Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[])], keywords=[]))

alias(name='numpy', asname='np')

(3, 0)Name(id='a', ctx=Store())

(3, 4)Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[])

(4, 0)Name(id='b', ctx=Store())

(4, 4)Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[])

(6, 0)Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[])], keywords=[])

Store()

(3, 4)Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())

(3, 13)List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())

Store()

(4, 4)Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())

(4, 13)List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())

(6, 0)Name(id='print', ctx=Load())

(6, 6)Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[])

(3, 4)Name(id='np', ctx=Load())

Load()

(3, 14)Num(n=5)

(3, 17)Num(n=6)

(3, 20)Num(n=7)

Load()

(4, 4)Name(id='np', ctx=Load())

Load()

(4, 14)Num(n=5)

(4, 17)Num(n=6)

(4, 20)Num(n=7)

Load()

Load()

(6, 6)Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load())

(6, 13)Name(id='a', ctx=Load())

(6, 16)Name(id='b', ctx=Load())

Load()

Load()

(6, 6)Name(id='np', ctx=Load())

Load()

Load()

Load()

Load()

#+end_example

Now which node covers line 6 column 4
#+BEGIN_SRC python
import ast

tree = ast.parse('''import numpy as np

a=np.array([5, 6, 7])
b=np.array([5,6,7])

print(np.dot(a, b))''')

exprs = [node for node in ast.walk(tree)
         if isinstance(node, ast.expr) or isinstance(node, ast.stmt)]

# nodes in line 6
for x in sorted([x for x in exprs if x.lineno == 6], key=lambda x: x.col_offset):
    print (x.lineno, x.col_offset), ast.dump(x) + '\n'


N = None

for x in sorted([x for x in exprs if x.lineno == 6], key=lambda x: x.col_offset):
    if x.col_offset <= 16:
        N = x
        continue
    else:
        break

print "N = ", (N.lineno, N.col_offset), ast.dump(N)
#+END_SRC

#+RESULTS:
#+begin_example
(6, 0) Print(dest=None, values=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)], nl=True)

(6, 6) Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)

(6, 6) Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load())

(6, 6) Name(id='np', ctx=Load())

(6, 13) Name(id='a', ctx=Load())

(6, 16) Name(id='b', ctx=Load())

N =  (6, 16) Name(id='b', ctx=Load())
#+end_example



* Working with org-contacts
  :PROPERTIES:
  :ID:       6FE39D46-894C-435B-8A56-DCAE4847AE82
  :END:
Rather than dig through org-contacts, here is a different approach to finding contacts. It is surprisingly fast, using org-map-entries with a list of contacts files.

Here I get my email addresses at CMU, with last names starting with K.
#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (org-entry-get (point) "EMAIL"))
 "EMAIL={cmu}+LASTNAME={^K}"
 org-contacts-files)
#+END_SRC

#+RESULTS:
| okonkwo@andrew.cmu.edu | yaesunk@andrew.cmu.edu | jelenak@cmu.edu | Aditya Khair <akhair@andrew.cmu.edu> | jkitchin@andrew.cmu.edu |

Here, I get current phd students. They are tagged with :phd: and a TODO state of "CURRENT".

#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (format "%s %s"
	   (org-entry-get (point) "FIRSTNAME")
	   (org-entry-get (point) "LASTNAME")))
 "EMAIL<>\"\"+phd+TODO=\"CURRENT\""
 org-contacts-files)
#+END_SRC

#+RESULTS:
| Jacob Boes | Zhongnan Xu | Alex Hallenbeck |

#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (nth 4 (org-heading-components)))
 "EMAIL<>\"\"+GENDER=\"F\""
 org-contacts-files)
#+END_SRC

#+RESULTS:
| Elizabeth Biddinger | Cathy Chin | Maria Curet-Arana | Carrie Farberow | Maria Flytzani-Stephanopoulos | Rachael Getman | Helena Hagelin-Weaver | Preeti Kamakoti | Heather Kulik | Cynthia Lo | Surya Mallapragada | Maria Martinez | Eranda Nikolla | Bihter Padak | Susan Stagg-Williams | Maureen Tang | Judith Yang | Perla B Balbuena | Sumathy Raman | Rachel Getman | Eranda Nikolla | Y-H. Cathy Chin | Aleksandra Vojvodic | Heather Mayes | Maria Curet-Arana | Gabriella Farnham | Susanna Scott | Lashonda Korley | Marianthi Ierapetritou | Heather Kulik | Lydia Contreras | Kathleen Schwarz | Carol Frieze | Ty Walton | Justine Cassell | Amy Burkert | Susan Polansky | Anna Fisher | Alissa Park |

#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (nth 4 (org-heading-components)))
 "EMAIL<>\"\"+cheme+assistant|associate"
 org-contacts-files)
#+END_SRC

#+RESULTS:
| Kris Dahl | Chrysanthos Gounaris | Aditya Khair | Kathryn Whitehead |

** org-contacts
   :PROPERTIES:
   :ID:       24BB8B84-3EAF-46C4-879B-CA84CC489EA6
   :END:
#+BEGIN_SRC emacs-lisp
(assoc "John Kitchin" org-contacts-db)
#+END_SRC

#+RESULTS:
| John Kitchin | #<marker at 9292 in department-contacts.org> | ((FILE . /Users/jkitchin/Dropbox/org-mode/contacts/department-contacts.org) (TAGS . :cheme:faculty:full:hiring:css:teqie:cfs:bias:) (ALLTAGS . :cheme:faculty:full:hiring:css:teqie:cfs:bias:) (BLOCKED . ) (scopus-id . 7004212771) (PHD . 2004) (FIRSTNAME . John) (LASTNAME . Kitchin) (EMAIL . jkitchin@andrew.cmu.edu) (LAST_SENT_EMAIL . [[mu4e:msgid:m2d1wfzpu8.fsf@andrew.cmu.edu][(search) application 623566 review (Thu Oct 15 19:14:57 2015)]]) (LAST-EMAIL-READ . mu4e:msgid:m2h9lrzq1v.fsf@andrew.cmu.edu) (CATEGORY . department-contacts)) |


#+BEGIN_SRC emacs-lisp
(let ((lexical-binding nil)
      (todo-only nil))
  (loop for contact in org-contac
ts-db
	for tags = (cdr (assoc "TAGS" (nth 2 contact)))
	for tags-list = (split-string
			 (substring
			  (or tags "  ")
			  1 -1)
			 ":")
	for tag-expression = (or (org-make-tags-matcher "group-phd") nil)
	if (and
	    ;; A name match
	    (string-match-p "h" (car contact))
	    ;; a property match
	    (string-match-p "cmu\\.edu" (org-contacts-get-property "EMAIL" contact))
	    ;; a tag match.
	    (eval (cdr tag-expression)))
	collect contact))
#+END_SRC

#+RESULTS:
| CURRENT Venkatesh Naik      | #<marker at 11335 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . vnaik@andrew.cmu.edu) (CATEGORY . group-contacts))    |
| CURRENT Siddharth Deshpande | #<marker at 11437 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . siddhard@andrew.cmu.edu) (CATEGORY . group-contacts)) |
| CURRENT Zhaofeng Chen       | #<marker at 11547 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . zhaofenc@andrew.cmu.edu) (CATEGORY . group-contacts)) |
| CURRENT Hari Thirumalai     | #<marker at 11651 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . hthiruma@andrew.cmu.edu) (CATEGORY . group-contacts)) |

#+BEGIN_SRC emacs-lisp
(defun org-contacts-match-tag-expression-p (contact tag-expression)
  "Test if a CONTACT matches a TAG-EXPRESSION."
  (let* ((lexical-binding nil)
	 (todo-only nil)
	 (tags-list (org-contacts-get-tag-list contact)))
    (eval (cdr (org-make-tags-matcher tag-expression)))))

(org-contacts-match-tag-expression-p
 (assoc "John Kitchin" org-contacts-db)
  "faculty")
#+END_SRC

#+RESULTS:
: t


#+BEGIN_SRC emacs-lisp
(org-contacts-filter-tags "group-phd+undergrad")
#+END_SRC

#+RESULTS:
| CURRENT Matt Palmer | #<marker at 11757 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :group:undergrad:) (ALLTAGS . :group:undergrad:) (BLOCKED . ) (EMAIL . Matthew Palmer <mjpalmer@andrew.cmu.edu>) (CATEGORY . group-contacts)) |


#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (org-entry-get (point) "EMAIL"))
 "EMAIL<>\"\"+group-undergrad"
 org-contacts-files)
#+END_SRC

#+RESULTS:
| mcurnan@andrew.cmu.edu | jboes@cmu.edu | zhongnanxu@cmu.edu | Alexander Hallenbeck <ahallenb@andrew.cmu.edu> | vnaik@andrew.cmu.edu | siddhard@andrew.cmu.edu | zhaofenc@andrew.cmu.edu | hthiruma@andrew.cmu.edu |



* Get all done headings in a new buffer
  :PROPERTIES:
  :ID:       317B73EA-AF13-4A14-A537-7F260C20F5AE
  :END:

By TODO keyword.
#+BEGIN_SRC emacs-lisp
(let ((entries (org-map-entries
		(lambda ()
		  (save-restriction
		    (org-narrow-to-subtree)
		    (buffer-string)))
		"TODO=\"DONE\"")))
  (switch-to-buffer (get-buffer-create "new"))
  (org-mode)
  (mapcar 'insert entries))
#+END_SRC

#+RESULTS:
: (#<marker at 417 in blog.org> #<marker at 437 in blog.org> nil nil nil nil nil nil nil nil nil nil nil nil nil nil #<marker at 417 in blog.org> #<marker at 437 in blog.org> #<marker at 417 in blog.org> #<marker at 421 in blog.org> #<marker at 422 in blog.org> #<marker at 437 in blog.org> #<marker at 436 in blog.org> #<marker at 437 in blog.org>)


* Exploring the Python AST
  :PROPERTIES:
  :ID:       32593110-9B7A-42CB-896C-656EB3F3587B
  :END:
[[http://stackoverflow.com/questions/1515357/simple-example-of-how-to-use-ast-nodevisitor][python - Simple example of how to use ast.NodeVisitor? - Stack Overflow]]

#+BEGIN_SRC python
import ast

def str_node(node):
    if isinstance(node, ast.AST):
        fields = [(name, str_node(val)) for name, val in ast.iter_fields(node) if name not in ('left', 'right')]
        rv = '%s(%s' % (node.__class__.__name__, ', '.join('%s=%s' % field for field in fields))
        return rv + ')'
    else:
        return repr(node)

def ast_visit(node, level=0):
    print('  ' * level + str_node(node))
    for field, value in ast.iter_fields(node):
        if isinstance(value, list):
            for item in value:
                if isinstance(item, ast.AST):
                    ast_visit(item, level=level+1)
        elif isinstance(value, ast.AST):
            ast_visit(value, level=level+1)


# ast_visit(ast.parse('a=5; b=a+1; a+b'))
print
ast_visit(ast.parse('''
def f(a, b):
    return a + b
f(5, 4)'''))
#+END_SRC

#+RESULTS:
#+begin_example

Module(body=[<_ast.FunctionDef object at 0x1004c0f50>, <_ast.Expr object at 0x1004c5190>])
  FunctionDef(name='f', args=arguments(args=[<_ast.Name object at 0x1004c0fd0>, <_ast.Name object at 0x1004c5050>], vararg=None, kwarg=None, defaults=[]), body=[<_ast.Return object at 0x1004c5090>], decorator_list=[])
    arguments(args=[<_ast.Name object at 0x1004c0fd0>, <_ast.Name object at 0x1004c5050>], vararg=None, kwarg=None, defaults=[])
      Name(id='a', ctx=Param())
        Param()
      Name(id='b', ctx=Param())
        Param()
    Return(value=BinOp(op=Add()))
      BinOp(op=Add())
        Name(id='a', ctx=Load())
          Load()
        Add()
        Name(id='b', ctx=Load())
          Load()
  Expr(value=Call(func=Name(id='f', ctx=Load()), args=[<_ast.Num object at 0x1004c5250>, <_ast.Num object at 0x1004c5290>], keywords=[], starargs=None, kwargs=None))
    Call(func=Name(id='f', ctx=Load()), args=[<_ast.Num object at 0x1004c5250>, <_ast.Num object at 0x1004c5290>], keywords=[], starargs=None, kwargs=None)
      Name(id='f', ctx=Load())
        Load()
      Num(n=5)
      Num(n=4)
#+end_example



#+BEGIN_SRC python
import ast

def str_node(node):
    if isinstance(node, ast.AST):
        fields = [(name, str_node(val)) for name, val in ast.iter_fields(node) if name not in ('left', 'right')]
        rv = '%s(%s' % (node.__class__.__name__, ', '.join('%s=%s' % field for field in fields)) + ')'
        if isinstance(node, ast.expr):
            rv += '\nline {0} col {1}'.format(node.lineno, node.col_offset)
        return rv
    else:
        return repr(node)

def ast_visit(node, level=0):
    print('  ' * level + str_node(node))
    for field, value in ast.iter_fields(node):
        if isinstance(value, list):
            for item in value:
                if isinstance(item, ast.AST):
                    ast_visit(item, level=level+1)
        elif isinstance(value, ast.AST):
            ast_visit(value, level=level+1)


# ast_visit(ast.parse('a=5; b=a+1; a+b'))
print
ast_visit(ast.parse('''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''))
#+END_SRC

#+RESULTS:
#+begin_example

Module(body=[<_ast.Import object at 0x1004c0f50>, <_ast.Assign object at 0x1004c0fd0>, <_ast.Assign object at 0x1004c5250>, <_ast.Print object at 0x1004c5490>])
  Import(names=[<_ast.alias object at 0x1004c0f90>])
    alias(name='numpy', asname='np')
  Assign(targets=[<_ast.Name object at 0x1004c5050>], value=Call(func=Attribute(value=Name(id='np', ctx=Load())
line 3 col 4, attr='array', ctx=Load())
line 3 col 4, args=[<_ast.List object at 0x1004c5150>], keywords=[], starargs=None, kwargs=None)
line 3 col 4)
    Name(id='a', ctx=Store())
line 3 col 0
      Store()
    Call(func=Attribute(value=Name(id='np', ctx=Load())
line 3 col 4, attr='array', ctx=Load())
line 3 col 4, args=[<_ast.List object at 0x1004c5150>], keywords=[], starargs=None, kwargs=None)
line 3 col 4
      Attribute(value=Name(id='np', ctx=Load())
line 3 col 4, attr='array', ctx=Load())
line 3 col 4
        Name(id='np', ctx=Load())
line 3 col 4
          Load()
        Load()
      List(elts=[<_ast.Num object at 0x1004c5190>, <_ast.Num object at 0x1004c51d0>, <_ast.Num object at 0x1004c5210>], ctx=Load())
line 3 col 13
        Num(n=5)
line 3 col 14
        Num(n=6)
line 3 col 17
        Num(n=7)
line 3 col 20
        Load()
  Assign(targets=[<_ast.Name object at 0x1004c5290>], value=Call(func=Attribute(value=Name(id='np', ctx=Load())
line 4 col 4, attr='array', ctx=Load())
line 4 col 4, args=[<_ast.List object at 0x1004c5390>], keywords=[], starargs=None, kwargs=None)
line 4 col 4)
    Name(id='b', ctx=Store())
line 4 col 0
      Store()
    Call(func=Attribute(value=Name(id='np', ctx=Load())
line 4 col 4, attr='array', ctx=Load())
line 4 col 4, args=[<_ast.List object at 0x1004c5390>], keywords=[], starargs=None, kwargs=None)
line 4 col 4
      Attribute(value=Name(id='np', ctx=Load())
line 4 col 4, attr='array', ctx=Load())
line 4 col 4
        Name(id='np', ctx=Load())
line 4 col 4
          Load()
        Load()
      List(elts=[<_ast.Num object at 0x1004c53d0>, <_ast.Num object at 0x1004c5410>, <_ast.Num object at 0x1004c5450>], ctx=Load())
line 4 col 13
        Num(n=5)
line 4 col 14
        Num(n=6)
line 4 col 17
        Num(n=7)
line 4 col 20
        Load()
  Print(dest=None, values=[<_ast.Call object at 0x1004c54d0>], nl=True)
    Call(func=Attribute(value=Name(id='np', ctx=Load())
line 6 col 6, attr='dot', ctx=Load())
line 6 col 6, args=[<_ast.Name object at 0x1004c5590>, <_ast.Name object at 0x1004c55d0>], keywords=[], starargs=None, kwargs=None)
line 6 col 6
      Attribute(value=Name(id='np', ctx=Load())
line 6 col 6, attr='dot', ctx=Load())
line 6 col 6
        Name(id='np', ctx=Load())
line 6 col 6
          Load()
        Load()
      Name(id='a', ctx=Load())
line 6 col 13
        Load()
      Name(id='b', ctx=Load())
line 6 col 16
        Load()
#+end_example



* Scopus author report
  :PROPERTIES:
  :ID:       62426E8E-0A0B-40E3-989D-CD33E6C6DC4F
  :END:
This is an example of using my scopus api to get tabular data about authors. It is time consuming to run because each document has to be downloaded.

#+BEGIN_SRC python :results value
from scopus.scopus_author import *

authors = [('Lars Grabow', '7005942402'),
           ('John Kitchin', '7004212771'),
           ('Eranda Nikolla', '14422415600'),
           ('Aaron Deskins', '8338495100'),
           ('Andreas Heyden', '56230635600'),
           ('Cynthia Lo', '36786289800'),
           ('Rachel Getman', '16028471000'),
           ('Elizabeth Biddinger', '14832345100'),
           ('Jessie Bond', '36011452800'),
           ('Liney Arnadottir', '6505601647'),
           ('Heather Kulik', '14421161700'),
           ('Bihter Padak', '15521044000'),
           ('Yuriy Roman', '14028938700'),
           ('Mike Janik', '7005984190'),
           ('Jeff Greeley', '56268000500'),
           ('Suljo Linic', '6602543828'),
           ('Rohan Mishra', '36876559500')]


return ([['Name', 'h-index', 'aif', '#first', '#last', 'N', 'cites', 'created'], None]
        + [[au.name,
            au.hindex,
            round(au.author_impact_factor(), 1),
            au.n_first_author_papers(),
            au.n_last_author_papers(),
            au.n_journal_articles(),
            au.ncitations,
            au.date_created]
           for au in [ScopusAuthor(sid) for name, sid in authors]])
#+END_SRC

#+RESULTS:
| Name                    | h-index |  aif | #first | #last |   N | cites | created      |
|-------------------------+---------+------+--------+-------+-----+-------+--------------|
| Lars C. Grabow          |      17 | 15.7 |     10 |     2 |  32 |  1084 | (2005 11 28) |
| John R. Kitchin         |      18 | 19.7 |     10 |    35 |  56 |  3428 | (2005 12 3)  |
| Eranda Nikolla          |      10 | 36.3 |      7 |     6 |  19 |   696 | (2006 9 14)  |
| Nathaniel Aaron Deskins |      14 | 14.6 |      8 |     2 |  29 |   853 | (2005 11 28) |
| Andreas Heyden          |      15 | 12.0 |      6 |    26 |  46 |  2349 | (2014 7 8)   |
| Cynthia Lo              |       8 |  5.9 |      0 |    16 |  24 |   216 | (2011 6 5)   |
| Rachel B. Getman        |       9 | 75.8 |      7 |     3 |  14 |   719 | (2007 3 18)  |
| Elizabeth J. Biddinger  |      12 | 12.4 |      6 |     2 |  21 |   639 | (2006 10 22) |
| Jesse Q. Bond           |      11 | 52.0 |      4 |     3 |  14 |  1249 | (2010 5 21)  |
| Líney Árnadõttir        |       6 |  5.0 |      3 |     0 |  12 |   119 | (2005 12 1)  |
| Heather J. Kulik        |      10 | 12.3 |     13 |     3 |  18 |   344 | (2006 9 14)  |
| Bihter Padak            |       3 |  0.0 |      1 |     1 |   3 |    93 | (2006 12 27) |
| Yuriy Román-Leshkov     |      17 | 32.6 |      7 |    26 |  40 |  3265 | (2006 8 9)   |
| Michael J. Janik        |      24 |  9.3 |     11 |    33 |  88 |  1729 | (2005 12 4)  |
| Jeffrey P. Greeley      |      36 | 23.6 |     14 |    22 | 108 |  5473 | (2014 7 26)  |
| Suljo Linic             |      29 | 33.1 |     13 |    28 |  47 |  3246 | (2005 11 28) |
| Rohan Mishra            |       6 |  7.4 |      6 |     0 |  20 |   106 | (2011 2 10)  |


None of Cynthia Lo's first author papers are showing up.
#+BEGIN_SRC python
from scopus.scopus_author import *
au = ScopusAuthor('36786289800')
au.n_first_author_papers()

scopus_abstracts = [ScopusAbstract(eid)
                    for eid in au.get_document_eids()
                    if ScopusAbstract(eid).aggregationType == 'Journal']

first_authors = [1 for ab in scopus_abstracts
                 if ab.authors[0].scopusid == au.author_id]
print first_authors
print [ab.authors[0].scopusid for ab in scopus_abstracts]
print [ab.authors[0].indexed_name for ab in scopus_abstracts]

#+END_SRC

#+RESULTS:
: []
: ['56416508500', '55581066000', '36967806600', '56416508500', '55923852900', '36967806600', '6507412549', '56405307200', '55372258500', '55581066000', '36727879000', '55006113200', '6507412549', '55006113200', '55372258500', '55581066000', '55006113200', '55006113200', '39961627300', '36727879000', '25651125000', '21741173000', '16314196200', '24072097500']
: ['Faghaninia A.', 'Jiang J.', 'Bricker W.P.', 'Faghaninia A.', 'Cheng Z.', 'Bricker W.P.', 'Niedzwiedzki D.M.', 'Mueller V.H.', 'Stoica M.', 'Jiang J.', 'Kovacs S.A.', 'Cheng Z.', 'Niedzwiedzki D.M.', 'Cheng Z.', 'Stoica M.', 'Jiang J.', 'Cheng Z.', 'Cheng Z.', 'Havran V.', 'Kovacs S.A.', 'Zheng X.', 'Unrau C.J.', 'Rycenga M.', 'Thimsen E.']




#+BEGIN_SRC python :results raw
from scopus.scopus_author import *
print ScopusAuthor('36786289800')
#+END_SRC

#+RESULTS:
** Cynthia Lo (updated on Tue Sep 29 15:57:43 2015)
   :PROPERTIES:
   :ID:       E9E4654D-77C1-4C7A-8F33-E7878C180083
   :END:
http://www.scopus.com/authid/detail.url?partnerID=HzOxMe3b&authorId=36786289800&origin=inward
36 documents cited 216 times by 206 people (44 coauthors)
#first author papers 0
#last author papers 16
h-index: 8        AIF(2014) = 5.88
Scopus ID created on (2011, 6, 5)

Current affiliation according to Scopus:
  Washington University in St. Louis, Department of Energy, Environmental and Chemical Engineering

Subject areas
  Chemical Engineering (all) (16), Chemistry (all) (12), Physical and
  Theoretical Chemistry (10), Surfaces, Coatings and Films (8),
  Catalysis (7), Biochemistry (6), Cell Biology (6), Industrial and
  Manufacturing Engineering (6), Electronic, Optical and Magnetic
  Materials (5), Materials Chemistry (5), Condensed Matter Physics
  (4), Biophysics (3), Energy (all) (3), Plant Science (3), Chemical
  Engineering (miscellaneous) (3), Medicine (all) (2), Physics and
  Astronomy (all) (2), Materials Science (all) (2), Biotechnology (1),
  Genetics (1), Molecular Biology (1), Structural Biology (1), Safety,
  Risk, Reliability and Quality (1), Information Systems (1), Modeling
  and Simulation (1), Bioengineering (1), Process Chemistry and
  Technology (1)

Publishes in:
  FEBS Lett., Conf. Proc. - AIChE Annu. Mtg., 09AIChE, AIChE - AIChE
  Annu. Meet., Conf. Proc., AIChE - AIChE Annu. Meet., Conf. Proc.,
  Top. Catal., New J. Phys., ACS Natl. Meet. Book Abstr., Catal.,
  Biochim. Biophys. Acta Bioenerg., J Phys Chem B, J Phys Chem B,
  Phys. Rev. B Condens. Matter Mater. Phys., J. Phys. Chem. B, Mol
  Simul, ACS Catal., AIChE - AIChE Annu. Meet., Conf. Proc., J Phys
  Condens Matter, Appl. Catal. A Gen., Photosynth. Res., Angew. Chem.
  Int. Ed., J Chem Phys, J. Phys. Chem. C, Phys. Rev. B Condens.
  Matter Mater. Phys., Biochim. Biophys. Acta Bioenerg., Photosyn.
  Res., J Phys Chem B, Ind. Eng. Chem. Res.

Affiliation history:
37 of 37 documents
 1. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=61649126491&origin=inward][2-s2.0-61649126491]]  E. Thimsen, S. Biswas, C.S. Lo and P. Biswas, Predicting the band structure of mixed transition metal oxides: Theory and experiment, Journal of Physical Chemistry C, 113(5), p. 2014-2021, (2009). https://doi.org/10.1021/jp807579h, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=61649126491&origin=inward, cited 71 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 2. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=72449177429&origin=inward][2-s2.0-72449177429]]  M. Rycenga, Z. Wang, E. Gordon, C.M. Cobley, A.G. Schwartz, C.S. Lo and Y. Xia, Probing the photothermal effect of gold-based nanocages with surface-enhanced Raman scattering (SERS), Angewandte Chemie - International Edition, 48(52), (no pages found) (2009). https://doi.org/10.1002/anie.200904382, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=72449177429&origin=inward, cited 43 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 3. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79958827846&origin=inward][2-s2.0-79958827846]]  V. Havran, M.P. Duduković and C.S. Lo, Conversion of methane and carbon dioxide to higher value products, Industrial and Engineering Chemistry Research, 50(12), p. 7089-7100, (2011). https://doi.org/10.1021/ie2000192, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79958827846&origin=inward, cited 32 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 4. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872066774&origin=inward][2-s2.0-84872066774]]  Z. Cheng, B.J. Sherman and C.S. Lo, Carbon dioxide activation and dissociation on ceria (110): A density functional theory study, Journal of Chemical Physics, 138(1), Art. No. 014702 (2013). https://doi.org/10.1063/1.4773248, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872066774&origin=inward, cited 16 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 5. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84860994429&origin=inward][2-s2.0-84860994429]]  J. Jiang, H. Zhang, Y. Kang, D. Bina, C.S. Lo and R.E. Blankenship, Characterization of the peridinin-chlorophyll a-protein complex in the dinoflagellate Symbiodinium, Biochimica et Biophysica Acta - Bioenergetics, 1817(7), p. 983-989, (2012). https://doi.org/10.1016/j.bbabio.2012.03.027, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84860994429&origin=inward, cited 10 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 6. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78049401297&origin=inward][2-s2.0-78049401297]]  X. Zheng, G.M. Veith, E. Redekop, C.S. Lo, G.S. Yablonsky and J.T. Gleaves, Oxygen and CO adsorption on Au/SiO2 catalysts prepared by magnetron sputtering: The role of oxygen storage, Industrial and Engineering Chemistry Research, 49(21), p. 10428-10437, (2010). https://doi.org/10.1021/ie100547f, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78049401297&origin=inward, cited 10 times (Scopus).
Affiliations:
   id:60028590 St. Louis University
   id:60010261 Washington University in St. Louis
   id:60024266 Oak Ridge National Laboratory

 7. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84858056670&origin=inward][2-s2.0-84858056670]]  Z. Cheng and C.S. Lo, Formation of active sites on WO 3 catalysts: A density functionaltheory study of olefin metathesis, ACS Catalysis, 2(3), p. 341-349, (2012). https://doi.org/10.1021/cs2005778, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84858056670&origin=inward, cited 9 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 8. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84898831441&origin=inward][2-s2.0-84898831441]]  D.M. Niedzwiedzki, J. Jiang, C.S. Lo and R.E. Blankenship, Spectroscopic properties of the Chlorophyll a-Chlorophyll c 2-Peridinin-Protein-Complex (acpPC) from the coral symbiotic dinoflagellate Symbiodinium, Photosynthesis Research, 120(1-2), p. 125-139, (2014). https://doi.org/10.1007/s11120-013-9794-5, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84898831441&origin=inward, cited 8 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 9. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84884926529&origin=inward][2-s2.0-84884926529]]  D.M. Niedzwiedzki, J. Jiang, C.S. Lo and R.E. Blankenship, Low-temperature spectroscopic properties of the peridinin-chlorophyll a-protein (PCP) complex from the coral symbiotic dinoflagellate symbiodinium, Journal of Physical Chemistry B, 117(38), p. 11091-11099, (2013). https://doi.org/10.1021/jp401022u, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84884926529&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

10. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84866142336&origin=inward][2-s2.0-84866142336]]  Z. Cheng, N.A. Fine and C.S. Lo, Platinum nanoclusters exhibit enhanced catalytic activity for methane dehydrogenation, Topics in Catalysis, 55(5-6), p. 345-352, (2012). https://doi.org/10.1007/s11244-012-9803-5, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84866142336&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

11. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78650413591&origin=inward][2-s2.0-78650413591]]  S.A. Kovács and C.S. Lo, Electronic structure and charge ordering in magnetite: Implications for the Fe3O4 (001)-water interface, Molecular Simulation, 36(15), p. 1289-1296, (2010). https://doi.org/10.1080/08927022.2010.517735, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78650413591&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

12. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77953502784&origin=inward][2-s2.0-77953502784]]  C.J. Unrau, R.L. Axelbaum and C.S. Lo, High-yield growth of carbon nanotubes on composite Fe/Si/O nanoparticle catalysts: A car-parrinello molecular dynamics and experimental study, Journal of Physical Chemistry C, 114(23), p. 10430-10435, (2010). https://doi.org/10.1021/jp909255r, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77953502784&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

13. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84905728423&origin=inward][2-s2.0-84905728423]]  W.P. Bricker and C.S. Lo, Excitation energy transfer in the peridinin-chlorophyll a-protein complex modeled using configuration interaction, Journal of Physical Chemistry B, 118(31), p. 9141-9154, (2014). https://doi.org/10.1021/jp5017054, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84905728423&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

14. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84907261562&origin=inward][2-s2.0-84907261562]]  J. Jiang, H. Zhang, G.S. Orf, Y. Lu, W. Xu, L.B. Harrington, H. Liu, C.S. Lo and R.E. Blankenship, Evidence of functional trimeric chlorophyll a/c2-peridinin proteins in the dinoflagellate Symbiodinium, Biochimica et Biophysica Acta - Bioenergetics, 1837(11), p. 1904-1912, (2014). https://doi.org/10.1016/j.bbabio.2014.07.023, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84907261562&origin=inward, cited 2 times (Scopus).
Affiliations:


15. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84892731712&origin=inward][2-s2.0-84892731712]]  S.Á. Kovács, W.P. Bricker, D.M. Niedzwiedzki, P.F. Colletti and C.S. Lo, Computational determination of the pigment binding motif in the chlorosome protein a of green sulfur bacteria, Photosynthesis Research, 118(3), p. 231-247, (2013). https://doi.org/10.1007/s11120-013-9920-4, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84892731712&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

16. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84887593491&origin=inward][2-s2.0-84887593491]]  Z. Cheng and C.S. Lo, Effect of support structure and composition on the catalytic activity of Pt nanoclusters for methane dehydrogenation, Industrial and Engineering Chemistry Research, 52(44), p. 15447-15454, (2013). https://doi.org/10.1021/ie400776n, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84887593491&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

17. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84867025683&origin=inward][2-s2.0-84867025683]]  M. Stoica and C.S. Lo, Electrical transport properties of Co-based skutterudites filled with Ag and Au, Physical Review B - Condensed Matter and Materials Physics, 86(11), Art. No. 115211 (2012). https://doi.org/10.1103/PhysRevB.86.115211, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84867025683&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

18. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84908620507&origin=inward][2-s2.0-84908620507]]  V.H. Mueller, M.P. Duduković and C.S. Lo, The role of metal-support interaction on catalytic methane activation, Applied Catalysis A: General, 488, p. 138-147, (2014). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84908620507&origin=inward, cited 1 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

19. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901709620&origin=inward][2-s2.0-84901709620]]  M. Stoica and C.S. Lo, P-type zinc oxide spinels: Application to transparent conductors and spintronics, New Journal of Physics, 16, Art. No. 055011 (2014). https://doi.org/10.1088/1367-2630/16/5/055011, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901709620&origin=inward, cited 1 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

20. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84935043479&origin=inward][2-s2.0-84935043479]]  A. Faghaninia, J.W. Ager and C.S. Lo, Ab initio electronic transport model with explicit solution to the linearized Boltzmann transport equation, Physical Review B - Condensed Matter and Materials Physics, 91(23), Art. No. 235123 (2015). https://doi.org/10.1103/PhysRevB.91.235123, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84935043479&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis
   id:60007174 Lawrence Berkeley National Laboratory

21. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84941426406&origin=inward][2-s2.0-84941426406]]  J. Jiang, H. Zhang, X. Lu, Y. Lu, M.J. Cuneo, H.M. O'Neill, V. Urban, C.S. Lo and R.E. Blankenship, Oligomerization state and pigment binding strength of the peridinin-Chl a-protein, FEBS Letters, 589(19), p. 2713-2719, (2015). https://doi.org/10.1016/j.febslet.2015.07.039, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84941426406&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis
   id:60024266 Oak Ridge National Laboratory

22. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84928995456&origin=inward][2-s2.0-84928995456]]  W.P. Bricker and C.S. Lo, Efficient pathways of excitation energy transfer from delocalized S <inf>2</inf> excitons in the peridinin-chlorophyll a -protein complex, Journal of Physical Chemistry B, 119(18), p. 5755-5764, (2015). https://doi.org/10.1021/jp511766j, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84928995456&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

23. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924411864&origin=inward][2-s2.0-84924411864]]  A. Faghaninia and C.S. Lo, First principles study of defect formation in thermoelectric zinc antimonide, β-Zn4Sb3
, Journal of Physics Condensed Matter, 27(12), Art. No. 125502 (2015). https://doi.org/10.1088/0953-8984/27/12/125502, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924411864&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

24. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84927721858&origin=inward][2-s2.0-84927721858]]  Z. Cheng and C.S. Lo, Propagation of Olefin Metathesis to Propene on WO<inf>3</inf> Catalysts: A Mechanistic and Kinetic Study, ACS Catalysis, 5(1), p. 59-72, (2015). https://doi.org/10.1021/cs500531b, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84927721858&origin=inward, cited 0 times (Scopus).
Affiliations:


25. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84937414302&origin=inward][2-s2.0-84937414302]]  E. Lee, Z. Cheng and C.S. Lo, Present and future prospects in heterogeneous catalysts for C<inf>1</inf> chemistry, Catalysis, 27, p. 187-208, (2015). https://doi.org/10.1039/9781782622697-00187, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84937414302&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

26. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872855145&origin=inward][2-s2.0-84872855145]]  S.A. Kovács, W.P. Bricker, J. Jiang and C.S. Lo, Evaluating photosynthetic antenna complex assemblies for efficient solar energy utilization, AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2012). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872855145&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

27. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872835453&origin=inward][2-s2.0-84872835453]]  Z. Cheng and C.S. Lo, Computational study on olefin metathesis of ethene and 2-butene on WO3 surfaces, AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2012). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872835453&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

28. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872856541&origin=inward][2-s2.0-84872856541]]  Z. Cheng, V. Havran, N.A. Fine, B. Sherman and C.S. Lo, A first-principles study on carbon dioxide reforming of methane over supported Pt catalysts, AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2012). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872856541&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60013372 University of Texas at Austin
   id:60010261 Washington University in St. Louis

29. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857217577&origin=inward][2-s2.0-84857217577]]  S. Kovcs and C.S. Lo, Modeling protein-surface interactions for biohybrid solar energy utilization, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857217577&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

30. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857226857&origin=inward][2-s2.0-84857226857]]  V. Havran, M.P. Dudukovic and C.S. Lo, Catalytic conversion of methane and carbon dioxide to higher value products, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857226857&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

31. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857214814&origin=inward][2-s2.0-84857214814]]  Z. Cheng and C.S. Lo, Computational study on dry reforming reactions over Pt/TiO
                    2 catalysts, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857214814&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

32. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857209688&origin=inward][2-s2.0-84857209688]]  Z. Cheng and C.S. Lo, Active sites for olefin metathesis on WO
                    3 catalysts: A density functional theory study, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857209688&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

33. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79251501995&origin=inward][2-s2.0-79251501995]]  N.A. Fine and C.S. Lo, Methane dehydrogenation on platinum-based nanocluster catalysts, 10AIChE - 2010 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2010). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79251501995&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

34. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951482671&origin=inward][2-s2.0-79951482671]]  B.J. Sherman, N.A. Fine and C.S. Lo, Computational design of multifunctional catalysts for efficient carbon dioxide and methane utilization, ACS National Meeting Book of Abstracts, None, (no pages found) (2010). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951482671&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

35. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951481223&origin=inward][2-s2.0-79951481223]]  S.Á. Kovács, W.P. Bricker, K.W. Leung and C.S. Lo, Structure and organization of photosynthetic antenna complexes for efficient excitation energy transfer, ACS National Meeting Book of Abstracts, None, (no pages found) (2010). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951481223&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

36. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77952256378&origin=inward][2-s2.0-77952256378]]  N.A. Fine and C.S. Lo, Density functional theory analysis of methane dehydrogenation on platinum nanoclusters for liquid fuels production, Conference Proceedings - 2009 AIChE Annual Meeting, 09AIChE, None, (no pages found) (2009). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77952256378&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

37. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77955601322&origin=inward][2-s2.0-77955601322]]  E. Thimsen, C.S. Lo and P. Biswas, Nanostructured TiO2 thin films co-doped with transition metals for enhanced visible light absorption: Experiments and first-principles calculations, ACS National Meeting Book of Abstracts, None, (no pages found) (2008). https://doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77955601322&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis



* time stamp in code block
  :PROPERTIES:
  :ID:       3D2C7A3D-CDED-48B7-AC50-F0A3CE051332
  :END:

#+name: update-timestamp
#+BEGIN_SRC emacs-lisp :var data=""

 (re-search-forward "#\\+END_SRC")
 (kill-line)
 (insert (concat " #Last run: "  (format-time-string "[%Y-%m-%d %a %H:%M:%S]" (current-time))))

data
#+END_SRC #Last run: [2015-09-21 Mon 15:19:10]



#+BEGIN_SRC python :post update-timestamp(data=*this*)
print('hello')
#+END_SRC

#+RESULTS:
: hello

#+BEGIN_SRC emacs-lisp :time-stamp
(defun j-add-ts ()
  (save-excursion
    ; this is a little hacky, but it works.
    (when (string= ":time-stamp" (plist-get (cadr (org-element-context)) :parameters))

      (re-search-forward "#\\+END_SRC")
      (forward-line)
      (beginning-of-line)
      (when (looking-at "# Last run:")
	(kill-line))
      (insert (concat
	       "# Last run: "
	       (format-time-string "[%Y-%m-%d %a %H:%M:%S]" (current-time)))))))


(add-hook 'org-babel-after-execute-hook 'j-add-ts)

;(remove-hook 'org-babel-after-execute-hook  'j-add-ts)
#+END_SRC

#+RESULTS:
| j-add-ts | org-babel-python-strip-session-chars | (lambda nil (org-refresh-images)) |

#+BEGIN_SRC python
print 'hello'
#+END_SRC

#+RESULTS:
: hello



* A more flexible s-format
  :PROPERTIES:
  :ID:       9C372ECA-9005-4263-831F-D5D7AFAB87AF
  :END:
s-format can take an arbitrary function

This is tough logic to get right in one conditional
#+BEGIN_SRC emacs-lisp :results output
(defun j-replacer (name &optional extra)
  "Find the replacement for NAME, possibly using EXTRA.
If EXTRA is a list, and NAME a number, then NAME refers to positions in EXTRA.
If EXTRA is a hash-table, and NAME is a key in it, it returns the value.
If EXTRA is a list, we try to get the value from assoc, then as a plist.
If NAME is a sexp, we return the evaluated form.
If NAME is a bound variable, we return its value."
  (let (result)
    (catch 'result
      ;; a numeric argument
      (when (and extra
		 (listp extra)
		 (string-match "^[0-9]+$" name))
	(throw 'result (format "%s" (elt extra (string-to-int name)))))

      ;; check hash table
      (when (and
	     extra
	     (hash-table-p extra))
	(when (setq result (gethash name extra))
	  (throw 'result result)))

      ;; try alist
      (when
	  (and extra
	       (listp extra)
	       (setq result (assoc name extra)))
	(throw 'result (cdr  result)))

      ;; try plist
      (when (and extra
		 (listp extra)
		 (setq result (plist-get extra (intern (concat ":" name)))))
	(throw 'result result))

      ;; maybe a sexp?
      (when (with-temp-buffer
	      (insert name)
	      (goto-char (point-min))
	      (and
	       (thing-at-point 'sexp)
	       (s-starts-with? "(" (buffer-string))
	       (s-ends-with? ")" (buffer-string))))
	(throw 'result (format "%s" (eval (read name)))))

      ;; Check for bound variables
      (when (intern-soft name)
	(when (-contains? '("name" "extra") name)
	  (error "You cannot expand \"%s\". Please change it to some other variable name." name))
	(throw 'result (symbol-value (intern-soft name))))

      ;; nothing found
      (error "\"%s\" was not found" name))))


(defun j-format (j-template &optional data)
  "Use `j-replacer' with `s-format' as a templating system."
  (s-format j-template 'j-replacer data))

(print (j-format "1. ${name} and ${(+ 4 5)}" '(("name" . "John"))))
(print (j-format "2. ${name} and ${(+ 4 5)}" '(:name "John")))

(setq data (make-hash-table :test 'equal))
(puthash "name" "Jimmy" data)
(print (j-format "3. ${name} and ${(+ 4 5)}"  data))

(setq name "untill")
(setq this-name "till")
(print  (j-format "4. ${this-name} ${user-full-name} and ${(+ 4 5)} or ${1}"  '(a b c)))
#+END_SRC

#+RESULTS:
:
: "1. John and 9"
:
: "2. John and 9"
:
: "3. Jimmy and 9"
:
: "4. till John Kitchin and 9 or b"


#+BEGIN_SRC emacs-lisp
(let ((name-it "bill"))
(boundp 'name-it))
#+END_SRC

#+RESULTS:
: t


* Customizing mu4e
  :PROPERTIES:
  :ID:       C8296B2A-EFC5-4779-A9CB-3EE88D2FA1A0
  :END:
[[http://www.djcbsoftware.nl/code/mu/mu4e/HV-Custom-headers.html#HV-Custom-headers][mu4e 0.9.12 user manual: HV Custom headers]]

#+BEGIN_SRC emacs-lisp
(add-to-list 'mu4e-header-info-custom
  '(:recipnum .
    ( :name "Number of recipients"  ;; long name, as seen in the message-view
      :shortname "Recip#"           ;; short name, as seen in the headers view
      :help "Number of recipients for this message" ;; tooltip
      :function
      (lambda (msg)
	(format "%d"
	  (+ (length (mu4e-message-field msg :to))
	    (length (mu4e-message-field msg :cc))))))))

(add-to-list 'mu4e-headers-fields (cons :recipnum nil) t)
(setq mu4e-headers-fields (-remove-item '(:recipnum) mu4e-headers-fields))
#+END_SRC

#+RESULTS:
| :recipnum | :name | Number of recipients | :shortname | Recip# | :help | Number of recipients for this message | :function | (lambda (msg) (format %d (+ (length (mu4e-message-field msg :to)) (length (mu4e-message-field msg :cc))))) |

mu4e:msgid:m2egi9np93.fsf@andrew.cmu.edu


Message-ID: <BLUPR0401MB177812963CF71FD54C291D93AB530@BLUPR0401MB1778.namprd04.prod.outlook.com>
References: <m2a8syxu48.fsf@andrew.cmu.edu>
 <BLUPR0401MB1778F500DA3CBA3C3B1B0B29AB530@BLUPR0401MB1778.namprd04.prod.outlook.com>
 <m2egi9np93.fsf@andrew.cmu.edu>
In-Reply-To: <m2egi9np93.fsf@andrew.cmu.edu>


#+BEGIN_SRC emacs-lisp
(defun open-msgid ()
  "get msg-id at point and open it."
  (interactive)
  (save-excursion
    (re-search-backward "<")
    (re-search-forward "<\\([^>]*\\)>")
    (org-open-link-from-string (format "[[mu4e:msgid:%s]]" (match-string 1)))))
#+END_SRC

#+RESULTS:
: open-msgid

** custom view header to org-headings
   :PROPERTIES:
   :ID:       CFCAA3E6-8CAA-4681-B1C0-EF3A0D6F288B
   :END:
mu4e-view-fields

#+BEGIN_SRC emacs-lisp
(defun org-ref-ids (msg)
  (let ((matches '()))
    (when (mu4e-message-field msg :body-txt)
      (with-temp-buffer
	(insert (mu4e-message-field msg :body-txt))
	(goto-char (point-min))
	(while (re-search-forward
		"\\[\\[id:\\(.*\\)\\]\\]"
		nil t)
	  (add-to-list 'matches
		       (match-string 0)))
	(when matches
	  (mapconcat 'identity matches "\n"))))))

(setq mu4e-org-refs
      '(:orgrefs . (:name "Org references"
			   :shortname "orgrefs"
			   :help "List of links to org headings by ID"
			   :function org-ref-ids)))
(setq mu4e-header-info-custom '())
(add-to-list 'mu4e-header-info-custom mu4e-org-refs)
(add-to-list 'mu4e-view-fields :orgrefs t)
#+END_SRC

#+RESULTS:
| :from | :to | :cc | :subject | :flags | :date | :maildir | :mailing-list | :tags | :attachments | :signature | :decryption | :orgrefs |

** Custom view header with links to in reply to and references
   :PROPERTIES:
   :ID:       9134A91B-F75F-4511-83B1-9A9D7BB38450
   :END:

#+BEGIN_SRC emacs-lisp
(defun mu4e-get-subject-from-msgid (msgid)
  (car
   (s-split
    "\n"
    (shell-command-to-string
     (format  "mu find msgid:%s -f s" msgid)))))

(defun mu4e-reference-links (msg)
  (interactive)
  (let ((references (mu4e-message-field msg :references)))
    (when references
	 (mapconcat
	  'identity
	  (loop for i from 1
		for reference in references
		collect (format "%s. [[mu4e:msgid:%s]]" i reference))
	  "\n"))))

(defun mu4e-reply-to-links (msg)
  (interactive)
  (let ((reply-to (mu4e-message-field msg :in-reply-to)))
    (when (not (string= "" reply-to))
     (format
      "[[mu4e:msgid:%s]]"
      (replace-regexp-in-string "<\\|>" "" reply-to)))))

(setq mu4e-message-refs
      '(:mrefs . (:name "References:"
			   :shortname "mrefs"
			   :help "List of links to messages by ID"
			   :function mu4e-reference-links)))

(setq mu4e-reply-to-refs
      '(:repref . (:name "In-Reply-To:"
			   :shortname "rrefs"
			   :help "Link to reply to message"
			   :function mu4e-reply-to-links)))

(add-to-list 'mu4e-header-info-custom mu4e-message-refs)
(add-to-list 'mu4e-view-fields :mrefs t)

(add-to-list 'mu4e-header-info-custom mu4e-reply-to-refs)
(add-to-list 'mu4e-view-fields :repref t)

(setq mu4e-view-fields (-remove-item :reprefs mu4e-view-fields))

(button-lock-set-button
 "\\[\\[mu4e:msgid:.*\\]\\]"
 (lambda ()
   (org-open-link-from-string
    (get-surrounding-text-with-property 'mu4e-msgid)))
 :face '((:foreground "Blue")
	 (:underline t))
 :additional-property 'mu4e-msgid)

#+END_SRC

#+RESULTS:
| \[\[mu4e:msgid:.*\]\] | (0 (quote (face ((:foreground Blue) (:underline t)) keymap (keymap (mouse-1 lambda nil (org-open-link-from-string (get-surrounding-text-with-property (quote mu4e-msgid))))) button-lock t mu4e-msgid t mouse-face button-lock-mouse-face rear-nonsticky t)) append) |

** Add note to headline from a message
   :PROPERTIES:
   :ID:       1302C78F-05FD-4F72-9DB9-A692B6C66123
   :END:

I want to scan the current message for an id link, open the headline, and put a link in it.

#+BEGIN_SRC emacs-lisp
(defun activate-on-id ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\[\\[id:\\(.*\\)\\]\\]" nil t)
      (let ((cb (current-buffer))
	    (msgid (mu4e-message-field (mu4e-message-at-point) :message-id))
	    (subject (mu4e-message-field (mu4e-message-at-point) :subject))
	    (id (match-string 1))
	    file
	    values)
	(setq file (org-id-find id))
        (find-file (car file))
        (goto-char (cdr file))
	(if (org-entry-get (point) "Message-IDs")
	    (setq values (read (org-entry-get (point) "Message-IDs")))
	  (setq values '()))
	(add-to-list 'values (format "[[mu4e:msgid:%s][%s]]" msgid subject))
	(org-entry-put (point) "Message-IDs" (format "%S" values))
        (save-buffer)
	(switch-to-buffer cb)))))

(add-hook 'mu4e-view-mode-hook 'activate-on-id)
#+END_SRC

#+RESULTS:
| activate-on-id | email-fontify | on-view | #[nil \301\300!\210\302\211\207 [bookmark-make-record-function make-local-variable mu4e-view-bookmark-make-record] 2] |

* a tblfm
  :PROPERTIES:
  :ID:       9E36112D-5412-4F0A-9334-AD8E2A37D697
  :END:

| Student | Assgn Points | Points Earned | Possible | Achieved | Percentage |
|---------+--------------+---------------+----------+----------+------------|
| Barney  |           40 |           35. |       16 |       14 |       87.5 |
| Barney  |           40 |           35. |       16 |       14 |       87.5 |
| Betty   |           40 |           30. |       16 |       12 |        75. |
| Fred    |           40 |           25. |       16 |       10 |       62.5 |
| Wilma   |           40 |          17.5 |       16 |        7 |      43.75 |
#+TBLFM: $6 = ($5 / $4) * 100 ::  $3 = ($6 / 100) * $2

#+BEGIN_SRC emacs-lisp
(/ 14.0 16.0)
#+END_SRC

#+RESULTS:
: 0.875

* dynamic yasnippet
  :PROPERTIES:
  :ID:       393D5FC5-90EB-48E2-B804-20FA735C6402
  :END:
#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# name : my-fortune
# key: myf
# expand-env: ((yas-indent-line nil)
# --

#+BEGIN_QUOTE:
${1:`(shell-command-to-string \"fortune\")`}
#END_QUOTE

$0
")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# -*- mode: snippet -*-
# key: sc
# name: Source Block
# group: HELP
# contributor: gcr@wisdomandwonder.com
# --
,#+NAME: ${1:`(org-id-new)`}
,#+BEGIN_SRC ${2:$$(yas-choose-value '(\"emacs-lisp\" \"python\" \"org\"))}${2:$(when (-contains? '(\"ditaa\" \"dot\"
\"plantuml\") yas-text) (concat \" :file \\\"./image/\" (yas-field-value 1)
\".png\\\"\"))} $3
$0
,#+END_SRC")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+NAME: 77C740DF-C6E6-4A99-885E-9C7D0E3B145A
#+BEGIN_SRC emacs-lisp
(+ 2 4)
#+END_SRC

#+RESULTS: 77C740DF-C6E6-4A99-885E-9C7D0E3B145A
: 6

#+BEGIN_SRC emacs-lisp
(defun org-src-block-store-link ()
  (let* ((object (org-element-context)))
    (when (equal (org-element-type object) 'src-block)
      (org-store-link-props
       :type "src-block"
       :link (concat "src-block:" (org-element-property :name object))))))

(add-hook 'org-store-link-functions 'org-src-block-store-link)

(org-add-link-type
 "src-block"
 (lambda (label)
   (org-mark-ring-push)
   (widen)
   (goto-char (point-min))
   (re-search-forward (regexp-quote (format "#+NAME: %s" label)))
   (beginning-of-line)))
#+END_SRC

#+RESULTS:
| lambda | (label) | (org-mark-ring-push) | (widen) | (goto-char (point-min)) | (re-search-forward (regexp-quote (format #+NAME: %s label))) | (beginning-of-line) |

[[src-block:77C740DF-C6E6-4A99-885E-9C7D0E3B145A]]

* Dates in headers and sorting
  :PROPERTIES:
  :ID:       4AB9F3A8-4217-4F7D-951D-6EEA3CCA1622
  :END:


** [2013-09-02 Mon]
   :PROPERTIES:
   :ID:       14031C0A-1F8A-46C3-9A04-605CBE60E616
   :END:
** [2014-09-02 Tue]
   :PROPERTIES:
   :ID:       A9E1F668-50BD-4D62-9777-205439FEB8FE
   :END:
** [2015-09-02 Wed]
   :PROPERTIES:
   :ID:       1DE36EB6-3D7E-416A-96A8-1D0ED40A81CE
   :END:

* Python tutor
  :PROPERTIES:
  :ID:       198C4A99-8C35-4AC5-A487-6A82334603CC
  :END:

** Example requests to get hints.
   :PROPERTIES:
   :ID:       1B2FA9D7-218B-45B1-BFAC-8A596D328AC6
   :END:
This is code to explore using the Python tutor That Kelly Rivers has developed. Below is an example that shows how to do it in Python.
#+BEGIN_SRC python
import json

payload = {'needsReturn': True,
           'code': '''def canDrinkAlcohol(age, isDriving):
    return age >= 21 and not isDrivin
''',
           'userId': 'jkitchin',
           'problemId': 'canDrinkAlcohol'}

url = 'http://www.krivers.net/feedback/gethint.php'
headers = {'Content-type': 'application/json'}

import requests

print requests.post(url, data=json.dumps(payload)).json()
#+END_SRC

#+RESULTS:
: {u'hint': u"In line 2 replace <b>isDrivin</b> with something in the value of the unary operation.<br>If you're still stuck, ask for the next level of hint!"}


Here is the equivalent code In Emacs Lisp


#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((url-request-method "POST")
      (url "http://www.krivers.net/feedback/gethint.php")
      (url-request-data (json-encode-alist `((needsReturn . t)
					     (userId . "jkitchin")
					     (problemId . "canDrinkAlcohol")
					     (code . "def canDrinkAlcohol(age, isDriving):
    return age >= 21 and not isDriving")))))
    (with-current-buffer  (url-retrieve-synchronously url)
      (message-box
       (buffer-substring url-http-end-of-headers (point-max)))))
#+END_SRC

#+RESULTS:
:
: {"hint":"Your solution is already correct! Press 'Submit' to get credit for solving the problem."}

** Get hint for a code block
   :PROPERTIES:
   :ID:       7BB91C52-D39C-4263-98DC-2BB445FA29E7
   :END:
Function to get a hint from a code block:

#+BEGIN_SRC emacs-lisp
(require 'json)

(defvar cloudcoder-userid "jkitchin")

(defun cloudcoder-check-answer (&optional debug)
  "With your cursor in a Python source block, send code to the
hint server to get a hint. Use a prefix arg for DEBUG."
  (interactive "P")
  ;;  first get code block
  (let* ((src-block (org-element-context))
	 (url-request-method "POST")
	 (url "http://www.krivers.net/feedback/gethint.php")
	 (url-request-data
	  (json-encode-alist `((needsReturn . t)
			       (userId . cloudcoder-userid)
			       (problemId . ,(org-element-property :name src-block))
			       (code . ,(org-element-property :value src-block)))))
	 json-response)
    (when debug
      (message "%s" url-request-data))
    (with-current-buffer  (url-retrieve-synchronously url)
      (let ((response (s-trim
		       (buffer-substring url-http-end-of-headers (point-max)))))
	(when debug
	  (message response))
	(setq json-response
	      (json-read-from-string
	       response))
	(message "%S"
		 (replace-regexp-in-string
		  "<br>" "\n" (cdr (assoc 'hint json-response))))))))
#+END_SRC

#+RESULTS:
: cloudcoder-check-answer

Here are some example code blocks.

It looks like for this to work, you need use a function the server can evaluate, and the function has to have a name the server knows. There needs to be a userID stored in a variable for this. The org src-block needs a name that is the problemID.

It might be nice to show model solutions and pep8 style feedback. I can get the hints, but I am not sure about submitting this.

For engineering, if we can use Enthought or Continuum we can get numpy, scipy, and matplotlib. I would also want some other packages installed. Synchronization between local installations and the server could be a challenge.

*** canDrinkAlcohol
    :PROPERTIES:
    :ID:       ABC673CA-7227-45DB-ACEC-C6BEE436CFEB
    :END:
#+name: canDrinkAlcohol
#+BEGIN_SRC python
def canDrinkAlcohol(age, isDriving):
    return age == 21 and not isDriving

print canDrinkAlcohol(20, True)
#+END_SRC

#+RESULTS: canDrinkAlcohol
: False

*** overNineThousand
    :PROPERTIES:
    :ID:       923C751E-B759-441E-8B00-7DA5E52CA8D1
    :END:
#+name: overNineThousand
#+BEGIN_SRC python
def overNineThousand(N):
    return N > 9000
#+END_SRC


*** findRoot
    :PROPERTIES:
    :ID:       DC446B5C-FEE2-4BAC-BA7E-AACBB5A03A48
    :END:
there seems to be some security manager issue.

#+name: findRoot
#+BEGIN_SRC python
import math
def findRoot(a, b, c):
    return max([(-b + math.sqrt(b**2 - 4 * a * c)) / (2 * a), (-b - math.sqrt(b**2 - 4 * a * c)) / (2 * a)])

print findRoot(1, -7, 12)
#+END_SRC

#+RESULTS:
: 4.0


#+name: findRoot
#+BEGIN_SRC python
def findRoot(a, b, c):
    s1 = (-b + (b**2 - 4 * a * c)**0.5) / (2 * a)
    s2 = (-b - (b**2 - 4 * a * c)**0.5) / (2 * a)
    if s1 > s2:
        return s1
    else:
        return s2
#+END_SRC

*** kthDigit
    :PROPERTIES:
    :ID:       EEF72072-5497-45C2-8EBA-D8644DEC9591
    :END:
Given two integers, x and k, return the kth digit of x, counting from the right. So:
kthDigit(789, 0) returns 9
kthDigit(789, 1) returns 8
kthDigit(789, 2) returns 7
kthDigit(789, 3) returns 0
Negative numbers should work, too, so:
kthDigit(-789, 0) returns 9

#+name: kthDigit
#+BEGIN_SRC python
def kthDigit(x, k):
    s = str(abs(x))[::-1]
    return int(s[k]) if k < len(s) else 0
#+END_SRC

*** isEvenPositiveInt
    :PROPERTIES:
    :ID:       3E81E1F0-70A5-47A7-94AC-A4165996D4D4
    :END:

Given an arbitrary value x, return True if it is an integer, and it is positive, and it is even (all 3 must be True), or False otherwise. Do not crash if the value is not an integer. So, isEvenPositiveInt("yikes!") returns False (rather than crashing), and isEvenPositiveInt(123456) returns True.

#+name: isEvenPositiveInt
#+BEGIN_SRC python
def isEvenPositiveInt(x):
    return isinstance(x, int) and x > 0 and (x % 2 == 0)

print isEvenPositiveInt('yikes')
print isEvenPositiveInt(1)
print isEvenPositiveInt(-1)
print isEvenPositiveInt(1.0)
#+END_SRC

#+RESULTS: isEvenPositiveInt
: False
: False
: False
: False

*** nearestBusStop
    :PROPERTIES:
    :ID:       478CCDEA-9177-4575-A104-00B427BAD402
    :END:
Write a function that takes a non-negative street number, and returns the nearest bus stop to the given street, where buses stop every 8th street, including street 0, and ties go to the lower street, so the nearest bus stop to 12th street is 8th street, and the nearest bus stop to 13 street is 16th street.

#+name: nearestBusStop
#+BEGIN_SRC python
def nearestBusStop(street):
    a = street % 8
    if a <= 4:
        return street - a
    else:
        return street + (8 - a)

print nearestBusStop(12)
print nearestBusStop(13)
#+END_SRC

#+RESULTS: nearestBusStop
: 4
: 5


*** circleArea
    :PROPERTIES:
    :ID:       A8582463-F7FE-4480-8EE8-06ED53C2DA32
    :END:
This seems to have some security issues. failed_by_security_manager

Given the radius of a circle, calculate its area (pi r^2). Note that you'll need to get the built-in value of pi from the math module.

#+name: circleArea
#+BEGIN_SRC python
import math
def circleArea(radius):
    return math.pi * radius**2
#+END_SRC


This example seems to return no hint
#+BEGIN_SRC python
def circleArea(radius):
    return 3.141 / radius**2

print circleArea(1.00)
#+END_SRC

#+RESULTS:
: 3.141


* transposed table
  :PROPERTIES:
  :ID:       A2148F4A-8913-4BD2-A495-A02C73A0BF72
  :END:

#+name: my-data
| 1 | 2 | 3 | 4 |
| a | b | c | d |

#+BEGIN_SRC emacs-lisp
(defun get-transposed-table (tblname)
  (save-excursion
    (org-open-link-from-string (format  "[[%s]]" tblname))
    (while (not (org-table-p))
      (forward-line))
    (let* ((table (delete 'hline (org-table-to-lisp)))
	   (contents (mapcar (lambda (p)
			       (let ((tp table))
				 (mapcar
				  (lambda (rown)
				    (prog1
					(pop (car tp))
				      (setq tp (cdr tp))))
				  table)))
			     (car table))))
      (mapconcat (lambda(x) (concat "| " (mapconcat 'identity x " | " ) "  |\n" ))
		 contents ""))))
#+END_SRC

#+RESULTS:
: get-transposed-table

#+BEGIN_SRC python :var data=(get-transposed-table "my-data")
print data
#+END_SRC

#+RESULTS:
: | 1 | a  |
: | 2 | b  |
: | 3 | c  |
: | 4 | d  |
:

[[my-data]]
* AIF
  :PROPERTIES:
  :ID:       3BCA1806-8D41-4381-A2C1-DD01E4FD4F1D
  :END:

#+BEGIN_SRC python
from scopus import *
from scopus.scopus_api import get_encoded_text, ns, ScopusAbstract
from scopus.my_scopus import MY_API_KEY
import requests
import xml.etree.ElementTree as ET

import matplotlib.pyplot as plt
plt.xkcd()

QUERY = 'au-id(7004212771) and ((pubyear is {0}) or (pubyear is {1}))'

YEARS = [2008, 2009, 2010, 2011, 2012, 2013, 2014]
AIF = []
Hind = []
for YEAR in YEARS:

    s = ScopusSearch(query=QUERY.format(YEAR - 2, YEAR - 1),
                     fields='dc:identifier')

    abstracts = [ScopusAbstract(eid) for eid in s.EIDS
                 if ScopusAbstract(eid).aggregationType == 'Journal']


    TOTAL = 0 # citation count

    for ab in abstracts:
        xml = requests.get(ab.cite_link,
                           headers={'Accept': 'application/xml',
                                    'X-ELS-APIKey': MY_API_KEY}).text.encode('utf-8')

        results = ET.fromstring(xml)
        N = int(get_encoded_text(results, 'opensearch:totalResults'))

        start = 0
        count = 25

        while N > 0:
            xml = requests.get(ab.cite_link,
                               headers={'Accept': 'application/xml',
                                        'X-ELS-APIKey': MY_API_KEY},
                               params={'count': count,
                                       'start': start}).text.encode('utf-8')
            results = ET.fromstring(xml)

            start += count
            N -= count

            for el in results.findall('atom:entry/prism:coverDate', ns):
                year = int(el.text.split('-')[0])
                if year <= YEAR:
                    TOTAL += 1

    AIF.append(float(TOTAL) / len(abstracts))

    print Hind, AIF

    s = 'Author Impact Factor ({1}) = {0:1.3f} ({2} papers, {3} citations)\n'
    print(s.format(float(TOTAL) / len(abstracts),
                   YEAR,
                   len(abstracts),
                   TOTAL))

plt.figure()
plt.plot(YEARS, AIF, 'ro')
plt.xlabel('Year')
plt.ylabel('AIF_{2,3}')
plt.savefig('aif23.png')

plt.show()
#+END_SRC

#+RESULTS:



* Radio targets
  :PROPERTIES:
  :ID:       412F747B-B6F9-409E-9E62-1215247A3C54
  :END:

You can see this (id) and here (id-2), but you might prefer a link like [[some target][this one]].

a

a

a

a

a

a

a

a

a

a

a
a
a

a

a

a

























<<<id>>> http://example.com/ "Optional Title Here"

<<<id-2>>> Some other tidbit.

<<some target>> A note about something.
* Run shell command asynchronously
  :PROPERTIES:
  :ID:       5EC5171F-4F92-4222-941B-ADD124394AD6
  :END:

#+BEGIN_SRC sh :tangle some_cmd.sh :tangle-mode (identity #o755) :shebang #!/bin/bash
sleep 10
touch async-file
echo "done"
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(require 'async)

(org-babel-tangle)

(async-start
 (lambda ()
   (shell-command (expand-file-name "some_cmd.sh")))
 (lambda (result)
   (message-box "%s" result)))

#+END_SRC

#+RESULTS:
: #<process emacs>

#+BEGIN_SRC sh
ls async-file
#+END_SRC

#+RESULTS:
: async-file

#+BEGIN_SRC emacs-lisp
(require 'async)

(async-start
 (lambda ()
   (shell-command "xterm"))
 (lambda (result)
   (message-box "%s" result)))
#+END_SRC
#+RESULTS:
: #<process emacs>


* Tag clouds
  :PROPERTIES:
  :ID:       6A7A879E-79BA-4C5F-B7B6-5FDFE1604F63
  :END:

** this works!
   :PROPERTIES:
   :ID:       517634B9-D3C3-494A-BECD-96890D19F39F
   :END:
#+BEGIN_SRC python

with open('pg2852.txt') as f:
    text = f.read()

from os import path
import matplotlib.pyplot as plt
from wordcloud import WordCloud

wordcloud = WordCloud(font_path='/Users/jkitchin/Library/Fonts/Inconsolata-g.ttf').generate(text)
# Open a plot of the generated image.
plt.imshow(wordcloud)
plt.axis("off")
plt.show()
#+END_SRC

#+RESULTS:
==

** pygame doesn't quite work for large tag clouds
   :PROPERTIES:
   :ID:       54985716-EB13-4BDF-8518-B9597DC634A5
   :END:
[[http://blog.matt-swain.com/post/87112978897/fixing-matplotlib-png-output-on-mac-os-x][Fixing matplotlib png output on Mac OS X | Matt Swain]]
[[https://bitbucket.org/pygame/pygame/issues/82/homebrew-on-leopard-fails-to-install][pygame / pygame / issues / #82 - homebrew on Leopard fails to install —
Bitbucket]]

[[https://github.com/atizo/PyTagCloud/blob/master/pytagcloud/test/tests.py][PyTagCloud/tests.py at master · atizo/PyTagCloud]]

#+BEGIN_SRC python
from pytagcloud import create_tag_image, make_tags
from pytagcloud.lang.counter import get_tag_counts

YOUR_TEXT = "A tag cloud is a visual representation for text data, typically\
used to depict keyword metadata on websites, or to visualize visualize visualize free form text."

with open('pg2852.txt') as f:
    YOUR_TEXT = f.read()

tags = make_tags(get_tag_counts(YOUR_TEXT), maxsize=120)
#create_tag_image(tags, 'cloud_large.png', size=(900, 600))
#+END_SRC

#+RESULTS:


[[./cloud_large.png]]


* Updating a timestamp in a heading
  :PROPERTIES:
  :LAST-EDITED: [2015-08-01 Sat 12:01:27]
  :ID:       B2F84337-7F12-489D-85E1-43DC1AB5AB38
  :END:
Here is the function to update a timestamp when you run it.
#+BEGIN_SRC emacs-lisp
(defun update-last-edited (beg end length)
  (when
      (and
       (not (org-before-first-heading-p))
       (org-get-heading))
    (org-entry-put nil "LAST-EDITED" (format-time-string "[%Y-%m-%d %a %H:%M:%S]"))))

(add-to-list 'after-change-functions 'update-last-edited)
#+END_SRC

#+RESULTS:
| update-last-edited |

** test
   :PROPERTIES:
   :LAST-EDITED: [2015-08-01 Sat 12:01:30]
   :ID:       183C2526-E580-4CDD-A548-82E8B9B59473
   :END:

* Record audio and put link to it in org-mode
  :PROPERTIES:
  :ID:       F1DFF41B-F6EB-4D81-8264-BEEDDB40803A
  :END:

#+BEGIN_SRC emacs-lisp
(defun insert-voice-memo ()
  "Record voice memo and insert an org-mode link to it.
memos are stored by time-stamp in the current directory."
  (interactive)

  (let ((memo-name (replace-regexp-in-string "\\( \\|:\\)" "-"
					     (concat (current-time-string)
						     ".m4a"))))
    (do-applescript
     (format "tell application \"Finder\"
        set savePath to \"%s\"
        set savePath to POSIX file \"%s\" as text
	tell application \"QuickTime Player\"
		activate
		set doku to new audio recording
		start doku
		set yn to (display dialog \"Press Stop to quit and save.\" buttons {\"Stop\"} giving up after 600)
		stop doku
		set newDoc to last item of (documents whose name contains \"Untitled\")
		export newDoc in file savePath using settings preset \"Audio Only\"
		quit saving no
	end tell
end tell" (expand-file-name memo-name ".") (expand-file-name memo-name ".")))
 (insert (format
	     "[[./%s][%s]]"
	     memo-name (read-input "Description: " "voice memo")))))
#+END_SRC

#+RESULTS:
: insert-voice-memo

[[./Sun-Jul-26-08-45-09-2015.m4a]]   [[./Sun-Jul-26-09-00-55-2015.m4a][voice memo]]


* getting altmetric by doi
  :PROPERTIES:
  :ID:       541837D4-5836-44D7-B55B-5203330D423F
  :END:

#+BEGIN_SRC emacs-lisp
(defun doi-altmetrics (doi)
  (interactive "sDOI: ")
  (let ((url-request-method "GET")
	(url (concat "http://api.altmetric.com/v1/doi/" doi))
	(json-object-type 'plist)
	(json-data))
    (setq json-data
	  (with-current-buffer
	      (url-retrieve-synchronously url)

	    (json-read-from-string
	     (buffer-substring
	      url-http-end-of-headers (point-max)))))
    (browse-url
     (plist-get json-data :details_url))))

(doi-altmetrics "10.1021/jp511426q")
#+END_SRC

#+RESULTS:
: #<process open http://www.altmetric.com/details.php?citation_id=3863449>

* Get bibtex entries from a PDF		 :ARCHIVE:
  :PROPERTIES:
  :ID:       A43CE1C8-527E-42F1-B788-6374B61329B0
  :END:

Some reference managers like Zotero, Mendeley and Endnote can take a pdf and build a reference entry from it. There is a python project here: https://github.com/venthur/gscholar/blob/master/gscholar/gscholar.py that builds a google scholar query to get bibtex entries. We will build on this here, using emacs-lisp. The first step we need is to build the query. In gscholar.py they use [[http://www.foolabs.com/xpdf/download.html][pdftotext]] to get the pdf text and then select 20 words. The first 20 don't seem like the right choice to me since many pdfs have cover pages with nothing of substance on them. A really sophisticated tool would try to find the most relevant text, e.g. something that is clearly a title or doi, but there is so little structure in pdfs across the literature this does not seem worthwhile right now. So, we will take the last 20 words from the second page.

#+BEGIN_SRC emacs-lisp
(defun gscholar-pdf-words (pdf)
  (s-join
   " "
   (last
    (s-split
     " "
     (replace-regexp-in-string
      "\\W" " "
      (shell-command-to-string
       (format "pdftotext -f 2 -l 2 %s - | less" pdf))))
    20)))

(gscholar-pdf-words "~/Dropbox/bibliography/bibtex-pdfs/alcock-1964-therm.pdf")
#+END_SRC

#+RESULTS:
: electrolyte  its flat base resting on a tablet of a mixture of metal A and its


[[https://github.com/cute-jumper/gscholar-bibtex/blob/master/gscholar-bibtex.el][gscholar-bibtex/gscholar-bibtex.el at master · cute-jumper/gscholar-bibtex]]


#+BEGIN_SRC emacs-lisp
;;; gscholar-bibtex.el --- Retrieve BibTeX from Google Scholar and other online sources(ACM, IEEE, DBLP)

;; Copyright (C) 2014  Junpeng Qiu

;; Author: Junpeng Qiu <qjpchmail@gmail.com>
;; Keywords: extensions
;; Version: 0.2

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; * gscholar bibtex

;;   Retrieve BibTeX entries from Google Scholar, ACM Digital Library, IEEE Xplore
;;   and DBLP by your query. All in Emacs Lisp!

;;   *UPDATE*: ACM Digital Library, IEEE Xplore, and DBLP are now supported though
;;    the package name doesn't suggest that.
;; ** Basic usage
;;    Without package.el:
;;        (add-to-list 'load-path "/path/to/gscholar-bibtex.el")
;;        (require 'gscholar-bibtex)

;;    With package.el: install via melpa!

;;    To use, simply call
;;         M-x gscholar-bibtex

;;   Choose a source, then enter your query and select the results.

;;   Available commands in `gscholar-bibtex-mode', i.e., in the window of search
;;   results:
;;   - n/p: next/previous
;;   - TAB: show BibTeX entry for current search result
;;   - A/W: append/write to `gscholar-bibtex-database-file' (see later)
;;   - a/w: append/write to a file
;;   - c: close BibTeX entry window
;;   - q: quit

;; ** Sources
;;   By default, I enable all sources(Google Scholar, ACM Digital Library, IEEE
;;   Xplore and DBLP). If you don't want to enable some of them, you could call
;;       M-x gscholar-bibtex-turn-off-sources

;;   Similarly, if you want to enable some of them, you could call
;;       M-x gscholar-bibtex-turn-on-sources

;;   To keep the configuration in your init file, you could use the following
;;   format(*NOT* real code):
;;       (gscholar-bibtex-source-on-off action source-name)

;;   Possible values:
;;   - action: :on or :off
;;   - source-name: "Google Scholar", "ACM Digital Library" or "IEEE Xplore"

;;   Say if you want to disable "IEEE Xplore", use the following code:
;;       (gscholar-bibtex-source-on-off :off "IEEE Xplore")

;; ** Default source
;;   If you have a preferred source, you can set it as default so you don't have to
;;   type the name to select the source every time you call `gscholar-bibtex'. Say
;;   if you want to set "Google Scholar" as default:
;;       (setq gscholar-bibtex-default-source "Google Scholar")

;;   Note that in order to make it work, you have to make sure the source name is
;;   correct and you don't disable the source that you set as default, otherwise
;;   the default source setting has no effect. Besides, if you only have one source
;;   enabled, then the enabled source automatically becomes the default, regardless
;;   of the value of `gscholar-bibtex-default-source'.

;; ** Configuring `gscholar-bibtex-database-file'
;;    If you have a master BibTeX file, say refs.bib, as database, and want to
;;    append/write the BibTeX entry to refs.bib without being asked for a
;;    filename to be written every time, you can set
;;    `gscholar-bibtex-database-file':
;;        (setq gscholar-bibtex-database-file "/path/to/refs.bib")

;;    Then use "A" or "W" to append or write to refs.bib, respectively.

;; ** Adding more sources
;;    Currently these three sources cover nearly all my needs, and it is possible
;;    if you need to add more sources.

;;    Basically, you need to implement following five functions(if you're willing,
;;    I think looking the source code is better. The implementation is easy!):
;; #+BEGIN_SRC elisp
;; (defun gscholar-bibtex-SourceName-search-results (query)
;; "In the body, call `gscholar-bibtex--url-retrieve-as-string' to return a string
;; containing query results"
;;   body)

;; (defun gscholar-bibtex-SourceName-titles (buffer-content)
;; "Given the string `buffer-content', return the list of titles"
;;   body)

;; (defun gscholar-bibtex-SourceName-subtitles (buffer-content)
;; "Given the string `buffer-content', return the list of subtitles"
;;   body)

;; (defun gscholar-bibtex-SourceName-bibtex-urls (buffer-content)
;; "Given the string `buffer-content', return the list of urls(or maybe other
;;  feature) of the BibTeX entries, which would be fed to the next function"
;;   body)

;; (defun gscholar-bibtex-SourceName-bibtex-content (arg)
;; "Given the url(or other feature) of a BibTeX entry, return the entry as string.
;; Also call `gscholar-bibtex--url-retrieve-as-string' for convenience"
;;   body)
;; #+END_SRC

;;    Then you need to add a line:
;;        (gscholar-bibtex-install-source "Source Name" 'SourceName)

;;    You should put this line somewhere near the end of `gscholar-bibtex.el',
;;    where you could find several `gscholar-bibtex-install-source' lines.

;;    That's all. Enjoy hacking^_^

;;; Code:

(require 'bibtex)
(require 'xml)

(defgroup gscholar-bibtex nil
  "Retrieve BibTeX from Google Scholar and other online sources(ACM, IEEE, DBLP)."
  :group 'bibtex)

(defconst gscholar-bibtex-version "0.2"
  "gscholar-bibtex version number")

(defvar gscholar-bibtex-caller-buffer nil
  "Buffer that calls gscholar-bibtex")

(defvar gscholar-bibtex-urls-cache nil
  "Cache for all the urls of BibTeX entries")

(defvar gscholar-bibtex-entries-cache nil
  "Cache for the retrieved BibTeX entries")

(defvar gscholar-bibtex-database-file nil
  "Default BibTeX database file")

(defconst gscholar-bibtex-item-height 3
  "The height for each item")

(defvar gscholar-bibtex-available-sources nil
  "Avaiable sources for query")

(defvar gscholar-bibtex-enabled-sources nil
  "List of enabled sources")

(defvar gscholar-bibtex-disabled-sources nil
  "List of disabled sources")

(defvar gscholar-bibtex-selected-source nil
  "Currently selected source")

(defvar gscholar-bibtex-default-source nil
  "Default source name")

(defconst gscholar-bibtex-result-buffer-name "*gscholar-bibtex Search Results*"
  "Buffer name for Google Scholar search results")

(defconst gscholar-bibtex-entry-buffer-name "*BibTeX entry*"
  "Buffer name for BibTeX entry")

(defconst gscholar-bibtex-function-suffixes-alist
  '((:search-results . "search-results")
    (:titles . "titles")
    (:subtitles . "subtitles")
    (:bibtex-urls . "bibtex-urls")
    (:bibtex-content . "bibtex-content")))

(defconst gscholar-bibtex-help
  "[n/p] next/previous; [TAB] show BibTeX entry; [A/W] append/write to database;\
 [a/w] append/write to file; [c] close BibTeX entry window; [q] quit;"
  "Help string for gscholar-bibtex")

;; Face related
(defface gscholar-bibtex-title
  '((t (:height 1.4 :foreground "light sea green")))
  "Face for title"
  :group 'gscholar-bibtex)

(defface gscholar-bibtex-subtitle
  '((t (:height 1.0)))
  "Face for subtitle"
  :group 'gscholar-bibtex)

(defconst gcholar-bibtex-highlight-item-overlay
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'face 'highlight)
    ov)
  "Overlay for item highlight")

(defun gscholar-bibtex--move-to-line (N)
  (goto-char (point-min))
  (forward-line (1- N)))

(defun gscholar-bibtex-prettify-title (s)
  (propertize s 'face 'gscholar-bibtex-title))

(defun gscholar-bibtex-prettify-subtitle (s)
  (propertize s 'face 'gscholar-bibtex-subtitle))

(defun gscholar-bibtex-highlight-current-item-hook ()
  (save-excursion
    (let* ((line (gscholar-bibtex--current-beginning-line))
           (beg (progn (gscholar-bibtex--move-to-line line) (point)))
           (end (progn (gscholar-bibtex--move-to-line (+ line 3)) (point))))
      (move-overlay gcholar-bibtex-highlight-item-overlay beg end
                    (current-buffer)))))

;; Major mode
(defvar gscholar-bibtex-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "n" 'gscholar-bibtex-next-item)
    (define-key map "p" 'gscholar-bibtex-previous-item)
    (define-key map (kbd "<tab>") 'gscholar-bibtex-retrieve-and-show-bibtex)
    (define-key map "A" 'gscholar-bibtex-append-bibtex-to-database)
    (define-key map "W" 'gscholar-bibtex-write-bibtex-to-database)
    (define-key map "a" 'gscholar-bibtex-append-bibtex-to-file)
    (define-key map "w" 'gscholar-bibtex-write-bibtex-to-file)
    (define-key map "c" 'gscholar-bibtex-quit-entry-window)
    (define-key map "q" 'gscholar-bibtex-quit-gscholar-window)
    map))

(define-derived-mode gscholar-bibtex-mode fundamental-mode "gscholar-bibtex"
  (setq buffer-read-only t)
  (add-hook 'pre-command-hook 'gscholar-bibtex-show-help nil t)
  (add-hook 'post-command-hook 'gscholar-bibtex-highlight-current-item-hook
            nil t))

(defun gscholar-bibtex-show-help ()
  (message gscholar-bibtex-help))

(defun gscholar-bibtex-guard ()
  (unless (eq major-mode 'gscholar-bibtex-mode)
    (error "Error: you are not in `gscholar-bibtex-mode'!")))

(defun gscholar-bibtex--string-cleanup (str)
  (while (string-match "\\`^\n+\\|^\\s-+\\|\\s-+$\\|\n+\\|\r+\\|^\r\\'" str)
    (setq str (replace-match "" t t str)))
  (replace-regexp-in-string "[\r\n\t ]+" " " str))

(defun gscholar-bibtex--current-beginning-line ()
  (1+ (* (gscholar-bibtex--current-index) gscholar-bibtex-item-height)))

(defun gscholar-bibtex--current-index ()
  (let ((line-number (+ (line-number-at-pos)
                        (if (= (point) (point-max))
                            -1 0))))
    (/ (1- line-number) gscholar-bibtex-item-height)))

(defun gscholar-bibtex--delete-response-header ()
  (ignore-errors
    (save-match-data
      (goto-char (point-min))
      (delete-region (point-min)
                     (1+ (re-search-forward "^$" nil t)))
      (goto-char (point-min)))))

(defun gscholar-bibtex--replace-html-entities (str)
  (let ((retval str)
        (pair-list
         '(("&amp;" . "&")
           ("&hellip;" . "...")
           ("&quot;" . "\"")
           ("&#[0-9]*;" .
            (lambda (match)
              (format "%c" (string-to-number (substring match 2 -1))))))))
    (dolist (elt pair-list retval)
      (setq retval (replace-regexp-in-string (car elt) (cdr elt) retval)))))

(defun gscholar-bibtex--html-value-cleanup (s)
  (gscholar-bibtex--string-cleanup
   (gscholar-bibtex--replace-html-entities
    (replace-regexp-in-string "<.*?>" "" s))))

(defun gscholar-bibtex--xml-child (children)
  (pcase-let ((`(,child) children)) child))

(defun gscholar-bibtex--xml-node-child (node)
  (gscholar-bibtex--xml-child
   (xml-node-children node)))

(defun gscholar-bibtex--xml-get-child (node child-name)
  (gscholar-bibtex--xml-child
   (xml-get-children node child-name)))

(defun gscholar-bibtex--url-retrieve-as-buffer (url)
  (let ((response-buffer (url-retrieve-synchronously url)))
    (with-current-buffer response-buffer
      (gscholar-bibtex--delete-response-header))
    response-buffer))

(defun gscholar-bibtex--url-retrieve-as-string (url)
  (let ((response-buffer (gscholar-bibtex--url-retrieve-as-buffer url))
        retval)
    (with-current-buffer response-buffer
      (setq retval (buffer-string)))
    (kill-buffer response-buffer)
    retval))

(defun gscholar-bibtex-re-search (buffer-content surrounding-regexp subexp-count)
  (save-match-data
    (with-temp-buffer
      (insert buffer-content)
      (let (retval)
        (goto-char (point-min))
        (while (re-search-forward surrounding-regexp nil t)
          (push (gscholar-bibtex--html-value-cleanup
                 (match-string-no-properties subexp-count)) retval))
        (nreverse retval)))))

(defun gscholar-bibtex-next-item ()
  (interactive)
  (gscholar-bibtex-guard)
  (gscholar-bibtex--move-to-line (+ (gscholar-bibtex--current-beginning-line)
                                    gscholar-bibtex-item-height)))

(defun gscholar-bibtex-previous-item ()
  (interactive)
  (gscholar-bibtex-guard)
  (gscholar-bibtex--move-to-line (- (gscholar-bibtex--current-beginning-line)
                                    gscholar-bibtex-item-height)))

(defun gscholar-bibtex-retrieve-and-show-bibtex ()
  (interactive)
  (gscholar-bibtex-guard)
  (let* ((index (gscholar-bibtex--current-index))
         (bibtex-entry
          (progn (when (string= "" (elt gscholar-bibtex-entries-cache index))
                   (aset gscholar-bibtex-entries-cache index
                         (gscholar-bibtex-dispatcher
                          :bibtex-content
                          (nth index gscholar-bibtex-urls-cache))))
                 (elt gscholar-bibtex-entries-cache index)))
         (entry-buffer (get-buffer-create gscholar-bibtex-entry-buffer-name))
         (entry-window (get-buffer-window entry-buffer))
         (gscholar-window (selected-window)))
    (with-current-buffer entry-buffer
      (erase-buffer)
      (insert bibtex-entry)
      (bibtex-mode)
      ;; Have to manually call this to set `bibtex-entry-head', otherwise
      ;; `bibtex-parse-buffers-stealthily' will throw some errors since the our
      ;; BibTeX buffer is not associated with an existing file:-(
      (bibtex-set-dialect)
      (goto-char (point-min)))
    (unless entry-window
      (select-window (split-window-below))
      (switch-to-buffer entry-buffer)
      (select-window gscholar-window))))

(defun gscholar-bibtex--write-bibtex-to-database-impl (&optional append)
  (gscholar-bibtex-guard)
  (gscholar-bibtex-retrieve-and-show-bibtex)
  (unless gscholar-bibtex-database-file
    (setq gscholar-bibtex-database-file
          (read-file-name "gscholar-bibtex database file:")))
  (if gscholar-bibtex-database-file
      (progn
        (with-current-buffer (get-buffer gscholar-bibtex-entry-buffer-name)
          (write-region nil nil gscholar-bibtex-database-file append))
        (message "%s BibTeX entry to %s" (if append "Append" "Write")
                 gscholar-bibtex-database-file))
    (error "Please set `gscholar-bibtex-database-file' first.")))

(defun gscholar-bibtex-append-bibtex-to-database ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-database-impl t))

(defun gscholar-bibtex-write-bibtex-to-database ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-database-impl))

(defun gscholar-bibtex--write-bibtex-to-file-impl (prompt &optional append)
  (gscholar-bibtex-guard)
  (gscholar-bibtex-retrieve-and-show-bibtex)
  (let ((filename (read-file-name prompt)))
    (with-current-buffer (get-buffer gscholar-bibtex-entry-buffer-name)
      (write-region nil nil filename append))
    (message "%s BibTeX entry to %s" (if append "Append" "Write") filename)))

(defun gscholar-bibtex-append-bibtex-to-file ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-file-impl "Append BibTeX entry to file: " t))

(defun gscholar-bibtex-write-bibtex-to-file ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-file-impl "Write BibTeX entry to file: "))

(defun gscholar-bibtex-quit-entry-window ()
  (interactive)
  (gscholar-bibtex-guard)
  (let ((gscholar-window (selected-window))
        (entry-window (get-buffer-window gscholar-bibtex-entry-buffer-name)))
    (when entry-window
      (select-window entry-window)
      (delete-window)
      (select-window gscholar-window))))

(defun gscholar-bibtex-quit-gscholar-window ()
  (interactive)
  (gscholar-bibtex-guard)
  (let ((gscholar-window (selected-window))
        (entry-window (get-buffer-window gscholar-bibtex-entry-buffer-name))
        (caller-window (get-buffer-window gscholar-bibtex-caller-buffer)))
    (gscholar-bibtex-quit-entry-window)
    (if (or (eq caller-window gscholar-window)
            (eq caller-window entry-window)
            (not (buffer-live-p gscholar-bibtex-caller-buffer)))
        (next-buffer)
      (if caller-window
          (progn (delete-window) (select-window caller-window))
        (switch-to-buffer gscholar-bibtex-caller-buffer))))
  (message ""))

(defun gscholar-bibtex-install-source (source-name source-symbol)
  (let ((retval t))
    (dolist (pair gscholar-bibtex-function-suffixes-alist retval)
      (unless
          (fboundp
           (gscholar-bibtex--get-dispatch-func-name (car pair) source-symbol))
        (setq retval nil)))
    (unless retval
      (error
       "Installation failed! You need to define all necessary functions!"))
    (push `(,source-name . ,source-symbol) gscholar-bibtex-available-sources)))

(defun gscholar-bibtex--get-dispatch-func-name (kind source-symbol)
  (intern
   (concat
    "gscholar-bibtex-"
    (symbol-name source-symbol)
    "-"
    (assoc-default kind gscholar-bibtex-function-suffixes-alist))))

;;; dispatcher
(defun gscholar-bibtex-dispatcher (kind arg)
  (funcall
   (gscholar-bibtex--get-dispatch-func-name
    kind
    (assoc-default gscholar-bibtex-selected-source
                   gscholar-bibtex-enabled-sources))
   arg))

(defun gscholar-bibtex--get-list-symbol-pair (action)
  (let* ((alist '((:on . ("disabled" . "enabled"))
                  (:off . ("enabled" . "disabled"))))
         (names (assoc-default action alist))
         (build-name (lambda (s)
                       (intern (concat "gscholar-bibtex-" s "-sources")))))
    `(,(funcall build-name (car names)) . ,(funcall build-name (cdr names)))))

(defun gscholar-bibtex-source-on-off (action source-name)
  (let* ((prompt (if (eq action :on) "available" "enabled"))
         (symbol-pair (gscholar-bibtex--get-list-symbol-pair action))
         (source-list (car symbol-pair))
         (dest-list (cdr symbol-pair))
         (source-pair (assoc source-name (symbol-value source-list))))
    (if source-pair
        (progn
          (set source-list
               (remove source-pair (symbol-value source-list)))
          (push source-pair (symbol-value dest-list)))
      (message
       (concat "Please choose from the " prompt " sources!")))))

(defun gscholar-bibtex--source-on-off-interactive-impl (action)
  (let ((source-list (car (gscholar-bibtex--get-list-symbol-pair action)))
        source-name)
    (while (and (symbol-value source-list)
                (not
                 (string= "" (setq source-name
                                   (completing-read
                                    "Source[empty to exit]:"
                                    (symbol-value source-list))))))
      (gscholar-bibtex-source-on-off action source-name))))

;;; acm
(defun gscholar-bibtex-acm-search-results (query)
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          '(("Content-Type" . "application/x-www-form-urlencoded")))
         (url-request-data
          (mapconcat (lambda (arg)
                       (concat (url-hexify-string (car arg))
                               "="
                               (url-hexify-string (cdr arg))))
                     `(("query" . ,(replace-regexp-in-string " " "\+" query)))
                     "&")))
    (gscholar-bibtex--url-retrieve-as-string
     "http://dl.acm.org/results.cfm?h=1")))
(defun gscholar-bibtex-acm-titles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<A HREF=\"citation.cfm[^>]*?>\\(.*?\\)</A>" 1))

(defun gscholar-bibtex-acm-subtitles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<div class=\"authors\">\\([[:print:][:space:]]*?\\)</div>" 1))

(defun gscholar-bibtex-acm-bibtex-urls (buffer-content)
  (mapcar
   (lambda (href)
     (let ((retval href)
           (case-fold-search t)
           (pair-list '(("coll=DL" . "expformat=bibtex")
                        ("id" . "parent_id")
                        ("\\." . "&id=")
                        ("cfm" . "downformats.cfm"))))
       (dolist (pair pair-list retval)
         (setq retval
               (replace-regexp-in-string (car pair) (cdr pair) retval)))))
   (gscholar-bibtex-re-search
    buffer-content
    "<A HREF=\"citation\.\\(.*?\\)\"" 1)))

(defun gscholar-bibtex-acm-bibtex-content (bibtex-url)
  (gscholar-bibtex--url-retrieve-as-string
   (concat "http://dl.acm.org/" bibtex-url)))

;;; ieee
(defun gscholar-bibtex-ieee-search-results (query)
  (let* ((url-request-method "GET"))
    (gscholar-bibtex--url-retrieve-as-string
     (concat
      "http://ieeexplore.ieee.org/search/searchresult.jsp?queryText="
      (url-hexify-string query)))))

(defun gscholar-bibtex-ieee-titles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "Select this article: \\(.*\\) type" 1))

(defun gscholar-bibtex-ieee-subtitles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<a.*?class=\"authorPreferredName[^>]*?>\\([[:space:][:print:]]*?\\)<a href='.." 1))

(defun gscholar-bibtex-ieee-bibtex-urls (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<input.*id=\'\\(.*\\)\'" 1))

(defun gscholar-bibtex-ieee-bibtex-content (bibtex-id)
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          '(("Content-Type" . "application/x-www-form-urlencoded")))
         (url-request-data
          (mapconcat (lambda (arg)
                       (concat (url-hexify-string (car arg))
                               "="
                               (url-hexify-string (cdr arg))))
                     `(("recordIds" . ,bibtex-id)
                       ("citations-format" . "citation-only")
                       ("download-format" . "download-bibtex"))
                     "&"))
         (pair-list '(("<br>\\|\r" . "")
                      ("\n\n+" . "\n")
                      ("\n *" . "\n  ")))
         (retval (gscholar-bibtex--url-retrieve-as-string
                  "http://ieeexplore.ieee.org/xpl/downloadCitations")))
    (dolist (pair pair-list retval)
      (setq retval (replace-regexp-in-string (car pair) (cdr pair) retval)))))

;;; Google Scholar
(defun gscholar-bibtex-google-scholar-search-results (query)
  (let* ((url-request-method "GET")
         (random-id (format "%016x" (random (expt 16 16))))
         (url-request-extra-headers
          `(("Cookie" . ,(concat "GSP=ID=" random-id ":CF=4")))))
    (gscholar-bibtex--url-retrieve-as-string
     (concat  "http://scholar.google.com/scholar?q="
              (url-hexify-string
               (replace-regexp-in-string " " "\+" query))))))

(defun gscholar-bibtex-google-scholar-bibtex-urls (buffer-content)
  (gscholar-bibtex-re-search buffer-content "\\(/scholar\.bib.*?\\)\"" 1))

(defun gscholar-bibtex-google-scholar-titles (buffer-content)
  (gscholar-bibtex-re-search buffer-content "<h3.*?>\\(.*?\\)</h3>" 1))

(defun gscholar-bibtex-google-scholar-subtitles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<div class=\"gs_a\">\\(.*?\\)</div>" 1))

(defun gscholar-bibtex-google-scholar-bibtex-content (bibtex-url)
  (gscholar-bibtex--url-retrieve-as-string
   (concat "http://scholar.google.com" bibtex-url)))

;;; DBLP
(defun gscholar-bibtex-dblp-search-results (query)
  (let* ((url-request-method "GET")
         (response-buffer (gscholar-bibtex--url-retrieve-as-buffer
                           (concat "http://dblp.uni-trier.de/search/publ/api?"
                                   (url-build-query-string
                                    `((q ,query)
                                      (format xml)))))))
    (with-current-buffer response-buffer
      (set-buffer-multibyte t))
    (prog1
        (pcase-let ((`(,(and result `(result . ,_))) (xml-parse-region nil nil response-buffer)))
          (mapcar (lambda (hit)
                    (gscholar-bibtex--xml-get-child hit 'info))
                  (xml-get-children (gscholar-bibtex--xml-get-child result 'hits) 'hit)))
      (kill-buffer response-buffer))))

(defun gscholar-bibtex-dblp-titles (search-results)
  (mapcar (lambda (info)
            (gscholar-bibtex--xml-node-child
             (gscholar-bibtex--xml-get-child info 'title)))
          search-results))

(defun gscholar-bibtex-dblp-subtitles (search-results)
  (mapcar (lambda (info)
            (mapconcat #'gscholar-bibtex--xml-node-child
                       (xml-get-children (gscholar-bibtex--xml-get-child info 'authors) 'author)
                       ", "))
          search-results))

(defun gscholar-bibtex-dblp-bibtex-urls (search-results)
  (mapcar (lambda (info)
            (gscholar-bibtex--xml-node-child
             (gscholar-bibtex--xml-get-child info 'url)))
          search-results))

(defun gscholar-bibtex-dblp-bibtex-content (html-url)
  (string-match "/rec/" html-url)
  (gscholar-bibtex--url-retrieve-as-string
   (replace-match "/rec/bib2/" t t html-url)))

;;;###autoload
(defun gscholar-bibtex-turn-on-sources ()
  (interactive)
  (gscholar-bibtex--source-on-off-interactive-impl :on))

;;;###autoload
(defun gscholar-bibtex-turn-off-sources ()
  (interactive)
  (gscholar-bibtex--source-on-off-interactive-impl :off))

;;;###autoload
(defun gscholar-bibtex ()
  (interactive)
  (if (= 1 (length gscholar-bibtex-enabled-sources))
      (setq gscholar-bibtex-selected-source
            (caar gscholar-bibtex-enabled-sources))
    (let* ((default-source (assoc
                            gscholar-bibtex-default-source
                            gscholar-bibtex-enabled-sources))
           (source-prompt (if default-source
                              (concat "Select a source[default "
                                      gscholar-bibtex-default-source
                                      "]: ")
                            "Select a source: "))
           (selected-source
            (completing-read source-prompt
                             gscholar-bibtex-enabled-sources)))
      (setq gscholar-bibtex-selected-source
            (if (string= "" selected-source)
                gscholar-bibtex-default-source
              selected-source))))
  (unless (assoc gscholar-bibtex-selected-source
                 gscholar-bibtex-enabled-sources)
    (error "Please select an installed source!"))
  (let* ((query (read-string
                 (concat "Query[" gscholar-bibtex-selected-source "]: ")))
         (search-results (gscholar-bibtex-dispatcher :search-results query))
         (titles (gscholar-bibtex-dispatcher :titles search-results))
         (subtitles (gscholar-bibtex-dispatcher :subtitles search-results))
         (gscholar-buffer
          (get-buffer-create gscholar-bibtex-result-buffer-name)))
    (setq gscholar-bibtex-caller-buffer (current-buffer))
    (setq gscholar-bibtex-urls-cache
          (gscholar-bibtex-dispatcher :bibtex-urls search-results))
    (setq gscholar-bibtex-entries-cache
          (make-vector (length gscholar-bibtex-urls-cache) ""))
    (unless (get-buffer-window gscholar-buffer)
      (switch-to-buffer-other-window gscholar-buffer))
    (setq buffer-read-only nil)
    (erase-buffer)
    (goto-char (point-min))
    (dotimes (i (length titles))
      (insert "* " (gscholar-bibtex-prettify-title (nth i titles)))
      (newline-and-indent)
      (insert "  "
              (gscholar-bibtex-prettify-subtitle (nth i subtitles)) "\n\n"))
    (goto-char (point-min))
    (gscholar-bibtex-mode)
    (gscholar-bibtex-show-help)))

;; install sources
(gscholar-bibtex-install-source "DBLP" 'dblp)
(gscholar-bibtex-install-source "IEEE Xplore" 'ieee)
(gscholar-bibtex-install-source "ACM Digital Library" 'acm)
(gscholar-bibtex-install-source "Google Scholar" 'google-scholar)
;; initalize
(setq gscholar-bibtex-disabled-sources gscholar-bibtex-available-sources)
;; enable all
(gscholar-bibtex-source-on-off :on "DBLP")
(gscholar-bibtex-source-on-off :on "IEEE Xplore")
(gscholar-bibtex-source-on-off :on "ACM Digital Library")
(gscholar-bibtex-source-on-off :on "Google Scholar")

;; Remove byte compilation warnings
(defvar evil-emacs-state-modes)
(eval-after-load "evil"
  '(add-to-list 'evil-emacs-state-modes 'gscholar-bibtex-mode))

(provide 'gscholar-bibtex)
;;; gscholar-bibtex.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp


(gscholar-bibtex-google-scholar-search-results " electrolyte  its flat base resting on a tablet of a mixture of metal A and its")
#+END_SRC

This sort of worked. I got blocked from google at one point, and I found it difficult to figure out how to get the bibtex entries from the code above (although it does do it). My doi-utils package seems better.








* A highlight annotation mode with overlays :ARCHIVE:
  :PROPERTIES:
  :ID:       092E2F6F-B824-4FF3-9429-D3704AEF7B59
  :END:
One of my students asked about highlighting text in emacs for note-taking. For temporary use, this is pretty easy, you put an overlay on a region that modifies the face, and any other properties you choose. One downside of overlays, as opposed to font-lock properties, is they do not "follow" text when you cut and paste them. On the other hand, they are easier to work with. So, we will work through doing this with overlays, and another day try it out with font-lock properties.

Here is a simple function to put a highlight on a region.

#+BEGIN_SRC emacs-lisp
(require 'ov)

(defun highlight-region (beg end)
 (interactive "r")
 (ov beg end 'face '(:background "Light Salmon") 'help-echo "highlighted" 'highlighted t))

(global-set-key (kbd "s-h") 'highlight-region)
#+END_SRC

#+RESULTS:
: highlight-region

The trouble is these are temporary, and disappear when you close the file. So, we need to save them. It is easy to get the overlays in the buffer, and we only want ones that have the 'highlighted property. So we just get those, and then save the information we need to recreate them.

#+BEGIN_SRC emacs-lisp
(ov-in 'highlighted t)
#+END_SRC

#+RESULTS:
| #<overlay from 1041 to 1062 in blog.org> | #<overlay from 536 to 552 in blog.org> |

Here is the code we use to save the overlay data in an external file. We use a hidden dotfile for this so we don't clutter our directory up. Then, we will save the start, end and properties of each overlay so we can reconstruct them later. We add this to a save hook, so it updates our file each time we save the buffer.

#+BEGIN_SRC emacs-lisp :results silent
(defun highlight-save-filename ()
  "Return name of file to save overlays in."
  (concat "." (file-name-nondirectory (buffer-file-name)) ".highlights"))

(defun highlight-save ()
  "Save highlight overlays in an external file"
  (interactive)
  (when (buffer-file-name)
    (save-buffer)
    (let ((fname (highlight-save-filename))
	  (ovs (ov-in 'highlighted t)))
      (if ovs
	  (with-temp-file fname
	    (prin1
	     (mapcar
	      (lambda (ov)
		(list (overlay-start ov)
		      (overlay-end ov)
		      (overlay-properties ov)))
	      ovs)
	     (current-buffer)))
	;; Delete file if no ovs
	(and (file-exists-p fname)
	     (delete-file fname))))))

(add-hook 'after-save-hook 'highlight-save)
#+END_SRC

#+RESULTS:
: highlight-save

#+BEGIN_SRC emacs-lisp
(highlight-save)
#+END_SRC

#+RESULTS:
| 1041 | 1062 | (highlighted t help-echo highlighted face (:background Light Salmon)) |
|  536 |  552 | (highlighted t help-echo highlighted face (:background Light Salmon)) |

#+BEGIN_SRC sh
cat .blog.org.highlights
#+END_SRC

#+RESULTS:
: ((4288 4296 (highlighted t help-echo "Some note to yourself about the tip" face (:background "Yellow1"))) (4184 4188 (highlighted t help-echo "highlighted" face (:background "Darkolivegreen1"))) (4178 4182 (highlighted t help-echo "highlighted" face (:background "Coral"))) (3496 3508 (highlighted t help-echo "highlighted" face (:background "Light Salmon"))) (1041 1062 (highlighted t help-echo "highlighted" face (:background "Light Salmon"))) (536 552 (highlighted t help-echo "highlighted" face (:background "Light Salmon"))))


Now, we also need to be able to load the overlays. We set this in a hook too, so the overlays get created when we open the file.

#+BEGIN_SRC emacs-lisp :results silent
(defun highlight-load ()
  "Load and apply overlays"
  (interactive)
  (let ((fname (highlight-save-filename)))
    (when (file-exists-p fname)
      (mapc
       (lambda (entry)
	 (ov (nth 0 entry)		; beg
	     (nth 1 entry)		; end
	     (nth 2 entry)))		; properties

      (with-temp-buffer
	(insert-file-contents fname)
	(read (current-buffer)))))))

(add-hook 'find-file-hook 'highlight-load)
#+END_SRC

So far so good. Let's raise the bar on ridiculosity and use helm-colors to select the highlight color. You will be able to highlight  with crazy color resolution. We will up the ante and also allow this function to update an existing highlight.

#+BEGIN_SRC emacs-lisp
(defun highlight (beg end &optional color)
  "Put a highlight overlay on the region. If on an overlay, change the color"
  (interactive "r")
  (unless color
    (setq color (s-trim (helm-colors))))
  (if (ov-at)
      (ov-set (ov-at) 'face `(:background ,color))
    (unless (region-active-p)
      (error "No region selected."))
    (ov beg end 'face `(:background ,color) 'help-echo "highlighted" 'highlighted t)))
#+END_SRC

#+RESULTS:
: highlight

What  else can we do? Let's make a special highlight note where you can put your own text as a tooltip, and a function to edit the text.

#+BEGIN_SRC emacs-lisp
(defun highlight-note (beg end &optional color note)
  (interactive "r")
  (unless (region-active-p)
    (error "No region selected."))
  (unless color
    (setq color (s-trim (helm-colors))))
  (unless note
    (setq note (read-input "Note: ")))
  (ov beg end 'face `(:background ,color) 'help-echo note 'highlighted t))

;; We need to edit a note too
(defun highlight-note-edit (new-note)
  (interactive (list (read-input "New note: " (overlay-get (ov-at) 'help-echo))))
  (ov-set (ov-at) 'help-echo new-note))
#+END_SRC

#+RESULTS:
: highlight-note-edit

After a while you may want to list your notes. This function is a little clumsy in window management. Basically we make a new buffer with the highlighted text and a link to get back to it.

#+BEGIN_SRC emacs-lisp
(defun highlight-list ()
  (interactive)
  (let* ((ovs (ov-in 'highlighted t))
	 (cb (current-buffer))
	 (links (mapcar
		 (lambda (ov)
		   (format "[[%s][link]]%s\n"
			   (format
			    "elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))"
			    cb (overlay-start ov))
			   (buffer-substring
			    (overlay-start ov)
			    (overlay-end ov))))
		 ovs)))
    (split-window-right)
    (switch-to-buffer-other-window "*highlights*") (erase-buffer)
    (org-mode)
    (mapc
     (lambda (s)
       (insert s))
     links)))
#+END_SRC

#+RESULTS:
: highlight-list

At some point you will want to clear all your highlights. After you do this, if you save the buffer, they will be gone forever.

#+BEGIN_SRC emacs-lisp
(defun highlight-clear ()
  (interactive)
  (ov-clear 'highlighted t)
  (when (get-buffer "*highlights*") (kill-buffer "*highlights*")))
#+END_SRC

#+RESULTS:
: highlight-clear


Finally, a few convenience functions and a menu. We define some standard highlight colors for convenience, an menu in the "Org" menu, a hydra, and a final key binding to the hydra.

#+BEGIN_SRC emacs-lisp
(defun highlight-yellow ()
  (interactive)
  (highlight (region-beginning) (region-end) "Yellow"))

(defun highlight-blue ()
  (interactive)
  (highlight (region-beginning) (region-end) "LightBlue"))

(defun highlight-pink ()
  (interactive)
  (highlight (region-beginning) (region-end) "Pink"))

(defun highlight-green ()
  (interactive)
  (highlight (region-beginning) (region-end) "Darkolivegreen1"))

(easy-menu-change
 '("Org") "highlighter"
 '(["Highlight" highlight]
   ["Highlight (B)" highlight-blue]
   ["Highlight (G)" highlight-green]
   ["Highlight (P)" highlight-pink]
   ["Highlight (Y)" highlight-yellow]
   ["List highlights" highlight-list]
   ["Clear highlights" highlight-clear])
 "Show/Hide")

(defhydra highlight (:color blue) "highlighter"
  ("b" highlight-blue "blue")
  ("g" highlight-green "Green")
  ("p" highlight-pink "Pink")
  ("s" (highlight (region-beginning) (region-end) "Lightsalmon1") "Salmon")
  ("y" highlight-yellow "yellow")
  ("c" highlight "Choose color")
  ("n" (highlight-note (region-beginning) (region-end) "Thistle") "Thistle Note")
  ("N" highlight-note "Note")
  ("m" highlight-mouse-on "Mouse highlight")
  ("M" highlight-mouse-off "Mouse off")
  ("e" highlight-note-edit "Edit note")
  ("l" highlight-list "List highlights")
  ("r" highlight-load "Reload")
  ("s" highlight-save "Save")
  ("C" highlight-clear "Clear"))

(global-set-key (kbd "s-h") 'highlight/body)
#+END_SRC

#+RESULTS:
: highlight/body

There  are some limitations here. Overlays are not attached to text, so you cannot cut and paste them. Boo... You have to use the hook functions to keep the external file synchronized with the buffer. If these ever get out of sync, good luck resynchronizing them.

* Insert images from image-dired
  :PROPERTIES:
  :ID:       DD2B5E79-B6AA-4E06-A852-B9A4B4CA415B
  :END:
[[http://stackoverflow.com/questions/31311833/copy-links-from-image-dired-to-org-mode][emacs - Copy links from image-dired to org-mode - Stack Overflow]]


#+BEGIN_SRC emacs-lisp
(defun my-insert-current-image-path ()
  (interactive)
  (insert
   (concat
    "[["
    (save-excursion
      (with-current-buffer "*image-dired*"
        (image-dired-original-file-name)))
    "]]")
(org-display-inline-images t t)))
#+END_SRC

#+RESULTS:
| 2576 | 2580 | #FFFFFF      |
| 2567 | 2574 | #FFFFFF      |
| 1742 | 1746 | Light Salmon |
|  479 |  509 | Light Salmon |
|  160 |  179 | Light Salmon |



* Using python in formulas in an org-mode spreadsheet
  :PROPERTIES:
  :ID:       9E0BFA22-E679-4B3E-B854-D59F24EC8D1B
  :END:
You can use emacs lisp in an org-mode spreadsheet as a formula. We will hack that to let us use Python. We will do that by making a lisp function that evaluates a python string and returns the results.

| x | y |    |
|---+---+----|
| 1 | 2 |  3 |
| 2 | 4 |  6 |
| 4 | 6 | 24 |
|---+---+----|
|   |   |    |
#+TBLFM: @2$3=@2$1 + @2$2
#+TBLFM: @3$3='(+ @3$1 @3$2);N
#+TBLFM: @4$3='(python "@4$1 * @4$2");N

#+BEGIN_SRC emacs-lisp
(defun python (string)
  "Send string to a python interpreter and return result."
  (python-shell-send-string-no-output
    string
    (or (python-shell-get-process)
	(run-python))))
#+END_SRC

#+RESULTS:
: python


* old dnd code
  :PROPERTIES:
  :ID:       D5AB316D-B0AE-47D6-8566-B36344DA3061
  :END:


#+BEGIN_SRC emacs-lisp
(defun org-image-dnd (uri action)
  "Insert org link to an image file at beginning of the line where the mouse is."
  (goto-char (nth 1 (event-start last-input-event)))
  (x-focus-frame nil)
  (cond
   ((eq 'C-drag-n-drop (car last-input-event))
    (insert "#+ATTR_ORG: :width 300\n")
    (insert (concat  "#+CAPTION: " (read-input "Caption: ") "\n"))
    (insert (format "[[%s]]\n" uri)))
   (t
    (insert (format "[[%s]]\n" uri))))
  (org-display-inline-images t t))


(defun org-file-dnd (uri action)
  "Insert org-link to file with drag-n-drop. For C-drag-n-drop
open file. See `org-file-M-dnd' for inserting attachfile links."
  (interactive)
  (x-focus-frame nil)
  (goto-char (nth 1 (event-start last-input-event)))
  (insert (format "[[%s]]" uri)))

; The order of addition is important. We need the most specific pattern first.
; each addition pushes into the first position.
(add-to-list 'dnd-protocol-alist '("^file:/" . org-file-dnd))
(add-to-list 'dnd-protocol-alist '("^file:/.*\\.\\(png\\|jp[e]?g\\)" . org-image-dnd))

(defun org-file-M-dnd (event)
  "Insert attachfile link on M-drag-n-drop."
  (interactive "e")
  (goto-char (nth 1 (event-start event)))
  (let ((payload (car (last last-input-event))))
    (when (eq 'file (car payload))
      (insert (format  "[[attachfile:%s]]" (cadr payload))))))

(kbd "<drag-n-drop>")
(kbd "<s-drag-n-drop>")
(kbd "<M-drag-n-drop>")
(kbd "<C-drag-n-drop>")
(kbd "<C-s-drag-n-drop>")
(kbd "<M-drag-n-drop>")
(kbd "<M-s-drag-n-drop>")

(global-set-key (kbd "<M-drag-n-drop>") 'org-file-M-dnd)
#+END_SRC
* Extracting content in MS Word and Powerpoint files for indexing in swish-e
  :PROPERTIES:
  :ID:       65960693-2712-4706-87FC-FD8A5F71C3DE
  :END:

Here is my swish-e code to index docx and pptx files. I have previously done this with FileFilters ([[id:2444338F-B4A1-4F87-B98C-867F344EFDA8][Indexing MS Office documents with swish-e]]) on the xml files inside these documents, but it is a little slow. I don't index excel files here, I am not sure how to extract meaningful text from them.

#+BEGIN_SRC python :tangle ~/.swish-e/msx/msx-swish.py :shebang #!/usr/bin/env python :tangle-mode (identity #o755)
from __future__ import print_function
from docx import Document
from pptx import Presentation

from xml.sax.saxutils import escape, quoteattr
import os
from os.path import join, getsize

def printtag(name,closing=False):
    if closing:
        return '</{}>'.format(name)
    else:
        return '<{}>'.format(name)


def tag(name, *content):
    return '{0}{1}{2}'.format(printtag(name),
                             ''.join(content),
                             printtag(name, closing=True))

template = '''Path-Name: {0}
Content-Length: {1}
Document-Type: XML*

{2}'''

def docx2swishxml(fdocx):
    doc = Document(fdocx)
    content = ''.join([paragraph.text.encode('utf-8')
                       for paragraph in doc.paragraphs])
    content = ''.join([i if ord(i) < 128 else ' ' for i in content])
    xml = tag('swishdefault', escape(content))

    return template.format(fdocx, len(xml), xml)

def pptx2swishxml(pptx):
    prs = Presentation(pptx)
    content = ''
    for slide in prs.slides:
        for shape in slide.shapes:
            if hasattr(shape, 'text'):
                content += shape.text.encode('utf-8')

    content = ''.join([i if ord(i) < 128 else ' ' for i in content])
    xml = tag('swishdefault', escape(content))

    return template.format(pptx, len(xml), xml)

index_dirs = ['/Users/jkitchin/Dropbox', '/Users/jkitchin/Box Sync']

for idir in index_dirs:
    for root, dirs, files in os.walk(idir):
        for f in files:
            try:
                # use end arg to avoid an extra space and carriage return
                fname = os.path.join(root, f)
                if fname.endswith('.docx'):
                    print(docx2swishxml(fname), end='')
                elif fname.endswith('.pptx'):
                    print(pptx2swishxml(fname), end='')
            except:
                pass
#+END_SRC

#+BEGIN_SRC text :tangle ~/.swish-e/msx/swish-msx-archive.conf
# Example configuration file

# where to save the index
IndexFile /Users/jkitchin/.swish-e/msx/index-msx-archive.swish-e

# Save descriptions for context on search results.
StoreDescription XML <desc> 500
StoreDescription XML* <desc> 500

MetaNames swishtitle swishdocpath keywords description
MetaNameAlias swishtitle title
MetaNameAlias swishdocpath path
#+END_SRC



#+BEGIN_SRC text :tangle ~/.swish-e/swish-pdf.conf
# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox/bibliography/bibtex-pdfs

# where to save the index
IndexFile /Users/jkitchin/.swish-e/pdf-index.swish-e

# What to index
IndexOnly .pdf

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .pdf

FileFilter  .pdf /Users/jkitchin/Library/Enthought/Canopy_64bit/User/bin/pdf2txt.py %p

MetaNames swishtitle swishdocpath keywords description
MetaNameAlias swishtitle title
MetaNameAlias swishdocpath path

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
#+END_SRC



#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish-pdf.conf
#+END_SRC

* The ultimate org indexer
  :PROPERTIES:
  :ID:       2ABE4537-A626-451F-A667-2DD9BEDB7CF0
  :END:


#+BEGIN_SRC emacs-lisp :tangle ~/bin/swish-org-documents.el :tangle-mode (identity #o755)
:;exec emacs -batch -l $0 "$@"

(require 'org)
(require 'xml)
(require 'cl)

(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/f-20140828.716")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/s-20140910.334")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/dash-20141201.2206")
(require 'f)

(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/helm-20150701.117")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/helm-bibtex-20150301.1221")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/parsebib-20150205.1305")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/org-ref")
(require 'org-ref)


(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\""
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 " "))
     "")))


(defmacro tag (name attributes &rest body)
  "macro to create an xml tag with NAME, ATTRIBUTES. BODY is executed in the tag."
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	    ,@body)
	   (print-tag ,name nil t)))


(defun swish-e-get-buffer-lines (n)
  "Get N lines from point from buffer. Return as string with no properties."
  (beginning-of-line)
  (let ((p (point)))
    (forward-line n)
    (buffer-substring-no-properties
     p (point))))


(defun document (fname char content)
  "Return string for a swish-e document to be indexed.
FNAME is path to file.
CHAR is a position in FNAME of the CONTENT."
  (let ((stripped-content (replace-regexp-in-string
			   "[^[:ascii:]]" "" (string-as-unibyte content))))
    (when stripped-content
      (format "Path-Name: [[elisp:(progn (find-file \"%s\") (goto-char %s) (show-subtree))][link]]
Content-Length: %s
Document-Type: XML*

%s" fname
char
(length stripped-content)
stripped-content))))


;; * Document - for broadest of searching
(defun document-xml ()
  "Return xml string for the open document. Provides indexing on
content, and file-keywords."
  (let ((keywords (org-element-map
		      (org-element-parse-buffer 'element)
		      'keyword
		    (lambda (keyword)
		      (tag (xml-escape-string
			    (format
			     "%s" (org-element-property :key keyword)))
			   ()
			   (xml-escape-string
			    (format
			     "%s"
			     (org-element-property :value keyword))))))))

    (tag 'document ()
	 (tag 'file-name () (buffer-file-name))
	 (tag 'last-modified ()
	      (format-time-string "%F %A %B" (visited-file-modtime)))
	 (tag 'last-accessed ()
	      (format-time-string
	       "%F %A %B"
	       (nth 4 (file-attributes (buffer-file-name)))))
	 (tag 'desc () (xml-escape-string
			(progn
			  (goto-char (point-min))
			  (swish-e-get-buffer-lines 4))))
	 (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
	 (tag 'swish-position () (int-to-string 1))
	 ;; this is the content. saved in swishdefault for simple searching
	 (tag 'swishdefault () (xml-escape-string (or (buffer-string) "")))
	 (when keywords
	   (tag 'file-keywords ()
		(mapconcat
		 'identity
		 keywords
		 ""))))))


;; special case for documents
(defun document-document ()
  (let ((stripped-content (replace-regexp-in-string
			   "[^[:ascii:]]" ""
			   (string-as-unibyte (document-xml)))))
    (when stripped-content
      (format "Path-Name: [[file:%s]]
Content-Length: %s
Document-Type: XML

%s" fname (length stripped-content) stripped-content))))


;; * Headlines
(defun headline-xml (headline)
  "Return xml representation of an element HEADLINE.
Provides indexing on headline title, tags, and properties."
  (let ((title (org-element-property :title headline))
	(tags (org-element-property :tags headline))
	(properties  (org-element-map headline 'node-property
		       (lambda (p)
			 (cons (org-element-property :key p)
			       (org-element-property :value p))))))
    (tag 'headline ()
	 (tag 'title () (xml-escape-string (format "%s" (car title))))
	 (tag 'desc () (xml-escape-string (progn
					    (goto-char
					     (org-element-property :begin headline))
					    (swish-e-get-buffer-lines 1))))
	 (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
	 (when tags
	   (tag 'tags () (xml-escape-string (mapconcat 'identity tags " "))))
	 (when (org-element-property :todo-keyword headline)
	   (tag 'todo-keyword ()
		(xml-escape-string
		 (format
		  "%s"
		  (org-element-property :todo-keyword headline)))))
	 (when (org-element-property :todo-type headline)
	   (tag 'todo-type ()
		(xml-escape-string
		 (format
		  "%s"
		  (org-element-property :todo-type headline)))))
	 (when (org-element-property :priority headline)
	   (tag 'priority ()
		(cond
		 ((symbolp (org-element-property :priority headline))
		  (format "%s" (org-element-property :priority headline)))
		 ((char-valid-p (org-element-property :priority headline))
		  (char-to-string (org-element-property :priority headline))))))
	 (when (org-element-property :archivedp headline)
	   (tag 'archivedp ()
		(format
		 "%s"
		 (org-element-property :archivedp headline))))
	 (when (org-element-property :commentedp headline)
	   (tag 'commentedp ()
		(format
		 "%s"
		 (org-element-property :commentedp headline))))
	 (when (org-element-property :quotedp headline)
	   (tag 'quotedp ()
		(format
		 "%s"
		 (org-element-property :quotedp headline))))
	 (when properties
	   (tag 'properties ()
		(mapconcat
		 'identity
		 (loop for (p . v) in properties
		       collect (tag p () (xml-escape-string (format "%s" v))))
		 ""))))))

(defun headline-document (headline)
  "Return the headline \"document\" for swish-e to index."
  (document (buffer-file-name)
	    (org-element-property :begin headline)
	    (headline-xml headline)))

;; * Links
(defun link-xml (link)
  (tag 'link
       `((type . ,(xml-escape-string (org-element-property :type link)))
	 (path . ,(xml-escape-string (org-element-property :path link)))
	 (raw-link . ,(xml-escape-string
		       (org-element-property :raw-link link))))
       (tag 'desc () (xml-escape-string (progn
					  (goto-char
					   (org-element-property :begin link))
					  (swish-e-get-buffer-lines 1))))
       (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
       ;; captions are in the parent paragraph. Captions can contain other stuff
       ;; like latex fragments and links.
       (when (org-element-property
	      :caption
	      (org-element-property :parent link))
	 (tag 'caption ()
	      (xml-escape-string
	       (mapconcat
		(lambda (x)
		  (mapconcat
		   (lambda (y)
		     (format "%s" (car y)))
		   x
		   " "))
		(org-element-property
		 :caption
		 (org-element-property :parent link))
		" "))))
       (when (org-element-property :contents-begin link)
	 (buffer-substring (org-element-property :contents-begin link)
			   (org-element-property :contents-end link)))))

(defun link-document (link)
  (document (buffer-file-name)
	    (org-element-property :begin link)
	    (link-xml link)))


;; * Tables
(defun table-xml (table)
  (tag 'table ()
       (let* ((caption (mapconcat
			(lambda (x)
			  (mapconcat 'car x " "))
			(org-element-property :caption table) ""))
	      (begin (org-element-property :begin table))
	      (end (org-element-property :end table))
	      (contents (buffer-substring begin end)))
	 (tag 'desc () (xml-escape-string (progn
					    (goto-char
					     (org-element-property :begin table))
					    (swish-e-get-buffer-lines 4))))
	 (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
	 (tag 'caption () (xml-escape-string (format "%s" caption)))
	 (tag 'table-contents () (xml-escape-string (format "%s" contents))))))


(defun table-document (table)
  (document (buffer-file-name)
	    (org-element-property :begin table)
	    (table-xml table)))


;; * src-blocks
(defun src-block-xml (src-block)
  (tag
   'src-block
   `((language . ,(xml-escape-string
		   (org-element-property :language src-block)))
     (switches . ,(xml-escape-string
		   (format
		    "%s"
		    (org-element-property :switches src-block))))
     (parameters . ,(xml-escape-string
		     (format
		      "%s"
		      (org-element-property :parameters src-block)))))
   (tag 'desc () (xml-escape-string (progn
				      (goto-char
				       (org-element-property :begin src-block))
				      (swish-e-get-buffer-lines 4))))
   (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
   (when (org-element-property :name src-block)
     (tag 'name () (xml-escape-string
		    (org-element-property :name src-block))))
   (when (org-element-property :caption src-block)
     (tag 'caption ()
	  (mapconcat
	   (lambda (x)
	     (mapconcat 'car x " "))
	   (org-element-property :caption src-block) "")))
   (tag 'code ()
	(xml-escape-string
	 (org-element-property :value src-block)))))


(defun src-block-document (src-block)
  (document (buffer-file-name)
	    (org-element-property :begin src-block)
	    (src-block-xml src-block)))


;; * paragraphs
(defun paragraph-xml (paragraph)
  (tag 'paragraph ()
       (tag 'swish-position ()
	    (format "%s" (org-element-property :begin paragraph)))
       (tag 'desc () (xml-escape-string (progn
					  (goto-char
					   (org-element-property :begin paragraph))
					  (swish-e-get-buffer-lines 4))))
       (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
       (xml-escape-string (buffer-substring-no-properties
			   (org-element-property :begin paragraph)
			   (org-element-property :end paragraph)))))


(defun paragraph-document (paragraph)
   (document (buffer-file-name)
	     (org-element-property :begin paragraph)
	     (paragraph-xml paragraph)))


(defun process-file (fname)
  "Print the `headline-document' for each headline in FNAME."
  (find-file fname)
  ;; one file had a local variable that switched the mode, so we make sure we
  ;; are in org-mode here
  (org-mode)
  (princ (document-document))

  (org-element-map (org-element-parse-buffer)
      'headline
    (lambda (headline)
      (princ (headline-document headline))))

  (org-element-map (org-element-parse-buffer)
      'link
    (lambda (link)
      (princ (link-document link))))

  (org-element-map (org-element-parse-buffer)
      'table
    (lambda (table)
      (princ (table-document table))))

  (org-element-map (org-element-parse-buffer)
      'src-block
    (lambda (src-block)
      (princ (src-block-document src-block))))

  (org-element-map (org-element-parse-buffer)
      'paragraph
    (lambda (paragraph)
      (princ (paragraph-document paragraph))))
  (kill-buffer))

;; Here is the main work in the script.
(loop for dir in '("/Users/jkitchin/Dropbox"
		   "/Users/jkitchin/Box Sync"
		   "/Users/jkitchin/dft-book"
		   "/Users/jkitchin/research"
		   "/Users/jkitchin/techela"
		   "/Users/jkitchin/blogofile-jkitchin.github.com/_blog"
)
      do
      (loop for fname in (f-entries
			  dir
			  (lambda (x)
			    (string=  "org"  (file-name-extension x)))
			  t)
            ;; I do not like to ignore errors here, but if you don't then any
            ;; error will stop the indexing.
	    do (ignore-errors (process-file fname))))
#+END_SRC

A configuration

#+BEGIN_SRC text :tangle ~/.swish-e/swish-org.conf
# Example configuration file

# where to save the index
IndexFile /Users/jkitchin/.swish-e/index-org.swish-e

PropertyNames swish-position

# Save descriptions for context on search results.
StoreDescription XML <desc> 500
StoreDescription XML* <desc> 500

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
#+END_SRC

And run it.

#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish-org.conf -S prog -i ~/bin/swish-org-documents.el
#+END_SRC

The following metanames are supported (actually there are more, these are just the ones created above).
- document
  - file-keywords
  - last-modified
  - last-accessed
  - content

- headline
  - title
  - properties
  - categories
  - tags
  - todo-keyword
  - priority

- link
 - link.type
 - link.path
 - link.raw-link
 - caption

- table
 - table-contents
 - caption

- src-block
 - src-block.language
 - src-block.switches
 - src-block.parameters
 - code

- author

- paragraph

#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index-org.swish-e -x '<swishrank>\t<swishdocpath>\t<swish-position>\t<swishtitle>\t<swishdescription>\n' -w dft
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: dft
# Removed stopwords:
# Number of hits: 4
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	[[file:/Users/jkitchin/dft-book/dft.org]]	1	/Users/jkitchin/dft-book/dft.org	#+TITLE:     Modeling materials using density functional theory #+AUTHOR:    John Kitchin #+DRAWERS: HIDDEN HINT SOLUTION #+EMAIL:     jkitchin@cmu.edu
498	[[file:/Users/jkitchin/dft-book/README.org]]	1	/Users/jkitchin/dft-book/README.org	This is a project to compile a pretty comprehensive set of notes and examples on using density functional theory to model properties of materials. Check out the new blog at http://jkitchin.github.com/dft-book.
299	[[file:/Users/jkitchin/dft-book/index.org]]	1	/Users/jkitchin/dft-book/index.org	#+TITLE: Welcome to dft-book - [[./dft.pdf][PDF]]
149	[[file:/Users/jkitchin/dft-book/header.org]]	1	/Users/jkitchin/dft-book/header.org	#+DRAWERS: HIDDEN HINT SOLUTION #+EMAIL:     jkitchin@cmu.edu #+DATE:      2012-07-11 Wed #+DESCRIPTION: A book on using density functional theory to model materials.
.
#+end_example


#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index-org.swish-e -x '<swishrank>\t<swishdocpath>\t<swish-position>\t<swishtitle>\t<swishdescription>\n' -w paragraph=solvation
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: paragraph=solvation
# Removed stopwords:
# Number of hits: 4
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 419791) (show-subtree))][link]]	419791	/Users/jkitchin/dft-book/dft.org	Here is the evidence that we actually ran a calculation with solvation: #+BEGIN_SRC sh grep -A 5 Solvation molecules/CO-solvated/OUTCAR
789	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 418900) (show-subtree))][link]]	418900	/Users/jkitchin/dft-book/dft.org	Next, we do the solvation calculation. We use the default solvent dielectric constant of water, which is 80. #+BEGIN_SRC python from jasp import *
499	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 419513) (show-subtree))][link]]	419513	/Users/jkitchin/dft-book/dft.org	Note these take quite a bit longer to calculate (e.g. 10 times longer)! The energies here are a little different than the vacuum result. To use this energy in an energy difference, you need to make sure the other energies were run with lsol=True also, and the same parameters. Here is the evidence that we actually ran a calculation with solvation:
499	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 418822) (show-subtree))][link]]	418822	/Users/jkitchin/dft-book/dft.org	The forces are high because nsw was set to 0, so only one iteration was run. Next, we do the solvation calculation. We use the default solvent dielectric constant of water, which is 80.
.
#+end_example

#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index-org.swish-e -w todo-keyword=TODO
#+END_SRC
#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: todo-keyword=TODO
# Removed stopwords:
# Number of hits: 42
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 21919) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 218
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 225
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 289
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 225
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 885779) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 256
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 884088) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 282
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 876922) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 226
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 871680) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 342
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 862511) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 310
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 860365) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 859209) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 333
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 858167) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 258
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 857251) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 228
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 848373) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 312
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 762835) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 238
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 717870) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 334
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 614118) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 217
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 614082) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 225
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 603103) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 227
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 115554) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 385
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 101644) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 385
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 2044) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org" 247
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 1989) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org" 243
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/README.org") (goto-char 1279) (show-subtree))][link]] "/Users/jkitchin/dft-book/README.org" 239
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 556337) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 247
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 462462) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 202
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 424294) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 242
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 417778) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 193
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 410212) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 227
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 410105) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 410069) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 229
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 398549) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 217
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 372769) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 217
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 370890) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 255
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 370836) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 263
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 304068) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 205
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 304020) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 189
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 303969) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 258
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 252305) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 238
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 85024) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 295
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 26371) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 213
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 233
.
#+end_example

* Worldcat
  :PROPERTIES:
  :ID:       3A53CAC8-CCCB-4AA9-8FE7-1A137834D7B2
  :END:
This returns an atom XML feed of entry items
#+BEGIN_SRC emacs-lisp :results output
;; (let* ((xml (with-current-buffer
;;		(url-retrieve-synchronously "http://www.worldcat.org/webservices/catalog/search/opensearch?q=civil%20war&wskey=Z65ynvQVhbmmxq07PX3IN1n71Z91pjUXYSSCCP9p2n8gD241P46jMyMHDuAvqRejIX1g8YbrwOAbobBM")
;;	      (xml-parse-region url-http-end-of-headers (point-max))))
;;        (entries (xml-get-children (car xml) 'entry))
;;        (formatted-entries (mapcar
;;			   (lambda (entry)
;;			     (format " - %s. %s\n  %s\n%s\n\n"
;;				     (car (xml-node-children
;;					   (car (xml-get-children  entry 'title))))
;;				     (car (xml-node-children
;;					   (car (xml-get-children
;;						 (car (xml-get-children entry 'author))
;;						 'name))))
;;				     (car (xml-node-children (car (xml-get-children entry 'summary))))
;;				     (car (xml-node-children (car (xml-get-children entry 'id))))))
;;			   entries)))
;;   (loop for s in formatted-entries
;;	do (princ s)))
#+END_SRC

#+RESULTS:
#+begin_example
 - The Civil War. Burns, Ken, 1953- Ward, Geoffrey C. Burns, Ric. McCullough, David G. Dewhurst, Colleen. Fishburne, Laurence, 1961- Freeman, Morgan. Irons, Jeremy, 1948- Jacobi, Derek. Robards, Jason. Waterston, Sam. Axton, Hoyt. Shaw, Bruce.
  An epic documentary bringing life to America's most destructive - and defining - conflict. Here is the saga of celebrated generals and the ordinary soldiers. A heroic and transcendent president and a country that had to divide itself in two in order to become one again.
http://worldcat.org/oclc/57408580

 - Pharsalia (aka "The civil war"). Lucan, 39-65.
  nil
http://worldcat.org/oclc/49294459

 - The Civil War.. Jordan, Robert Paul.
  Personalized portrait and pictorial chronicle of the men and events, campaigns and battlefields of the American Civil War.
http://worldcat.org/oclc/1034667

 - The Spanish Civil War. Thomas, Hugh, 1931-
  nil
http://worldcat.org/oclc/395987

 - Civil War. Stanchak, John E.
  Examines many aspects of the Civil War, including the issue of slavery, secession, the raising of armies, individual battles, the commanders, Northern life, Confederate culture, the surrender of the South, and the aftermath.
http://worldcat.org/oclc/43487214

 - The red badge of courage : an episode of the American Civil War. Crane, Stephen, 1871-1900.
  This stirring tale of action in the American Civil War captures the immediacies and experiences of actual battle and army life.
http://worldcat.org/oclc/8114241

 - The Civil War. Simpson, Brooks D., editor. Sears, Stephen W., editor. Sheehan-Dean, Aaron Charles, editor.
  Drawn from letters, diaries, speeches, articles, poems, songs, military reports, legal opinions, and memoirs, this collection brings together over 120 pieces by more than 60 men and women to create a firsthand narrative of the first year of the Civil War. Beginning on the eve of Lincoln's election in 1860 and ending in January 1862 with the appointment of Edwin M. Stanton as Secretary of War, the selections provide a sense of the immediacy, uncertainty, and urgency of events as the nation was torn asunder. Includes headnotes, a chronology of events, and biographical and explanatory endnotes.--Adapted from publisher description.
http://worldcat.org/oclc/642844029

 - The Civil War. Catton, Bruce, 1899-1978.
  nil
http://worldcat.org/oclc/197955

 - Observations on the nature of civil liberty, the principles of government, and the justice and policy of the war with America to which is added an appendix, containing a state of the national debt, an estimate of the money drawn from the public by the taxes, and an account of the national income and expenditure since the last war. Price, Richard, 1723-1791.
  nil
http://worldcat.org/oclc/65353752

 - The war was you and me : civilians in the American Civil War. Cashin, Joan E.
  Though civilians constituted the majority of the nation's population and were intimately involved with almost every aspect of the war, we know little about the civilian experience of the Civil War. Southerners lived through the breakup of basic social and economic institutions, including slavery. Northerners witnessed the reorganization of society to fight the war. And citizens of the border regions grappled with elemental questions of loyalty that reached into the family itself. These original essays recover the stories of civilians from Natchez to New England. They address the experiences of men, women, and children of whites, slaves, and free blacks and of civilians from numerous classes. Not least of these stories are the on-the-ground experiences of slaves seeking emancipation and the actions of white Northerners who resisted the draft. Many of the authors present brand new material, such as the war's effect on the sounds of daily life and on reading culture. Others examine the war's premiere events, including the battle of Gettysburg and the Lincoln assassination, from fresh perspectives. Several consider the passionate debate that broke out over how to remember the war, a debate that has persisted into our own time.
http://worldcat.org/oclc/47785571

#+end_example

* Looking up chemicals by CAS number
  :PROPERTIES:
  :ID:       8F4E3661-B2F2-45AB-AA8D-3509516D5EC7
  :END:

Benzene has a [[https://en.wikipedia.org/wiki/CAS_Registry_Number][CAS]] number of 71-43-2. That number can be used to retrieve information about benzene, e.g.

http://www.commonchemistry.org/ChemicalDetail.aspx?ref=71-43-2

Aldrich: http://www.sigmaaldrich.com/catalog/search?term=71-43-2&interface=CAS%20No.&N=0&mode=partialmax

What? Of course that looks like an opportunity for an org-link ;) Here is a bare bones link to open a website and export to html.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "cas"
 (lambda (cas-number)
   (browse-url
    (format "http://www.commonchemistry.org/ChemicalDetail.aspx?ref=%s" cas-number)))
 (lambda (cas-number desc backend)
   (format "<a href=\"http://www.commonchemistry.org/ChemicalDetail.aspx?ref=%s\">CAS:%s</a>" cas-number (or desc cas-number))))
#+END_SRC

And here is the link in action: cas:71-43-2. The link syntax is pretty rigid (but has the advantage of exporting in a fixed format), and you might prefer some flexibility, say CAS: 71-43-2 or CAS 71-43-2. Maybe because you want to apply this to text that is not org-mode formatted. button-lock to the rescue (again).

We can build a regexp that defines a CAS number (https://en.wikipedia.org/wiki/CAS_Registry_Number), and use it to make clickable text. A wrinkle on past examples here is we need a regexp that provides some context around the number, but ultimately we want to extract a piece of the regexp (the number). We do this by saving the regexp as a variable so that we can match to it later. We use a lot of shy groups in the regexp and explicitly number the group we want. We will make the clickable text open a website to the search results on the CAS number.

#+BEGIN_SRC emacs-lisp
(setq cas-re  "\\(?:CAS\\|cas\\)\\(?::?\\)\\s-*\\(?1:[0-9]\\{2,7\\}-[0-9]\\{2\\}-[0-9]\\)")

(button-lock-set-button
 cas-re
 (lambda ()
   (interactive)
   (save-match-data
     (let ((s  (let ((result (button-lock-find-extent (point))))
		 (buffer-substring (car result) (cdr result)))))
       (string-match cas-re s)
       (browse-url
	(format
	 "http://www.commonchemistry.org/ChemicalDetail.aspx?ref=%s"
	 (match-string 1 s))))))
 :face '((:underline t))
 :help-echo "A Chemical Abstracts Service number. Click to search"
 :additional-property 'cas)
#+END_SRC

This is an example where we use some context to identify the relevant text to make functional (e.g. 71-43-2 by itself is not highlighted).

* Using lisp to enable data reuse from a program
  :PROPERTIES:
  :LAST-EDITED: [2015-08-01 Sat]
  :ID:       AAB489C9-9852-4DEC-8C56-7854981C924F
  :END:

Here is some code in a file.
#+name: code
#+BEGIN_SRC emacs-lisp :tangle code.el
(-max '(8 3 2 4 5))
#+END_SRC

#+RESULTS: code
: (defn butlast [coll]
:   "Returns coll except of last element."
:   (drop-last 1 coll))

We can read it in like this.
#+BEGIN_SRC emacs-lisp
(read (with-temp-buffer
	(insert-file-contents "code.el")
	(buffer-string)))
#+END_SRC

#+RESULTS:
| -max | (quote (8 3 2 4 5)) |

#+BEGIN_SRC emacs-lisp
(nth 1 (nth 1 (read (with-temp-buffer
			   (insert-file-contents "code.el")
			   (buffer-string)))))
#+END_SRC

#+RESULTS:
| 8 | 3 | 2 | 4 | 5 |

Now, we reuse the data /from the code/. We read the code in as data,
#+BEGIN_SRC emacs-lisp
(-min (nth 1 (nth 1 (read (with-temp-buffer
			   (insert-file-contents "code.el")
			   (buffer-string))))))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC emacs-lisp
(eval '(2 3 4))
#+END_SRC
That is a little awkward but illustrates the idea.
* python extract html
  :PROPERTIES:
  :ID:       792586F0-6707-44E4-BB2A-3D0B07587A62
  :END:
libextract

Wow...

#+BEGIN_SRC python
from requests import get
from lxml import html

req = get('http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/abstract')
parsed_doc = html.fromstring(req.content)

print parsed_doc.xpath('head/meta[@name="citation_pdf_url"]')[0].attrib['content']
#+END_SRC

#+RESULTS:
: http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/pdf

[[http://rodricios.github.io/posts/solving_the_data_extraction_problem.html][How to Solve Data Extraction]]


#+BEGIN_SRC emacs-lisp
(let* ((html (with-current-buffer (url-retrieve-synchronously "http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/abstract")
	       (libxml-parse-html-region url-http-end-of-headers (point-max))))
       (head (car (xml-get-children html 'head)))
       (metas (xml-get-children head 'meta)))
  (loop for meta in metas
	if (eq 'citation_pdf_url  (xml-get-attribute meta 'name))
	return meta
	)
  )
#+END_SRC

#+RESULTS:

Double wow. In emacs-lisp.
#+BEGIN_SRC emacs-lisp :results value code
(let* ((html (with-current-buffer (url-retrieve-synchronously "http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/abstract")
	       (libxml-parse-html-region url-http-end-of-headers (point-max))))
       (head (car (xml-get-children html 'head)))
       (metas (xml-get-children head 'meta)))
  (loop for meta in metas
	when (string= "citation_pdf_url" (xml-get-attribute meta 'name))
        return (xml-get-attribute meta 'content)))
#+END_SRC

* rx
  :PROPERTIES:
  :ID:       2976EF6C-558E-468E-85C4-39256A40C317
  :END:
A sometimes better way to make regular expressions.

#+BEGIN_SRC emacs-lisp
(rx (group bow (one-or-more (or "C" "H" "Cu") (zero-or-more digit)) eow))
#+END_SRC

#+RESULTS:
: \(\<\(?:\(?:Cu\|[CH]\)[[:digit:]]*\)+\>\)

* rdp a recursive descent parser in emacs
  :PROPERTIES:
  :ID:       BF275A5C-BC14-40A5-830A-80097DF7DB6B
  :END:
Example from [[https://github.com/skeeto/rdp][skeeto/rdp]]

#+BEGIN_SRC emacs-lisp
(require 'rdp)

(defvar arith-tokens
  '((sum       prod  [([+ -] sum)  no-sum])
    (prod      value [([* /] prod) no-prod])
    (num     . "-?[0-9]+\\(\\.[0-9]*\\)?")
    (+       . "\\+")
    (-       . "-")
    (*       . "\\*")
    (/       . "/")
    (pexpr     "(" [sum prod num pexpr] ")")
    (value   . [pexpr num])
    (no-prod . "")
    (no-sum  . "")))

(defun arith-op (expr)
  (destructuring-bind (a (op b)) expr
    (funcall op a b)))

(defvar arith-funcs
  `((sum     . ,#'arith-op)
    (prod    . ,#'arith-op)
    (num     . ,#'string-to-number)
    (+       . ,#'intern)
    (-       . ,#'intern)
    (*       . ,#'intern)
    (/       . ,#'intern)
    (pexpr   . ,#'cadr)
    (value   . ,#'identity)
    (no-prod . ,(lambda (e) '(* 1)))
    (no-sum  . ,(lambda (e) '(+ 0)))))

(defun arith (string)
  (rdp-parse-string string arith-tokens arith-funcs))

(arith "(1 + 2 + 3 * 4)*-3/4.0")
#+END_SRC

#+RESULTS:
: -11.25

this doesn't work as I expect.
#+BEGIN_SRC emacs-lisp
(require 'rdp)

(setq tokens
 '((email  name at address)
   (address  (word "." word "." word))
   (at . "@")
   (word . "[a-z]*")
   (name . "[a-z]*")))

(setq funcs
 `((email . ,(lambda (e) (message-box "email: %s" e)))
   (address . ,(lambda (e) (message-box "address: %s" e)))
   (name . ,(lambda (e) (message-box "name: %s" e)))
   (at . ,(lambda (e) (message-box "at: %s" e)))
   (word . ,(lambda (e) (message-box "word: %s" e)))))

(defun parse-email (string)
 (rdp-parse-string string tokens funcs))

;(email "jkitchin@andrew.cmu.edu")

(parse-email "jkitchin@andrew.cmu")
#+END_SRC

#+RESULTS:
: address: ((word: jkitchin @ word: andrew . word: cmu))


** peg
   :PROPERTIES:
   :ID:       F42336E6-0AE3-4594-9C1F-27338C9966D3
   :END:
I cannot figure out how to get the parsed results here.
#+BEGIN_SRC emacs-lisp
(require 'peg)
(peg-parse-string ((number   sign digit)
                    (sign     (or "+" "-" ""))
                    (digit    [0-9]))
 "9a")
#+END_SRC
#+RESULTS:

#+BEGIN_SRC emacs-lisp
(defun peg-ex-recognize-int ()
  (peg-parse (number   sign digit (* digit))
	     (sign     (or "+" "-" ""))
	     (digit    [0-9])))

(peg-ex-recognize-int)
#+END_SRC
* Links to Acrobat pages
  :PROPERTIES:
  :ID:       322BBBD2-5F56-4AF4-A260-FDC0B7D9DADD
  :END:

#+BEGIN_SRC emacs-lisp
(do-applescript "tell application \"Adobe Acrobat Pro\"
open file \"Macintosh HD:Users:jkitchin:Desktop:ALL_EFRC_technical_summaries.pdf\" options \"nameddest=light\"
end tell")
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC emacs-lisp
(org-add-link-type "acrobat" 'org-mac-acrobat-open)

(defun org-mac-acrobat-open (uri)
  "Visit page of pdf in Acrobat"
  (let* ((page (when (string-match "::\\(.+\\)\\'" uri)
                 (match-string 1 uri)))
         (document (substring uri 0 (match-beginning 0))))
    (do-applescript
     (concat
      "tell application \"Adobe Acrobat Pro\"\n"
      "  activate\n"
      "  set theDoc to \"" document "\"\n"
      "  set thePage to " page "\n"
      "  open theDoc\n"
      "  tell PDF Window 1\n"
      "    goto page thePage\n"
      "  end tell\n"
      "end tell"))))

;; The applescript returns link in the format
;; path_to_pdf_file::document_title::page_number::page_label

(defun as-get-acrobat-page-link ()
  (do-applescript
   (concat
    "tell application \"Adobe Acrobat Pro\"\n"
    "  set theDoc to active doc\n"
    "  set theWindow to (PDF Window 1 of theDoc)\n"
    "  set thePath to (file alias of theDoc)\n"
    "  set theTitle to (name of theWindow)\n"
    "  set thePage to (page number of theWindow)\n"
    "  set theLabel to (label text of (page thePage of theWindow))\n"
    "end tell\n"
    "set theResult to thePath & \"::\" & theTitle & \"::\" & thePage & \"::\" & theLabel\n"
    "return theResult as string\n")))

(defun org-mac-acrobat-get-page ()
  (interactive)
  (message "Applescript: Getting Acrobat page link...")
  (let* ((descriptor (as-get-acrobat-page-link))
         (components (split-string descriptor "::"))
         (path (car components))
         (title (nth 1 components))
         (page (nth 2 components))
         (label (nth 3 components))
         (link (concat "acrobat:" path "::" page))
         (description (concat title ", p." label))
         (org-link))
    (when (not (string= link ""))
      (setq org-link (org-make-link-string link description)))
    (kill-new org-link)
    org-link))

(defun org-mac-acrobat-insert-page ()
  (interactive)
  (insert (org-mac-acrobat-get-page)))
#+END_SRC

#+RESULTS:
: org-mac-acrobat-insert-page

[[acrobat:Macintosh%20HD:Users:jkitchin:Dropbox:CMU:meetings:@planning:NAM-2015:NAM-final-program-pdf:v4.pdf::190][v4.pdf, p.190]]

[[acrobat:Macintosh%20HD:Users:jkitchin:Dropbox:CMU:meetings:@planning:NAM-2015:NAM-final-program-pdf:v4.pdf::191][v4.pdf, p.191]] number 54

[[acrobat:Macintosh%20HD:Users:jkitchin:Dropbox:CMU:meetings:@planning:NAM-2015:NAM-final-program-pdf:v4.pdf::190]]


[[acrobat:

* document similarity
  :PROPERTIES:
  :ID:       20CB2AA6-903B-41E7-BA1E-5AB8313200F7
  :END:
[[http://brandonrose.org/clustering][Document Clustering with Python]]

#+BEGIN_SRC python
import numpy as np
import pandas as pd
import nltk
import re
import os
import codecs
from sklearn import feature_extraction
import mpld3

stopwords = nltk.corpus.stopwords.words('english')
print stopwords[:10]

# load nltk's SnowballStemmer as variabled 'stemmer'
from nltk.stem.snowball import SnowballStemmer
stemmer = SnowballStemmer("english")

# here I define a tokenizer and stemmer which returns the set of stems in the text that it is passed

def tokenize_and_stem(text):
    # first tokenize by sentence, then by word to ensure that punctuation is caught as it's own token
    tokens = [word for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)]
    filtered_tokens = []
    # filter out any tokens not containing letters (e.g., numeric tokens, raw punctuation)
    for token in tokens:
        if re.search('[a-zA-Z]', token):
            filtered_tokens.append(token)
    stems = [stemmer.stem(t) for t in filtered_tokens]
    return stems


def tokenize_only(text):
    # first tokenize by sentence, then by word to ensure that punctuation is caught as it's own token
    tokens = [word.lower() for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)]
    filtered_tokens = []
    # filter out any tokens not containing letters (e.g., numeric tokens, raw punctuation)
    for token in tokens:
        if re.search('[a-zA-Z]', token):
            filtered_tokens.append(token)
    return filtered_tokens
#+END_SRC

#+RESULTS:
: [u'i', u'me', u'my', u'myself', u'we', u'our', u'ours', u'ourselves', u'you', u'your']

#+BEGIN_SRC python
from sklearn.externals import joblib
#+END_SRC

#+RESULTS:


* see link message under point
  :PROPERTIES:
  :ID:       7DA962F0-3EF1-4DE9-A0A7-B1D72141169F
  :END:

#+BEGIN_SRC emacs-lisp
(defun link-message ()
  (let ((object (org-element-context)))
    (when (eq (car object) 'link)
      (message "%s"
	       (org-element-property :raw-link object)))))

(add-hook 'post-command-hook 'link-message)
#+END_SRC

#+RESULTS:
| link-message | eldoc-schedule-timer |

(org-activate-bracket-links (point-max))

foobar

#+BEGIN_SRC emacs-lisp
; add a tooltip to every instance of foobar
(save-excursion  ;return cursor to current-point
  (goto-char 1)
    (while (search-forward "foobar" (point-max) t)
      (set-text-properties  (match-beginning 0) (match-end 0)
                            `(help-echo "You know... a bar for foos!"
					font-lock-face (:foreground "dark slate gray")
					point-entered (lambda (old-point new-point) (message-box "point-entered %s" new-point))
					point-left (lambda (old-point new-point) (message-box "point-left %s old-point")))
)))

#+END_SRC

* A new annotation syntax
  :PROPERTIES:
  :ID:       B91E1CE3-DAF8-4F58-8E52-B3E726058924
  :END:

[@annotate :type comment :author John Kitchin :content This is great]

is matched by "\\[@annotate[^]]*\\]"

#+BEGIN_SRC emacs-lisp
(require 'ov)
(ov-set "\\[@annotate\\([^]]\\)*\\]" 'face '(:foreground "red") 'help-echo (match-string 1) 'display "comment" 'ov1 t)

(defun my-ov-evaporate-ov1 (_ov _after _beg _end &optional _length)
  (let ((inhibit-modification-hooks t))
    (if _after (ov-clear 'ov1))))

;; remove overlays if you edit one. it would be nice to do this on one, not all.
(ov-set "ov-" 'face 'warning
              'ov1 t
              'modification-hooks '(my-ov-evaporate-ov1))
;(ov-clear 'ov1)
#+END_SRC

#+RESULTS:
| #<overlay from 255369 to 255372 in blog.org> | #<overlay from 255352 to 255355 in blog.org> | #<overlay from 255342 to 255345 in blog.org> | #<overlay from 255307 to 255310 in blog.org> | #<overlay from 255165 to 255168 in blog.org> | #<overlay from 255044 to 255047 in blog.org> | #<overlay from 254702 to 254705 in blog.org> | #<overlay from 254681 to 254684 in blog.org> | #<overlay from 254601 to 254604 in blog.org> | #<overlay from 254593 to 254596 in blog.org> | #<overlay from 254492 to 254495 in blog.org> | #<overlay from 254378 to 254381 in blog.org> | #<overlay from 254249 to 254252 in blog.org> |



I don't know how to get a specific overlay, eg. the content, or to make a different overlay for different types of annotation. Also, this does not automatically update new content. [@annotate :type insert :content these words].

[@annotate :type delete :Date today]


#+BEGIN_SRC emacs-lisp
(setq ov1 (ov-set "\\[@annotate\\([^]]\\)*\\]" 'face '(:foreground "red") 'help-echo (match-string 1) 'display "comment"))
(mapcar 'ov-end ov1)
#+END_SRC
#+RESULTS:
| 996 | 933 | 894 | 201 | 129 | 97 |

#+BEGIN_SRC emacs-lisp
(defun mod-ov () (interactive)
 (let ((overlay (ov-at)))
 (message "%s" overlay)
 (ov-clear (ov-beg overlay) (ov-end overlay))))
#+END_SRC

** With fontlock
   :PROPERTIES:
   :ID:       85DB1C99-07D0-4465-B3C3-273EF4D148E9
   :END:


[@annotate :type delete :Date today]

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("\\[@annotate\\([^]]*\\)\\]"
    (1 'font-lock-variable-name-face))))

(font-lock-add-keywords
 'org-mode
 '("\\[@annotate\\([^]]*\\)\\]" . 'font-lock-variable-name-face))

(font-lock-add-keywords nil
  '(("foo" . (:foreground "red"))))
#+END_SRC

[@annotate :type delete]

foo  foo  foo foo  foo

foo

(defface extra-whitespace-face
  '((t (:background "pale green")))
  "Used in text-mode and friends for exactly one space after a period.")

(mapcar (lambda (mode)
	  (font-lock-add-keywords
	   mode
	   '(("FIXME" 0 'show-paren-mismatch-face)
	     ("\\.\\( \\)\\b" 1 'extra-whitespace-face))))
	'(text-mode latex-mode html-mode emacs-lisp-mode org-mode
	  texinfo-mode)) FIXME fdksaf
* sweet new babel things
  :PROPERTIES:
  :ID:       6993E912-88F0-454C-A2F9-8700F9D1F05A
  :END:

Thanks to William Henney for sharing this on the orgmode mailing list. specify return value

#+BEGIN_SRC python :results value :return mytable
NROWS, NCOLS = 6, 4
mytable = []
mytable.append(['A', 'B', 'C', 'D'])  # Table header
mytable.append(None)                  # hline
for irow in range(NROWS):
    mytable.append([icol**irow for icol in range(NCOLS)])
mytable.append(None)                  # hline
 #+END_SRC

#+RESULTS:
| A | B |  C |   D |
|---+---+----+-----|
| 1 | 1 |  1 |   1 |
| 0 | 1 |  2 |   3 |
| 0 | 1 |  4 |   9 |
| 0 | 1 |  8 |  27 |
| 0 | 1 | 16 |  81 |
| 0 | 1 | 32 | 243 |
|---+---+----+-----|



* miscellaneous scopus things I have used.
  :PROPERTIES:
  :ID:       AEAE60EC-F2D4-4DDC-A71A-4E08EE2B3E5D
  :END:
** author 1 - metrics view
   :PROPERTIES:
   :ID:       931B71C5-06B0-4285-B74B-5B6BDD8C05EF
   :END:
This seems to return a simple view with basic metrics.

http://api.elsevier.com/content/author

http://api.elsevier.com/content/author/AUTHOR_ID:7202762180?start=0&count=200&view=DOCUMENTS


#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((url-request-method "GET")
      (url-mime-accept-string "application/json")
      (url-request-extra-headers  '(("X-ELS-APIKey" . "5cd06d8a7df3de986bf3d0cd9971a47c")))
      (json-object-type 'plist)
      (json-data))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://api.elsevier.com/content/author?author_id=7102750465&view=metrics")
    (setq json-data
	  (elt (plist-get
	   (json-read-from-string
	    (buffer-substring url-http-end-of-headers (point-max)))
	   :author-retrieval-response)
	       0)))
  (list (plist-get json-data :h-index)
    (plist-get (plist-get json-data :coredata) :document-count)
    (plist-get (plist-get json-data :coredata) :citation-count)))
#+END_SRC

#+RESULTS:
| 56 | 451 | 10188 |


#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7102750465&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "270",
            "coredata": {
                "citation-count": "10009",
                "cited-by-count": "5002",
                "dc:identifier": "AUTHOR_ID:7102750465",
                "document-count": "447",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7102750465"
            },
            "h-index": "56"
        }
    ]
}
#+end_example

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18"
        }
    ]
}
#+end_example

** author - enhanced view
   :PROPERTIES:
   :ID:       A9CCAC8E-9B89-4E36-98BA-9A4EDD17691B
   :END:
This provides affiliation history, and a lot more information, but interestingly not the list of published documents.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=enhanced",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:


** Author retrieval 2
   :PROPERTIES:
   :ID:       F3EA8901-9ABC-4163-91C2-DBEC02D2558A
   :END:
This seems to be almost the same as the enhanced view
#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author/author_id/7004212771",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:


** Citation retrieval
   :PROPERTIES:
   :ID:       CC8F3F1F-43F2-4635-8478-DE9948F26B60
   :END:
Retrieves citation data for a DOI.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/search/index:SCOPUS?query=DOI(10.1021/jp047349j)&field=citedby-count",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))

#+END_SRC

#+RESULTS:
#+begin_example
{
    "search-results": {
        "entry": [
            {
                "@_fa": "true",
                "citedby-count": "1050",
                "prism:url": "http://api.elsevier.com/content/abstract/scopus_id:9744261716"
            }
        ],
        "link": [
            {
                "@_fa": "true",
                "@href": "http://api.elsevier.com:80/content/search/index:scopus?start=0&count=25&query=DOI%2810.1021%2Fjp047349j%29&field=citedby-count",
                "@ref": "self",
                "@type": "application/json"
            },
            {
                "@_fa": "true",
                "@href": "http://api.elsevier.com:80/content/search/index:scopus?start=0&count=25&query=DOI%2810.1021%2Fjp047349j%29&field=citedby-count",
                "@ref": "first",
                "@type": "application/json"
            }
        ],
        "opensearch:Query": {
            "@role": "request",
            "@searchTerms": "DOI%2810.1021%2Fjp047349j%29",
            "@startPage": "0"
        },
        "opensearch:itemsPerPage": "1",
        "opensearch:startIndex": "0",
        "opensearch:totalResults": "1"
    }
}
#+end_example

requests.el [[http://tkf.github.io/emacs-request/][Request.el – Easy HTTP request for Emacs Lisp — Request.el 0.2.0 documentation]]


* Scientific writing references
  :PROPERTIES:
  :ID:       6FA5D74B-9762-4D63-BC48-8F8983FCCDD1
  :END:


cite:whitesides-2004-whites-group

cite:powell-2010-public

https://medium.com/@write4research/why-do-academics-and-phders-carefully-choose-useless-titles-for-articles-and-chapters-518f02a2ecbb


http://pubs.acs.org/isbn/9780841239999

cite:2006-acs-style-guide


* Scientific researcher IDs
  :PROPERTIES:
  :ID:       850902E6-8045-4E73-B306-6EB01AE046CB
  :END:
** ORCID
   :PROPERTIES:
   :ID:       CC9A2829-CD5F-4381-9586-71BCA4E31C47
   :END:
"ORCID provides a persistent digital identifier that distinguishes you from every other researcher and, through integration in key research workflows such as manuscript and grant submission, supports automated linkages between you and your professional activities ensuring that your work is recognized."

orcid:0000-0003-2625-9232

** Researcher ID
   :PROPERTIES:
   :ID:       78A1B9E2-FCC7-453E-A6D0-1FD2682C8E11
   :END:
"ResearcherID provides a solution to the author ambiguity problem within the scholarly research community. Each member is assigned a unique identifier to enable researchers to manage their publication lists, track their times cited counts and h-index, identify potential collaborators and avoid author misidentification. In addition, your ResearcherID information integrates with the Web of Science and is ORCID compliant, allowing you to claim and showcase your publications from a single one account."

researcherid:A-2363-2010

One thing I like about ResearcherID is they provide some HTML to give you a dynamic "badge":

#+BEGIN_HTML
<span id='badgeCont777711' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont777711&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span>
#+END_HTML

You also get interesting things like my [[http://labs.researcherid.com/mashlets/rid/mashletsServer.jsp?rid%3DA-2363-2010&mid%3DCollaborationNetwork&cat%3DMap][collaboration map]], and a map of who [[http://labs.researcherid.com/mashlets/rid/mashletsServer.jsp?rid=A-2363-2010&mid=CitationDistribution&cat=Map][cites my work]].

** Scopus ID
   :PROPERTIES:
   :ID:       11DC882D-C4D2-44DD-96D1-C94D66D784EE
   :END:
I really like Scopus. It does a remarkable job identifying your papers and giving you a Scopus ID. Here is mine: scopusid:7004212771. While it is at it, you can see citation information, h-index, and other things.

** Google Scholar
   :PROPERTIES:
   :ID:       3486BCC1-1921-4345-8FFC-CEDA73794A2C
   :END:
Who knows who long this will be around (e.g. Google reader, Google Code, Google+, ...). It is pretty easy to use, but it tends to over citations, and to make correspondingly higher h-index (mine is 20 in Google Scholar).

https://scholar.google.com/citations?user=jD_4h7sAAAAJ

** ResearchGate
   :PROPERTIES:
   :ID:       2C2E07D1-D4BA-4329-9CAC-FCEC4DCF2164
   :END:
One nice feature of ResearchGate is it provides a way to serve full text versions of your papers.
https://www.researchgate.net/profile/John_Kitchin


* PDFsync for org files
  :PROPERTIES:
  :ID:       41830E29-DDCB-4F36-BC6E-80D2E73E6FD4
  :END:


\(e^x = 3.14\)

First, we need a way to check if the current buffer has changed since the last time we built so we can avoid unnecessary builds. We can use an md5 sum for this. We will just store the md5 sum in a global variable, so we can compare it at any point in time.

#+BEGIN_SRC emacs-lisp
(md5 (current-buffer))
#+END_SRC

#+RESULTS:
: 62126c8993a8caa7541c42a907660b08

We want our build to happen asynchronously, so we can continue typing. First, we develop the build function.

#+BEGIN_SRC emacs-lisp
(defvar *last-md5* nil "md5 of current buffer")
(defvar *async-building* nil "is a build happening")

(defun async-build ()
  (interactive)
  (cond
   (*async-building*
    (message "Build in progress"))
   ((equal *last-md5* (md5 (current-buffer)))
    (message "No change to build"))
   (t
    (message "building")
    (setq *last-md5* (md5 (current-buffer)))
    (setq *async-building* t)
    (save-buffer)
    (org-latex-export-to-pdf t))))
#+END_SRC
#+RESULTS:
: async-build

That last function will launch an asynchronous build process. We can see the contents and progress of this in this variable.

#+BEGIN_SRC emacs-lisp
org-export-stack-contents
#+END_SRC
#+RESULTS:
| *Org Export Process*                                         | nil   | org-export-process    |
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.pdf | latex | (21752 50592 42735 0) |
| #<killed buffer>                                             | nil   | org-export-process    |


When the export is done,
#+BEGIN_SRC emacs-lisp
org-export-stack-contents
#+END_SRC


We can view the result here in docview.
#+BEGIN_SRC emacs-lisp
(find-file-other-window (caar org-export-stack-contents))
#+END_SRC
#+RESULTS:
: #<buffer blog.pdf>

The last little idea is to create an idle timer to launch the build whenever we are idle. There are some tricks we want to use. First, we need to save the timer so we can cancel it later. Second, we need two timers, one to start the build, and one to check when it is done.

#+BEGIN_SRC emacs-lisp
(defvar async-message-timer1 nil
  "Variable to store the timer in.")

(defvar async-message-timer2 nil
  "Variable to store the timer in.")

;; timer that starts builds when we are idle
(setq async-message-timer1 (run-with-idle-timer 0.5 t 'async-build))

(setq async-message-timer2
      (run-with-idle-timer
       0.5 t
       (lambda ()
	 (when (and (stringp (caar org-export-stack-contents))
		    (file-exists-p (caar org-export-stack-contents))
                    (string= "pdf" (f-ext (caar org-export-stack-contents))))
	   (setq *async-building* nil)
	   (find-file-other-window (caar org-export-stack-contents))))))
#+END_SRC

#+RESULTS:
: [nil 0 0 500000 t (lambda nil (when (and (stringp (caar org-export-stack-contents)) (file-exists-p (caar org-export-stack-contents)) (string= "pdf" (f-ext (caar org-export-stack-contents)))) (setq *async-building* nil) (find-file-other-window (caar org-export-stack-contents)))) nil idle 0]

#+BEGIN_SRC emacs-lisp
(cancel-timer async-message-timer1)
(cancel-timer async-message-timer2)
#+END_SRC
#+RESULTS:

* Writing emacs-lisp code with lentic
  :PROPERTIES:
  :categories: emacs
  :ID:       794F6775-C99B-44A8-B432-0A66F374F148
  :END:
org-mode provides a way to do literate programming where you can intermingle code and narrative text. The code can be "tangled" out to the real executable code file. I mostly love this capability, and have used it to write several packages in [[https://github.com/jkitchin/org-ref][jkitchin/org-ref]]. There are some things that are tricky though. I find I have to manage carefully which blocks get tangled explicitly because different setups might have different default tangle behavior. This does allow me to intermingle code, example usage, and even tests in one document.  After it has been tangled, all the narrative text is gone, and separated from what I consider to be the "source". Not everyone is fluent in using org to automatically load code from an org file. Finally, it is not currently possible to distribute org-ref through MELPA or to include it in org because the code is in org-format. I could have some kind of release tool, perhaps a Makefile that tangles the file to make an elisp file, and ideally run some tests on it. I want to avoid this redirection, and keep the source as close to what I use as possible, ideally the same as what I use.

Here we consider [[https://github.com/phillord/lentic][phillord/lentic]], which is an alternative point of view to literate programming. In lentic, you have a source file that is in its native language, e.g. emacs-lisp, but you can create a view of the file as if it was an org-mode file. You can edit either view, and both views are automatically updated in the proper format, i.e. narrative text in org appears as comments in emacs-lisp, and code in emacs-lisp appears in a source block in org. There is only one permanent file, and the views exist temporarily.

Is this useful? The code in the end is functionally equivalent, and a user would never know the difference. It is useful then, if it helps the author write better code, or a maintainer to maintain it. Being both of those for some packages, hopefully this will be useful!

So, lentic works by having some minor markup in the emacs-lisp code that enables it to transform the elisp to an org-file. For example consider this example from the lentic package:
#+BEGIN_SRC emacs-lisp
;;; orgel-org.el --- A test file -*- lexical-binding: t -*-

;; Author: Phillip Lord

;;; Commentary:

;; This is an "orgel" file. That is a valid emacs lisp file with comments in
;; org-mode. The header comments are translated into header one in org mode.


;; #+BEGIN_SRC emacs-lisp
(defun orgel-function ())
;; #+END_SRC

;; And we finish off with the local variables declaration.

;; # Local Variables:
;; # lentic-init: lentic-orgel-org-init
;; # End:
#+END_SRC

There is mostly the usual header section, but the code is wrapped in comments that resemble the org-mode code-block. There is also a local variable that is defined when the file is opened. There is a small amount of boiler-plate stuff here, namely the top line and the local variables. I should note that lentic provides a function to insert the local variables for you, and it is bound to "C-c , f", and it even has completion. It is important that the lentic-init variable be defined before you can create a lentic view. This makes for a minor dilemma in starting a new file you want to edit with lentic. When you first create the file you need to create the file and either manually set this variable, or open it and close it. You need this file because it might be possible you prefer a LaTeX file instead of an org-file, or in the future perhaps some other kind of markup like markdown, etc... Maybe the file wouldn't even be emacs-lisp, it could be clojure, or one might hope Python in the future.

Anyway, this brings me to the point of this post, which is to write a little function that generates this boilerplate stuff and creates a lentic view for a new file, or that opens an existing file in my preferred view.

#+BEGIN_SRC emacs-lisp
(defun lentic-open-orgel (base-name)
 "Create a new lentic el file if base-name.el does not exist, or open it if it does.
Create a lentic view with org-file on the right."
 (interactive "sBase name (no extension): ")
 (delete-other-windows)
 (unless (file-exists-p (concat base-name ".el"))
   (with-temp-file (concat base-name ".el")
     (insert
      (format ";;; %s.el ---    -*- lexical-binding: t -*-
;;; Header:

;;; Commentary:

;;; Reminders about lentic:
;; Lentic key binding reminders
;; C-c , h  Move here in other view
;; C-c , s  Swap windows
;; [[elisp:lentic-mode-split-window-right]]  C-c o to open this link and make the view

;;; Code:

;;; %s.el ends here

;; # Local Variables:
;; # lentic-init: lentic-orgel-org-init
;; # End:" base-name base-name))))
 (find-file (concat base-name ".el"))
 (lentic-mode-split-window-right))
#+END_SRC
#+RESULTS:
: lentic-open-orgel

#+BEGIN_SRC emacs-lisp
(lentic-open-orgel "test-orgel")
#+END_SRC

Time will tell if I use this often. Maybe there are other simpler ways to do this that bypass the local variables. The lentic source uses a directory variable, but that is nearly the same except that it might have less impact on the distributed code. In any case, I really like this idea.

* Exceptions on entering a context manager
  :PROPERTIES:
  :ID:       C49B0B8F-4BCC-4F07-87AA-AB4400E6F60B
  :END:

#+BEGIN_SRC python
class WithContext(object):
    def __init(self, context):
        print('within context init({0})'.format(context))

    def __enter__(self):
        print('Entering')

        try:
            raise Exception('NotImplemented')
        except:
            self.__exit__('exception in enter')
            raise

    def __exit__(self, *args):
        print('Exiting with {0}'.format(args))
        return False

with WithContext() as c:
    print("running context test")
#+END_SRC

#+RESULTS:

* Find value in column 2 corresponding to maximum of column 4
  :PROPERTIES:
  :ID:       346B577D-346F-4B3B-B0DB-3F0658029F71
  :END:

#+tblname: tab-data
| Menge (x) | P(x) |   E(x) |   K(x) |  Gewinn |
|-----------+------+--------+--------+---------|
|         0 |   20 |   0.00 | 140.00 | -140.00 |
|        10 |   18 | 180.00 | 180.00 |    0.00 |
|        20 |   16 | 320.00 | 220.00 |  100.00 |
|        30 |   14 | 420.00 | 260.00 |  160.00 |
|        40 |   12 |    100 |    158 |      50 |



#+BEGIN_SRC emacs-lisp :var data=tab-data :results code
(let ((c4 (mapcar (lambda (x) (nth 4 x)) data))
      (c2 (mapcar (lambda (x) (nth 2 x)) data)))
   (nth (-elem-index (-max c4) c4) c2))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
420.0
#+END_SRC


org-table-get-field
(org-table-next-row)
(org-table-goto-column
(org-table-current-column)

#+BEGIN_SRC emacs-lisp
(defun jt ()
 "find max in column, message the corresponding value in column 3."
 (interactive)
 (let ((max (string-to-number (org-table-get-field)))
       (row (org-table-current-line)))
   (while (org-table-next-row)
     (when (>  (string-to-number (org-table-get-field)) max)
       (setq max (string-to-number (org-table-get-field))
	     ind (org-table-current-line))))
   (org-table-goto-line ind)
   ; columns start at 1?
   (org-table-goto-column 3)
   (message-box "%s" (org-table-get-field))))
#+END_SRC

#+RESULTS:
: jt

* Wrapping selected text into an org-block
  :PROPERTIES:
  :ID:       CF93B80C-472D-479D-A514-21714351DE79
  :END:
** Wrap selected text in an org block
:PROPERTIES:
:EXPORT_TITLE: An Interesting Article
:EXPORT_AUTHOR: Simon Jones
:EXPORT_FILE_NAME: an-interesting-article
:EXPORT_DATE: 2015-02-16
:ID:       3DA7F192-E6F2-4635-A2F6-EA160C2193E1
:END:


#+BEGIN_SRC emacs-lisp
(defun export-subtree ()
 (interactive)
 (let ((fname  (concat (org-entry-get (point) "EXPORT_FILE_NAME") ".org"))
       (author (org-entry-get (point) "EXPORT_AUTHOR"))
       (title (org-entry-get (point) "EXPORT_TITLE"))
       (date (org-entry-get (point) "EXPORT_DATE"))
       (content (progn (set-buffer (org-org-export-as-org nil t t))
                   (buffer-string))))
   ;; warning you can delete something unintentionally
   (when (file-exists-p fname) (delete-file fname))
   (find-file fname)
   (insert "#+TITLE: " title "\n")
   (insert "#+AUTHOR: " author "\n")
   (insert "#+DATE: " date "\n")
   (insert "\n" content)
   ;; remove properties drawer. Kind of hacky.
   (goto-char (point-min))
   (re-search-forward ":PROPERTIES:")
   (setf (buffer-substring
	  (org-element-property :begin (org-element-context))
	  (org-element-property :end (org-element-context)))
           "")
   (save-buffer)))

(export-subtree)
#+END_SRC

#+RESULTS:



#+BEGIN_SRC emacs-lisp
(defun wrap-text-in-org-block (start end)
  (interactive "r")
  (goto-char end)
  (insert "\n#+END_QUOTE\n")
  (goto-char start)
  (insert "\n#+BEGIN_QUOTE:\n"))
#+END_SRC


#+BEGIN_QUOTE:
TEstesat
#+END_QUOTE

* Command line export of a section in an org-file
  :PROPERTIES:
  :ID:       5A36F4AF-7ED6-4695-9F6B-CE0940D2DCF3
  :END:
#+LATEX_CLASS: article
#+BEGIN_SRC emacs-lisp :tangle export-org-section :shebang #!/bin/sh
:;exec emacs -batch  -l ~/Dropbox/kitchingroup/jmax/init.el -l "$0" "$@"

;; usage: export-org-section section-id org-file

;; now goto, narrow and export the section
(let ((section-id (pop command-line-args-left))
      (org-file (pop command-line-args-left)))
  (print (format "Opened %s" org-file))
  (find-file (expand-file-name org-file))
  (org-open-link-from-string (format "[[#%s]]" section-id))
  (org-narrow-to-subtree)
  (org-latex-export-to-pdf)
)
#+END_SRC


#+BEGIN_SRC sh :results silent
rm -f blog.pdf
./export-org-section sec-2 blog.org
open blog.pdf
#+END_SRC

** Test section 1
   :PROPERTIES:
   :CUSTOM_ID: sec-1
   :ID:       E2FD563A-9B40-4731-AC81-B29BCBD31016
   :END:

Some words and an equation \(e^x-1=0\).


** Test section 2
   :PROPERTIES:
   :CUSTOM_ID: sec-2
   :ID:       9612FE98-9063-4020-BEE5-C1D8A77EBAF3
   :END:

Some words and a table:

| a | b |
|---+---|
| 9 | 8 |
| 8 | 8 |


#+BEGIN_SRC emacs-lisp :tangle test2 :shebang #!/bin/sh
#!/bin/sh
":"; exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(defun main ()
  (print (version))
  (print (format "I did it. you passed in %s" command-line-args-left)))

(main)
;; Local Variables:
;; mode: emacs-lisp
;; End:
#+END_SRC


#+BEGIN_SRC sh
./test2 arg1 arg2 arg3
#+END_SRC
#+RESULTS:
:
: "GNU Emacs 25.0.50.1 (x86_64-apple-darwin13.4.0, NS appkit-1265.21 Version 10.9.5 (Build 13F34))
:  of 2015-01-18 on vpn-128-237-146-193.library.vpn.cmu.edu"
:
: "I did it. you passed in (arg1 arg2 arg3)"
* About face
  :PROPERTIES:
  :ID:       40CB7860-C186-457F-9FCE-890EAE3BABC4
  :END:

You have probably wondered why some words are colored in Emacs and wondered how some text behaves like a link. That happens from font locking. Here we look at some ways you can modify this behavior too.

Following and lightly adapting the example here [[info:emacs#Font%20Lock][info:emacs#Font Lock]], we can add some keywords that get highlighted for us like this:

#+BEGIN_SRC emacs-lisp :results silent
(font-lock-add-keywords
 nil  ;; mode, nil for current buffer
 '(("FIXME"  ; regexp with group you want to match
    'font-lock-warning-face	; the face to use
)))
#+END_SRC

FIXME some text. FIXME again. It works!

How do you know what faces are available? M-x list-faces-display will give you a nice buffer of face names you can choose from. Let's do one better though, and create our own face.

#+BEGIN_SRC emacs-lisp
(defface my-face
  '((t		; display type
     (:background "yellow" :foreground "black")))
     "My custom face.")

(font-lock-add-keywords
 'org-mode  ;; mode, nil for current buffer
 '(("BROKEN"  ; regexp with group you want to match
    0
    'my-face	; the face to use
)))
#+END_SRC

#+RESULTS:


 BROKEN  fdsafdFIXME



* Count headlines in current level
  :PROPERTIES:
  :ID:       07710AF2-C8CF-42FB-A86F-4E0F5BFC4606
  :END:


#+BEGIN_SRC emacs-lisp
(save-restriction
  (org-narrow-to-subtree)
  (1- (length
   (org-element-map
       (org-element-parse-buffer)
       'headline
     (lambda (x) 1)))))
#+END_SRC

#+RESULTS:
: 5

** one
   :PROPERTIES:
   :ID:       E669123D-5142-4164-BB10-3DB7C7A77590
   :END:
** two
   :PROPERTIES:
   :ID:       B81DA3FD-423E-43BC-8F41-89ABEB1704E1
   :END:
*** three
    :PROPERTIES:
    :ID:       D3E48755-BE00-4397-BAA4-188BD7767BFE
    :END:
**** four
     :PROPERTIES:
     :ID:       B221FC14-2127-4424-A7A3-30BD712444E7
     :END:
** five
   :PROPERTIES:
   :ID:       A755B048-E3A9-43FD-8853-9DEBC29B3607
   :END:

* Getting messages about the link under the mouse cursor
  :PROPERTIES:
  :ID:       E027BD25-A05C-4A0A-9947-62D5620A9D63
  :END:
Now that I have set up org-ref to give minibuffer messages when the cursor is on a link, I thought, why can't this happen when I mouse over a link. I am likely to just mouse over links while reading them, and not necessarily have the cursor moving. Well, here is the idea. We can get the mouse position, which is approximately the number of lines from the top of the frame, and a number of characters from the beginning of a line. A trick is that there may not be a character at that position, if the line is shorter than those characters. So, we will have to calculate from the mouse position whether there is a character where the mouse is.

Another trick is we don't want to remessage our selves constantly, so we will store the last mouse position, and not do anything unless it changes.

An idle timer does not do what we want here. Apparently, idle refers to the cursor, not the mouse. I use a regular timer here, and run it every 1/2 second. I don't notice any performance issues with this.

#+BEGIN_SRC emacs-lisp
efvar org-ref-last-mouse-pos nil
 "Stores last mouse position for use in `org-ref-mouse-message'.")

(defun can-move-p ()
  "See if a character is under the mouse. If so return the position for `goto-char'."
  (let* ((line (cddr org-ref-last-mouse-pos))
	 (col  (cadr org-ref-last-mouse-pos)))
    (save-excursion
      (goto-char (window-start))
      (forward-line line)
      (if
	  (> (- (line-end-position) (line-beginning-position)) col)
	  (progn  (forward-char col) (point))
	nil))))

(defun org-ref-mouse-message ()
  "Display message for link under mouse cursor"
  (interactive)
  (when (not (equal (mouse-position) org-ref-last-mouse-pos))
    (setq org-ref-last-mouse-pos (mouse-position))
    (when (can-move-p)
      (save-excursion
	(goto-char (can-move-p))
	(org-ref-link-message)))))


(setq org-ref-message-timer-mouse
       (run-at-time "0.5 sec" 0.5 'org-ref-mouse-message))

;(cancel-timer org-ref-message-timer-mouse)
#+END_SRC

#+RESULTS:
: [nil 21706 25351 779030 0.5 org-ref-mouse-message nil nil 0]

Ok, that is the code. Here are some links to test it out.

ref:icon


label:icon


cite:shi-2007-first-au

cite:needs-1989-calcul,jarvi-2008-devel-reaxf

It looks like it worked pretty well for me!




* org to org
  :PROPERTIES:
  :ID:       BB340702-2769-43C5-9F35-D2526BA33D2C
  :END:


http://google.com

mailto:jkitchin@andrew.cmu.edu



one citation cite:shi-2007-first-au


multi-citation cite:shi-2007-first-au,jarvi-2008-devel-reaxf,kondratyuk-2013


pre and post text  [[cite:grimme-2006-semiem-gga][See::page 34]]


Just pre text [[cite:marjolin-2015-therm-descr][See also]]

#+BEGIN_SRC emacs-lisp
(defun pandoc-cite-format (link contents info)
  (if (-contains? org-ref-cite-types  (org-element-property :type link))
      (cond
       ;; link with description
       ((org-element-property :contents-begin link)
	(let* ((contents (buffer-substring
			  (org-element-property :contents-begin link)
			  (org-element-property :contents-end link)))
	       (split (split-string contents "::"))
	       (pre-text (nth 0 split))
	       (post-text (nth 1 split)))
	  (concat
	   "[@" (org-element-property :path link)
	   (when pre-text (concat ", " pre-text))
	   (when post-text (concat ", " post-text))
	   "]"
	   )
	  ))
       ;; plain citations
       (t
	(concat "["
	      (mapconcat (lambda (key) (concat "@" key))
			 (split-string (org-element-property :path link) ",")
			 "; ")
	      "]")))
    ;; not a cite link. just return the original link
    (org-org-identity link contents info)))

(org-export-define-derived-backend 'pandoc-org 'org
  :translate-alist '((link . pandoc-cite-format)))

(find-file (org-export-to-file 'pandoc-org "org-to-org.org"))
#+END_SRC

#+RESULTS:





* exploring Zotero sqlite
  :PROPERTIES:
  :ID:       B23B6DE7-EC6D-47A7-B942-2E2B7C6EF5E6
  :END:

#+BEGIN_SRC sh
cp /Users/jkitchin/Library/Application\ Support/Zotero/Profiles/hiro2nsy.default/zotero/zotero.sqlite .
#+END_SRC

#+RESULTS:

What tables do we have?
#+BEGIN_SRC sqlite :db zotero.sqlite :list
.tables
#+END_SRC

#+RESULTS:
#+begin_example
annotations                itemNotes
baseFieldMappings          itemSeeAlso
baseFieldMappingsCombined  itemTags
charsets                   itemTypeCreatorTypes
collectionItems            itemTypeFields
collections                itemTypeFieldsCombined
creatorData                itemTypes
creatorTypes               itemTypesCombined
creators                   items
customBaseFieldMappings    libraries
customFields               proxies
customItemTypeFields       proxyHosts
customItemTypes            relations
deletedItems               savedSearchConditions
fieldFormats               savedSearches
fields                     settings
fieldsCombined             storageDeleteLog
fileTypeMimeTypes          syncDeleteLog
fileTypes                  syncObjectTypes
fulltextItemWords          syncedSettings
fulltextItems              tags
fulltextWords              transactionLog
groupItems                 transactionSets
groups                     transactions
highlights                 translatorCache
itemAttachments            users
itemCreators               version
itemData                   zoteroDummyTable
itemDataValues
#+end_example

Best I can tell, items contains a list of our items. Although, this db should have 4 items. presumably it kept some things I deleted.

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select itemID,key from items;
#+END_SRC
#+RESULTS:
: 1|ABCD2345
: 2|ABCD3456
: 3|95VXFTCD
: 4|TKAZVJDH
: 5|NMW5IEF2
: 6|EU3FEG47

This lists the fields defined in item 3, itemid, fieldid, valueid

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select itemData.itemID, fields.fieldName, itemDataValues.value from itemData
inner join ItemDataValues
on itemData.valueID == itemDataValues.valueID
inner join fields
on fields.fieldID == itemData.fieldID
where itemData.itemID==3;
#+END_SRC
#+RESULTS:
#+begin_example
3|url|http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5756277
3|volume|13
3|issue|3
3|pages|66-73
3|publicationTitle|Computing in Science & Engineering
3|ISSN|1521-9615
3|date|2011-05-00 05/2011
3|DOI|10.1109/MCSE.2011.41
3|accessDate|2015-01-27 23:27:14
3|libraryCatalog|CrossRef
3|title|Active Documents with Org-Mode
#+end_example

To get the authors:

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select firstName, lastName from creatorData
inner join itemCreators
on itemCreators.creatorID == creatorData.creatorDataID
where itemCreators.itemID==3;
#+END_SRC

#+RESULTS:
: Eric|Schulte
: Dan|Davison


* Helm source for headings with TODO
  :PROPERTIES:
  :ID:       673E4099-85C2-4710-846A-A50AD5D649D5
  :END:


For a helm source we need a list of cons cells that have a car of a selection, and a cdr that corresponds to that selection.

#+BEGIN_SRC emacs-lisp :results raw
(defun helm-todo-candidates ()
  (let ((results '()))
    (org-map-entries
     (lambda ()
       (add-to-list 'results
		    (cons
		     (concat (make-string (nth 1 (org-heading-components)) ?*)
			     " TODO "
			     (nth 4 (org-heading-components)))
		     (point-marker))))
     "TODO=\"TODO\"")
    results))

(helm-todo-candidates)
#+END_SRC

#+RESULTS:
((** post it . #<marker at 977 in blog.org>) (** work it out . #<marker at 941 in blog.org>))

Now to run helm, there is a subtle point. We need to map the current buffer /before/ running helm, otherwise we will map an empty helm buffer.

#+BEGIN_SRC emacs-lisp
(defun helm-todo ()
  "Helm interface to headlines with TODO status in current buffer."
  (interactive)
  (let ((candidates (helm-todo-candidates)))
    (setq helm-todo-source '((name . "TODO headlines")
			     (candidates . candidates)
			     (action . (("open" . goto-char)))))
    (helm :sources '(helm-todo-source))))

(helm-todo)
#+END_SRC

#+RESULTS:

Now, let us expand the idea to a helm-agenda. We want a function that prompts for a match criteria, then presents a helm buffer to select matching entries in your agenda files.

#+BEGIN_SRC emacs-lisp
(defun helm-agenda-candidates (query)
  (let ((results '()))
    (mapc (lambda (f)
      (with-current-buffer (find-file-noselect f)
	(org-map-entries
	 (lambda ()
	   (add-to-list 'results
			(cons
			 (concat
			  (file-name-nondirectory f) " | "
			  (make-string (nth 1 (org-heading-components)) ?*)
			  " "
			  (org-get-heading))
			 (point-marker))))
	 query))) (org-agenda-files))
    results))


(defun helm-query-agenda (query)
  "Helm interface to headlines with TODO status in current buffer."
  (interactive "sQuery: ")
  (let ((candidates (helm-agenda-candidates query)))
    (helm :sources '(((name . "TODO headlines")
		      (candidates . candidates)
		      (action . (("open" . (lambda (m)
					     (switch-to-buffer (marker-buffer m))
					     (goto-char m)
					     (show-children))))))))))
#+END_SRC

#+RESULTS:

** TODO work it out
   :PROPERTIES:
   :ID:       508D2347-9A65-483B-9F00-859ADCEFBC72
   :END:
** DONE test it
   :PROPERTIES:
   :ID:       DB113820-7728-4079-B940-CAAEC8133AC9
   :END:
** TODO post it
   :PROPERTIES:
   :ID:       E587FCBC-0284-48F4-AD1D-2D854C7E889F
   :END:




* Filtering an org-mode table
  :PROPERTIES:
  :ID:       1D966382-F050-4070-9CB7-B03A2B0D3BDF
  :END:

Suppose I have this table, and I want to filter it for all entries having a topic of 1. Of course you can sort the table by topic and find the group. I want something like Excel has where you filter and make the other rows disappear.

First, let's take a look at some org-table functions that will be useful. Let us assume our filtering command is run interactively in a table. We need to know what column we are in, which we can get with =org-table-current-column=. We then might go to the beginning of the table. WE can find that with =org-table-begin=. Then, we iterate through the rows with =org-table-next-row=, and check the value of a field in the desired column with =org-table-get-field=.

#+BEGIN_SRC emacs-lisp
(defun filter-message ()
  (interactive)
  (let* ((current-column (org-table-current-column))
	 (current-value (org-table-get-field))
	 (filtered-lines  '()))
    (goto-char (org-table-begin))
    ;(message-box "%s" (org-table-current-dline))
    (while (org-table-p)
      (forward-line)
      (message "%s" (org-table-get-field current-column))
      (if (not
	   (string= current-value (org-table-get-field current-column)))
	  (add-to-list 'filtered-lines nil)
	(add-to-list 'filtered-lines t)))
    (message-box "%s" filtered-lines    )
    ))
#+END_SRC

#+RESULTS:
: filter-message




maybe see https://gist.github.com/doitian/1571162 for a folding way

#+tblname: my-data
| name | topic |
|------+-------|
| a    |     1 |
| v    |     1 |
| c    |     2 |
| d    |     3 |
| e    |     2 |
| f    |     1 |

First, we try making a row invisible.

(remove-from-invisibility-spec '(org-table-filter))
#+BEGIN_SRC emacs-lisp :results silent
(re-search-backward "#\\+tblname: my-data")
(re-search-forward "| v")
(beginning-of-line)
(let ((beg (point))
      (end)(ov))

  (end-of-line)
  (setq end (point))
  (setq ov (make-overlay beg end))
  (message-box "%s" (buffer-substring beg end))
  ;(overlay-put (make-overlay beg end) 'invisible 'org-table-filter))
  (overlay-put ov 'display '(height 0)))

(add-to-invisibility-spec '(org-table-filter))
#+END_SRC


see http://www.gnu.org/software/emacs/manual/html_node/elisp/Pixel-Specification.html#Pixel-Specification

maybe we can make lines on pixel high

* Indirect buffer in another mode
  :PROPERTIES:
  :ID:       475CA10F-968E-4E89-AD14-E2F5B9B4BBBD
  :END:

#+BEGIN_SRC emacs-lisp
(defun dwiw-indirect ()
  (if (org-in-block-p '("src"))
    (let* ((temp (org-edit-src-find-region-and-lang))
	   (beg (nth 0 temp))
	   (end (nth 1 temp))
	   (lang (nth 2 temp)))
      (message "in block: %s" lang)
      (pop-to-buffer (or
		      (get-buffer "*indirect*")
		      (make-indirect-buffer (current-buffer) "*indirect*")))
      (narrow-to-region beg end)
      ;; set mode(major-mode)
      (funcall (intern (concat lang "-mode"))))

    (when (eq major-mode 'org-mode)
      (when (get-buffer "*indirect*")
	(kill-buffer (get-buffer "*indirect*")))
      (font-lock-fontify-buffer))))


(add-hook 'post-command-hook 'dwiw-indirect)
;(remove-hook 'post-command-hook 'dwiw-indirect)
#+END_SRC




* toggle images in section
  :PROPERTIES:
  :ID:       24F85538-192C-4E8B-95E8-12963E7B59A0
  :END:

#+BEGIN_SRC emacs-lisp
(defun show-images-subtree ()
 (interactive)
(save-restriction
  (org-narrow-to-subtree)
  (org-display-inline-images nil t (point-min) (point-max))))
#+END_SRC
** section 1
   :PROPERTIES:
   :ID:       CA7CBB23-5800-40E3-AD61-2EAAB877D4CF
   :END:

[[./images/eos.png]]



** section 1
   :PROPERTIES:
   :ID:       960ACA3B-BBD6-4120-9E45-AA7F2ABCED68
   :END:

[[./images/eos.png]]

* get a count of unique elements
  :PROPERTIES:
  :ID:       1C1F6388-8813-498C-8905-A77E6549424B
  :END:

  ;; we need counts for each atom type. eventually we need to make sure the POTCAR file is written consistently with the order here. This is the clumsiest part of VASP, and the reason for the complex sorting done in ase. Some effort is made to group the atoms together so there is only one copy of each POTCAR.
  (insert "\n")
  (let* ((all-symbols (loop for atom in (oref atoms atoms)
			    collect (oref atom symbol)))
	 (unique-syms (-uniq all-symbols))
	 (counts (loop for usym in unique-syms
		       collect (cl-count usym all-symbols))))

    (dolist (c counts)
      (insert (format "%d " c))))

* OOP in emacs-lisp
  :PROPERTIES:
  :ID:       64E475DF-959D-451D-8308-A656104C19D9
  :END:

#+BEGIN_SRC emacs-lisp
(defclass student ()
  ((first-name :initarg :first-name
	       :documentation "First name")
   (last-name :initarg :last-name
	      :documentation "Last name")
   (email :initarg :email
	  :documentation "Email address")))

(defmethod email-student ((rec student))
  "send email to student stored in REC."
  (message "sending email to %s"
	   (oref rec email)))

(setq s1 (student "s1" :first-name "John"
		 :last-name "Kitchin"
		 :email "jkitchin@andrew.cmu.edu"))

(email-student s1)
#+END_SRC

#+RESULTS:
: sending email to jkitchin@andrew.cmu.edu

* Getting items done today
  :PROPERTIES:
  :ID:       15346174-50C3-48E2-B370-95F0C10FA54D
  :END:

** DONE item 1
   CLOSED: [2014-11-26 Wed 13:09] DEADLINE: <2014-11-26 Wed>
   :PROPERTIES:
   :ID:       AA4B5421-006F-4369-997D-DDA4C4F4D4B7
   :END:



** DONE item 2
   CLOSED: [2014-11-25 Tue 13:09] DEADLINE: <2014-11-26 Wed>
   :PROPERTIES:
   :ID:       6604614C-310F-4E0E-A044-D52480AEEFF0
   :END:


** Mapping entries to find what closed today.
   :PROPERTIES:
   :ID:       589E7983-73DB-46C8-9085-2C195CB0A1B3
   :END:

First, we look at a timestamp comparison function.
#+BEGIN_SRC emacs-lisp
(org-time= "<2014-11-26 Wed>" "<2014-11-26 Wed>")
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
(org-map-entries
  (lambda ()
    (let* ((closed (org-entry-get (point) "CLOSED"))
           (today (format-time-string "<%Y-%m-%d>")))
      (when closed
	(when
	    (org-time=
	     today
	     (let ((parts (org-parse-time-string closed)))
	       (format "<%s-%s-%s>"
		       (nth 5 parts) ; year
		       (nth 4 parts) ; month
		       (nth 3 parts) ; day
		       )))
	  (message-box "Found a closed task: %s"
		       (org-heading-components)))))))

#+END_SRC

#+RESULTS:
| nil | Found a closed task: (2 2 DONE nil item 1 nil) | nil | nil |

* A new data structure for me in emacs-lisp
  :PROPERTIES:
  :ID:       683D257C-3A5A-446D-A179-7E7D5E0592BB
  :END:

I am examining the struct data type in emacs-lisp today. This creates something like an object with fields of data that are accessed by name. We will create a student object that contains first name, last name and an email address.

#+BEGIN_SRC emacs-lisp
(defstruct student first-name last-name email)
#+END_SRC

#+RESULTS:
: student

Let us make a student now, and assign it to a variable.
#+BEGIN_SRC emacs-lisp
(setq s1
      (make-student :first-name "John"
		    :last-name "Kitchin"
		    :email "jkitchin@andrew.cmu.edu"))
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@andrew.cmu.edu"]

The defstruct macro automatically creates accessor functions with names of NAME-SLOT. NAME in this case is student, and SLOT is one of the words we defined in the defstruct call. We access data from the student like this.

#+BEGIN_SRC emacs-lisp
(list
 (student-first-name s1)
 (student-last-name s1)
 (student-email s1))
#+END_SRC

#+RESULTS:
| John | Kitchin | jkitchin@andrew.cmu.edu |

Now, let us print the object.
#+BEGIN_SRC emacs-lisp
(princ s1)
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@andrew.cmu.edu"]

We can use generalized setf to change the values in the object.

#+BEGIN_SRC emacs-lisp
(setf (student-email s1) "jkitchin@cmu.edu")
(princ s1)
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@cmu.edu"]

Finally, the defstruct macro also defines a function to test if a variable is one of these objects. We can confirm a variable is a student object like this:
#+BEGIN_SRC emacs-lisp
(student-p s1)
#+END_SRC

#+RESULTS:
: t

This looks like a relatively handy way to encapsulate data in emacs-lisp, and accessing the data seems more readable than using any combination of car, cdr, elt and nth.


* TODO A custom block in orgmode with attributes
  :PROPERTIES:
  :ID:       9E1C5637-EF34-4B4F-8464-5296982D327B
  :END:

#+BEGIN_EXAMPLE
Example text in a block to make sure it gets handled
#+END_EXAMPLE

Some instructions for the quiz.

#+ATTR_quiz: :points 5 :correct-answer A
#+BEGIN_quiz
test quiz
- [ ] answer A
- [ ] answer B
#+END_quiz


#+BEGIN_SRC emacs-lisp :exports none
(defun my-org-html-export-block (export-block contents info)
  "Transcode a EXPORT-BLOCK element from Org to HTML.
CONTENTS is nil.  INFO is a plist used as a communication
channel. QUIZ blocks are handled separately."

  (cond
   ;; handle our special quiz block
   ((string= (org-element-property :type export-block) "QUIZ")

    (format
     "<b>got it:</b> %s points, correct answer = %s
<br>
You would have to parse the body to generate your html here.
<br>
<pre>%s</pre>"
     (plist-get
      (read (format "%s" (org-element-property :attr_quiz export-block)))
     :points)
     (plist-get
      (read (format "%s" (org-element-property :attr_quiz export-block)))
     :correct-answer)
     (org-element-property :value export-block)
     ))
   ;; handle every other kind of block
   (t
    (org-html-export-block (export-block contents info)))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((export-block . my-org-html-export-block))
  ;; quiz blocks will not be parsed, they are handled directly in org-html-export-block.
  :export-block "quiz"
)


(browse-url (org-export-to-file 'my-html "custom-element.html"))
#+END_SRC

#+RESULTS:
: #<process open /Users/jkitchin/blogofile-jkitchin.github.com/_blog/custom-element.html>


* Helm notes
  :PROPERTIES:
  :ID:       58958528-FF0D-4C21-96C1-6DBFEB4E6EC9
  :END:

from [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.helm.user#loom.20140114T194900-298@post.gmane.org][Email from Tom: Making google suggest even mor]]
#+BEGIN_SRC emacs-lisp
(setq helm-source-google-suggest
  '((name . "Google Suggest")
    (candidates . (lambda ()
                    (funcall helm-google-suggest-default-function)))
    (action . (("Google Search" . helm-google-suggest-action)
               ("Wikipedia" . (lambda (candidate)
                     (browse-url
                      (concat "https://en.wikipedia.org/wiki/Special:Search?search="
                              (url-hexify-string candidate)))))
               ("Youtube" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.youtube.com/results?aq=f&search_query="
                              (url-hexify-string candidate)))))
               ("IMDb" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.imdb.com/find?s=all&q="
                              (url-hexify-string candidate)))))
               ("Google Maps" . (lambda (candidate)
                     (browse-url
                      (concat "http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q="
                              (url-hexify-string candidate)))))
               ("Google News" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.google.com/search?hl=en&safe=off&prmd=nvlifd&source=lnms&tbs=nws:1&q="
                              (url-hexify-string candidate)))))
               ))
    (volatile)
    (requires-pattern . 3)))

(helm :sources 'helm-source-google-suggest)
#+END_SRC

#+RESULTS:
: #<process open http://www.imdb.com/find?s=all&q=kitchen%20cabinets>


https://github.com/krisajenkins/helm-spotify/blob/master/helm-spotify.el

(require 'multi)

** dictionary
   :PROPERTIES:
   :ID:       04F4FF49-BD2F-4684-AEE8-DA689ABABFA5
   :END:
[[https://raw.githubusercontent.com/emacs-helm/helm-dictionary/master/helm-dictionary.el]]

#+BEGIN_SRC emacs-lisp
;;; helm-dictionary.el --- Helm source for looking up dictionaries

;; Copyright 2013 Titus von der Malsburg <malsburg@posteo.de>

;; Author: Titus von der Malsburg <malsburg@posteo.de>
;;         Michael Heerdegen <michael_heerdegen@web.de>
;; Maintainer: Titus von der Malsburg <malsburg@posteo.de>
;; URL: https://github.com/emacs-helm/helm-dictionary
;; Version: 1.0.0
;; Package-Requires: ((helm "1.5.5"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This helm source can be used to look up words in local (offline)
;; dictionaries.  It also provides short-cuts for various online
;; dictionaries, which is useful in situations where the local
;; dictionary doesn't have an entry for a word.
;;
;; Dictionaries are available for a variety of language pairs.  See
;; the project page for an incomplete list:
;;
;;     https://github.com/emacs-helm/helm-dictionary

;;; Install:

;; Put this file on your Emacs-Lisp load path and add the following in
;; your Emacs startup file:
;;
;;     (require 'helm-dictionary)
;;
;; Alternatively, you can use autoload:
;;
;;     (autoload 'helm-dictionary "helm-dictionary" "" t)
;;
;; In order to specify a dictionary set the variable
;; `helm-dictionary-database' to the filename of that dictionary.
;;
;; A dictionary for German and English can be found in the Debian
;; package trans-de-en.  This package is also available in many
;; distributions derived from Debian such as Ubuntu.  Alternatively,
;; this dictionary can also be downloaded here:
;;
;;   http://www-user.tu-chemnitz.de/~fri/ding/
;;
;; A dictionary for German and Spanish can be found here:
;;
;;   https://savannah.nongnu.org/projects/ding-es-de
;;
;; A variety of dictionaries with English as the source or target
;; language can be found here:
;;
;;   https://en.wiktionary.org/wiki/User:Matthias_Buchmeier
;;
;; These dictionaries were automatically created from the Wiktionary
;; database.  Their size and quality may vary.  Also generated from
;; Wiktionary are the following dictionaries with Russian as the
;; source or target language:
;;
;;   http://wiktionary-export.nataraj.su/en/
;;
;; If the local dictionary doesn't have an entry for a word, it can be
;; useful to try online dictionaries available on the
;; web.  Helm-dictionary has a dummy source that provides shortcuts
;; for looking up the currently entered string in these online
;; dictionaries.  The variable `helm-dictionary-online-dicts'
;; specifies which online dictionaries should be listed.  The value of
;; that variable is a list conses.  The first element of each cons
;; specifies the name of an online dictionary for display during
;; searches.  The second element is the URL used for retrieving search
;; results from the respective dictionary.  This URL has to contain a
;; "%s" at the position where the search term should be inserted.
;;

;; The browser specified in `helm-dictionary-browser-function' will be
;; used to show results from online dictionaries.  If this variable is
;; nil (default), the value of the variable
;; `browse-url-browser-function' will be used (the currently
;; configured Emacs-wide default browser).  If that variable is also
;; nil, helm uses the first available browser in
;; `helm-browse-url-default-browser-alist'.

;;; Usage:

;; Use the command `helm-dictionary' to start a new search.  As usual,
;; a search is case-insensitive unless the expression contains capital
;; letters.  Regular expressions can also be used as search
;; terms.  During a search, you can use `M-n` to search for the word
;; at which you called `helm-dictionary`.

;; There are two actions available: insert the currently selected term
;; in the source language (left) or in the target language (right) at
;; point, i.e., the cursor position at which `helm-dictionary' was
;; called.

;; In the section "Look up online", you can choose among several online
;; dictionaries.  If you select one of the entries listed in this
;; section, a browser will be used to display search results from the
;; respective dictionary.

;;; Code:

(require 'cl-lib)
(require 'helm)
(require 'helm-net)
(require 'helm-plugin)

(defgroup helm-dictionary nil
  "Helm plugin for looking up a dictionary."
  :group 'helm)

(defcustom helm-dictionary-database "/usr/share/trans/de-en"
  "The file containing the dictionary."
  :group 'helm-dictionary
  :type  'file)

(defcustom helm-dictionary-online-dicts
  '(("translate.reference.com de->eng" .
     "http://translate.reference.com/translate?query=%s&src=de&dst=en")
    ("translate.reference.com eng->de" .
     "http://translate.reference.com/translate?query=%s&src=en&dst=de")
    ("leo eng<->de" .
     "http://dict.leo.org/ende?lp=ende&lang=de&search=%s")
    ("en.wiktionary.org" . "http://en.wiktionary.org/wiki/%s")
    ("de.wiktionary.org" . "http://de.wiktionary.org/wiki/%s")
    ("linguee-eng<->de" . "http://www.linguee.de/deutsch-englisch/search\
?sourceoverride=none&source=auto&query=%s"))
  "Alist of online dictionaries.  The key of each entry is the
name of the online dictionary.  The value is the URL used for
retrieving results.  This URL must contain a %s at the position
where the search term should be inserted.")

(defcustom helm-dictionary-browser-function nil
  "The browser that is used to access online dictionaries.  If
nil (default), the value of `browse-url-browser-function' is
used.  If that value is nil, Helm uses the first available
browser in `helm-browse-url-default-browser-alist'"
  :group 'helm-dictionary
  :type '(choice
          (const         :tag "Default" :value nil)
          (function-item :tag "Emacs interface to w3m" :value w3m-browse-url)
          (function-item :tag "Emacs W3" :value  browse-url-w3)
          (function-item :tag "W3 in another Emacs via `gnudoit'"
                         :value  browse-url-w3-gnudoit)
          (function-item :tag "Mozilla" :value  browse-url-mozilla)
          (function-item :tag "Firefox" :value browse-url-firefox)
          (function-item :tag "Chromium" :value browse-url-chromium)
          (function-item :tag "Galeon" :value  browse-url-galeon)
          (function-item :tag "Epiphany" :value  browse-url-epiphany)
          (function-item :tag "Netscape" :value  browse-url-netscape)
          (function-item :tag "eww" :value  eww-browse-url)
          (function-item :tag "Mosaic" :value  browse-url-mosaic)
          (function-item :tag "Mosaic using CCI" :value  browse-url-cci)
          (function-item :tag "Text browser in an xterm window"
                         :value browse-url-text-xterm)
          (function-item :tag "Text browser in an Emacs window"
                         :value browse-url-text-emacs)
          (function-item :tag "KDE" :value browse-url-kde)
          (function-item :tag "Elinks" :value browse-url-elinks)
          (function-item :tag "Specified by `Browse Url Generic Program'"
                         :value browse-url-generic)
          (function-item :tag "Default Windows browser"
                         :value browse-url-default-windows-browser)
          (function-item :tag "Default Mac OS X browser"
                         :value browse-url-default-macosx-browser)
          (function-item :tag "GNOME invoking Mozilla"
                         :value browse-url-gnome-moz)
          (function-item :tag "Default browser"
                         :value browse-url-default-browser)
          (function      :tag "Your own function")
          (alist         :tag "Regexp/function association list"
                         :key-type regexp :value-type function)))

(easy-menu-add-item nil '("Tools" "Helm" "Tools") ["Dictionary" helm-dictionary t])


(defun helm-dictionary-transformer (candidates)
  "Formats entries retrieved from the data base."
  (cl-loop for i in candidates
           with entry and l1terms and l2terms
           and width = (with-helm-window (window-width))
           unless (or (string-match "\\`#" i)
                      (not (string-match " :: ?" i)))
           do (progn (setq entry (split-string i " :: ?"))
                     (setq l1terms (split-string (car entry) " | "))
                     (setq l2terms (split-string (cadr entry) " | ")))
           and append
           (cl-loop for l1term in l1terms
                    for l2term in l2terms
                    if (or (string-match helm-pattern l1term)
                           (string-match helm-pattern l2term))
                    collect
                    (cons
                     (concat
                      (truncate-string-to-width l1term (- (/ width 2) 1) 0 ?\s)
                      " "
                      (truncate-string-to-width l2term (- (/ width 2) 1) 0 ?\s))
                     (cons l1term l2term)))))


(defun helm-dictionary-insert-l1term (entry)
  (insert
    (replace-regexp-in-string
      " *{.+}\\| *\\[.+\\]" "" (car entry))))

(defun helm-dictionary-insert-l2term (entry)
  (insert
    (replace-regexp-in-string
      " *{.+}\\| *\\[.+\\]" "" (cdr entry))))


(defvar helm-source-dictionary
  '((name . "Search dictionary")
    (candidates-file . helm-dictionary-database)
    (candidate-transformer . helm-dictionary-transformer)
    (action . (("Insert source language term" . helm-dictionary-insert-l1term)
               ("Insert target language term" . helm-dictionary-insert-l2term)))))

(defvar helm-source-dictionary-online
  '((name . "Look up online")
    (match (lambda (_candidate) t))
    (candidates . helm-dictionary-online-dicts)
    (no-matchplugin)
    (nohighlight)
    (action
     . (lambda (cand)
         (let ((browse-url-browser-function
                (or helm-dictionary-browser-function
                    browse-url-browser-function)))
           (helm-browse-url (format cand (url-hexify-string helm-pattern)))))))
  "Source for online look-up.")

;;;###autoload
(defun helm-dictionary ()
  (interactive)
  (helm :sources '(helm-source-dictionary helm-source-dictionary-online)
        :full-frame t
        :candidate-number-limit 500
        :buffer "*helm dictionary*"))

(provide 'helm-dictionary)

;; Local Variables:
;; byte-compile-warnings: (not cl-functions obsolete)
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:

;;; helm-dictionary.el ends here
#+END_SRC

#+RESULTS:
: helm-dictionary


** mail list
   :PROPERTIES:
   :ID:       8F1A203A-603C-4837-A975-9ECC3ECCA6AB
   :END:
[[gnus:nntp%2Bnews.gmane.org:gmane.emacs.helm.user#87eh8mpakg.fsf@gmail.com][Email from Thierry Volpiatto: Re: Get the full path to the c]]

helm-describe-helm-attribute

* Using filters to get pdf images into html export
  :PROPERTIES:
  :ID:       E15DAA33-A564-45A9-93BC-83E3C506E01E
  :END:

#+BEGIN_SRC python
import matplotlib.pyplot as plt

plt.plot([1, 2, 4, 8])
plt.savefig('im.pdf')
#+END_SRC

Here is our inline image as a pdf file. We would like it to be converted to a png, and rendered in an html export. This is most easily done with a derived backend.

[[./im.pdf]]


#+BEGIN_SRC emacs-lisp
(defun my-link-format (link contents info)
  (let ((type (org-element-property :type link))
	(path (org-element-property :path link)))
    (cond
     ((and
       (string= type "file")
       (string-match "\.pdf" path))
      (shell-command
       (format
	"convert %s %s"
	path
	(replace-regexp-in-string "\.pdf" ".png" path)))
      (format "<img src=\"%s\">" (replace-regexp-in-string "\.pdf" ".png" path)))
     ;; anything else, we just do the regular thing
     (t
      (org-html-link link contents info)))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((link . my-link-format)))


(browse-url (org-export-to-file 'my-html "custom-link.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-link.html>




* make any org link a menu link
  :PROPERTIES:
  :ID:       9890E268-29DD-4E39-AE7E-E0A4278ECDDB
  :END:

It seems like it should be possible to make org links have variable behavior. For example, if one action is defined, it should be done. If more than one action is defined, you should get a menu. One way to achieve this is to hijack the org-link functions, or in cases where lambda functions are used, we have to redefine them. The follow functions are defined in org-link-protocols.

#+BEGIN_SRC emacs-lisp :results code
org-link-protocols
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("google"
  (lambda
    (link-string)
    (browse-url
     (format "http://www.google.com/search?q=%s"
	     (url-hexify-string link-string))))
  nil)
 ("ResearcherID"
  (lambda
    (link-string)
    (browse-url
     (format "http://www.researcherid.com/rid/%s" link-string)))
  nil)
 ("orcid"
  (lambda
    (link-string)
    (browse-url
     (format "http://orcid.org/%s" link-string)))
  nil)
 ("message" org-mac-message-open nil)
 ("mac-outlook" org-mac-outlook-message-open nil)
 ("skim" org-mac-skim-open nil)
 ("addressbook" org-mac-addressbook-item-open nil)
 ("x-together-item" org-mac-together-item-open nil)
 ("rmail" org-rmail-open nil)
 ("mhe" org-mhe-open nil)
 ("irc" org-irc-visit nil)
 ("info" org-info-open nil)
 ("gnus" org-gnus-open nil)
 ("docview" org-docview-open org-docview-export)
 ("bibtex" org-bibtex-open nil)
 ("bbdb" org-bbdb-open org-bbdb-export)
 ("ans"
  (lambda
    (path)
    (let*
	((fields
	  (split-string path "::"))
	 (label
	  (nth 0 fields))
	 (data
	  (nth 1 fields))
	 (data-file
	  (format "%s-%s.dat" tq-userid label)))
      (let
	  ((temp-file data-file)
	   (temp-buffer
	    (get-buffer-create
	     (generate-new-buffer-name " *temp file*"))))
	(unwind-protect
	    (prog1
		(save-current-buffer
		  (set-buffer temp-buffer)
		  (insert data))
	      (save-current-buffer
		(set-buffer temp-buffer)
		(write-region nil nil temp-file nil 0)))
	  (and
	   (buffer-name temp-buffer)
	   (kill-buffer temp-buffer))))
      (mygit
       (format "git add %s" data-file))
      (mygit
       (format "git commit -m \"%s\"" data-file))
      (mygit "git push origin master")))
  nil)
 ("exercise"
  (lambda
    (arg)
    (tq-check-internet)
    (tq-get-assignment arg))
  nil)
 ("solution"
  (lambda
    (label)
    (tq-check-internet)
    (let
	((default-directory
	   (file-name-as-directory
	    (expand-file-name tq-root-directory))))
      (if
	  (file-exists-p "solutions")
	  nil
	(make-directory "solutions"))
      (let
	  ((default-directory
	     (file-name-as-directory
	      (expand-file-name "solutions"))))
	(if
	    (file-exists-p label)
	    (progn
	      (find-file
	       (concat label "/" label ".org"))
	      (tq-update))
	  (mygit
	   (format "git clone %s@%s:solutions/%s" tq-current-course tq-git-server label))
	  (find-file
	   (concat label "/" label ".org"))))))
  nil)
 ("assignment"
  (lambda
    (arg)
    (tq-check-internet)
    (tq-get-assignment arg))
  nil)
 ("doi" doi-link-menu nil)
 ("bibentry" org-ref-cite-onclick-minibuffer-menu org-ref-format-bibentry)
 ("Autocites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocites)
 ("autocites" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocites)
 ("supercites" org-ref-cite-onclick-minibuffer-menu org-ref-format-supercites)
 ("Textcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Textcites)
 ("textcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-textcites)
 ("Smartcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Smartcites)
 ("smartcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-smartcites)
 ("footcitetexts" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcitetexts)
 ("footcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcites)
 ("Parencites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Parencites)
 ("parencites" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencites)
 ("Cites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Cites)
 ("cites" org-ref-cite-onclick-minibuffer-menu org-ref-format-cites)
 ("fnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-fnotecite)
 ("Pnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Pnotecite)
 ("pnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-pnotecite)
 ("Notecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Notecite)
 ("notecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-notecite)
 ("footfullcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-footfullcite)
 ("fullcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-fullcite)
 ("citeurl" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeurl)
 ("citedate*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citedate*)
 ("citedate" org-ref-cite-onclick-minibuffer-menu org-ref-format-citedate)
 ("citetitle*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetitle*)
 ("citetitle" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetitle)
 ("Citeauthor*" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citeauthor*)
 ("Autocite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocite*)
 ("autocite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocite*)
 ("Autocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocite)
 ("autocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocite)
 ("supercite" org-ref-cite-onclick-minibuffer-menu org-ref-format-supercite)
 ("parencite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencite*)
 ("cite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-cite*)
 ("Smartcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Smartcite)
 ("smartcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-smartcite)
 ("Textcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Textcite)
 ("textcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-textcite)
 ("footcitetext" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcitetext)
 ("footcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcite)
 ("Parencite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Parencite)
 ("parencite" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencite)
 ("Cite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Cite)
 ("Citeauthor" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citeauthor)
 ("Citealp" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citealp)
 ("Citealt" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citealt)
 ("Citep" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citep)
 ("Citet" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citet)
 ("citeyear*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeyear*)
 ("citeyear" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeyear)
 ("citeauthor*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeauthor*)
 ("citeauthor" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeauthor)
 ("citetext" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetext)
 ("citenum" org-ref-cite-onclick-minibuffer-menu org-ref-format-citenum)
 ("citealp*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealp*)
 ("citealp" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealp)
 ("citealt*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealt*)
 ("citealt" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealt)
 ("citep*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citep*)
 ("citep" org-ref-cite-onclick-minibuffer-menu org-ref-format-citep)
 ("citet*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citet*)
 ("citet" org-ref-cite-onclick-minibuffer-menu org-ref-format-citet)
 ("nocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-nocite)
 ("cite" org-ref-cite-onclick-minibuffer-menu org-ref-format-cite)
 ("eqref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (goto-char
     (point-min))
    (if
	(or
	 (re-search-forward
	  (format "label:%s" label)
	  nil t)
	 (re-search-forward
	  (format "\\label{%s}" label)
	  nil t)
	 (re-search-forward
	  (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	  nil t))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<eqref>%s</eqref>)" path))
     ((eq format 'latex)
      (format "\\eqref{%s}" keyword)))))
 ("nameref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<nameref>%s</nameref>)" path))
     ((eq format 'latex)
      (format "\\nameref{%s}" keyword)))))
 ("pageref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "label:%s\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<pageref>%s</pageref>)" path))
     ((eq format 'latex)
      (format "\\pageref{%s}" keyword)))))
 ("ref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "label:%s\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (org-show-entry)
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<ref>%s</ref>)" path))
     ((eq format 'latex)
      (format "\\ref{%s}" keyword)))))
 ("label"
  (lambda
    (label)
    "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
    (message
     (format "%s occurences"
	     (+
	      (count-matches
	       (format "label:%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "^#\\+tblname:\\s-*%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "\\label{%s}\\b" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "^#\\+label:\\s-*%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)))))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<label>%s</label>)" path))
     ((eq format 'latex)
      (format "\\label{%s}" keyword)))))
 ("list-of-tables" org-ref-list-of-tables
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\listoftables")))))
 ("list-of-figures" org-ref-list-of-figures
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\listoffigures")))))
 ("addbibresource"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-addbibresource)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format ""))
     ((eq format 'latex)
      (format "\\addbibresource{%s}" keyword)))))
 ("bibliographystyle"
  (lambda
    (arg)
    (message "Nothing implemented for clicking here."))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\bibliographystyle{%s}" keyword)))))
 ("printbibliography"
  (lambda
    (arg)
    (message "Nothing implemented for clicking here."))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      "\\printbibliography"))))
 ("nobibliography"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-bibliography)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'ascii)
      (org-ref-get-ascii-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      (format "\\nobibliography{%s}"
	      (replace-regexp-in-string "\\.bib" ""
					(mapconcat 'identity
						   (mapcar 'expand-file-name
							   (split-string keyword ","))
						   ",")))))))
 ("bibliography"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-bibliography)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'ascii)
      (org-ref-get-ascii-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      (format "\\bibliography{%s}"
	      (replace-regexp-in-string "\\.bib" ""
					(mapconcat 'identity
						   (mapcar 'expand-file-name
							   (split-string keyword ","))
						   ",")))))))
 ("pydoc"
  (lambda
    (link-string)
    (shell-command
     (format "python -m pydoc %s" link-string)))
  nil)
 ("index"
  (lambda
    (path)
    (tq-index)
    (occur path))
  nil)
 ("attachfile"
  (lambda
    (link-string)
    (org-open-file link-string))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format ""))
     ((eq format 'latex)
      (format "\\attachfile{%s}" keyword)))))
 ("msx" org-msx-open nil)
 ("id" org-id-open nil)
 ("file+emacs" org-open-file-with-emacs nil)
 ("file+sys" org-open-file-with-system nil))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results code
(car org-link-protocols)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("google"
 (lambda
   (link-string)
   (browse-url
    (format "http://www.google.com/search?q=%s"
	    (url-hexify-string link-string))))
 nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setf (cadr (assoc "google" org-link-protocols))
  (lambda (x) (message "You googled %s good" x)))
#+END_SRC

#+RESULTS:
| lambda | (x) | (message You googled %s good x) |

#+BEGIN_SRC emacs-lisp :results code
(car org-link-protocols)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("google"
 (lambda
   (x)
   (message "You googled %s good" x))
 nil)
#+END_SRC

google:test

This way you can make the function do what ever you want, without digging into the source code, advising functions etc...

#+BEGIN_SRC emacs-lisp
(assoc "file" org-link-protocols)
#+END_SRC

#+RESULTS:
skim:ts
* Unlinkify an org link
  :PROPERTIES:
  :ID:       A43D270A-056E-42F4-8260-112BD669C630
  :END:

cnn

a f test.regfdsa


#+BEGIN_SRC emacs-lisp
(defun unlinkify ()
  "replace an org-link with the path, or description."
  (interactive)
  (let ((eop (org-element-context)))
    (when (eq 'link (car eop))
(message "%s" eop)
      (let* ((start (org-element-property :begin eop))
	     (end (org-element-property :end eop))
	     (contents-begin (org-element-property :contents-begin eop))
	     (contents-end (org-element-property :contents-end eop))
	     (path (org-element-property :path eop))
	     (desc (and contents-begin
			contents-end
			(buffer-substring contents-begin contents-end))))
	(setf (buffer-substring start end) (or desc path))))))
#+END_SRC

#+RESULTS:
: unlinkify

* Spelling and grammar checking in emacs with a web API
  :PROPERTIES:
  :ID:       BB6397A2-C026-429C-80F0-E29E1EFC36EA
  :END:

After the deadline (http://www.afterthedeadline.com/api.slp) has an API for checking spelling, grammar, statistics and style. You post to their server, and they send back some xml. Here is a minimal example in emacs.

#+BEGIN_SRC emacs-lisp
(let ((url-request-method "POST")
      (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not"))))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://service.afterthedeadline.com/checkDocument")
    (buffer-substring url-http-end-of-headers (point-max))))
#+END_SRC

#+RESULTS:
#+begin_example

<results>
  <error>
    <string>spel</string>
    <description>Spelling</description>
    <precontext>be</precontext>
    <suggestions>
        <option>spell</option>
        <option>spelt</option>
        <option>sped</option>
        <option>spec</option>
        <option>spew</option>
    </suggestions>
    <type>spelling</type>

  </error>
  <error>
    <string>gud</string>
    <description>Spelling</description>
    <precontext>spel</precontext>
    <suggestions>
        <option>gd</option>
        <option>gu</option>
        <option>gcd</option>
        <option>gad</option>
        <option>guid</option>
    </suggestions>
    <type>spelling</type>

  </error>
  <error>
    <string>weather</string>
    <description>Did you mean...</description>
    <precontext>gud</precontext>
    <suggestions>
        <option>whether</option>
    </suggestions>
    <type>spelling</type>
    <url>http://service.afterthedeadline.com/info.slp?text=weather&amp;tags=NN&amp;engine=0</url>

  </error>
  <error>
    <string>to be</string>
    <description>Passive voice</description>
    <precontext>want</precontext>

    <type>grammar</type>
    <url>http://service.afterthedeadline.com/info.slp?text=to+be&amp;tags=TO%2FVB&amp;engine=3</url>

  </error>
</results>
#+end_example

It finds two spelling errors, and a probable other kind of error (whether/weather), and a grammar issue. It would be nice to parse this into something more helpful. Emacs has come xml parsing [[http://www.emacswiki.org/emacs/XmlParserExamples][capabilities]], which we consider next.

#+BEGIN_SRC emacs-lisp
(describe-function 'xml-get-children)
#+END_SRC

#+RESULTS:
: xml-get-children is a compiled Lisp function in `xml.el'.
:
: (xml-get-children NODE CHILD-NAME)
:
: Return the children of NODE whose tag is CHILD-NAME.
: CHILD-NAME should match the value returned by `xml-node-name'.

#+BEGIN_SRC emacs-lisp
(describe-function 'xml-node-children)
#+END_SRC

#+RESULTS:
: xml-node-children is a compiled Lisp function in `xml.el'.
:
: (xml-node-children NODE)
:
: Return the list of children of NODE.
: This is a list of nodes, and it can be nil.

#+BEGIN_SRC emacs-lisp :results drawer
(let* ((url-request-method "POST")
       (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not")))
       (xml  (with-current-buffer
		 (url-retrieve-synchronously
		  "http://service.afterthedeadline.com/checkDocument")
	       (xml-parse-region url-http-end-of-headers (point-max)))))
  xml)
#+END_SRC

#+RESULTS:
:RESULTS:
((results nil
   (error nil
     (string nil spel)
     (description nil Spelling)
     (precontext nil be)
     (suggestions nil
         (option nil spell)
         (option nil spelt)
         (option nil sped)
         (option nil spec)
         (option nil spew)
    )
     (type nil spelling)

  )
   (error nil
     (string nil gud)
     (description nil Spelling)
     (precontext nil spel)
     (suggestions nil
         (option nil gd)
         (option nil gu)
         (option nil gcd)
         (option nil gad)
         (option nil guid)
    )
     (type nil spelling)

  )
   (error nil
     (string nil weather)
     (description nil Did you mean...)
     (precontext nil gud)
     (suggestions nil
         (option nil whether)
    )
     (type nil spelling)
     (url nil http://service.afterthedeadline.com/info.slp?text=weather&tags=NN&engine=0)

  )
   (error nil
     (string nil to be)
     (description nil Passive voice)
     (precontext nil want)

     (type nil grammar)
     (url nil http://service.afterthedeadline.com/info.slp?text=to+be&tags=TO%2FVB&engine=3)

  )
))
:END:

Here, we have some code that parses that xml into some more readable text. It took a while to work this out, and it still doesn't seem very beautiful.

#+BEGIN_SRC emacs-lisp :results output
(let* ((url-request-method "POST")
       (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not")))
       (xml  (with-current-buffer
		 (url-retrieve-synchronously
		  "http://service.afterthedeadline.com/checkDocument")
	       (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (errors (xml-get-children results 'error)))
  (dolist (err errors)
    (let* ((children (xml-node-children err))
	   ;; for some reason I could not get the string out, and had to do this.
	   (s (car (last (nth 1 children))))
	   ;; the last/car stuff doesn't seem right. there is probably
	   ;; a more idiomatic way to get this
           (desc (last (car (xml-get-children children 'description))))
	   (type (last (car (xml-get-children children 'type))))
	   (suggestions (xml-get-children children 'suggestions))
	   (options (xml-get-children (xml-node-name suggestions) 'option))
	   (opt-string  (mapconcat
		 (lambda (el)
		   (when (listp el)
		     (car (last el))))
		 options
		 " "))
	  )
      (princ (format "** %s ** %s
Description: %s
Suggestions: %s

" s type desc opt-string)))))
#+END_SRC

#+RESULTS:
#+begin_example
** spel ** (spelling)
   :PROPERTIES:
   :ID:       071C0510-EF87-4EEF-838A-EC6D6CB39123
   :END:
Description: (Spelling)
Suggestions: spell spelt sped spec spew

** gud ** (spelling)
   :PROPERTIES:
   :ID:       81241D47-A3FC-48CD-B08C-1FE8D2A58AD1
   :END:
Description: (Spelling)
Suggestions: gd gu gcd gad guid

** weather ** (spelling)
   :PROPERTIES:
   :ID:       753C472B-43C0-4F0F-8615-1BDC27D6AE82
   :END:
Description: (Did you mean...)
Suggestions: whether

** to be ** (grammar)
   :PROPERTIES:
   :ID:       E607A7E6-A46B-478A-A029-1FD7FAD90037
   :END:
Description: (Passive voice)
Suggestions:

#+end_example

Still, from here we could make some org links to go to different places in the buffer for editing.

** python approach
   :PROPERTIES:
   :ID:       CA9E22DF-3998-4218-99CE-7B1E795F68C1
   :END:

Basically, you post a request to the website, and you get an xml response back. I adapted this code from https://bitbucket.org/miguelventura/after_the_deadline/wiki/Home to do a simple spell check. The idea is to build this up to an emacs lisp library that does this from a command.

#+BEGIN_SRC python
import requests
import urllib

payload = urllib.urlencode({'key': None,
                            'data': 'I spel gud'})

url = "http://service.afterthedeadline.com/checkDocument"

r = requests.post(url, data=payload)

from xml.etree import ElementTree
e = ElementTree.fromstring(r.text)

errs = e.findall('message')
if len(errs) > 0:
    raise Exception('Server returned an error: %s' % errs[0].text)

for err in e.findall('error'):
    if err[1].text == 'Spelling':
        print '\n**{}** mispelled\nSuggestions:'.format(err[0].text)
        for opt in err.findall('suggestions/option'):
            print '  {}'.format(opt.text)
#+END_SRC

#+RESULTS:
#+begin_example

**spel** mispelled
Suggestions:
  sped
  spell
  spelt
  spec
  spew

**gud** mispelled
Suggestions:
  guy
  god
  gun
  gum
  gut
#+end_example



* Capturing stderr and stdout in org-mode
  :PROPERTIES:
  :ID:       A437E0CF-A71E-420F-86F1-F641E7F37CF2
  :END:

It looks like you have to send these to files, and then read them.

If we run this in org-mode, there is no message about stderr.
#+BEGIN_SRC python :tangle peo.py
import sys

print >>sys.stdout, "on stdout"
print >>sys.stderr, "on stderr"
#+END_SRC

#+RESULTS:
: on stdout

elisp:org-babel-tangle

Interestingly, we get stderr here...
#+BEGIN_SRC emacs-lisp
(shell-command-to-string "python peo.py")
#+END_SRC
#+RESULTS:
: on stderr
: on stdout



* "live" graphics in org-mode on a timer
  :PROPERTIES:
  :ID:       8F2049BA-D5C3-4A67-846C-999644408880
  :END:

#+tblname: tbldata
|   x |   y |
|-----+-----|
|  10 |   1 |
|   1 |   0 |
|   2 |   4 |
|   3 |   5 |
| 0.2 | 0.3 |


#+RESULTS: make-table-graph
#+BEGIN_SRC org
[[1, 1], [1, 0], [2, 4], [3, 5], [0.2, 0.3]]
[[./live-chart.png]]
#+END_SRC

** Code
   :PROPERTIES:
   :ID:       9CD7C4DB-A7B0-49F0-9F33-7AD44FDBEEC2
   :END:

#+NAME: make-table-graph
#+BEGIN_SRC python :var data=tbldata :results org
import matplotlib.pyplot as plt
plt.plot([x[0] for x in data], [x[1] for x in data])
plt.savefig('live-chart.png')
print data
print '[[./live-chart.png]]'
#+END_SRC

Now, for the elisp part.

#+BEGIN_SRC emacs-lisp
(defun update-graph ()
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "#\\+NAME: make-table-graph")
    (forward-line 2)
    (org-babel-execute-src-block)))

(defvar my-timer nil)

(setq my-timer (run-with-idle-timer
		5 ; idle for this many seconds
		t ; repeat indefinitely
		'update-graph))
#+END_SRC

#+RESULTS:
: [nil 0 5 0 t update-graph nil idle 0]

#+BEGIN_SRC emacs-lisp
(cancel-timer my-timer)
#+END_SRC
* An experiment of integrating git with save
  :PROPERTIES:
  :categories: git
  :ID:       01681796-5C1A-4E0F-AF0D-9907BFD93D07
  :END:
This is a little experiment to integrate saving a file with git. The idea is that every time we save, we also commit the changes. That way later we can undo changes, even after the file is closed and undo history is lost.

#+BEGIN_SRC emacs-lisp
(defun git-save-commit ()
  "Save buffer and commit it to the git repo."
  (interactive)
  (when
      (shell-command "git rev-parse --is-inside-work-tree")
    (save-buffer)

    ;; I am not sure if this works on a file nested in the repo
    (let ((f (file-relative-name
	      (buffer-file-name)
	      default-directory)))
      (shell-command (format "git add %s" f))
      (shell-command (format "git commit %s -m \"save\"" f)))))

(add-hook 'after-save-hook 'git-save-commit)

;; this runs just before autosave
(add-hook 'auto-save-hook 'git-save-commit)
#+END_SRC

#+RESULTS:
| git-save-commit | tramp-set-auto-save-file-modes |

#+BEGIN_SRC sh
git hist -n 10
#+END_SRC

* archived introspection work
  :PROPERTIES:
  :ID:       2AE30911-0191-4856-8F27-2B1FADDA3E25
  :END:
some hints to get started

http://stackoverflow.com/questions/605785/how-do-i-get-a-list-of-emacs-lisp-non-interactive-functions

related code that might allow us to find all functions defined in a file with some filtering, if we find where the functions are from.

#+BEGIN_SRC emacs-lisp
(find-lisp-object-file-name 'jmax-stringify-journal-name  'defun)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(flet ((first-line (text)
         (if text
             (substring text 0 (string-match "\n" text))
           "")))
  (mapatoms
   (lambda (x)
     (and (fboundp x)                          ; does x name a function?
          (not (commandp (symbol-function x))) ; is it non-interactive?
          (subrp (symbol-function x))          ; is it built-in?
          (insert (symbol-name x) " - " (first-line (documentation x)) "\n")))))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results drawer
(let ((r '()))
      (mapatoms
       (lambda (x)
	 (add-to-list 'r
		      (find-lisp-object-file-name x 'defun)))))
#+END_SRC

#+RESULTS:
:RESULTS:
nil
:END:

(documentation 'jmax-stringify-journal-name)

(describe-key)
(describe-function)



#+BEGIN_SRC emacs-lisp
(require 'bibtools)
(let ((funclist ()))
  (mapatoms
   (lambda (x)
     (when (and (fboundp x)                     ; does x name a function?
                (let ((f (symbol-file x)))
                  (and f (string= (file-name-base f) "jmax-bibtex"))))
       (push x funclist))))
  funclist)
#+END_SRC

#+RESULTS:
| jmax-replace-nonascii | jmax-stringify-journal-name | jmax-bibtex-next-entry | jmax-title-case-article | jmax-bibtex-generate-shorttitles | jmax-bibtex-mode-keys | jmax-bibtex-generate-longtitles | jmax-bibtex-previous-entry | jmax-sentence-case-article |


#+BEGIN_SRC emacs-lisp :results code
((find-file  "../../Dropbox/kitchingroup/jmax/jmax-bibtex.el")
(imenu-default-create-index-function))
;; (imenu-choose-buffer-index))
#+END_SRC

#+RESULTS:


http://stackoverflow.com/questions/26330363/how-do-i-get-a-list-of-functions-defined-in-an-emacs-lisp-file/26360946?iemail=1&noredirect=1#26360946

#+BEGIN_SRC emacs-lisp
(cdr (assoc "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el" load-history ))
#+END_SRC

#+RESULTS:
| jmax-bibtex-journal-abbreviations | (defun . jmax-bibtex-generate-longtitles) | (defun . jmax-bibtex-generate-shorttitles) | (defun . jmax-stringify-journal-name) | (defun . jmax-set-journal-string) | jmax-nonascii-latex-replacements | (defun . jmax-replace-nonascii) | jmax-lower-case-words | (defun . jmax-title-case-article) | (defun . jmax-sentence-case-article) | (defun . jmax-bibtex-next-entry) | (defun . jmax-bibtex-previous-entry) | (defun . jmax-bibtex-mode-keys) | (provide . jmax-bibtex) |
* cycle src blocks
  :PROPERTIES:
  :ID:       54FF3C7D-49A5-470A-924C-A59FBF0CD503
  :END:

#+BEGIN_SRC emacs-lisp
(save-restriction
  (org-narrow-to-subtree)
  (goto-char (point-min))
  (let ((case-fold-search t))
    (while (re-search-forward "#\\+BEGIN_SRC" nil t)
      (org-cycle))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(save-excursion
  (save-restriction
    (org-narrow-to-subtree)
    (goto-char (point-min))
    (org-element-map
	(org-element-parse-buffer)
	'src-block
      (lambda (element)
	(goto-char (org-element-property :begin element))
	(org-cycle)))))
#+END_SRC

#+RESULTS:


(remove-hook 'org-cycle-hook 'org-hide-block-all)


#+BEGIN_SRC emacs-lisp
(defun my-hide (state)
  (message "%s" state)
  (if (or (eq state 'children)
	  (eq state 'subtree))
      (save-restriction
	(org-narrow-to-subtree)
	(org-hide-block-all))))

(add-hook 'org-cycle-hook 'my-hide)
#+END_SRC

#+RESULTS:
| my-hide | org-cycle-hide-archived-subtrees | org-cycle-hide-drawers | org-cycle-hide-inline-tasks | org-cycle-show-empty-lines | org-optimize-window-after-visibility-change |

** code blocks
   :PROPERTIES:
   :ID:       B818E9C3-293E-4DEF-A526-24541274C6BB
   :END:

#+BEGIN_SRC python
print 'hello'
#+END_SRC

#+BEGIN_SRC sh
echo hello
#+END_SRC

#+BEGIN_SRC emacs-lisp
(format "hello")
#+END_SRC
#+RESULTS:

** another heading
   :PROPERTIES:
   :ID:       1BC81ECB-572F-46DE-9844-3638CEE814B8
   :END:
with test

* Using filters to redefine output
  :PROPERTIES:
  :ID:       A41969CD-7580-4211-BA8B-B6278B7A4BA9
  :END:

I have written about filters before, but admittedly, I have never fully grasped how to get all the information you need. For example, in [[http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][this post]] I came up with a convoluted method to preprocess an org-file to get a list of link properties, and then keep a running counter to access the nth property. Recently I saw this [[http://lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html][post]] on the org-mode mail list that made me think I have totally missed the boat on how to do this!

Here is the key point I have missed all along. You can apparently get the element associated with the text, and from that you can get any property of the element. Apparently, you find the next property change, and then get them. The element is stored sometimes as a text property.

file:bib1.bib

[[file:bib1.bib]]

[[./bib1.bib][bibliography]]


#+BEGIN_SRC emacs-lisp :results output
(defun ox-mrkup-filter-link (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (link (if beg (get-text-property beg :parent text))))
    (cond
     (link
      (princ (format "%s: %s\n\n\n" beg link (org-element-property :type link))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))
;; >     (cond ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "bib"))
;; >            (format "\\cite{%s}" (org-element-property :path link)))
;; >           ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "file")
;; >                 (string= (org-element-property :path link) "~/.bib.bib"))
;; >            (format "\\cite{%s}" (org-element-property :search-option link)))
;; >           (t text))))
(let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-html-export-as-html))
#+END_SRC


#+tblname: my-table
| 1 | 3 |
| 3 | 4 |

#+BEGIN_SRC emacs-lisp :results output
(defun ox-mrkup-filter-table (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (table (if beg (get-text-property beg :parent text))))
    (cond
     (table
      (princ (format "%s: %s\n\n\n" beg table (org-element-property :name table))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table)))
    (org-html-export-as-html))
#+END_SRC

#+RESULTS:
#+begin_example
198: (table-cell (:begin 2020 :end 2024 :contents-begin 2021 :contents-end 2022 :post-blank 0 :parent (table-row (:type standard :begin 2019 :end 2029 :contents-begin 2020 :contents-end 2028 :post-blank 0 :parent (table (:begin 1999 :end 2040 :type org :tblfm nil :contents-begin 2019 :contents-end 2039 :value nil :post-blank 1 :post-affiliated 2019 :name my-table :parent (section (:begin 38 :end 2530 :contents-begin 38 :contents-end 2523 :post-blank 7 :parent (headline (:raw-value Using filters to redefine output :begin 2 :end 2530 :pre-blank 1 :hiddenp nil :contents-begin 38 :contents-end 2523 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 7 :footnote-section-p nil :archivedp nil :commentedp nil :quotedp nil :CATEGORY blog :title (Using filters to redefine output) :parent (org-data nil #8)) #6)) (paragraph (:begin 38 :end 639 :contents-begin 38 :contents-end 638 :post-blank 1 :post-affiliated 38 :parent #6) I have written about filters before, but admittedly, I have never fully grasped how to get all the information you need. For example, in  (link (:type http :path //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ :raw-link http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ :application nil :search-option nil :begin 175 :end 288 :contents-begin 276 :contents-end 285 :post-blank 1 :parent #7) this post) I came up with a convoluted method to preprocess an org-file to get a list of link properties, and then keep a running counter to access the nth property. Recently I saw this  (link (:type http :path //lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html :raw-link http://lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html :application nil :search-option nil :begin 463 :end 543 :contents-begin 536 :contents-end 540 :post-blank 1 :parent #7) post) on the org-mode mail list that made me think I have totally missed the boat on how to do this!
) (paragraph (:begin 639 :end 895 :contents-begin 639 :contents-end 894 :post-blank 1 :post-affiliated 639 :parent #6) Here is the key point I have missed all along. You can apparently get the element associated with the text, and from that you can get any property of the element. Apparently, you find the next property change, and then get them. The element is stored in
) (paragraph (:begin 895 :end 910 :contents-begin 895 :contents-end 909 :post-blank 1 :post-affiliated 895 :parent #6) (link (:type file :path bib1.bib :raw-link file:bib1.bib :application nil :search-option nil :begin 895 :end 908 :contents-begin nil :contents-end nil :post-blank 0 :parent #7))
) (paragraph (:begin 910 :end 929 :contents-begin 910 :contents-end 928 :post-blank 1 :post-affiliated 910 :parent #6) (link (:type file :path bib1.bib :raw-link file:bib1.bib :application nil :search-option nil :begin 910 :end 927 :contents-begin nil :contents-end nil :post-blank 0 :parent #7))
) (paragraph (:begin 929 :end 960 :contents-begin 929 :contents-end 958 :post-blank 2 :post-affiliated 929 :parent #6) (link (:type file :path ./bib1.bib :raw-link ./bib1.bib :application nil :search-option nil :begin 929 :end 957 :contents-begin 943 :contents-end 955 :post-blank 0 :parent #7) bibliography)
) (src-block (:language emacs-lisp :switches nil :parameters nil :begin 960 :end 1999 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (defun ox-mrkup-filter-link (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (link (if beg (get-text-property beg :parent text))))
    (cond
     (link
      (princ (format "%s: %s\n\n\n" beg link (org-element-property :type link))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))
;; >     (cond ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "bib"))
;; >            (format "\\cite{%s}" (org-element-property :path link)))
;; >           ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "file")
;; >                 (string= (org-element-property :path link) "~/.bib.bib"))
;; >            (format "\\cite{%s}" (org-element-property :search-option link)))
;; >           (t text))))
(let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-html-export-as-html))
 :post-blank 2 :post-affiliated 960 :parent #6)) #4 (src-block (:language emacs-lisp :switches nil :parameters nil :begin 2040 :end 2495 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (defun ox-mrkup-filter-table (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (table (if beg (get-text-property beg :parent text))))
    (cond
     (table
      (princ (format "%s: %s\n\n\n" beg table (org-element-property :name table))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table)))
    (org-html-export-as-html))
 :post-blank 1 :post-affiliated 2040 :parent #6)) (fixed-width (:begin 2495 :end 2523 :value 198: nil


 :post-blank 0 :post-affiliated 2506 :results () :parent #6)))) #2 (table-row (:type standard :begin 2029 :end 2039 :contents-begin 2030 :contents-end 2038 :post-blank 0 :parent #4) (table-cell (:begin 2030 :end 2034 :contents-begin 2031 :contents-end 2032 :post-blank 0 :parent #5) 3) (table-cell (:begin 2034 :end 2038 :contents-begin 2035 :contents-end 2036 :post-blank 0 :parent #5) 4)))) #0 (table-cell (:begin 2024 :end 2028 :contents-begin 2025 :contents-end 2026 :post-blank 0 :parent #2) 3))) 1)


#+end_example








* redefining how images are displayed
  :PROPERTIES:
  :ID:       E4F07819-10C4-4929-BD7B-E62AC2728F3C
  :END:

#+BEGIN_SRC emacs-lisp
(defun org-display-inline-images (&optional include-linked refresh beg end)
  "Display inline images.
Normally only links without a description part are inlined, because this
is how it will work for export.  When INCLUDE-LINKED is set, also links
with a description part will be inlined.  This can be nice for a quick
look at those images, but it does not reflect what exported files will look
like.
When REFRESH is set, refresh existing images between BEG and END.
This will create new image displays only if necessary.
BEG and END default to the buffer boundaries."
  (interactive "P")
  (when (display-graphic-p)
    (unless refresh
      (org-remove-inline-images)
      (if (fboundp 'clear-image-cache) (clear-image-cache)))
    (save-excursion
      (save-restriction
	(widen)
	(setq beg (or beg (point-min)) end (or end (point-max)))
	(goto-char beg)
	(let ((re (concat "\\[\\[\\(\\(file:\\)\\|\\([./~]\\)\\)\\([^]\n]+?"
			  (substring (org-image-file-name-regexp) 0 -2)
			  "\\)\\]" (if include-linked "" "\\]")))
	      (case-fold-search t)
	      old file ov img type attrwidth width)
	  (while (re-search-forward re end t)
	    (setq old (get-char-property-and-overlay (match-beginning 1)
						     'org-image-overlay)
		  file (expand-file-name
			(concat (or (match-string 3) "") (match-string 4))))
	    (when (image-type-available-p 'imagemagick)
	      (setq attrwidth (if (or (listp org-image-actual-width)
				      (null org-image-actual-width))
				  (save-excursion
				    (save-match-data
				      (when (re-search-backward
;; I modified this regexp
					     "#\\+attr.*:width[ \t]+\\([0-9]+\\)\\(in\\|px\\|cm\\)"
					     (save-excursion
					       (re-search-backward "^[ \t]*$\\|\\`" nil t)) t)
;; and here, if we catch units, we fall back on org-image-actual-width
;; by setting attrwidth to nil
					(if (match-string 2) nil
					  (string-to-number (match-string 1)))))))
		    width (cond ((eq org-image-actual-width t) nil)
				((null org-image-actual-width) attrwidth)
				((numberp org-image-actual-width)
				 org-image-actual-width)
				((listp org-image-actual-width)
				 (or attrwidth (car org-image-actual-width))))
		    type (if width 'imagemagick)))
	    (when (file-exists-p file)
	      (if (and (car-safe old) refresh)
		  (image-refresh (overlay-get (cdr old) 'display))
		(setq img (save-match-data (create-image file type nil :width width)))
		(when img
		  (setq ov (make-overlay (match-beginning 0) (match-end 0)))
		  (overlay-put ov 'display img)
		  (overlay-put ov 'face 'default)
		  (overlay-put ov 'org-image-overlay t)
		  (overlay-put ov 'modification-hooks
			       (list 'org-display-inline-remove-overlay))
		  (push ov org-inline-image-overlays))))))))))
#+END_SRC

#+RESULTS:
: org-display-inline-images
:

#+attr_latex: :width 4in :placement [H]
#+ATTR_org: :width 200
[[./images/batch-multiple.png]]

elisp:org-display-inline-images
* Scripting git
  :PROPERTIES:
  :ID:       C365D05B-368B-4BC9-9436-DA4548164D4B
  :END:
I am running a project where I need to script git to "do the right thing" non-interactively. The project involves students creating assignments, and then turning them in. They create the assignments in Emacs+org-mode, and then "turn in" the assignment by running a menu command that commits their work to a git repository, and then pushes it to my server. Some emacs-lisp code does all this magic. Most of the time.

Occasionally, students have had trouble when it comes time to update their graded assignments. These assignments have been pulled from the server by me, graded, and pushed back. I did not anticipate that students would continue changing their local repos after turning the work in, and this causes issues when they try to pull the results back.

Here I document how to make this process a bit more robust. Basically, we need to make sure the local repo is clean before we pull, then we need to check if there were merge conflicts. Since the conflicts are probably notes the students took, we will be conservative and just accept the merge markers in the text so they do not lose their notes.

What we need to do is check the output of "git status --porcelain" and do an appropriate action for each file. The output of this command is one line per file that requires some action. Basically we can have untracked files, which should just be added and committed. The reason for this is that if I create a file with the same name, it will be a conflict for git to overwrite their existing file. There could be added or modified files, renamed files, deleted files  updated but unmerged, and some other possibilities too.

The "git status --porcelain" command gives a two letter status code for each file that is not "clean". The first letter is the status of the index, and the second letter is the status of the work-tree, unless there is a merge conflict, and then they are the status of the file on each side of the merge.

#+BEGIN_EXAMPLE
       o   ' ' = unmodified

       o    M = modified

       o    A = added

       o    D = deleted

       o    R = renamed

       o    C = copied

       o    U = updated but unmerged

       Ignored files are not listed, unless --ignored option is in effect, in
       which case XY are !!.

           X          Y     Meaning
           -------------------------------------------------
                     [MD]   not updated
           M        [ MD]   updated in index
           A        [ MD]   added to index
           D         [ M]   deleted from index
           R        [ MD]   renamed in index
           C        [ MD]   copied in index
           [MARC]           index and work tree matches
           [ MARC]     M    work tree changed since index
           [ MARC]     D    deleted in work tree
           -------------------------------------------------
           D           D    unmerged, both deleted
           A           U    unmerged, added by us
           U           D    unmerged, deleted by them
           U           A    unmerged, added by them
           D           U    unmerged, deleted by us
           A           A    unmerged, both added
           U           U    unmerged, both modified
           -------------------------------------------------
           ?           ?    untracked
           !           !    ignored
           -------------------------------------------------
#+END_EXAMPLE

The man page recommends we use the -z option for parsing which ends strings with a null character.
#+BEGIN_SRC sh :dir ~/Desktop/A
git status --porcelain
#+END_SRC

#+RESULTS:
: R  f1 -> f1-rname
:  D f2
: ?? f2-rname


It seems like we need to parse the porcelain command, get X, and Y, and depending on what those are, we have a set of cond statements to act appropriately.


Here is a function to parse a line of porcelain output.
#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results raw
(defun parse-line (line)
  (let* ((X (substring line 0 1))
	 (Y (substring line 1 2))
	 (PATHS (split-string (substring line 3)))
	 (PATH1 (nth 0 PATHS))
         ; for a rename there will be PATH1 -> PATH2
	 (PATH2 (if (= 3 (length PATHS)) (nth 2 PATHS) nil)))
    (list X Y PATH1 PATH2 line)))

(defun parse-git-status ()
 (interactive)
(loop for line in (split-string
		  (shell-command-to-string "git status --porcelain") "\n")
      when (not (string= "" line)) collect (parse-line line)))
#+END_SRC

Now we check out the results.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| R |   | f1       | f1-rname | R  f1 -> f1-rname |
|   | D | f2       | nil      | D f2              |
| ? | ? | f2-rname | nil      | ?? f2-rname       |

That function gives us a list of X, Y, FROM, and TO, and the original string.

Now, we can start building the logic to handle these. The goal of this block as after running, the repo is clean, and you can then pull into it.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results output
(let ((merge-p nil))
  (loop for (X Y FROM TO LINE) in (parse-git-status)
	do
	(cond
	 ;; untracked files get added and committed.
	 ((and (string= X "?")
	       (string= Y "?"))
	  (shell-command (format "git add %s" FROM))
	  (shell-command
	   (format "git commit %s \"adding %s.\""
		   FROM FROM)))

	 ;; user rename
	 ((and (string= X "R")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO)))

	 ;; rename and modify
	 ((and (string= X "R")
	       (string= Y "M"))
	  ;; commit the rename
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO))
	  (shell-command (format "git commit %s -m \"changes in %s\"" TO TO)))

	 ;; added file
	 ((and (string= X "A")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m  \"Adding %s\"" FROM FROM)))

	 ;; deleted file
	 ((and (string= X " ")
	       (string= Y "D"))
	  (shell-command (format "git commit %s -m \"Deleting %s\"" FROM FROM)))

	 ;; modified file
	 ((or (string= X "M")
	      (string= Y "M"))
          (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"changes in %s\"" FROM FROM)))

	 ;; merge conflict, we just add the file
	 ;; we do not commit here because you cannot partially commit.
	 ;; after the loop, we do the commit if merge-p is t
	 ((or (string= X "U")
	      (string= Y "U"))
	  (setq merge-p t)
	  (shell-command (format "git add %s" FROM)))

	 ;; catch everything else
	 (t
	  (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"%s\"" FROM LINE))
	  (message "%s not handled gracefully\n" LINE))))
  ;;
  (when merge-p
    (shell-command "git commit -m \"accepting merge\"")))
#+END_SRC
#+RESULTS:


#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| M |   | empty | nil | M  empty |



* Showing that Emacs is working
  :PROPERTIES:
  :ID:       1ACF368D-063D-4B68-8F60-641788314502
  :END:


#+name: my-code
#+BEGIN_SRC python
import numpy
print 5
#+END_SRC

#+RESULTS: my-code
: 5

#+RESULTS:
: 5

This does not work, because there is no way to update the reporter while the code block is running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (let ((pr (make-progress-reporter "Running")))
    ad-do-it
    (progress-reporter-done pr)))
#+END_SRC


Here we create a buffer that indicates what is running
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((code-block (org-element-property :name (org-element-at-point)))
        (LN (line-number-at-pos)))

    (split-window-below)
    (other-window 1)
    (switch-to-buffer "*My Babel*")
    (if code-block
	(insert (format "Running %s\n" code-block))
      (insert (format "Running block at line %s\n" LN)))
    (insert "Started at: " (current-time-string) "\n")
    (other-window 1)
    ad-do-it
    (kill-buffer "*My Babel*")
    (delete-other-windows)))
#+END_SRC

#+BEGIN_SRC python
import time
time.sleep(1)
print 5

# (set-face-attribute 'org-block-background nil :background "LightYellow1")
#+END_SRC

#+RESULTS:
: 5



Here we change the color of the codeblocks when they are running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (let ((bg (face-attribute 'org-block-background :background)))

    (set-face-attribute 'org-block-background nil :background "LightSteelBlue")
    (font-lock-default-fontify-region
     (org-element-property :begin (org-element-at-point))
     (org-element-property :end (org-element-at-point))
     nil)
    ad-do-it
    (set-face-attribute 'org-block-background nil :background bg)))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

Try using an overlay
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((ol (make-overlay (org-element-property :begin (org-element-at-point))
			  (org-element-property :end (org-element-at-point)))))

    (overlay-put ol 'face '(background-color . "blue"))
(message-box "t")
    ad-do-it

    (delete-overlay ol)))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

* Checking if processes are done
  :PROPERTIES:
  :ID:       C3733BD9-63C0-45E2-BB3B-CC0A0CFA0680
  :END:

#+BEGIN_SRC emacs-lisp
(setq my-process (start-process-shell-command "slp" "*sleep*" "sleep 30"))
#+END_SRC

#+RESULTS:
: #<process slp>

#+BEGIN_SRC emacs-lisp
(process-live-p my-process)
#+END_SRC

#+RESULTS:


Now we try for a set of processes.

#+BEGIN_SRC emacs-lisp
(setq my-processes
      (mapcar
       (lambda (x)
	 (start-process-shell-command "slp" "*sleep*"
				      (format "sleep %s" (random 10))))
       '(1 2)))
#+END_SRC

#+RESULTS:
| slp | slp<1> |

And now check if they are all done.

#+BEGIN_SRC emacs-lisp :results raw
(mapcar (lambda (process) (process-live-p process)) my-processes)
#+END_SRC

#+RESULTS:
((run open listen connect stop) (run open listen connect stop))

This will tell us if any process is still alive.

#+BEGIN_SRC emacs-lisp :results raw
(-any-p 'process-live-p  my-processes))
#+END_SRC

#+RESULTS:
nil
nil
t
t

* Insert a timestamp that is one week older than the last timestamp found
  :PROPERTIES:
  :ID:       A52424E1-CAAA-4919-B5B2-B0B339746BC6
  :END:
Someone on the maillist asked how to insert a new timestamp that is one week newer than the last timestamp found in the buffer. Here is an exploration of doing that.
** week 1 (<2014-08-25 Mon>)
   :PROPERTIES:
   :ID:       3D412312-F0D3-4D40-9100-337B5151EA89
   :END:

** week 2 (<2014-09-01 Mon 13:00>)
   :PROPERTIES:
   :ID:       B163818B-1407-4522-B814-09C87C5E0A3A
   :END:

** Getting the last timestamp
   :PROPERTIES:
   :ID:       3931C46E-902B-48E4-9378-27A711B7A7DA
   :END:

Here we assume that the last element from org-element-map is the last timestamp found. We get the raw value of that timestamp, insert it, and then use interactive commands to change the timestamp.
#+BEGIN_SRC emacs-lisp
(defun insert-ts+1w ()
  "Insert a timestamp at point that is one week later than the
last timestamp found in the buffer."
  (interactive)
  (let ((last-ts (car (last (org-element-map (org-element-parse-buffer) 'timestamp
			      (lambda (timestamp)
				(org-element-property :raw-value timestamp)))))))
    (insert last-ts)
    (backward-char 2)
    (org-timestamp-change +7 'day)
    ))
#+END_SRC


This is the result I got from running the command I wrote above. <2014-09-08 Mon 13:00>. It worked!
* insert pages in org-ref
  :PROPERTIES:
  :ID:       49FB7401-AB7D-4584-BEFB-5A943E992B2F
  :END:

if you use C-c C-l, you can use completion to enter the bibtex key, and then type the page in the description. That is handy if you do not need to search for the entry.

#+BEGIN_SRC emacs-lisp
(defun cite-with-pages (key page)
  (interactive
   (list
    (car (reftex-citation t))
    (read-from-minibuffer "page: ")))
  (insert (format "[[cite:%s][page %s]]" key page)))
#+END_SRC

[[cite:armiento-2014-high][page 34]]


bibliography:../../bibliography/references.bib

* Insert formatted text
  :PROPERTIES:
  :ID:       35AFEAFF-C02E-4F3E-9F36-04D7545419CE
  :END:
We can insert propertized strings, e.g. with different colors like this.
#+BEGIN_SRC emacs-lisp

(with-temp-buffer
  (rename-buffer "test")
  (insert "a "
	  (propertize "mail client"
		      'font-lock-face
		      '(:foreground "blue" :background "white" :underline t))
	  " b "
	  (propertize "smtp" 'font-lock-face '(:foreground "red"))
	  " "
	  (propertize "smtp" 'font-lock-face '(:foreground "forestgreen")))
  (goto-char (point-min))
  (display-buffer (current-buffer))
  (org-mode)
  ;; this just pauses long enough to see the results
  (completing-read "what? " '(1 2 3)))
#+END_SRC

#+RESULTS:

* Selectively writing out code blocks in org-mode
  :PROPERTIES:
  :ID:       C45682EC-D162-4D2D-BD49-128A1C68F7A3
  :END:

I have a set of notes for two software packages that contain code examples for each package. I want to selectively extract the code blocks. This post examines a way I could do that. I am going to "tag" each code block with a header. Apparently this is ok, and org-mode ignores the unknown header argument!

#+BEGIN_SRC python :tag package1
print "For use with package1"
#+END_SRC

#+RESULTS:
: For use with package1

#+BEGIN_SRC python :tag package2
print "For use with package2"
#+END_SRC

#+RESULTS:
: For use with package2

Apparently, the :tag header argument is stored in the :parameters property as a string.

#+BEGIN_SRC emacs-lisp :results raw
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element) (org-element-property :parameters element)))
#+END_SRC
#+RESULTS:
(:tag package1 :tag package2 :results raw)

So, we just need to map the source blocks, and perform some action on the ones matching the block we want. Here is one example.

#+BEGIN_SRC emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element)
    (let ((tag (org-element-property :parameters element)))
      (cond
       ((null tag) "no parameters")
       ((string-match ":tag\\s-*package1" tag)
	(format "match p1. code:\n%s" (org-element-property :value element)))
       ((string-match ":tag\\s-*package2" tag)
	(format "match p2. code:\n%s" (org-element-property :value element)))
       (t (format "\"%s\"" tag))))))
#+END_SRC

#+RESULTS:
| match p1. code:\nprint "For use with package1"\n | match p2. code:\nprint "For use with package2"\n | ":results raw" | no parameters |


* Write and read json in emacs
  :PROPERTIES:
  :ID:       9079EC35-567D-4317-8710-75896064F7B8
  :END:

If you know your data type, you can get a json representation like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/06-364.log"))))
  (json-encode-alist data))
#+END_SRC

#+RESULTS:
: {"org-course":"c:\/Users\/jkitchin\/Dropbox\/blogofile-jkitchin.github.com\/_blog\/06-364.log"}

You write a file like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "data.json"
  (let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")
		("06625" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com"))))
    (insert (json-encode-alist data))))
#+END_SRC

#+RESULTS:

Now to read it:

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdar (json-read-file "data.json"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com

We also need to conveniently set and change data. We can use setf for this. setf is a generalized version of setq that can take a "place" to set a value to. A "place" can be defined by a cdr, or car, for example. Here is a working example.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((data '(("org-course" . (("userid" . "jkitchin")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")))
	      ("06625" . (("userid" . "somestudent")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com")))))
      (course))
  (setq course (cdr (assoc "org-course" data))) ;; settings for a course

  (setf (cdr (assoc "root" course)) "blog")
data)

#+END_SRC

#+RESULTS:
((org-course (userid . jkitchin) (root . blog)) (06625 (userid . somestudent) (root . c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com)))




* org-rubric functions
  :PROPERTIES:
  :ID:       58B7D4EB-7B29-4B46-B372-B80C66AE0C2A
  :END:

prototype idea to create a rubric function

#+BEGIN_SRC emacs-lisp
(defun ta-rubric-hwk (technical-grade presentation-grade typography-grade)
  (interactive "nTechnical Grade: \nnPresentation Grade: \nnTypography Grade: ")
  (let
      ((t-weight 0.7) ; weight of technical grade
       (p-weight 0.2) ; weight of presentation grade
       (y-weight 0.1) ; weight of typography grade
       (grade))
    (setq grade (+
		 (* t-weight technical-grade)
		 (* p-weight presentation-grade)
		 (* y-weight typography-grade)))
    (end-of-buffer)
    (insert "\n"
	    (format "#+TECHNICAL_GRADE: %s\n" technical-grade)
	    (format "#+PRESENTATION_GRADE: %s\n" presentation-grade)
	    (format "#+TYPOGRAPHY_GRADE: %s\n" typography-grade)
	    (format "#+GRADE: %s" grade))))
#+END_SRC

#+RESULTS:
: ta-rubric-hwk

Maybe I can add a rubric keyword to assignments so that the right rubric function is called.
* Use org-agenda to select multiple items
  :PROPERTIES:
  :ID:       A9EDF4A8-87AC-4D48-BE41-BCB1193B0159
  :END:

This is a hacky way to use the org-contacts agenda to get multiple email addresses from a selection. We remap the return key function to call our function that maps over the selected list and gets the emails from it, and finally undoes the remapping before quitting the agenda. It feels a little hacky because you have to communicate through global variable, and the agenda call is not blocking, so the code carries on. I am not sure how to fix that.

#+BEGIN_SRC emacs-lisp
(defun get-marked ()
 (interactive)
 (setq *marked-entries*
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries)
       *done* t)
 ;; remap key
 (define-key org-agenda-mode-map [remap org-agenda-switch-to] nil)
 (org-agenda-quit))

(defun doit ()
  (interactive)
  (setq *marked-entries* nil
        *done* nil) ; make sure this is empty
  ;;remap so return exits and runs our function above
  (define-key org-agenda-mode-map [remap org-agenda-switch-to] 'get-marked)
  (org-contacts "kit")

  *marked-entries*)
#+END_SRC

This works ok. You can define a function that acts upon the marked entries.
#+BEGIN_SRC emacs-lisp
(defun email-marked ()
 (setq *marked-entries*
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries))
  (compose-mail)
  (message-goto-to)
  (insert (mapconcat 'identity *marked-entries* ",")))

  (org-contacts "kit")
#+END_SRC

* Completion in emacs commands using ido
  :PROPERTIES:
  :ID:       823C37DE-AFE5-4108-92BE-703553505631
  :END:

These are some examples of using ido to provide completion in interactive commands. You just need a list of options, which can be calculated if desired, and the ido-completing-read function. You use these in the interactive function.

** string completion
   :PROPERTIES:
   :ID:       9EBFC1E3-AEC1-48FF-9EE0-7C5E0B7D569C
   :END:

#+BEGIN_SRC emacs-lisp
(defun email-1 (address)
  (interactive
   (list
    (ido-completing-read
     "Email: "     ; prompt
     '("em1" "em2" "em3") ; choices
     nil ; predicate; ignored, here for compatibility with completing-read
     t ; require match
     )))
  (message "you picked %s" address))
#+END_SRC

#+RESULTS:
: email-1

It is pretty easy to get two arguments.
#+BEGIN_SRC emacs-lisp
(defun email-2 (address label)
  (interactive (list (ido-completing-read "Email: " '("em1" "em2" "em3"))
		     (ido-completing-read "label: " '("important" "easy"))))
  (message "you picked %s with a label of %s" address label))
#+END_SRC

#+RESULTS:
: email-2

** select directories
   :PROPERTIES:
   :ID:       17305BE7-6D33-4191-A41E-08F696C7CBD7
   :END:

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun pick-dir (dir)
  (interactive
   (list
    (ido-completing-read
     "Dir: "
     (remove-if-not
      'file-directory-p
      ;; list directories, except for . and ..
      (directory-files default-directory nil "[^.{1,2}]")))))
 (message "you picked this dir: %s" dir))

#+END_SRC

#+RESULTS:
: pick-dir




* get sha1 of a file
  :PROPERTIES:
  :ID:       620D907F-4AAF-4593-8907-812564C90A6E
  :END:

use this to make reproducible temp images for org-show.

(secure-hash 'sha1 (with-temp-buffer (insert-file-contents "tst.png") (buffer-string)))


* Running commands in emacs and showing what they do
  :PROPERTIES:
  :ID:       E5929B7C-7F38-472E-875A-B54ECCC1D57D
  :END:

I sometimes need to script shell commands into emacs functions. Recently, I needed to see the output, to see what was going wrong. This code sort of does that.

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "git status")
(eshell-send-input)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "ls")
(eshell-send-input)
(insert "echo $?")
(eshell-send-input)
#+END_SRC

#+RESULTS:

* Running git commands that are interactive
  :PROPERTIES:
  :ID:       3B13AF1C-DEFA-49A8-8277-EEA18348AA01
  :END:

** commands that freeze emacs because of ssh
   :PROPERTIES:
   :ID:       99BF86CF-0BF8-4407-B338-DCA473E45957
   :END:
Vanilla git calls vanilla ssh, which appears to hang anytime you get prompted for /anything/. The following all seems to hang, and you have to kill the ssh process to get control back.
#+BEGIN_SRC emacs-lisp
(shell-command "git clone bad@techela.cheme.cmu.edu:none")
#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(shell-command "git --no-pager clone bad@techela.cheme.cmu.edu:none")
#+END_SRC

#+RESULTS:
: 128

#+BEGIN_SRC emacs-lisp

(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none")

#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(with-timeout (1)
(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none"))

#+END_SRC


Let's try that in Python. This also freezes
#+BEGIN_SRC python
import subprocess
print subprocess.call(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], shell=True)
#+END_SRC

#+RESULTS:
: 128

** Solution, is ssh batch mode
   :PROPERTIES:
   :ID:       10C7934D-F836-439A-860C-4DEC786AA941
   :END:
The key is modifying the ssh command so that it runs in batch mode. You have to create a custom shell script that runs ssh in batch mode, then set GIT_SSH as an environment variable to use it.

Here is the working script.
#+BEGIN_SRC sh :tangle techela_ssh
#!/bin/sh
exec ssh -o "BatchMode yes" "$@"
#end
#+END_SRC

This will not hang.
#+BEGIN_SRC sh
./techela_ssh bad@techela.cheme.cmu.edu
#+END_SRC

#+RESULTS:

Running in sh
#+BEGIN_SRC sh
rm -fr none # rm old dir
GIT_SSH='c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh' git clone bad@techela.cheme.cmu.edu:none
#+END_SRC

#+RESULTS:


Running in Python
#+BEGIN_SRC python
import subprocess, os
my_env = os.environ.copy()
my_env['GIT_SSH'] = 'c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh'
p = subprocess.Popen(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], env=my_env)
print p.communicate()
#+END_SRC

#+RESULTS:
: (None, None)


And finally, running in emacs-lisp
#+BEGIN_SRC emacs-lisp
(let ((process-environment (cons "GIT_SSH=c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh" process-environment)))
  (shell-command-to-string "git clone bad@techela.cheme.cmu.edu:none"))
#+END_SRC

#+RESULTS:
: Cloning into 'none'...
: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
: fatal: Could not read from remote repository.
:
: Please make sure you have the correct access rights
: and the repository exists.

Finally, it appears I have a solution for this.





* Running the whole course through emacs and org-mode
  :PROPERTIES:
  :ID:       21450026-A6CC-4D59-8002-F0E829F17B0E
  :END:

I can write a command that retrieves a repo and opens it. and submits it to the server.

M-x oc-get label
This will check for label, and clone it if needed

#+BEGIN_SRC emacs-lisp
(defun oc-get (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
    (format "git clone gitolite@git-it.cheme.cmu.edu:%s" repo))))

(oc-get "hwk1")
#+END_SRC

#+RESULTS:
: git clone gitolite@git-it.cheme.cmu.edu:06-625-jkitchin-hwk1

We need to be able to update a repo. This will be tricky I think, because if students have made changes, this will not work without merges. It may be possible to commit their changes first, and then just deal with merges, but I think that will be confusing.

#+BEGIN_SRC emacs-lisp
(defun oc-update (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
   (oc-get label)) ;; first get it.

 (let (default-directory repo)
   (format "git pull"))))

#+END_SRC

M-x oc-turn-in

add everything in the directory,  commit it, and push the repo. It looks something like this:

#+BEGIN_SRC emacs-lisp
(defun oc-turn-in ()
  "Run this with the assignment open or in assignment directory"
  (interactive)
  ;; should check that we are in a git repo.

  (shell-command "git add *")
  (shell-command "git commit -am \"done\"")
  (shell-command "git push"))
#+END_SRC

What happens if students delete files?

see http://stackoverflow.com/questions/3258243/git-check-if-pull-needed for some ways to test if pull is needed.

* Getting system information and storing it in an org-mode Drawer
  :PROPERTIES:
  :ID:       128264F6-9883-4DC8-A711-88C1C1ED8755
  :END:



#+BEGIN_SRC emacs-lisp
(system-name)
#+END_SRC

#+RESULTS:
: KITCHINX61TABLE

#+BEGIN_SRC emacs-lisp
(princ system-configuration)
#+END_SRC

#+RESULTS:
: i386-mingw-nt6.1.7601


#+BEGIN_SRC emacs-lisp
(princ system-type)
#+END_SRC

#+RESULTS:
: windows-nt


#+BEGIN_SRC emacs-lisp
(shell-command-to-string ifconfig-program)
#+END_SRC

#+RESULTS:
#+begin_example

Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
#+end_example

System info function
#+BEGIN_SRC emacs-lisp
(defun insert-system-info-drawer ()
 (interactive)
 (end-of-buffer)
 (insert "\n\n")
 (org-insert-drawer nil "LOGBOOK")
 (insert (format "Name: %s\n" user-full-name))
 (insert (format "Email: %s\n" user-mail-address))
 (insert "System name: " (system-name))
 (insert (format "\n%s" system-type))
 (insert (shell-command-to-string ifconfig-program)))
#+END_SRC

#+RESULTS:
: insert-system-info-drawer
:

cite:armiento-2014-high

:LOGBOOK:
John Kitchin
jkitchin@andrew.cmu.edu
System name: KITCHINX61TABLEwindows-nt
Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

:END:

* Making a bunch of words invisible
  :PROPERTIES:
  :ID:       A4AE1CF7-053E-4800-9020-9A4AA39AB2C3
  :END:

(org-map-entries (lambda ()
                   (let ((level (org-entry-get (point) "level"))
                          (symbol-level))
                     (when level
                       (setq symbol-level (intern level))
                       (org-mark-subtree)
                       (overlay-put (make-overlay (point) (mark))
                                    'invisible
                                    symbol-level)
                       ;; make regions with symbol-level invisible
                       (add-to-invisibility-spec `(,symbol-level))))))
#+BEGIN_SRC emacs-lisp
(while (re-search-forward ":slide:" nil t)
(overlay-put (make-overlay (match-beginning 0) (match-end 0))
                                    'invisible
                                    'slide))

(add-to-invisibility-spec 'slide)
#+END_SRC
 :slide: in the text


Later when you want them back,

#+BEGIN_SRC emacs-lisp :results silent
(remove-from-invisibility-spec 'slide)
#+END_SRC

We also may want to have slide numbers, and an ability to jump to a slide.

Let us start by getting a list of slides. Our list will be cons cells with a slide number and marker. That will give us the

#+BEGIN_SRC emacs-lisp
(let ((slides '()) (n 0))
  (org-map-entries
   (lambda ()
     (when (string-match-p ":slide:" (or (nth 5 (org-heading-components)) ""))
       (setq n (+ n 1))
       (add-to-list 'slides (cons n (set-marker (make-marker) (point))) t))))
(goto-char (cdr (assoc 2 slides)))
slides)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1580 in blog.org>) | (2 . #<marker at 1603 in blog.org>) |

** subheading :slide:
   :PROPERTIES:
   :ID:       2B98C129-C9AB-4ADC-BF7A-F902C7190550
   :END:

** next one :slide:
   :PROPERTIES:
   :ID:       967BE800-5C02-4701-A21F-9DC06EA0130E
   :END:


* Inherited properties
  :PROPERTIES:
  :ID:       F0F90B9A-9CF2-495B-94F0-93115BA18AEC
  :END:
example of getting an inherited property, in this case an email address
** student 1
   :PROPERTIES:
   :ID:       B53FDB78-99C1-4207-8730-DAE0F46563D6
   :END:
*** lesson 1
    :PROPERTIES:
    :SENT-ON:  Sun Jun  8 20:43:16 2014
    :TO:       John Kitchin <jkitchin@andrew.cmu.edu>
    :ID:       29ECBC9B-1EEA-4A4B-91C4-040AA2E6B0B5
    :END:
we just turn on inheritance in the property get function.
#+BEGIN_SRC emacs-lisp
(org-entry-get (point) "TO" t)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1693 in blog.org>) | (2 . #<marker at 1716 in blog.org>) |

check out https://github.com/jwiegley/emacs-async/blob/master/async.el
for asynchronous things.

* Calculating months since a date
  :PROPERTIES:
  :ID:       D8D08670-D8D9-451E-A725-62EE2DD31387
  :END:

To calculate the number of months between two dates, we parse the dates to get the year for each date, and the month for each date. Then we calculate the number of months as:

\[12 * (year2 - year1) + (month2 - month1)\]

To get the year,

#+BEGIN_SRC emacs-lisp
(nth 5 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 2014

Now the month:
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 5

Note this subtlety
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat>")))
#+END_SRC

#+RESULTS:
: 2

It appears that since no time is specified, this gets parsed as the 28th of Feb? Maybe that is a limitation of the date format in Emacs?
#+BEGIN_SRC emacs-lisp
(decode-time (date-to-time "<2014-03-01 Sat>"))
#+END_SRC

#+RESULTS:
| 0 | 0 | 19 | 28 | 2 | 2014 | 5 | nil | -18000 |

We get the right value if we specify the time.

#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat 00:01>")))
#+END_SRC

#+RESULTS:
: 3

And now for the number of months between two times

#+BEGIN_SRC emacs-lisp
(let* ((d1  (decode-time (date-to-time "2014-03-01 00:01")))
       (d2 (decode-time (date-to-time "2014-05-31  00:01")))
       (y1 (nth 5 d1))
       (y2 (nth 5 d2))
       (m1 (nth 4 d1))
       (m2 (nth 4 d2)))
  (+ (* 12 (- y2 y1)) (- m2  m1)))
#+END_SRC

#+RESULTS:
: 2




* An org-table rubric
  :PROPERTIES:
  :ID:       6A28593E-E284-4B50-8562-AAEC47E2E774
  :END:
I had an idea to insert a table that represents a rubric into an org-file

The table would compute the overall grade.

|              | weight | Emerging (1,2) | Developing (3,4)   | Mastery (5,6)      | grade |
|--------------+--------+----------------+--------------------+--------------------+-------|
| content      |    0.1 | Text rambles   | articulate ideas   | clear and concise  |     1 |
| organization |    0.2 | unorganized    | not well organized | logical            |     2 |
| mechanics    |    0.3 | many errors    | a few per page     | no errors          |     4 |
| figures      |    0.1 | inappropriate  | flawed             | proper             |     5 |
| style        |    0.2 | inappropriate  | informal, jargon   | neat               |     6 |
| format       |    0.2 | not followed   | somewhat followed  | conforms to format |     7 |
|--------------+--------+----------------+--------------------+--------------------+-------|
|              |      0 |                |                    | Total              |       |
#+TBLFM: B2=vsum(@1..@5)


You would create the table in advance as a snippet, and you could insert it. Maybe the table would have a name.

* A pyparsing example
  :PROPERTIES:
  :ID:       F0D0EE3A-AE9B-4990-8CF5-58A626021516
  :END:
#+BEGIN_SRC python
#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolXXX class instances, which can then
# later be evaluated for their boolean value.
#
# Copyright 2006, by Paul McGuire
# Updated 2013-Sep-14 - improved Python 2/3 cross-compatibility
#
from pyparsing import operatorPrecedence, opAssoc, Keyword, Word, alphas

# define classes to be built at parse time, as each matching
# expression type is parsed
class BoolOperand(object):
    def __init__(self,t):
        self.label = t[0]
        self.value = eval(t[0])
    def __bool__(self):
        return self.value
    def __str__(self):
        return self.label
    __repr__ = __str__
    __nonzero__ = __bool__

class BoolBinOp(object):
    def __init__(self,t):
        self.args = t[0][0::2]
    def __str__(self):
        sep = " %s " % self.reprsymbol
        return "(" + sep.join(map(str,self.args)) + ")"
    def __bool__(self):
        return self.evalop(bool(a) for a in self.args)
    __nonzero__ = __bool__
    __repr__ = __str__

class BoolAnd(BoolBinOp):
    reprsymbol = '&'
    evalop = all

class BoolOr(BoolBinOp):
    reprsymbol = '|'
    evalop = any

class BoolNot(object):
    def __init__(self,t):
        self.arg = t[0][1]
    def __bool__(self):
        v = bool(self.arg)
        return not v
    def __str__(self):
        return "~" + str(self.arg)
    __repr__ = __str__
    __nonzero__ = __bool__

TRUE = Keyword("True")
FALSE = Keyword("False")
boolOperand = TRUE | FALSE | Word(alphas,max=1)
boolOperand.setParseAction(BoolOperand)

# define expression, based on expression operand and
# list of operations in precedence order
boolExpr = operatorPrecedence( boolOperand,
    [
    ("not", 1, opAssoc.RIGHT, BoolNot),
    ("and", 2, opAssoc.LEFT,  BoolAnd),
    ("or",  2, opAssoc.LEFT,  BoolOr),
    ])


if __name__ == "__main__":
    p = True
    q = False
    r = True
    tests = [("p", True),
             ("q", False),
             ("p and q", False),
             ("p and not q", True),
             ("not not p", True),
             ("not(p and q)", True),
             ("q or not p and r", False),
             ("q or not p or not r", False),
             ("q or not (p and r)", False),
             ("p or q or r", True),
             ("p or q or r and False", True),
             ("(p or q or r) and False", False),
            ]

    print("p =", p)
    print("q =", q)
    print("r =", r)
    print()
    for t,expected in tests:
        res = boolExpr.parseString(t)[0]
        success = "PASS" if bool(res) == expected else "FAIL"
        print (t,'\n', res, '=', bool(res),'\n', success, '\n')



#+END_SRC
#+RESULTS:
#+begin_example
('p =', True)
('q =', False)
('r =', True)
()
('p', '\n', p, '=', True, '\n', 'PASS', '\n')
('q', '\n', q, '=', False, '\n', 'PASS', '\n')
('p and q', '\n', (p & q), '=', False, '\n', 'PASS', '\n')
('p and not q', '\n', (p & ~q), '=', True, '\n', 'PASS', '\n')
('not not p', '\n', ~~p, '=', True, '\n', 'PASS', '\n')
('not(p and q)', '\n', ~(p & q), '=', True, '\n', 'PASS', '\n')
('q or not p and r', '\n', (q | (~p & r)), '=', False, '\n', 'PASS', '\n')
('q or not p or not r', '\n', (q | ~p | ~r), '=', False, '\n', 'PASS', '\n')
('q or not (p and r)', '\n', (q | ~(p & r)), '=', False, '\n', 'PASS', '\n')
('p or q or r', '\n', (p | q | r), '=', True, '\n', 'PASS', '\n')
('p or q or r and False', '\n', (p | q | (r & False)), '=', True, '\n', 'PASS', '\n')
('(p or q or r) and False', '\n', ((p | q | r) & False), '=', False, '\n', 'PASS', '\n')
#+end_example

* Advising org-ctrl-c-ctrl-c
  :PROPERTIES:
  :categories: org-mode,emacs
  :ID:       F733D961-5066-4050-B718-892FAAB95E61
  :END:
I use a lot of equations in org-mode, and I like to use the LaTeX overlays (C-c C-x C-l (org-preview-latex-fragment)). I also use a lot of code blocks in my org-documents, and I like to run them during lectures, which I do with C-c C-c. However, this also removes the overlays from my equations, causing two irritations: 1) the code did not run when I thought it would, and I have to press C-c C-c again, 2) the equations that the code implements disappears so then I have C-c C-x C-l to get them back.  A lot of extra key strokes. The issue is one line in org.el at line 20222: (org-remove-latex-fragment-image-overlays).

I have been thinking about how to change that behavior. I do not want to patch my org-mode, because I do not want to deal with future updates. The simplest idea is to just redefine that function in my init files, with the offending line commented out. Here it is.

#+BEGIN_SRC emacs-lisp
(defun org-ctrl-c-ctrl-c (&optional arg)
  "Set tags in headline, or update according to changed information at point.

This command does many different things, depending on context:

- If a function in `org-ctrl-c-ctrl-c-hook' recognizes this location,
  this is what we do.

- If the cursor is on a statistics cookie, update it.

- If the cursor is in a headline, prompt for tags and insert them
  into the current line, aligned to `org-tags-column'.  When called
  with prefix arg, realign all tags in the current buffer.

- If the cursor is in one of the special #+KEYWORD lines, this
  triggers scanning the buffer for these lines and updating the
  information.

- If the cursor is inside a table, realign the table.  This command
  works even if the automatic table editor has been turned off.

- If the cursor is on a #+TBLFM line, re-apply the formulas to
  the entire table.

- If the cursor is at a footnote reference or definition, jump to
  the corresponding definition or references, respectively.

- If the cursor is a the beginning of a dynamic block, update it.

- If the current buffer is a capture buffer, close note and file it.

- If the cursor is on a <<<target>>>, update radio targets and
  corresponding links in this buffer.

- If the cursor is on a numbered item in a plain list, renumber the
  ordered list.

- If the cursor is on a checkbox, toggle it.

- If the cursor is on a code block, evaluate it.  The variable
  `org-confirm-babel-evaluate' can be used to control prompting
  before code block evaluation, by default every code block
  evaluation requires confirmation.  Code block evaluation can be
  inhibited by setting `org-babel-no-eval-on-ctrl-c-ctrl-c'."
  (interactive "P")
  (cond
   ((or (and (boundp 'org-clock-overlays) org-clock-overlays)
	org-occur-highlights
	org-latex-fragment-image-overlays)
    (and (boundp 'org-clock-overlays) (org-clock-remove-overlays))
    (org-remove-occur-highlights)
    ;; commented out by jkitchin 2014-03-01 to avoid removing latex images
    ;; on running code blocks.
    ;(org-remove-latex-fragment-image-overlays)
    (message "Temporary highlights/overlays removed from current buffer"))
   ((and (local-variable-p 'org-finish-function (current-buffer))
	 (fboundp org-finish-function))
    (funcall org-finish-function))
   ((run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-hook))
   (t
    (let* ((context (org-element-context)) (type (org-element-type context)))
      ;; Test if point is within a blank line.
      (if (save-excursion (beginning-of-line) (looking-at "[ \t]*$"))
	  (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	      (user-error "C-c C-c can do nothing useful at this location"))
	(case type
	  ;; When at a link, act according to the parent instead.
	  (link (setq context (org-element-property :parent context))
		(setq type (org-element-type context)))
	  ;; Unsupported object types: check parent element instead.
	  ((bold code entity export-snippet inline-babel-call inline-src-block
		 italic latex-fragment line-break macro strike-through subscript
		 superscript underline verbatim)
	   (while (and (setq context (org-element-property :parent context))
		       (not (memq (setq type (org-element-type context))
				  '(paragraph verse-block table-cell)))))))
	;; For convenience: at the first line of a paragraph on the
	;; same line as an item, apply function on that item instead.
	(when (eq type 'paragraph)
	  (let ((parent (org-element-property :parent context)))
	    (when (and (eq (org-element-type parent) 'item)
		       (= (point-at-bol) (org-element-property :begin parent)))
	      (setq context parent type 'item))))
	;; Act according to type of element or object at point.
	(case type
	  (clock (org-clock-update-time-maybe))
	  (dynamic-block
	   (save-excursion
	     (goto-char (org-element-property :post-affiliated context))
	     (org-update-dblock)))
	  (footnote-definition
	   (goto-char (org-element-property :post-affiliated context))
	   (call-interactively 'org-footnote-action))
	  (footnote-reference (call-interactively 'org-footnote-action))
	  ((headline inlinetask)
	   (save-excursion (goto-char (org-element-property :begin context))
			   (call-interactively 'org-set-tags)))
	  (item
	   ;; At an item: a double C-u set checkbox to "[-]"
	   ;; unconditionally, whereas a single one will toggle its
	   ;; presence.  Without an universal argument, if the item
	   ;; has a checkbox, toggle it.  Otherwise repair the list.
	   (let* ((box (org-element-property :checkbox context))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (parents (org-list-parents-alist struct))
		  (prevs (org-list-prevs-alist struct))
		  (orderedp (org-not-nil (org-entry-get nil "ORDERED"))))
	     (org-list-set-checkbox
	      (org-element-property :begin context) struct
	      (cond ((equal arg '(16)) "[-]")
		    ((and (not box) (equal arg '(4))) "[ ]")
		    ((or (not box) (equal arg '(4))) nil)
		    ((eq box 'on) "[ ]")
		    (t "[X]")))
	     ;; Mimic `org-list-write-struct' but with grabbing
	     ;; a return value from `org-list-struct-fix-box'.
	     (org-list-struct-fix-ind struct parents 2)
	     (org-list-struct-fix-item-end struct)
	     (org-list-struct-fix-bul struct prevs)
	     (org-list-struct-fix-ind struct parents)
	     (let ((block-item
		    (org-list-struct-fix-box struct parents prevs orderedp)))
	       (if (and box (equal struct old-struct))
		   (if (equal arg '(16))
		       (message "Checkboxes already reset")
		     (user-error "Cannot toggle this checkbox: %s"
				 (if (eq box 'on)
				     "all subitems checked"
				   "unchecked subitems")))
		 (org-list-struct-apply-struct struct old-struct)
		 (org-update-checkbox-count-maybe))
	       (when block-item
		 (message "Checkboxes were removed due to empty box at line %d"
			  (org-current-line block-item))))))
	  (keyword
	   (let ((org-inhibit-startup-visibility-stuff t)
		 (org-startup-align-all-tables nil))
	     (when (boundp 'org-table-coordinate-overlays)
	       (mapc 'delete-overlay org-table-coordinate-overlays)
	       (setq org-table-coordinate-overlays nil))
	     (org-save-outline-visibility 'use-markers (org-mode-restart)))
	   (message "Local setup has been refreshed"))
	  (plain-list
	   ;; At a plain list, with a double C-u argument, set
	   ;; checkboxes of each item to "[-]", whereas a single one
	   ;; will toggle their presence according to the state of the
	   ;; first item in the list.  Without an argument, repair the
	   ;; list.
	   (let* ((begin (org-element-property :contents-begin context))
		  (beginm (move-marker (make-marker) begin))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (first-box (save-excursion
			       (goto-char begin)
			       (looking-at org-list-full-item-re)
			       (match-string-no-properties 3)))
		  (new-box (cond ((equal arg '(16)) "[-]")
				 ((equal arg '(4)) (unless first-box "[ ]"))
				 ((equal first-box "[X]") "[ ]")
				 (t "[X]"))))
	     (cond
	      (arg
	       (mapc (lambda (pos) (org-list-set-checkbox pos struct new-box))
		     (org-list-get-all-items
		      begin struct (org-list-prevs-alist struct))))
	      ((and first-box (eq (point) begin))
	       ;; For convenience, when point is at bol on the first
	       ;; item of the list and no argument is provided, simply
	       ;; toggle checkbox of that item, if any.
	       (org-list-set-checkbox begin struct new-box)))
	     (org-list-write-struct
	      struct (org-list-parents-alist struct) old-struct)
	     (org-update-checkbox-count-maybe)
	     (save-excursion (goto-char beginm) (org-list-send-list 'maybe))))
	  ((property-drawer node-property)
	   (call-interactively 'org-property-action))
	  ((radio-target target)
	   (call-interactively 'org-update-radio-target-regexp))
	  (statistics-cookie
	   (call-interactively 'org-update-statistics-cookies))
	  ((table table-cell table-row)
	   ;; At a table, recalculate every field and align it.  Also
	   ;; send the table if necessary.  If the table has
	   ;; a `table.el' type, just give up.  At a table row or
	   ;; cell, maybe recalculate line but always align table.
	   (if (eq (org-element-property :type context) 'table.el)
	       (message "Use C-c ' to edit table.el tables")
	     (let ((org-enable-table-editor t))
	       (if (or (eq type 'table)
		       ;; Check if point is at a TBLFM line.
		       (and (eq type 'table-row)
			    (= (point) (org-element-property :end context))))
		   (save-excursion
		     (if (org-at-TBLFM-p)
			 (progn (require 'org-table)
				(org-table-calc-current-TBLFM))
		       (goto-char (org-element-property :contents-begin context))
		       (org-call-with-arg 'org-table-recalculate (or arg t))
		       (orgtbl-send-table 'maybe)))
		 (org-table-maybe-eval-formula)
		 (cond (arg (call-interactively 'org-table-recalculate))
		       ((org-table-maybe-recalculate-line))
		       (t (org-table-align)))))))
	  (timestamp (org-timestamp-change 0 'day))
	  (otherwise
	   (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	       (user-error
		"C-c C-c can do nothing useful at this location")))))))))
#+END_SRC


$x^2$

* Making sure you have a notes entry for each bibtex entry
  :PROPERTIES:
  :ID:       25780E69-94D0-4C9E-AA22-E3FDA1A100E4
  :END:
As I mentioned [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf/][here]], I like to have a notes entry for each bibtex entry in an org-mode file. There are a couple of reasons for that:
1. I can tag the org-mode entries to help me find entries later
2. I can organize the org-mode entries by topic, including using links to entries when they belong in multiple places.
3. I can mark the entry as TODO to make it easy to find unfiled entries
4. I can keep typed notes in these entries.

It is usually part of my workflow to create these entries when I enter the bibtex entry, but occasionally I do not get to that. As part of the regular maintenance of my bibtex file, I like to find entries with no notes entry, and make them.

* TODO A gradebook app for emacs
  :PROPERTIES:
  :categories: emacs-lisp
  :ID:       8B78A517-C25E-4080-87B8-77892385B854
  :END:
The goal is to create an emacs library to compute grades from a table in org-mode.

All grades are stored in a table with this structure.

#+tblname: gradebook
| first name | last name | email       | Hwk 1 | Hwk2 | exam1 | project 1 |
|            |           |             | 10    | 10   | 60    | 20        |
|------------+-----------+-------------+-------+------+-------+-----------|
| Jane       | Doe       | jd@cmu.edu  | A     | A    | B     | B         |
| John       | Dillinger | jdi@cmu.edu | B     | B/C  | A     | C         |
| jill       | wutz      | jw@cmu.edu  | D     | D    | R     | R         |

The grading system works like this:

1. Each assignment is worth a certain number of points (in row2).
2. Each assignment for a student is given a letter grade that indicates the quality and correctness of the work.
3. Each letter grade corresponds to a point multiplier:

| A++ |  1.0 |
| A+  | 0.95 |
| A   |  0.9 |
| A-  | 0.85 |
| A/B |  0.8 |
| B+  | 0.75 |
| B   |  0.7 |
| B-  | 0.65 |
| C/B |  0.6 |
| C+  | 0.55 |
| C   |  0.5 |
| C-  | 0.45 |
| C/D |  0.4 |
| D+  | 0.35 |
| D   |  0.3 |
| D-  | 0.25 |
| D/R |  0.2 |
| R+  | 0.15 |
| R   |  0.1 |
| R-  | 0.05 |
| R-- |  0.0 |

4. The number of points earned for an assignment is the point multiplier for the letter grade times the number of points for that assignment.
5. The overall grade is computed as sum(multiplier*points)/sum(points).
6. The overall letter grade is determined by the fraction of overall points received, mapped back on to the letter grade scale.

For example, in the table above, Jane Doe's grade is:

#+BEGIN_SRC emacs-lisp :results value
(let* ((multipliers '(0.9 0.9 0.7 0.7))
       (points '(10 10 60 20))
       (earned-points (mapcar* (lambda (a b) (* a b)) multipliers points))
       (total-earned-points (apply '+ earned-points))
       (total-points (apply '+ points)))
  (/ total-earned-points total-points))
#+END_SRC
#+RESULTS:
: 0.74

Which corresponds to an overall grade of B.

The goal here is to write emacs-lisp code to compute the overall grade of each student and convert it to an overall letter grade and write a little report.

We start by defining a variable to hold the multipliers. We will use an association list. We will prefix every variable and function with =gb/= to indicate it is part of our gradebook code.

#+BEGIN_SRC emacs-lisp
(defvar gb/MULTIPLIERS
  '(("A++" . 1.0)
    ("A+"   . 0.95)
    ("A"    . 0.9)
    ("A-"   . 0.85)
    ("A/B"  . 0.8)
    ("B+"   . 0.75)
    ("B"    . 0.7)
    ("B-"   . 0.65)
    ("B/C"  . 0.6)
    ("C+"   . 0.55)
    ("C"    . 0.5)
    ("C-"   . 0.45)
    ("C/D"  . 0.4)
    ("D+"   . 0.35)
    ("D"    . 0.3)
    ("D-"   . 0.25)
    ("D/R"  . 0.2)
    ("R+"   . 0.15)
    ("R"    . 0.1)
    ("R-"   . 0.05)
    ("R--"  . 0.0))
  "Numeric multipliers for letter grades")
#+END_SRC

#+RESULTS:

Here are two examples of using the gb/MULTIPLIER variable. It is an association list, so the multipler we want is the =cdr= of what the letter is associated with. We take the =cdr= of the return value, which is the numeric multiplier

#+BEGIN_SRC emacs-lisp :results value
(cdr (assoc "A" gb/MULTIPLIERS))
#+END_SRC

#+RESULTS:
: 0.9

We are going to write a series of functions that will compute the overall grade for each student.

A function we will need is to move the cursor into the table. Here is a function that will do that. This function moves the cursor to the beginning of the buffer, searches forward to find a line starting with a #+tblname: "name", and then moves the cursor to the next line which is in the table.

#+BEGIN_SRC emacs-lisp
(defun gb/goto-table (tblname)
  "move cursor into the table labeled tblname"
  (interactive)
  (goto-char (point-min))
  (search-forward-regexp (format "^#\\+tblname:\s+%s" tblname))
  (next-line))
#+END_SRC

#+RESULTS:

We use the function to move the cursor into the table, and then extract all the contents out.  We wrap the function call inside =save-excursion= so that the cursor gets put back where we want it. In this snippet, we use the (org-table-to-lisp) function to convert the table to a lisp structure which we can do further analysis on.

#+BEGIN_SRC emacs-lisp :results value verbatim
;; http://orgmode.org/worg/org-api/org-table-api.html
(require 'org-table) ; needed for access to org-table api

(defun gb/get-gradebook-lisp ()
  (interactive)
  (save-excursion
    (gb/goto-table "gradebook")
    (org-table-to-lisp)))

(gb/get-gradebook-lisp)
#+END_SRC
#+RESULTS:
: (("first name" "last name" "email" "Hwk 1" "Hwk2" "exam1" "project 1") ("" "" "" "10" "10" "60" "20") hline ("Jane" "Doe" "jd@cmu.edu" "A" "A" "B" "B") ("John" "Dillinger" "jdi@cmu.edu" "B" "B/C" "A" "C") ("jill" "wutz" "jw@cmu.edu" "D" "D" "R" "R"))

This is handy. Now we can think about processing the lisp data. Let us get the assignment names, and point values and save them in variables. The assignment names are in the first row, and start in column 3.

#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row1 (car (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENTS (mapcar 'identity (nthcdr 3 row1))))

gb/ASSIGNMENTS
#+END_SRC

#+RESULTS:
: ("Hwk 1" "Hwk2" "exam1" "project 1")

And now the point values, and total points.
#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row2 (cadr (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENT-POINTS (mapcar 'string-to-number (nthcdr 3 row2)))
 (setq gb/TOTAL-POINTS (apply '+ gb/ASSIGNMENT-POINTS)))

(format "ASSIGNMENT-POINTS=%s TOTAL-POINTS=%s" gb/ASSIGNMENT-POINTS gb/TOTAL-POINTS)
#+END_SRC

#+RESULTS:
: "ASSIGNMENT-POINTS=(10 10 60 20) TOTAL-POINTS=100"

So far, so good. Now, we need to get the letter grades for each student, and turn them into point multipliers.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-multiplier (LG)
  "return numeric multiplier for a letter grade"
  (interactive)
  (cdr (assoc (upcase LG) gb/MULTIPLIERS)))

(defun gb/get-multipliers(LGS)
  "apply get-multiplier to a list of letter grades"
  (interactive)
  (mapcar 'gb/get-multiplier LGS))

(defun gb/get-all-student-multipliers ()
  (mapcar 'gb/get-multipliers
          (mapcar (lambda (x)
                    (nthcdr 3 x))
                  (cdddr (gb/get-gradebook-lisp)))))

(gb/get-all-student-multipliers)
#+END_SRC

#+RESULTS:
: ((0.9 0.9 0.7 0.7) (0.7 0.6 0.9 0.5) (0.3 0.3 0.1 0.1))


Finally, we need the product of each multiplier with the gb/ASSIGNMENT-POINTS. This needs some care; some grades may be nil, which we cannot multiply. For now we neglect this detail.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-earned-points (multipliers)
  (mapcar* (lambda (a  b) (* a b)) multipliers gb/ASSIGNMENT-POINTS))

(defun gb/get-all-earned-points ()
  "returns total points earned by each student"
  (mapcar 'gb/get-earned-points  (gb/get-all-student-multipliers)))

(gb/get-all-earned-points)
#+END_SRC

#+RESULTS:
: ((9.0 9.0 42.0 14.0) (7.0 6.0 54.0 10.0) (3.0 3.0 6.0 2.0))

Next, we need to sum all the points and divide by the total points to get the overall numeric grade.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-all-numeric-grades ()
(mapcar (lambda (x)
          (/ (apply '+ x) gb/TOTAL-POINTS))
          (gb/get-all-earned-points)))

(gb/get-all-numeric-grades)
#+END_SRC

#+RESULTS:
: (0.74 0.77 0.14)

And finally, convert the numeric grades to letter grades. This involves finding the highest letter grade multiplier that the overall grade is larger than.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-final-letter-grade (grade)
 (dolist (pair gb/MULTIPLIERS letter-grade)
   (if (< (cdr pair) grade)
       (progn
         (setq letter-grade (car pair))
         (return letter-grade)))))

(mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))
#+END_SRC

#+RESULTS:
: ("B" "B+" "R")

That looks good. Now, let's make a final report of the results.

#+BEGIN_SRC emacs-lisp :results value
(let ((emails (mapcar '(lambda (x) (nth 2 x)) (cdddr (gb/get-gradebook-lisp))))
      (first-names (mapcar '(lambda (x) (nth 0 x)) (cdddr (gb/get-gradebook-lisp))))
      (last-names (mapcar '(lambda (x) (nth 1 x)) (cdddr (gb/get-gradebook-lisp))))
      (final-grades (mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))))
(mapcar* (lambda (fn ln em fg)
           `(,fn ,ln ,em ,fg))
         first-names
         last-names
         emails
         final-grades))
#+END_SRC

#+RESULTS:
| Jane | Doe       | jd@cmu.edu  | B  |
| John | Dillinger | jdi@cmu.edu | B+ |
| jill | wutz      | jw@cmu.edu  | R  |

** Summary
   :PROPERTIES:
   :ID:       AC6BA076-46E7-4ED8-A470-4E7EBB1A7A3B
   :END:
This is a pretty functional bit of code for computing final grades of a fixed format gradebook. It is missing some features. For example, it would not work well if any grades are missing, or if the gradebook is incomplete.

* TODO Testing units
  :PROPERTIES:
  :ID:       559AA3AF-7BAD-4322-867B-D54223B377A4
  :END:
#+BEGIN_SRC python
from pycse.units import units

u = units()

a = 5 * u.kJ
print repr(a)

b = u.kJ**2# * (1.0 / u.kJ)
print repr(b)
c = (1.0 / u.kJ)
print repr(c)

print repr(b*c)
print a.AS((1.0 / u.kJ) * u.kJ**2)
#print a.as_units(u.m)

#print '{0:1.3e}'.format(a)
#print '{0:f kJ}'.format(a)
#+END_SRC

#+RESULTS:
: Unit(5000.0, exponents=[ 2 -2  1  0  0  0  0], label=kJ)
: Unit(1000000.0, exponents=[ 4 -4  2  0  0  0  0], label=kJ^2)
: Unit(0.001, exponents=[-2  2 -1  0  0  0  0], label=kJ^-1)
: Unit(1000.0, exponents=[ 2 -2  1  0  0  0  0], label=(kJ^2)*(kJ^-1))
: 5.0 * (kJ^-1)*(kJ^2)



#+BEGIN_SRC python
from pycse.units import *
from pycse.umath import quad


u = units()
k = 0.23 * 1 / u.min
Cao = 2 * u.mol / u.L
V = 1 * u.L

Nao = Cao * V

def integrand(Na):
    return 1 / (k * Na)

t, terr = quad(integrand, 0.5 * Nao, Nao)
print t
#+END_SRC

#+RESULTS:
: 180.821003624 * s

* TODO Overloading subclass methods
  :PROPERTIES:
  :ID:       B4B1E820-C629-4174-8EF7-6BFAF23F5F54
  :END:

#+BEGIN_SRC python
import numpy as np

class A(np.ndarray):

    def __new__(cls, input_array, label=None):
        # Input array is an already formed ndarray instance
        # We first cast to be our class type
        obj = np.asarray(input_array).view(cls)
        # add the new attribute to the created instance
        obj.label = label
        # Finally, we must return the newly created object:
        return obj

    def __array_finalize__(self, obj):
        if obj is None: return
        self.label = getattr(obj, 'label', None)

    def __array_wrap__(self, out_arr, context=None):
        return np.ndarray.__array_wrap__(self, out_arr, context)

    def __str__(self):
        return 'A({0}, label={1!s})'.format(np.array(self), self.label)


a = A(2)
print a

print a * 2
print np.float(2) * a
print np.float32(2) * a
print np.float64(2) * a
print np.__version__

#+END_SRC

#+RESULTS:
: A(2, label=None)
: A(4, label=None)
: A(4.0, label=None)
: A(4.0, label=None)
: 4.0
: 1.6.1
: 1.6.1
* TODO Testing out a new python units package
  :PROPERTIES:
  :categories: units
  :ID:       B306B21D-7C71-4A51-B51D-1C4577086D58
  :END:

#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()

distance = 1.0 * u.meter

dd = distance / (1*u.cm)
print 'dd = ',dd
print dd.magnitude, dd.dimensionality
print dd.to('dimensionless')
print
print 5 * dd * u.cm
print 'float = ',float(dd)
import numpy as np
print np.log(dd)


E = 10 * u.kJ/u.mol
R = 2 * u.cal/u.mol/u.K
T = 300 * u.K

print E/R/T
#+END_SRC

#+RESULTS:
: dd =  1.0 meter / centimeter
: 1.0 dimensionless

: 100.0 dimensionless
:
: 5.0 meter
: float =  100.0
: 4.60517018599
: 0.0166666666667 kilojoule / cal



#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()


from scipy.optimize import fsolve
Fa0 = 3.0                 # mol/min
Fa = Fa0 * (1.0 - 0.8)    # mol/min
G = Fa / Fa0

def objective(D):
    return 1 - G - D * G

Dsol, = fsolve(objective, 1.0)


nu = 1 * u.L / u.min
k = 0.34 * 1 / u.hr

# V = D * nu / k
print Dsol * nu / k   # this prints oddly because the units are not simplified
print (Dsol * nu / k).to(u.L)

#+END_SRC

#+RESULTS:
: 11.7647058824 hour * liter / minute
: 705.882352941 liter

* TODO erf and erfc for switching functions
  :PROPERTIES:
  :ID:       22CD3E93-9A7E-4520-9443-4B5BF9506678
  :END:
In a [[http://jkitchin.github.io/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions/][previous post]] I examined a way to switch between discontinuous functions smoothly using a sigmoid function. The [[http://en.wikipedia.org/wiki/Error_function][error function]] has similar properties to the sigmoid function we used previously, and the complementary error function (erfc) is defined as 1 - erf. So, these are two functions we could use to smoothly transition from one function to another.


#+BEGIN_SRC python
import numpy as np
from scipy.special import erf, erfc

xspan = np.linspace(-5, 5)

import matplotlib.pyplot as plt

plt.plot(xspan, 0.5 * (1 + erf(xspan)), xspan, 0.5 * erfc(xspan))
plt.legend(['erf', 'erfc'])
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
from scipy.special import erf, erfc

def fF_laminar(Re):
    return 16.0 / Re

def fF_turbulent_unvectorized(Re):
    # Nikuradse correlation for turbulent flow
    # 1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)
    # we have to solve this equation to get f
    def func(f):
        return 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    fguess = 0.01
    f, = fsolve(func, fguess)
    return f

# this enables us to pass vectors to the function and get vectors as
# solutions
fF_turbulent = np.vectorize(fF_turbulent_unvectorized)

# Now we plot the correlations.

Re1 = np.linspace(500, 3000)
f1 = fF_laminar(Re1)

Re2 = np.linspace(3000, 10000)
f2 = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label='laminar')
plt.plot(Re2, f2, label='turbulent')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()


def fanning_friction_factor(Re):
    alpha = 20
    f =  0.5 * erfc(alpha*(Re-3000))* fF_laminar(Re) + 0.5 * (1 + erf(alpha*(Re-3000))) * fF_turbulent(Re)
    return f

Re = np.linspace(500,10000);
f = fanning_friction_factor(Re);

# add data to figure 1
plt.figure(1)
plt.plot(Re,f, label='smooth transition')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
* TODO Penalizing digital assignments that are turned in late
  :PROPERTIES:
  :ID:       41B38A89-8D4E-462A-8E8B-1A2039BA80CE
  :END:

This semester I have experimented with using box.com to have students turn in assignments. The assignments often have deadlines. For homeworks, we were soft on this, and there was often time between the deadline and when assignments were "collected" for grading. As long as the assignments were available by the time we collected them, we gave students credit for the assignments. Still, some students turned in assignments after that, and we did not have a good strategy for dealing with that.

A new wrinkle came about when I started using box.com to give quizzes and exams. I learned how to make students collaborators on a folder for the duration of the quiz/exam, and then to turn off their ability to upload at the end of the quiz. The first time I ran this, students were unprepared for the amount of time it could take to upload, and a good fraction failed to turn in their quiz. They were /very/ unhappy. I tried modifying the approach to give them a visual timer, with a warning, and a buffer time to enable uploads. That helped, but some were still unable to upload in time. This puts you in an uncomfortable position of telling students they get no credit, or dealing with emails from them of their assignments after they are due, and then figuring out an appropriate penalty. The students are stressed out because they are worried about their grades, and they don't think it is fair. Even if they are deservedly so, worried, stressed out students aren't learning.

Now, I recognize these students should have turned it in when told to, and if this were a paper exam, there is a hard deadline of me walking out the door with the exams. Digitally turned in assignments do not have this kind of behavior. A way to reduce the overall stress around this is that rather than shutting off access to the upload, we should simply use an appropriate late penalty. That way, students get to turn in their work, which is psychologically less stressful, and they are appropriately penalized for being late.

Now, why is this difficult? It turns out it is not that easy to tell when a file is uploaded or modified on box.com. You can do it through the box.com api, but the timestamp comes in an unfamiliar form. Second, late is a difference in time.  The local time on a computer is not the same as the time on the box.com servers, so we cannot (or should not) use that difference to determine lateness.

#+BEGIN_SRC python
from box_course.box import *
import json

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

print json.dumps(jf, sort_keys=True, indent=4)
#+END_SRC

#+RESULTS:
#+begin_example
{
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
    "created_at": "2013-12-08T06:31:46-08:00",
    "created_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "description": "",
    "etag": "0",
    "id": "12178719122",
    "item_status": "active",
    "modified_at": "2013-12-08T06:31:47-08:00",
    "modified_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "name": "reference.txt",
    "owned_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "parent": {
        "etag": "0",
        "id": "1364917348",
        "name": "test",
        "sequence_id": "0",
        "type": "folder"
    },
    "path_collection": {
        "entries": [
            {
                "etag": null,
                "id": "0",
                "name": "All Files",
                "sequence_id": null,
                "type": "folder"
            },
            {
                "etag": "1",
                "id": "1328895168",
                "name": "group-course",
                "sequence_id": "1",
                "type": "folder"
            },
            {
                "etag": "0",
                "id": "1364917348",
                "name": "test",
                "sequence_id": "0",
                "type": "folder"
            }
        ],
        "total_count": 3
    },
    "purged_at": null,
    "sequence_id": "0",
    "sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "shared_link": null,
    "size": 0,
    "trashed_at": null,
    "type": "file"
}
#+end_example


I think the relevant information is:
#+BEGIN_EXAMPLE
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
#+END_EXAMPLE

These timestamps are described [[https://www.ietf.org/rfc/rfc3339.txt][here]]. These timestamps are related to utc time, and can be converted to local time like this:

#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

def utc_to_local(timestamp):
    utc = parser.parse(timestamp)
    to_zone = tz.gettz('America/New_York')
    return utc.astimezone(to_zone)

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

from dateutil import parser
dc = jf['content_created_at']
print utc_to_local(dc)
#+END_SRC

#+RESULTS:
: 2013-12-08 09:31:46-05:00

In fact, I did create that file around 9:31am on 12/8. The =-05:00= is related t the offset of our local time with utc.

Now, the key idea in calculating lateness is that I have a reference time on box.com now, by virtue of having created reference.txt at the beginning of the assignment. I created two assignment files, assignment1.txt and assignment2.txt that I uploaded about 30 seconds, and one minute after the reference.txt was created. Below, I calculate the amount of time elapsed between the reference file and assignment files.


#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
jf = get_file_information(j['id'])
t0 = jf['content_modified_at']

j1 = get_item('group-course/test/assignment1.txt')
jf1 = get_file_information(j1['id'])
t1 = jf1['content_modified_at']

j2 = get_item('group-course/test/assignment2.txt')
jf2 = get_file_information(j2['id'])
t2 = jf2['content_modified_at']

p2 = parser.parse(t2)
p1 = parser.parse(t1)
p0 = parser.parse(t0)

d1 = p1 - p0
d2 = p2 - p0

print d1.total_seconds()
print d2.total_seconds()
#+END_SRC

#+RESULTS:
: 25.0
: 63.0

So, now we have a quantitative way to measure lateness. It is not a speedy method, since you have to make several box.com api calls, but, we can say how late it is, and since we use a reference file created on box.com at the beginning of the assignment, we take out the local time issue. The reference file could be created at the end of the assignment to mark when it is done.

Now about the penalty function. This is arbitrary, but should be a function that decays from 100% credit to some lower level of credit that is appropriate. For a homework, you might choose 50% as a floor, with some hours of decay time, whereas for a quiz/exam, it should be minutes of decay time down to 0%. Linear decay is the simplest. Let us say we want the credit to go from 100% to 50% over a 5 minute span. It would look like this:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

@np.vectorize
def penalty(t):
    if t < (5 * 60):
        p = 1.0 - (1.0 - 0.5) / (5 * 60) * t
    else:
        p = 0.5
    return p

t = np.linspace(0, 600, 100)
p = penalty(t)

plt.plot(t, p)
plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-penalty.png')
#+END_SRC

#+RESULTS:

[[./images/example-penalty.png]]

There are many options for a smooth decrease. Let us examine this gaussian function. We define a function that decays in the normal distribution sense, and allows you to set upper and lower bounds. To go from 1.0 to 0.5 we use this code:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

def penalty(t, mu=0.0, sigma=5, ub=1.0, lb = 0.0):
    return (ub - lb) * np.exp(-(t-mu)**2 / (2 * sigma**2)) + lb

t = np.linspace(0, 30)
plt.plot(t, penalty(t, lb=0.5))

plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-gaussian-penalty.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/example-gaussian-penalty.png]]

You can see that after about 15 minutes (3 * sigma), the penalty will be


I think this would help reduce stress in the classroom, and make it more systematic to apply lateness penalties to assignments. I still have not worked out precisely how to integrate this into a grading workflow, since you need to run a script to get the penalties for each assignment, and then multiply the grade by it to get the penalized grade. You could grade normally, and have the script create a late file in the directory which is only used in calculating the overall grade.

* TODO Exporting LaTeX manuscripts from org-mode
  :PROPERTIES:
  :categories: org-mode
  :ID:       3FCC06F3-2CB3-4891-9A2E-030DA47708DC
  :END:
We have been using org-mode to write manuscripts for submission to journals for publication. Our typical workflow is writing in org-mode, and then using a custom export function to turn the document into LaTeX, and then compiling to pdf via pdflatex. This /mostly/ works great, except for the following two issues:

1. We use BibTex for references, and most journals want us to replace the \bibliography{} lines with the contents of the .bbl file so it is self-contained.
2. We use png files in the org file so they show up in emacs. However, most journals want eps files, and we have to manually remove the .png extension from the LaTeX file so it will build on the journal site (which does not use pdflatex).

I am exploring some code that would automate those things.

** Replacing the bibliography line
   :PROPERTIES:
   :ID:       719AD091-CC35-4059-9F15-39730BBA8CB1
   :END:
Starting with item one, we need to get the contents of the bbl file, and then replace the bibliography line with that. The .bbl file is typically named after the tex file, which is named after the org file. So, if the org-file is blog.org, the tex file would be blog.tex, and the corresponding bbl file would be blog.bbl.

#+BEGIN_SRC emacs-lisp
; derive bbl filename from org file
(concat (file-name-sans-extension (file-name-nondirectory (buffer-file-name))) ".bbl")
#+END_SRC

An alternative approach is to replace text using a regexp.
#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name)))
#+END_SRC

Now, we need a way to get the contents of the bbl file. This works:
#+BEGIN_SRC emacs-lisp
(let* ((bbl-file (replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name))))
       (contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string))))
  (princ contents))
#+END_SRC

#+RESULTS:
: You got the contents of blog.bbl!

Finally, we should replace the bibliography string in the tex file with the contents of the bbl file. This block seems to do that. I think as long as the bibliography line does not span more than one line, and that there is not more than one of them this should work fine.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (bbl-file (replace-regexp-in-string "org$" "bbl" org-file))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (bbl-contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string)))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string "\\\\bibliography{.*}" bbl-contents tex-contents))))
#+END_SRC

#+RESULTS:

A work flow here would be to run a code block that exports the org-file to LaTeX, then run the code block above to insert the bbl file.

** Removing the image extensions
   :PROPERTIES:
   :ID:       5F0F61BC-5C77-4BF0-87C3-81DA61D89814
   :END:
We put the .png extension in the figure links in org-mode so that org-mode will show the images in the buffer. That is convenient for writing. It is also fine if one uses pdflatex to compile the resulting LaTeX source. Some journals, however, use latex to build the document, and latex does not support png files; encapsulated postscript is preferrable for latex.

Luckily, you do not have to specify a file extension to latex, it will automatically look for the right extension (.eps for latex, .pdf or .png for pdflatex). So, we just need to strip the extension off of the image paths. Here is a regular expression and code block that seems to do this correctly.

#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"
 "\includegraphics{./images/test.png}


\\includegraphics{image/with/no/extension}
other latex

\\includegraphics[width=2in]{images/figure2.png}

\\includegraphics[width=3in]{./images/bulkmodulus-volume.png}
")
#+END_SRC

#+RESULTS:
: includegraphics{./images/test}
:
:
: \includegraphics{image/with/no/extension}
: other latex
:
: \includegraphics[width=2in]{images/figure2}
:
: \includegraphics[width=3in]{./images/bulkmodulus-volume}


We can combine this with the previous work on replacing the bibliography to replace all the extensions like this.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}\.].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"  tex-contents))))
#+END_SRC

#+RESULTS:

** Putting this together
   :PROPERTIES:
   :ID:       75DA1112-7532-4012-8BA1-718A1A977D16
   :END:
What we want to create is a function we could use to create the manuscript. There would be a function like this for different journals and/or publishers. For instance, APS journals use revtex, while ACS journals use achemso. There could be one publisher function that takes some options for the specific journal.

#+BEGIN_SRC emacs-lisp

#+END_SRC
* TODO textify html
  :PROPERTIES:
  :ID:       64D072FE-027F-43B6-8BAD-61DB6FB57A66
  :END:

#+BEGIN_EXAMPLE
	<title>Philip Herron: Cython Book</title>	<guid>http://redbrain.co.uk/?p=147</guid>	<link>http://redbrain.co.uk/cython-book/</link>		<description><p>Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. <a href="http://bit.ly/195ahQs">http://bit.ly/195ahQs</a></p> <p><a href="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"><img class="aligncenter size-full wp-image-148" alt="photo" src="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg" width="640" height="480" /></a>The code can be found: <a href="https://github.com/redbrain/cython-book">https://github.com/redbrain/cython-book</a></p></description>		<pubDate>Tue, 10 Dec 2013 14:45:08 +0000</pubDate>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun ph (start end) (interactive "r")
 (setq output (libxml-parse-html-region start end)))
#+END_SRC

(cdr '(a nil b))


#+BEGIN_SRC emacs-lisp :results output
(setq phtml
'(html nil
      (head nil
            (title nil "Philip Herron: Cython Book")
            (guid nil "http://redbrain.co.uk/?p=147")
            (link nil))
      (body nil
            (p nil "http://redbrain.co.uk/cython-book/		"
               (description nil
                            (p nil "Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. "
                               (a
                                ((href . "http://bit.ly/195ahQs"))
                                "http://bit.ly/195ahQs"))
                            " "
                            (p nil
                               (a
                                ((href . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"))
                                (img
                                 ((class . "aligncenter size-full wp-image-148")
                                  (alt . "photo")
                                  (src . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg")
                                  (width . "640")
                                  (height . "480"))))
                               "The code can be found: "
                               (a
                                ((href . "https://github.com/redbrain/cython-book"))
                                "https://github.com/redbrain/cython-book")))
               (pubdate nil "Tue, 10 Dec 2013 14:45:08 +0000")))))


;; (defun print-elements-recursively (list)
;;        "Print each element of LIST on a line of its own.
;;      Uses recursion."
;;        (when list                            ; do-again-test
;;              (print (car list))              ; body
;;              (if (listp (cdr list)) (print-elements-recursively (cdr list)))
;;              (print-elements-recursively     ; recursive call
;;               (cdr list))))                  ; next-step-expression

;(print-elements-recursively phtml)

(defun print-list (lst)
 (when lst
   (if (atom (car lst))
     (print (car lst)) (print-list (cdr lst)))))


(print-list phtml)
#+END_SRC

#+RESULTS:






** another approach
   :PROPERTIES:
   :ID:       F92D8984-7C25-4C1E-9265-DB66BE92E851
   :END:

<p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA"><img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img></a>
</div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
[[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>

(defun ph (r1 r2) (interactive "r") (setq html (buffer-substring r1 r2)))
#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1]]"  html)
#+END_SRC

#+RESULTS:
: <p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA]]
: </div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
: [[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>


http://www.mkyong.com/regular-expressions/how-to-extract-html-links-with-regular-expression/

these worked in re-builder (C-c C-w) then c-y to get them

"<p>\\(.+?\\)</p>" \\1 is the stuff between them


#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]"  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>")
#+END_SRC

#+RESULTS:
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]



(url-file-local-copy "http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA")

[[./tst.png]]


** downloading images
   :PROPERTIES:
   :ID:       95CB00C5-B241-468B-8C35-520DE77F2E3B
   :END:

#+BEGIN_SRC emacs-lisp :results raw
(defun download-src (arg)
  (format "[[%s][image]]" (save-match-data
                            (url-file-local-copy
                             (replace-regexp-in-string
                              "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"
                              "\\1"
                              arg)))))

(princ (replace-regexp-in-string "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>" #'download-src  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA">[[c:/Users/jkitchin/AppData/Local/Temp/url8408MBa][image]]</a>


** replacing <a>
   :PROPERTIES:
   :ID:       78686AEE-C3CA-41D0-9768-C87A04330D6C
   :END:
#+BEGIN_SRC emacs-lisp :results raw
(princ (replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]" "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
[[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]

** some regexs
   :PROPERTIES:
   :ID:       8051DF72-DC4F-4BDB-B636-F60FAA0C5CB8
   :END:
"<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>"  \\1 is the href \\2 is the target

"<img\\([^>]+\\)></img>"

"<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"  \\1 is the src
* TODO Email buffer after time out
  :PROPERTIES:
  :ID:       B5128720-00DC-4CDE-A1A9-472460BE36C8
  :END:

(timer-duration "0.5 min")


#+BEGIN_SRC emacs-lisp
(run-at-time 5 nil
             (lambda (args)
(princ "uuuu")
               (let ((body (buffer-string)))
                 (mail)
                 (mail-to)
                 (insert "jkitchin@andrew.cmu.edu")
                 (mail-subject)
                 (insert "exam")
                 (mail-text)
                 (insert body)
                 (mail-send-and-exit))))
#+END_SRC

#+RESULTS:


(run-at-time 5 nil
             (lambda (args) (insert "done")))

"09:40pm" 10

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defvar jao-totd-timer (run-at-time "12:00am" (* 30 1) 'totd))
(cancel-timer jao-totd-timer)


(defun jao-cancel-totd
  (interactive)
  (cancel-timer jao-totd-timer))

(defun td ()
  (interactive)
  (with-output-to-temp-buffer "*my-timer*"
  (insert "done")))

(defvar jao-totd-timer (run-at-time "12:00am" 1 'td))
(cancel-timer jao-totd-timer)




* Storing INCAR parameters in a yaml file
  :PROPERTIES:
  :ID:       D25800E4-1B2F-4838-BC2B-10E4E87FD373
  :END:

#+BEGIN_SRC python
import yaml
document = r'''
encut:
  type: float
  units: eV
  description:  "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$   The number of plane waves differs for each k-point, leading to a superior beahviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations." '''

print yaml.load(document)
#+END_SRC

#+RESULTS:


There doesn't appear to be an emacs yaml reader. This is a dead end for now. Also, it is not clear that yaml is flexible enough to contain the markup.

* Storing INCAR parameters in a json file
  :PROPERTIES:
  :ID:       4764BC3F-8476-4A1E-AD2B-E75455AC7692
  :END:

I am exploring a way to list all the INCAR parameters for VASP in a file format that would allow me to generate the list of keywords in Python /and/ provide documentation in Emacs. Right now these keywords exist in a set of lists in ase.calculators.vasp, with some comments that indicate what they are. However, the only way to access the comments is via the source code. There is no way to show them to the user via a help command. Furthermore, most of the keywords are built in VASP keywords, but some are ase specific. For the VASP keywords, one can search the internet for them, which often brings up the VASP documentation, but sometimes that is slow. For the ase keywords, which implement convenience, one has to read the source. It would be nice to avoid all these issues, and provide documentation that is accessible in an editor too, e.g. in Emacs.

Here we explore doing all of this in a json file. There are json parsers for python and emacs, so it seems possible.

Here is an example of what the json file might look like. The encut documentation is adapted from the VASP documentation

#+BEGIN_SRC text :tangle incar.json
{
    "ispin": {
        "description": "turn spin polarization on (2) or off (1)",
        "default": 1,
        "allowed_values": [
            1,
            2
        ],
        "units": null,
        "type": "int",
        "long_description": "The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. "
    },
    "encut": {
        "units": "eV",
        "type": "float",
        "description": "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. "
    }
}
#+END_SRC

Now, we parse it with Python.
#+BEGIN_SRC python
import json

with open('incar.json') as f:
    data = json.loads(f.read())

print data

print data.keys()
#+END_SRC

#+RESULTS:
: {u'ispin': {u'description': u'turn spin polarization on (2) or off (1)', u'default': 1, u'allowed_values': [1, 2], u'units': None, u'type': u'int', u'long_description': u'The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. '}, u'encut': {u'units': u'eV', u'type': u'float', u'description': u'Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. '}}
: [u'ispin', u'encut']

That is easy enough. We only have to remember that the strings are read in a unicode. It is similarly easy in Emacs.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(let ((my-json (json-read-from-string (with-temp-buffer
					(insert-file-contents "incar.json")
					(buffer-string)))))
  (princ my-json)
  (princ "\n")
  (princ (mapcar (lambda (x) (car x)) my-json)))
#+END_SRC

#+RESULTS:
: ((encut (description . Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$
:
: The number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. ) (type . float) (units . eV)) (ispin (long_description . The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. ) (type . int) (units) (allowed_values . [1 2]) (default . 1) (description . turn spin polarization on (2) or off (1))))
: (encut ispin)

This looks pretty promising. I could have a json file that describes the keywords, provides documentation of the keywords, etc... In python I would use that file to generate the lists that vasp.py uses for each type of keyword, and to provide help functions in python. I could also do that in Emacs too.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((my-json (json-read-from-string (with-temp-buffer
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc 'description (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help 'ispin))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

It might be confusing for a while that you use symbols instead of strings here. That is changeable with the json-object-type and json-key-type variable which can make them into strings. Here is an example.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((json-key-type 'string)
	 (my-json (json-read-from-string (with-temp-buffer
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc "description" (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help "ispin"))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

This seems like a promising approach to provide flexible documentation to the keywords.

* Set a headline to DONE
  CLOSED: [2014-01-27 Mon 13:50]
  :PROPERTIES:
  :ID:       7B16380E-AD69-45FE-AF31-19CE28C529E2
  :END:

#+BEGIN_SRC emacs-lisp
(org-narrow-to-subtree)
(goto-char (point-min)) ; beginning of buffer
(org-todo 'done)
(widen)
#+END_SRC

#+RESULTS:

* A widget based quiz in Emacs
  :PROPERTIES:
  :categories: emacs
  :ID:       F2A41EC3-8067-4145-BABD-A4BF562756EF
  :END:

I have been interested in making quizzes in Emacs. Quizzes that
students would take, and somehow submit. One issue with an org-mode
quiz is the totally free-form; everything can be edited. Enter the
[[https://www.gnu.org/software/emacs/manual/html_mono/widget.html][widget]] library in Emacs. Below is an illustrative example of making a
quiz, adapted from [[https://www.gnu.org/software/emacs/manual/html_mono/widget.html#Programming-Example][here]]. I also adapted some code from [[http://stackoverflow.com/questions/13590811/how-i-can-get-values-of-all-widgets-in-current-widget-minor-mode-buffer-in-emacs][here]] to get a
list of widgets in a buffer, how they are tagged, and their values.

#+BEGIN_SRC emacs-lisp
(require 'widget)

(eval-when-compile
  (require 'wid-edit))

(require 'cl)
(defun get-widgets ()
  "return a list of widget tags and values from the buffer"
  (mapcar (lambda (x)
	      `(,(widget-get x :tag) ,(widget-value x)))
	  (save-excursion
	    (goto-char (point-min))
	    (loop while (not (eobp))
		  for new = (widget-at)
		  and old = nil then new
		  when (and new (not (eq new old))) collect new
		  do (goto-char (next-overlay-change (point)))))))

(defun submit-quiz (&rest ignore)
  "email results from quiz"
  (interactive)
  (let ((widgets (get-widgets)))
    (mail)
    (mail-to)
    (insert "jkitchin@andrew.cmu.edu")
    (mail-subject)
    (insert "quiz1")
    (mail-text)
    (insert (format "%s" widgets))
;    (insert quiz)
    (mail-send-and-exit)))

(defun quiz1 ()
  "create a simple quiz"
  (interactive)
  (switch-to-buffer "*Quiz 1*")
  (kill-all-local-variables)
  (let ((inhibit-read-only t))
    (erase-buffer))
  (remove-overlays)
  (widget-insert "You will take a quiz.\n\n")
  (widget-create 'editable-field
		 :size 13
                 :tag "quiz1-name"
		 :format "Name: %v ")

  (widget-insert "\n\nCheck all true statements:\n")
  (widget-create 'checkbox :tag "p1-a" nil)
  (widget-insert " 2+2 = 4\n")
  (widget-create 'checkbox :tag "p1-b" nil)
  (widget-insert " 3*3=8\n")
  (widget-create 'checkbox :tag "p1-c" nil)
  (widget-insert " widgets are cool.\n")

  (widget-insert " \n\nSelect the best answer. \\sqrt{64} = \n\n")
  (widget-create 'radio-button-choice
		 :tag "p2" :value nil
		 '(item "2")
                 '(item "4")
		 '(item "8"))

  (widget-insert "\n\nWrite a long essay.\n")
  (widget-create 'editable-field
                  :format "Text: %v "
                  :tag "p3-essay"
                  :size 20)

  (widget-insert "\n")
  (widget-create 'push-button
		 :notify #'submit-quiz
		 "Submit")
  (widget-insert " ")
  (widget-create 'push-button
		 :notify (lambda (&rest ignore) (kill-buffer))
		 "Quit")

  (use-local-map widget-keymap)
  (widget-setup))
#+END_SRC

#+RESULTS:
: quiz1

Now, we just run [[elisp:(quiz1)]] and we get a "form" to fill out.

On my computer, I get this after I fill it out:

[[./images/quiz1.png]]


After I press submit, this gets emailed to me:

[[./images/quiz1-answers.png]]

It is obviously not perfect, since it did not capture the radio buttons in a useful way, and it collected the Submit and Quit buttons, since they are widgets. Those can probably all be fixed with better code, or maybe more specific code.

It is not too simple to write a quiz like this, but with some practice, and best practice development, it might be pretty straightforward after a while. The benefits are a more tightly controlled quiz environment. Submission may still be tricky, since at least in this case I rely on Emacs being setup for email. Other methods might work too, e.g. an http POST, or saving a file to a shared location.

See these links too:
- http://www.emacswiki.org/emacs/widget-demo.el

* Introspecting the variables in a python script
  :PROPERTIES:
  :ID:       3E933764-F79D-4AB1-8184-C5CC163ED585
  :END:

I want to build an emacs command that views an atoms, or prints a summary of a calculator in a code block. The idea is to get the python code in the block, run it in an interpreter, then view the atoms or print the calculator.

The reason I want to try this is that I often want a quick view of the atoms, but I do not want to import the module, write in the view line, and then comment them out.

#+BEGIN_SRC emacs-lisp
(defun get-source ()
  "mark region of source block"
  (interactive)
  (let ((case-fold-search nil)
	(start)
	(end))
    (re-search-backward "^#\\+BEGIN_SRC")
    (forward-line)
    (setq start (point))

    (re-search-forward "^#\\+END_SRC")
    (previous-line)
    (end-of-line)
    (setq end (point))
    ;(message-box "%s %s %s" start end (buffer-substring start end))
    (buffer-substring start end)))

(defun print-calculator ()
  "print any calculators found in *jasp-calculator*"
  (interactive)
  (python-shell-internal-send-string (concat (get-source) "\n"))

  (switch-to-buffer "*jasp-calculator*")
  (erase-buffer)
  (insert (python-shell-internal-send-string "
for k,v in globals().items():
    if isinstance(v, ase.calculators.vasp.Vasp):
        print v
")))

(defun view-atoms ()
  (interactive)
  "view any Atoms objects found"
  (python-shell-internal-send-string (concat (get-source) "\n"))
  (insert (python-shell-internal-send-string "
from ase.visualize import view

for k,v in globals().items():
    if isinstance(v, ase.atoms.Atoms):
        view(v)
")))

#+END_SRC

#+RESULTS:
: view-atoms

#+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

atoms = Atoms([Atom('O',[5, 5, 5], magmom=1)],
             cell=(6, 6, 6))

with jasp('O_sv',
          encut=300,
          xc='PBE',
          ispin=2,
          ismear=0,
          sigma=0.001,
          setups={'O':'_sv'}, # specifies O_sv potential
          atoms=atoms) as calc:
    print type(calc)
    print calc.__class__
    atoms.get_potential_energy()
#end
#+END_SRC

#+RESULTS:
: <type 'instance'>
: ase.calculators.vasp.Vasp
