* DONE 2015 in a nutshell for the Kitchin Research Group
  CLOSED: [2015-12-26 Sat 08:09]
  :PROPERTIES:
  :categories: news
  :date:     2015/12/26 08:09:25
  :updated:  2015/12/26 08:20:23
  :END:
2015 was a busy, productive year for the Kitchin Research group. Here are a few of the highlights!

** org-ref made it to Melpa
At long last org-ref has made it onto [[https://melpa.org/#/org-ref][Melpa]]! This makes it easy to install for many people. There are (as of this writing) 17 contributors to org-ref, with 677 commits to the [[https://github.com/jkitchin/org-ref][repo]]. Thanks everyone who has reported issues, feature requests, etc. With your help we will make this the best way to write technical papers there is!


** Student accomplishments
Congratulations to these students who completed their degrees! They do a lot of the hard work in the group, so also, many thanks to them!

Matt Curnan completed his PhD.

Siddharth Deshpande, Hari Thirumalai, Zhaofeng Chen, John Michael and Mehak Chawla completed their M.S. degrees.

Hari will be joining Lars Grabow at the University of Houston for a PhD program.

Nitish Govindarajan (MS 2014) will be leaving Bloom Energy to join the Van't Hoff Institute of Molecular Science (University of Amsterdam) to work on his PhD with funding from the Shell-Computational Sciences for Energy Research program.

Wenqin You (MS 2014) joined the PhD program in the Chemical Engineering Department at Georgia Tech.

John Michael has accepted a position with Eastern Research Group.

We already miss everyone who is leaving. Luckily, six new MS students are joining the group! Welcome to Chen Wang, Akshay Tharval, Teng Ma, Feiyang Geng, Devon Walker, and Tianyu Gao. We will also welcome a new PhD student Elif Erdinc who will be joining us in early 2016.

We also welcomed Kenate Nemera as a visiting Fulbright Scholar from Ethiopia to our group this past year.

** Publications

We had a great year in publications. We have 5 out for review now, so next year will probably be good too!

Here are this year's papers. These were all written in org-mode!

Metal oxide papers
- cite:xu-2015-tunin-oxide
- cite:xu-2015-relat
- cite:xu-2015-linear-respon
- cite:xu-2015-accur-u
- cite:curnan-2015-inves-energ

Oxygen evolution electrocatalysis:
- cite:michael-2015-alkal-elect

Data sharing papers:
- cite:kitchin-2015-examp
- cite:kitchin-2015-data-surfac-scien

Alloy catalysis/surface science papers:
- cite:boes-2015-estim-bulk
- cite:boes-2015-core-cu
- cite:thirumalai-2015-pt-pd

CO_{2} capture:
- cite:hallenbeck-2015-compar-co2

These were collaborative papers, they were not written in org-mode.
- cite:gumuslu-2015-correl-elect
- cite:watkins-2015

bibliography:~/Dropbox/bibliography/references.bib

Our citation count has continued to rise!

#+caption: Citation metrics for the Kitchin Research group.
[[./2015-citation-metrics.png]]

This remarkable paper cite:norskov-2004-origin has a total number of citations that exceeded 1000 this past year!

** Social media

We had about 94 blog posts this past year. Traffic to our blog did not grow much this year, but it is a little higher than last year.

#+caption: Web traffic to http://kitchingroup.cheme.cmu.edu for 2015.
[[./kitchingroup-traffic-2015.png]]

** Outlook for 2016
I am planning to continue promoting Emacs + org-mode for technical writing. org-ref is pretty good, and I expect to do mostly do some polishing on it. I will probably try to formalize ox-manuscript, which we use to create our scientific manuscripts. I will also try to formalize org-citeproc, which will let us use citations in non-LaTeX exports.

* DONE Exporting numbered citations in html with unsorted numbered bibliography
  CLOSED: [2014-05-17 Sat 14:42]
  :PROPERTIES:
  :categories: org-mode
  :date:     2015/12/03 15:53:08
  :updated:  2015/12/03 16:49:31
  :END:

In this [[http://kitchingroup.cheme.cmu.edu/blog/2014/05/17/Exporting-citations-in-html/][post]] we illustrated a simple export of org-ref citations to html. This was a simple export that simply replaced each citation with a hyperlink as defined in the export function for each type of link. Today we look at formatting in text citations with superscripted numbers, and having an unsorted (i.e. in order of citation) numbered bibliography. This will take one pass to get the citations and calculate replacements and the bibliography, and one pass to replace them and insert the bibliography.

This text is just some text with somewhat random citations in it for seeing it work. You might like my two data sharing articles cite:kitchin-2015-examp,kitchin-2015-data-surfac-scien. We illustrate the use of org-mode in publishing computational work cite:xu-2015-tunin-oxide,mehta-2014-ident-poten,curnan-2014-effec-concen, experimental cite:hallenbeck-2013-effec-o2 and mixed computational and experimental work cite:miller-2014-simul-temper,boes-2015-estim-bulk. This example will correctly number multiple references to a citation, e.g.  cite:kitchin-2015-examp and cite:kitchin-2015-data-surfac-scien.

This post is somewhat long, and the way I worked it out is at the end ([[id:1D63E1FB-55CD-48B7-B5E1-D0AC5E4D989B][Long appendix illustrating how we got the code to work]]). The short version is that we do some preprocessing to get the citations in the document, calculate replacement values for them and the bibliography, replace them in the org-buffer /before/ the export in the backend (html) format we want, and then conclude with the export. This is proof of concept work.

The main issues you can see are:
1. Our formatting code is very rudimentary, and relies on reftex. It is not as good as bibtex, or presumably some citation processor. Major improvements would require abandoning the reftex approach to use something that builds up the bibliography entry, allows modification of author names, and accomodates missing information gracefully.
2. The bibliography contents reflect the contents of my bibtex file, which is LaTeX compatible. We could clean it up more, by either post-processing to remove some things like escaped &, or by breaking compatibility with LaTeX.
3. The intext citations could use some fine tuning on spaces, e.g. to remove trailing spaces after words, or to move superscripts to the right of punctuation, or to adjust spaces after some citations.
4. Changing the bibliography style for each entry amounts to changing a variable for the bibliography. We have to modify a function to change the intext citation style, e.g. to brackets, or (author year).
5. I stuck with only cite links here, and only articles and books. It would not get a citenum format correct, e.g. it should not be superscripted in this case, or a citeauthor format correct. That would require some code in the replacement section that knows how to replace different types of citations.

The  org-ref-unsrt-html-processor function could be broken up more, and could take some parameters to fine-tune some of these things, and generalize some things like getting the citation elements for the buffer. Overall, I think this shows that citations in org-mode with org-ref are actually pretty flexible. It is not as good as bibtex/LaTeX, and won't be for an unforseeably long time unless someone really needs high quality citations in a format other than LaTeX. Note for LaTeX export, we don't have to do any preprocessing at all. If you wanted to try Word export, you might make a pandoc processor that replaces everything in pandoc citation syntax, and then use pandoc for the conversion. If you didn't care to use the bibtex database for anything else, you could just use backend specific markup to make it exactly right for your output. I did this in reference cite:boes-2015-estim-bulk where you can see the chemical formulas are properly subscripted.

If you would like to see the bibtex file used for this you can get it here: [[./numbered.bib]]

bibliographystyle:unsrt

bibliography:~/numbered.bib

** The working code
Here is a function to process the org file prior parsing during the export process. This function goes into org-export-before-parsing-hook, and takes one argument, the backend. We simply replace all the citation links with formatted HTML snippets or blocks. If the snippets get longer than a line, it will break.

We use org-ref-reftex-format-citation to generate the bibliography, which uses reftex to format a string with escape characters in it.

#+BEGIN_SRC emacs-lisp
(setq org-ref-bibliography-entry-format
      '(("article" . "<li><a name=\"\%k\"></a>%a, %t, <i>%j</i>, <b>%v(%n)</b>, %p (%y). <a href=\"%U\">link</a>. <a href=\"http://dx.doi.org/%D\">doi</a>.</li>")
	("book" . "<li><a name=\"\%k\"></a>%a, %t, %u (%y).</li>")))

(defun org-ref-unsrt-latex-processor () nil)
(defun org-ref-unsrt-html-processor ()
  "Citation processor function for the unsrt style with html output."
  (let (links
	unique-keys numbered-keys
	replacements
	bibliography-link
	bibliographystyle-link
        bibliography)
    ;; step 1 - get the citation links
    (setq links (loop for link in (org-element-map
				      (org-element-parse-buffer) 'link 'identity)
		      if (-contains?
			  org-ref-cite-types
			  (org-element-property :type link))
		      collect link))

    ;; list of unique numbered keys. '((key number))
    (setq unique-keys (loop for i from 1
			    for key in (org-ref-get-bibtex-keys)
			    collect (list key (number-to-string i))))


    ;; (start end replacement-text)
    (setq replacements
	  (loop for link in links
		collect
		(let ((path (org-element-property :path link)))
		  (loop for (key number) in unique-keys
			do
			(setq
			 path
			 (replace-regexp-in-string
			  key (format "<a href=\"#%s\">%s</a>" key number)
			  path)))
		  (list (org-element-property :begin link)
			(org-element-property :end link)
			(format "@@html:<sup>%s</sup>@@" path)))))

    ;; construct the bibliography string
    (setq bibliography
	  (concat "#+begin_html
<h1>Bibliography</h1><ol>"
		  (mapconcat
		   'identity
		   (loop for (key number) in unique-keys
			 collect
			 (let* ((result (org-ref-get-bibtex-key-and-file key))
				(bibfile (cdr result))
				(entry (save-excursion
					 (with-temp-buffer
					   (insert-file-contents bibfile)
					   (bibtex-set-dialect
					    (parsebib-find-bibtex-dialect) t)
					   (bibtex-search-entry key)
					   (bibtex-parse-entry t)))))
			   ;; remove escaped & in the strings
			   (replace-regexp-in-string "\\\\&" "&"
					   (org-ref-reftex-format-citation
					    entry
					    (cdr (assoc (cdr (assoc "=type=" entry))
							org-ref-bibliography-entry-format))))))
		   "")
		  "</ol>
,#+end_html"))

    ;; now, we need to replace each citation. We do that in reverse order so the
    ;; positions do not change.
    (loop for (start end replacement) in (reverse replacements)
	  do
	  (setf (buffer-substring start end) replacement))

    ;; Eliminate bibliography style links
    (loop for link in (org-element-map
			  (org-element-parse-buffer) 'link 'identity)
	  if (string= "bibliographystyle"
		      (org-element-property :type link))
	  do
	  (setf (buffer-substring (org-element-property :begin link)
				  (org-element-property :end link))
		""))

    ;; replace the bibliography link with the bibliography text
    (setq bibliography-link (loop for link in (org-element-map
						  (org-element-parse-buffer) 'link 'identity)
				  if (string= "bibliography"
					      (org-element-property :type link))
				  collect link))
    (if (> (length bibliography-link) 1)
	(error "Only one bibliography link allowed"))

    (setq bibliography-link (car bibliography-link))
    (setf (buffer-substring (org-element-property :begin bibliography-link)
			    (org-element-property :end bibliography-link))
	  bibliography)))


(defun org-ref-citation-processor (backend)
  "Figure out what to call and call it"
  (let (bibliographystyle)
    (setq
     bibliographystyle
     (org-element-property
      :path (car
	     (loop for link in
		   (org-element-map
		       (org-element-parse-buffer) 'link 'identity)
		   if (string= "bibliographystyle"
			       (org-element-property :type link))
		   collect link))))
    (funcall (intern (format "org-ref-%s-%s-processor" bibliographystyle backend)))))

(add-hook 'org-export-before-parsing-hook 'org-ref-citation-processor)

(browse-url (org-html-export-to-html))
#+END_SRC

#+RESULTS:
: #<process open ./blog.html>


** Long appendix illustrating how we got the code to work
   :PROPERTIES:
   :ID:       1D63E1FB-55CD-48B7-B5E1-D0AC5E4D989B
   :END:
The first thing we need is a list of all the citation links, in the order cited. Here they are.

#+BEGIN_SRC emacs-lisp
(mapcar
 (lambda (link) (org-element-property :path link))
 (loop for link in (org-element-map (org-element-parse-buffer) 'link 'identity)
       if (-contains? org-ref-cite-types (org-element-property :type link))
       collect link))
#+END_SRC
#+RESULTS:
| kitchin-2015-examp,kitchin-2015-data-surfac-scien | xu-2015-tunin-oxide,mehta-2014-ident-poten,curnan-2014-effec-concen | hallenbeck-2013-effec-o2 | miller-2014-simul-temper,boes-2015-estim-bulk | kitchin-2015-examp | kitchin-2015-data-surfac-scien | boes-2015-estim-bulk |

Now, we need to compute replacements for each citation link, and construct the bibliography. We will make a numbered, unsorted bibliography, and we want to replace each citation with the corresponding numbers, hyperlinked to the entry.

We start with a list of the keys in the order cited, and a number we will use for each one.

#+BEGIN_SRC emacs-lisp
(loop for i from 1
      for key in (org-ref-get-bibtex-keys)
      collect (list key i))
#+END_SRC

#+RESULTS:
| kitchin-2015-examp             | 1 |
| kitchin-2015-data-surfac-scien | 2 |
| xu-2015-tunin-oxide            | 3 |
| mehta-2014-ident-poten         | 4 |
| curnan-2014-effec-concen       | 5 |
| hallenbeck-2013-effec-o2       | 6 |
| miller-2014-simul-temper       | 7 |
| boes-2015-estim-bulk           | 8 |

Now, we need to compute replacements for each cite link. This will be replacing each key with the number above. We will return a list of ((start end) . "replacement text") that we can use to replace each link. For fun, we make these superscripted html.

#+BEGIN_SRC emacs-lisp
(let ((links (loop for link in (org-element-map (org-element-parse-buffer) 'link 'identity)
		   if (-contains? org-ref-cite-types (org-element-property :type link))
		   collect link))
      (replacements (loop for i from 1
			  for key in (org-ref-get-bibtex-keys)
			  collect (list key (number-to-string i)))))
  (loop for link in links
	collect (let ((path (org-element-property :path link)))
		  (dolist (repl replacements)
		    (setq path (replace-regexp-in-string (car repl) (nth 1 repl) path)))
		  (list (org-element-property :begin link)
			(org-element-property :end link)
			(format "<sup>%s</sup>" path)))))
#+END_SRC

#+RESULTS:
|  950 | 1004 | <sup>1,2</sup>   |
| 1073 | 1145 | <sup>3,4,5</sup> |
| 1160 | 1190 | <sup>6</sup>     |
| 1236 | 1286 | <sup>7,8</sup>   |
| 1364 | 1388 | <sup>1</sup>     |
| 1392 | 1427 | <sup>2</sup>     |
| 4091 | 4117 | <sup>8</sup>     |

We also need to compute the bibliography for each key. We will use org-ref-reftex-format-citation to do this. For that we need the parsed bibtex entries, and a format string. org-ref provides most of this.

#+BEGIN_SRC emacs-lisp :results html
(setq org-ref-bibliography-entry-format
      '(("article" . "<li>%a, %t, <i>%j</i>, <b>%v(%n)</b>, %p (%y). <a href=\"%U\">link</a>. <a href=\"http://dx.doi.org/%D\">doi</a>.</li>")
	("book" . "<li>%a, %t, %u (%y).</li>")))

(concat "<h1>Bibliography</h1><br><ol>"
	(mapconcat
	 'identity
	 (loop for key in (org-ref-get-bibtex-keys)
	       collect
	       (let* ((result (org-ref-get-bibtex-key-and-file key))
		      (bibfile (cdr result))
		      (entry (save-excursion
			       (with-temp-buffer
				 (insert-file-contents bibfile)
				 (bibtex-set-dialect (parsebib-find-bibtex-dialect) t)
				 (bibtex-search-entry key)
				 (bibtex-parse-entry)))))
		 (org-ref-reftex-format-citation
		  entry
		  (cdr (assoc (cdr (assoc "=type=" entry))
			      org-ref-bibliography-entry-format)))))
	 "")
	"</ol>")
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<h1>Bibliography</h1><br><ol><li>Kitchin, Examples of Effective Data Sharing in Scientific Publishing, <i>{ACS Catalysis}</i>, <b>5(6)</b>, 3894-3899 (2015). <a href=" http://dx.doi.org/10.1021/acscatal.5b00538 ">link</a>. <a href="http://dx.doi.org/10.1021/acscatal.5b00538">doi</a>.</li><li>"John Kitchin", Data Sharing in Surface Science, <i>"Surface Science "</i>, <b>(0)</b>,  -  (2015). <a href="http://www.sciencedirect.com/science/article/pii/S0039602815001326">link</a>. <a href="http://dx.doi.org/10.1016/j.susc.2015.05.007">doi</a>.</li><li>Zhongnan Xu \& John R Kitchin, Tuning Oxide Activity Through Modification of the Crystal and  Electronic Structure: From Strain To Potential Polymorphs, <i>{Phys. Chem. Chem. Phys.}</i>, <b>17()</b>, 28943-28949 (2015). <a href="http://dx.doi.org/10.1039/C5CP04840K">link</a>. <a href="http://dx.doi.org/10.1039/c5cp04840k">doi</a>.</li><li>Prateek Mehta, Paul Salvador \& John Kitchin, Identifying Potential BO2 Oxide Polymorphs for Epitaxial  Growth Candidates, <i>{ACS Appl. Mater. Interfaces}</i>, <b>6(5)</b>, 3630-3639 (2014). <a href="http://dx.doi.org/10.1021/am4059149">link</a>. <a href="http://dx.doi.org/10.1021/am4059149">doi</a>.</li><li>Curnan \& Kitchin, Effects of Concentration, Crystal Structure, Magnetism, and  Electronic Structure Method on First-Principles Oxygen Vacancy  Formation Energy Trends in Perovskites, <i>{The Journal of Physical Chemistry C}</i>, <b>118(49)</b>, 28776-28790 (2014). <a href="http://dx.doi.org/10.1021/jp507957n">link</a>. <a href="http://dx.doi.org/10.1021/jp507957n">doi</a>.</li><li>"Hallenbeck \& Kitchin, Effects of O2 and SO2 on the Capture Capacity of a  Primary-Amine Based Polymeric CO2 Sorbent, <i>"Industrial \& Engineering Chemistry Research"</i>, <b>52(31)</b>, 10788-10794 (2013). <a href="http://pubs.acs.org/doi/abs/10.1021/ie400582a">link</a>. <a href="http://dx.doi.org/10.1021/ie400582a">doi</a>.</li><li>Spencer Miller, Vladimir Pushkarev, Andrew, Gellman \& John Kitchin, Simulating Temperature Programmed Desorption of Oxygen on  Pt(111) Using DFT Derived Coverage Dependent Desorption  Barriers, <i>{Topics in Catalysis}</i>, <b>57(1-4)</b>, 106-117 (2014). <a href="http://dx.doi.org/10.1007/s11244-013-0166-3">link</a>. <a href="http://dx.doi.org/10.1007/s11244-013-0166-3">doi</a>.</li><li>Jacob Boes, Gamze Gumuslu, James Miller, Andrew, Gellman \& John Kitchin, Estimating Bulk-Composition-Dependent H<sub>2</sub> Adsorption Energies  on Cu<sub>x</sub>Pd<sub>1-x</sub> Alloy (111) Surfaces, <i>{ACS Catalysis}</i>, <b>5()</b>, 1020-1026 (2015). <a href="http://dx.doi.org/10.1021/cs501585k">link</a>. <a href="http://dx.doi.org/10.1021/cs501585k">doi</a>.</li></ol>
#+END_HTML


* DONE Post-processing an org-buffer on export
  CLOSED: [2015-12-01 Tue 13:58]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/12/01 13:58:46
  :updated:  2015/12/01 21:01:27
  :END:

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2015/11/22/Adding-emacs-command-key-bindings-and-help-functionality-to-org-mode/][post]] we examined getting tooltips on emacs keybindings and command syntax in an org-buffer. Someone asked in a comment if we could get that to export to html, or LaTeX. The short answer is not directly, org-mode doesn't recognize our functionalized syntax as an element, and there is no direct way to modify their appearance on export.

There is, however, a hook function that runs before parsing, and we can use that to transform these patterns to what we want. Here, I illustrate how to make the key-bindings and commands bold with a tooltip on them for an html export. Basically, we do an export, and then post-process the html output to put what we want in. I found this easier than pre-processing because the documentation for the command tooltip was too big to fit into an html snippet, and an html block causes carriage returns in the html. I didn't find a more elegant solution to that problem.

Here we replace the key-binding syntax with the actual keybinding in bold, and a tooltip of the command, and the command syntax we replace with bold command and a tooltip for the documentation. It works pretty well. The documentation for helm is pretty extensive, and gets cutoff in the tooltip. Otherwise, this seems pretty satisfactory.

This won't show in the blog post, so you will have to checkout the exported html here: [[./blog.html]].

Try \\[helm-find-files] to open a file. You might enjoy using `helm' too. Or this variable `org-agenda-files'.


#+BEGIN_SRC emacs-lisp
(require 'rx)

(defvar elisp-symbol-keybinding-re
  (rx
   ;; opening \\[
   (eval "\\[")
   ;; one or more characters that are not ]
   (group (one-or-more (not (any "]"))))
   ;; The closing ]
   "]")
"Regexp for an elisp command keybinding syntax. \\[some-command]
Regexp group 1 matches src_emacs-lisp[:results html]{(command-html "some-command")}.")

(defun org-process-key-bindings (backend)
  (goto-char (point-min))
  (while (re-search-forward elisp-symbol-keybinding-re nil t)
    (replace-match
     (cond
      ((eq backend 'html)
       (format "<b title=\"The command is %s.\">%s</b>"
	       (match-string 1)
	       (substitute-command-keys (match-string 0))))))))


(defun org-process-emacs-commands (backend)
  (goto-char (point-min))
  (while (re-search-forward "`\\([^']+\\)'" nil t)
    (replace-match
     (cond
      ((eq backend 'html)
       (format "<b title=\"%s\">%s</b>"
	  (if (or (fboundp (intern (match-string 1)))
		  (boundp (intern (match-string 1))))
	      (documentation (intern (match-string 1)))
	    "No command found.")
	  (match-string 1)))))))

(with-current-buffer (org-html-export-as-html)
  (org-process-key-bindings 'html)
  (org-process-emacs-commands 'html)
  (write-file "blog.html")
  (browse-url "blog.html"))
#+END_SRC
#+RESULTS:


** Update: A filter approach to exporting
Our patterns are all in org-paragraphs. We can use a filter to modify the paragraph after it is "transcoded". Here is the filter function. It basically does the same thing, through another mechanism.

#+BEGIN_SRC emacs-lisp
(defun my-paragraph-filter (data backend info)
  (cond
   ((eq 'html backend)
    ;; emacs commands
    (setq data (replace-regexp-in-string
		"`\\([^']+\\)'"
		(lambda (x)
		  (string-match "`\\([^']+\\)'" x)
		  (when (match-string 1 x)
		    (format "<b title=\"%s\">%s</b>"
			    (if (or (fboundp (intern (match-string 1 x)))
				    (boundp (intern (match-string 1 x))))
				(documentation (intern (match-string 1 x)))
			      "No command found.")
			    (match-string 1 x))))
		data))
    ;; keybindings
    (setq data (replace-regexp-in-string
		"\\\\\\[\\([^]]+\\)]"
		(lambda (x)
		  (string-match "\\\\\\[\\([^]]+\\)]" x)
		  (when (fboundp  (intern (match-string-no-properties 1 x)))
		    (format "<b title=\"The command is %s.\">%s</b>"
			    (match-string 1 x)
			    (substitute-command-keys (match-string 0 x)))))
		data)))))

(add-to-list 'org-export-filter-paragraph-functions 'my-paragraph-filter)
(browse-url (org-html-export-to-html))
#+END_SRC

#+RESULTS:
: #<process open ./blog.html>

Try the command `org-ref' to check your document for issues.  Insert a citation with org-ref using \\[org-ref-insert-cite-link].

Now, this should show up in the blog!

#+BEGIN_SRC emacs-lisp
(defun my-paragraph-filter (data backend info)
  (cond
   ((eq 'html backend)
    ;; emacs commands
    (setq data (replace-regexp-in-string
		"`\\([^']+\\)'"
		(lambda (x)
		  (string-match "`\\([^']+\\)'" x)
		  (when (match-string 1 x)
		    (format "<b title=\"%s\">%s</b>"
			    (if (or (fboundp (intern (match-string 1 x)))
				    (boundp (intern (match-string 1 x))))
				(documentation (intern (match-string 1 x)))
			      "No command found.")
			    (match-string 1 x))))
		data))
    ;; keybindings
    (setq data (replace-regexp-in-string
		"\\\\\\[\\([^]]+\\)]"
		(lambda (x)
		  (string-match "\\\\\\[\\([^]]+\\)]" x)
		  (when (fboundp  (intern (match-string-no-properties 1 x)))
		    (format "<b title=\"The command is %s.\">%s</b>"
			    (match-string 1 x)
			    (substitute-command-keys (match-string 0 x)))))
		data)))))

(let ((org-export-filter-final-output-functions '(my-paragraph-filter)))
 (browse-url (org-html-export-to-html)))
#+END_SRC

* DONE LDAP lookups from Emacs
  CLOSED: [2015-11-25 Wed 09:31]
  :PROPERTIES:
  :categories: emacs,helm
  :date:     2015/11/25 09:31:58
  :updated:  2015/11/25 09:31:58
  :ID:       10791C84-F860-4ABF-AC42-3B7B2E009CCD
  :END:

Now that I have email and Cisco Jabber totally integrated into Emacs it would be nice to tap into the CMU LDAP (Lightweight Directory Access Protocol) service  to find emails and phone numbers. We to use the ldapsearch command-line utility to query our LDAP service like this to find an email address.

You might like the video explanation here: https://www.youtube.com/watch?v=N7AaKHRd9uw

#+BEGIN_SRC emacs-lisp
(shell-command-to-string "ldapsearch -x -LLL -h ldap.andrew.cmu.edu -b ou=Person,dc=cmu,dc=edu cn=\"John Kitchin\"")
#+END_SRC

#+RESULTS:
#+begin_example
dn: guid=1976CCAA-B465-11D8-8000-080020CC75D3,ou=person,dc=cmu,dc=edu
objectClass: cmuPerson
eduPersonPrimaryAffiliation: Faculty
guid: 1976CCAA-B465-11D8-8000-080020CC75D3
cmuPrivate: homePostalAddress
cmuPrivate: homePhone
cn: John Kitchin
givenName: John
sn: Kitchin
cmuPrimaryCampus: Pittsburgh
cmuCampus: Pittsburgh
cmuAndrewId: jkitchin
cmueduId: jkitchin
cmuAndrewCommonNamespaceId: jkitchin
mail: jkitchin@cmu.edu
eduPersonSchoolCollegeName: CIT - Consolidated
cmuPersonPrincipalName: jkitchin@ANDREW.CMU.EDU
postalAddress: DH A207F
cmuDepartment: Chemical Engineering
cmuDepartment: MSE: Materials Science & Engineering
cmuPersonAffiliation: Tenure-Track Faculty
eduPersonAffiliation: Faculty
cmuAccount: uid=jkitchin,ou=account,dc=andrew,dc=cmu,dc=edu
cmuAccount: uid=jkitchin,ou=account,dc=cmu,dc=edu
cmuActiveDN: uid=jkitchin,ou=account,dc=andrew,dc=cmu,dc=edu
cmuActiveDN: uid=jkitchin,ou=account,dc=cmu,dc=edu
title: Professor
telephoneNumber: +1 412 268 7803

#+end_example

We actually get LDIF data from ldapsearch with a lot of details. Next we wrap the output in a function that converts each result from ldapsearch into a p-list that we will use later in a helm function to help us select a match.

#+BEGIN_SRC emacs-lisp
(defun ldap-query (query-string)
  "Send QUERY-STRING to our ldap server and parse results into a
list of p-lists for each entry returned."
  (interactive "sLDAP query: ")
  (let ((output (butlast (split-string
			  (shell-command-to-string
			   (format (concat  "ldapsearch -x -LLL "
					    "-h ldap.andrew.cmu.edu "
					    "-b ou=Person,dc=cmu,dc=edu %s")
				   query-string))
			  "\n")))
	(lines '())
	(result '())
	(results '(())))
    ;; cleanup trailing lines and ignore initial lines
    (loop for line in output
	  do
	  (cond
	   ;; join lines that run over
	   ((s-starts-with? " " line)
	    (setf (car (last lines))
		  (concat (car (last lines)) line)))
	   ;; ignore this
	   ((string-match "Size limit exceeded" line)
	    nil)
	   (t
	    (add-to-list 'lines line t))))

    ;; now we need to parse the lines. A new entry starts with a dn: line.
    (dolist (line lines)
      (cond
       ((s-starts-with? "dn:" line)
	;; add new entry
	(add-to-list 'results `(:dn ,line)))
       ((string-match ":" line)
	(let* ((s (split-string line ":"))
	       (prop (intern (concat ":" (s-trim (car s)))))
	       (val (s-trim (cadr s))))
	  (setf (car results) (plist-put (car results) prop val))))))
    ;; last result seems to be nil so we drop it
    (-filter (lambda (x) (not (null x))) results)))
#+END_SRC

#+RESULTS:
: ldap-query

Here is an example of that function:

#+BEGIN_SRC emacs-lisp
(ldap-query "cn=\"John Kitchin\"")
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((:dn "dn: guid=1976CCAA-B465-11D8-8000-080020CC75D3,ou=person,dc=cmu,dc=edu" :objectClass "cmuPerson" :eduPersonPrimaryAffiliation "Faculty" :guid "1976CCAA-B465-11D8-8000-080020CC75D3" :cmuPrivate "homePhone" :cn "John Kitchin" :givenName "John" :sn "Kitchin" :cmuPrimaryCampus "Pittsburgh" :cmuCampus "Pittsburgh" :cmuAndrewId "jkitchin" :cmueduId "jkitchin" :cmuAndrewCommonNamespaceId "jkitchin" :mail "jkitchin@cmu.edu" :eduPersonSchoolCollegeName "CIT - Consolidated" :cmuPersonPrincipalName "jkitchin@ANDREW.CMU.EDU" :postalAddress "DH A207F" :cmuDepartment "MSE" :cmuPersonAffiliation "Tenure-Track Faculty" :eduPersonAffiliation "Faculty" :cmuAccount "uid=jkitchin,ou=account,dc=cmu,dc=edu" :cmuActiveDN "uid=jkitchin,ou=account,dc=cmu,dc=edu" :title "Professor" :telephoneNumber "+1 412 268 7803"))
#+END_SRC


Now, we wrap a helm function around that to give us a nice menu to select entries from, and a few actions like sending an email, calling, copying the name and email, and seeing the information in a reasonable way. We also add a fallback method in case we don't find what we want and need to do a new search.

#+BEGIN_SRC emacs-lisp
(defun helm-ldap (query-string)
  (interactive "sLDAP query: ")
  (helm
   :sources
   `(((name . "HELM ldap")
      (candidates . ,(mapcar
		      (lambda (x)
			(cons
			 (format
			  "%20s|%30s|%30s|%20s|%s"
			  (s-truncate
			   20
			   (or (plist-get x :title) " "))
			  (plist-get x :cn)
			  (plist-get x :mail)
			  (plist-get x :cmuDisplayAddress)
			  (or (plist-get x :telephoneNumber) " "))
			 x))
		      (ldap-query
		       (if (string-match "=" query-string)
			   query-string
			 (concat "cn=*" query-string "*")))))
      (action . (("Email" . (lambda (x)
			      (compose-mail)
			      (message-goto-to)
			      (insert (plist-get x :mail))
			      (message-goto-subject)))
		 ("Call" . (lambda (x)
			     (cisco-call
			      (plist-get x :telephoneNumber))))
		 ("Copy Name and email address" . (lambda (x)
						    (kill-new
						     (format
						      "%s <%s>"
						      (plist-get x :cn)
						      (plist-get x :mail)))))
		 ("Information" . (lambda (x)
				    (switch-to-buffer
				     (get-buffer-create "*helm ldap*"))
				    (erase-buffer)
				    (dolist (key (cl-loop
						  for key in x by #'cddr
						  collect key))
				      (insert (format "|%s | %s|\n"
						      key (plist-get x key))))
				    (org-mode)
				    (goto-char 0)
				    (org-ctrl-c-ctrl-c)
				    (insert "press q to quit.\n\n")
				    (setq buffer-read-only t)
				    (use-local-map (copy-keymap org-mode-map))
				    (local-set-key "q"
						   #'(lambda ()
						       (interactive)
						       (quit-window t))))))))
     ;; fallback action
     ((name . "New search")
      (dummy)
      (action . (lambda (x) (helm-ldap x)))))))
#+END_SRC

#+RESULTS:
: helm-ldap

That is pretty convenient!

John Kitchin <jkitchin@cmu.edu>
* DONE Contextual help in org-mode
  CLOSED: [2015-11-24 Tue 10:08]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/11/24 10:08:41
  :updated:  2015/11/24 10:08:41
  :ID:       06742A47-56EF-4599-BF7D-5049E4DF03BB
  :END:
org-mode is great, plain text and all, but it can be difficult to figure out all the things you can do at any particular place in the buffer. Here, we explore some ideas on making org-mode a bit more discoverable. One way to do this that we explore here is to create a help function that you run, and it tells you about the element that `org-element-context' knows about, then gives you some hints of what you can do there. To do this, we create a series of functions for each kind of element we provide help on.

You may want to see the video: https://www.youtube.com/watch?v=99uxJWqZGzA

The kind of help we want is a description of the element, some commands we can run on the element and what they do, and if there are some key-bindings. We also want to make sure if the user has changed the key-bindings, the right values get shown. Finally, it would be nice to allow users to add their own documentation if they want.

So, here is the lengthy block of code we use for this purpose. We create a function for each element type that we provide documentation for. We also provide a mechanism for users to add their own notes for future reference. I leverage the help-buffer here to simplify some functional text, e.g. the key commands and clickable functions, as well as history navigation. I could also do most of that in org-mode buffers, with different functionality, but I save that for another day.

#+BEGIN_SRC emacs-lisp
(defvar ore-user-directory "~/.emacs.d/ore/"
  "Directory to store user additions to the notes.")


(defun ore-user-documentation (type)
  "Return user documentation for org element TYPE if it exists.
Notes are returned as plain text, and will be rendered in `help-mode'."
  (let ((fname (expand-file-name (format "%s.org" type) ore-user-directory)))
    (concat
     "User documentation:\n"
     (if (file-exists-p fname)
	 (with-temp-buffer
           (insert "\n")
	   (insert-file-contents fname)
	   (indent-rigidly (point-min) (point-max) 5)
	   (buffer-string))
       "None defined.")
     (format  "\n\nEdit [[file:%s]]" fname))))


(defun ore-latex (element)
  "`ore' documentation for latex fragment."
  (concat
   (substitute-command-keys "You are on a LaTeX fragment or environment.

\\[org-toggle-latex-overlays] or `org-toggle-latex-overlays' to toggle LaTeX images on it.

")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'latex)))


(defun ore-link (element)
  "`ore' documentation for org links."
  (let* ((link (org-element-context))
	 (type (org-element-property :type link))
	 (protocols (assoc type org-link-protocols))
	 (follow-func (cadr protocols))
	 (export-func (caddr protocols)))
    (concat
     (format
      (substitute-command-keys "You are on a %s link.

Link path: %s
%s

Clicking on the link will run `%s'.

This link uses this function for export: `%s'

If you are on an image link, you can toggle it with \\[org-toggle-inline-images] or `org-toggle-inline-images'.

You can toggle the link display with `org-toggle-link-display'.

See Info node `(org) Hyperlinks'.

%s

%s\n\n")
      type
      (org-element-property :path link)
      (format "Whole link: %s" (buffer-substring
				(org-element-property :begin link)
				(org-element-property :end link)))
      (pp-to-string follow-func)
      (pp-to-string export-func)
      (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
      (ore-user-documentation 'link)))))


(defun ore-src-block-header-p (element)
  "Return whether point is in a src-block header."
  (and (eq 'src-block (car element))
       (save-excursion
	 (let ((cp (point))
	       (lp (line-number-at-pos)))
	   (goto-char (org-element-property :begin element))
	   (= lp (line-number-at-pos))))))


(defun ore-src-block-header (element)
  "`ore' documentation for src-block header."
  (concat
   "You are in a src-block header.

This line tells org-mode that
it is a src-block, and language of the src-block. There are
also optional header arguments. See Info node `(org) Header arguments'

"
   (format "The default headers are described here: `org-babel-default-header-args:%s'

" (org-element-property :language element))
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'src-block-header)))


(defun ore-src-block (element)
  "`ore' documentation for a src-block."
  (concat
   (substitute-command-keys "You are in a src-block.

C-c C-c to execute this block.
\\[org-babel-tangle]  org-babel-tangle

You can edit the block with \\[org-edit-special] or `org-edit-special'.

See Info node `(org) Working with source code' for more details.\n\n")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'src-block)))


(defun ore-headline (element)
  "`ore' documentation for a headline."
  (concat
   (when (bolp)
     (format  "You are at the beginning of a headline.

\\[org-cycle] to cycle Info node `(org) Global and local cycling'.

Check `org-use-speed-commands'\n\n"))

   ;; in a headline
   (substitute-command-keys
    "You are in a headline. You can change:

 Visibility with \\[org-cycle]

 TODO state \\[org-shiftleft] and \\[org-shiftright] or
 `org-todo'.

 Your current todo sets can be found in `org-todo-sets'.

 Priority \\[org-shiftup] (`org-priority-up') and
 \\[org-shiftdown] (`org-priority-down')

 Tags  \\[org-ctrl-c-ctrl-c] or `org-set-tags'

 Set a property with \\[org-set-property] `org-set-property'.

 Delete a property with \\[org-delete-property] or `org-delete-property'.

")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'headline)))


;; timestamp
(defun ore-timestamp (element)
  "`ore' documentation for timestamps."
  (concat
   (substitute-command-keys "You are on a timestamp.

If you click on it, you will see the date in the agenda. With the
cursor on the <> or [] \\[org-shiftup] and \\[org-shiftdown] will
switch from active to inactive timestamps.

You can change the date by putting the cursor on a date part and
using \\[org-shiftup] and \\[org-shiftdown] or \\[org-shiftleft]
and \\[org-shiftright]

See Info node `(org) Dates and times'.

")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'timestamp)))


;; table table-row table-cell
(defun ore-table (element)
  "`ore' documentation for tables."
  (concat
   "You are in a table.

Move cell to cell with [TAB]. When you are in the last cell, TAB adds a new row.

Move rows up and down with \\[org-metaup] and \\[org-metadown].
Move columns left and right with \\[org-metaleft] and \\[org-metaright].

Sort a column with \\[org-sort] `org-sort'.

Insert a row with `org-table-insert-row'.
Delete a row with `org-table-kill-row'.

Insert a column with `org-table-insert-column'.
Delete a column with `org-table-delete-column'.

`C-c -     (`org-table-insert-hline')'
     Insert a horizontal line below current row.  With a prefix
     argument, the line is created above the current line.

`C-c <RET>     (`org-table-hline-and-move')'
     Insert a horizontal line below current row, and move the cursor
     into the row below that line.

You can transpose a table with `org-table-transpose-table-at-point'.

Info node `(org) Tables'.

"
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'table)))


(defun ore-plain-list (element)
  "`ore' doucmentation for plain lists."
  (concat
   (substitute-command-keys
    "You are on a plain list.
See Info node `(org) Plain lists'.

")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'plain-list)))


(defun ore-item (element)
  "`ore' documentation for items in a list"
  (concat
   (substitute-command-keys
    "You are on an item in a list.

You can move items up and down with \\[org-metaup] or `org-metaup' and \\[org-meta-down] or `org-metadown'.

You can add a new item with \\[org-meta-return] or `org-meta-return'.

You can change the indentation of an item with  \\[org-metaleft] or `org-metaleft' and \\[org-meta-right] or `org-meta-right'.

You can change the bullet of the item with  \\[org-shiftleft] or `org-shiftleft' and \\[org-shiftright] or `org-shiftright'.

See Info node `(org) Plain lists' for other things like sorting, cycling, checkboxes, etc...

")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'item)))


(defun ore-keyword (element)
  "`ore' documentation for a keyword."
  (concat
   (substitute-command-keys
    "You are on a keyword.

You may need to run \\[org-ctrl-c-ctrl-c] or `org-ctrl-c-ctrl-c' to refresh its value if you change it.

You can move keywords up and down with \\[org-metaup] or `org-metaup' and \\[org-metadown] or `org-metadown'.

")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'keyword)))


(defun ore-paragraph (element)
  "`ore' documentation for a paragraph."
  (concat
   (substitute-command-keys
    "You are in a paragraph.

You can move a paragraph up with \\[org-metaup] or `org-metaup'.

You can move a paragraph up with \\[org-metadown] or `org-metadown'.

You can mark the paragraph with `mark-paragraph'.


")
   (format  "\nClick for details on the face [[face:%s]]\n" (face-at-point))
   (ore-user-documentation 'paragraph)))


(defun ore ()
  "Help function for the org-mode element at point."
  (interactive)
  (with-help-window
      (help-buffer)
    (let* ((oeap (org-element-context))
	   (ore-func (intern (format "ore-%s" (car oeap))))
	   (s (if (fboundp ore-func)
		  (funcall ore-func oeap)
		(format
		 "No documentation found for %s.

%s"
		 (car oeap)
		 (ore-user-documentation (car oeap))))))
      ;; There are some special cases.
      (cond
       ((and  (eq 'src-block (car oeap))
	      (ore-src-block-header-p oeap))
	(setq s (ore-src-block-header oeap)))

       ((or (eq 'table (car oeap))
	    (eq 'table-row (car oeap))
	    (eq 'table-cell (car oeap)))
	(setq s (ore-table oeap)))

       ((or (eq 'latex-fragment (car oeap))
	    (eq 'latex-environment (car oeap)))
	(setq s (ore-latex oeap))))

      (princ s)
      (princ "\n\nHere is how org-mode sees the element.\n\n")
      (pp oeap))))


(defun match-next-ore-file (&optional limit)
  "Font-lock function to make file links clickable in help-mode."
  (when  (re-search-forward "\\[\\[file:\\([^]]*\\)\\]\\]" limit t)
    (let* ((fname (expand-file-name
		   (match-string 1)
		   ore-user-directory))
	   (beg (match-beginning 0))
	   (end (match-end 0))
	   (find-func `(lambda ()
			 (interactive)
			 (find-file ,fname))))

      (add-text-properties
       beg
       end
       `(mouse-face
	 highlight
         display "User documentation"
	 local-map ,(let ((map (copy-keymap help-mode-map)))
		      (define-key map [mouse-1] find-func)
		      map)
	 help-echo (format
		    "Click to edit User documentation.\n%s"
		    fname))))))

(defun match-next-ore-face (&optional limit)
  "Font-lock function to make face links clickable in help-mode."
  (when  (re-search-forward "\\[\\[face:\\([^]]*\\)\\]\\]" limit t)
    (let* ((face (match-string 1))
	   (beg (match-beginning 0))
	   (end (match-end 0))
	   (func `(lambda ()
		    (interactive)
		    (describe-face ,face))))

      (add-text-properties
       beg
       end
       `(mouse-face
	 highlight
	 local-map ,(let ((map (copy-keymap help-mode-map)))
		      (define-key map [mouse-1] func)
		      map)
	 display ,face
	 help-echo (format
		    "Click to show face information.\n%s"
		    face))))))

(add-hook 'help-mode-hook
	  (lambda ()
	    (font-lock-add-keywords
	     nil
	     '((match-next-ore-file . font-lock-keyword-face)
	       (match-next-ore-face . font-lock-keyword-face)))))


;; Let's add to the org menu for "Help at point"
(easy-menu-change
 '("Org")
 "Help"
 '(["Help at point" ore])
 "Show/Hide")
#+END_SRC

#+RESULTS:

cite:xu-suppor   $e^x$

** TODO elements
   :PROPERTIES:
   :ID:       3DD2B408-4A4A-4BAF-8E9B-EF2735D4F43F
   :END:


| a | b |
| 3 | 4 |

#+keyword: test

list (plain/numbered)
 - add element
   - move elements (up/down indent/outdent)
 -

1. item 1
2. item 2
3. item 3

checkbox
- [ ] check it

[[./11-eos.png]]

 [[info:org#External links]]

cite:lizzit-2001-surfac-ru


@@latex:$e^x=4@@

$latex_fragment$

\(latex fragment\)

\begin{equation}
2-3
\end{equation}

#+BEGIN_SRC emacs-lisp
(+ 3 4 5)
#+END_SRC

#+RESULTS:
: 12

<2015-10-18 Sun>   [2015-10-18 Sun]
* DONE Improving org-ref cite links with tooltips
  CLOSED: [2015-11-23 Mon 07:03]
  :PROPERTIES:
  :categories: orgmode,emacs,orgref
  :date:     2015/11/23 07:03:06
  :updated:  2015/11/23 07:03:06
  :ID:       C88699D6-76CF-4759-B15E-39950FA2847E
  :END:
Org-ref uses timers to give you messages about the cite link at point. I am not so crazy about the timer, there is always a (short) delay, and I have had trouble debugging timers in the past, and you have to put the point on the link. Since I wrote that code, I have learned some new things about Emacs, including dynamic tooltips. This will allow me to use the mouse to see what a cite link refers to. While reading documents, I am more likely to use a mouse than when typing a document, and getting a tooltip by hovering sounds like a good idea.

Here, we explore using dynamic tooltips on cite links. The idea is pretty simple, we tie into font-lock to add a function to the :help-echo property of a cite link. The function will go to point, and compute the citation string at point, which will be displayed as a tooltip when the mouse hovers over the citation.

Font-lock allows you to specify a function that sets match-data and that can have other side-effects, e.g. setting text properties. Org-ref has a regexp that defines cite links, which we use here, and a function that gets the citation string at point. We just go to the mouse position, and get that string, wrapped in a save-excursion macro so that point does not actually move. Then, we add the function to font-lock keywords, and we are done!

Here are some papers we wrote on using org-mode
cite:kitchin-2015-examp,kitchin-2015-data-surfac-scien and some other references
in my bibliography cite:zou-2014-cobal-embed,zlotea-2014-nanoal and one final
example cite:zhu-2015. cite:kitchin-2015-data-surfac-scien


Here is the short code required to do this. You can see the tooltips in action here: https://www.youtube.com/watch?v=ifSmlId2rk0

#+BEGIN_SRC emacs-lisp
(defun org-ref-match-next-cite-link (&optional limit)
  (when (re-search-forward org-ref-cite-re limit t)
    (add-text-properties
     (match-beginning 0) (match-end 0)
     (list
      'help-echo (lambda (window object position)
		   (save-excursion
		     (goto-char position)
		     (let ((s (org-ref-get-citation-string-at-point)))
		       (with-temp-buffer
			 (insert s)
			 (fill-paragraph)
			 (buffer-string)))))))))

; do this for this buffer
(font-lock-add-keywords
    nil
    '((org-ref-match-next-cite-link (0  'org-ref-cite-face t)))
    t)
(font-lock-fontify-buffer)

;; do this for every org file
(add-hook
 'org-mode-hook
 (lambda ()
   (font-lock-add-keywords
    nil
    '((org-ref-match-next-cite-link (0  'org-ref-cite-face t)))
    t)))
#+END_SRC


bibliography:~/Dropbox/bibliography/references.bib

* DONE Adding emacs command key-bindings and help functionality to org-mode
  CLOSED: [2015-11-22 Sun 10:08]
  :PROPERTIES:
  :categories: emacs,orgmode
  :ID:       1B122428-E8FF-476B-B07B-79A7541003DC
  :date:     2015/11/22 10:08:18
  :updated:  2015/11/22 10:08:18
  :END:
The documentation of functions in emacs allows you to put some light markup into function doc strings that will render as the key sequence required to run the command when you look up the help on the function. I would like to have something like that in org-mode. You can look up the key-binding to a command like this:
#+BEGIN_SRC emacs-lisp
(substitute-command-keys "\\[org-agenda]")
#+END_SRC

#+RESULTS:
: C-c a

We are going to explore a way to recognize the syntax shown above, change its appearance to alert us that we are looking at an emacs command, add a tooltip, and make it clickable to open the documentation, and s (super) clickable to find the function code. Font lock is the tool we will use for this. Basically, we need a regular expression to match the syntax, and a function to find the next instance, and put some properties on the matched text.

I made a video (https://www.youtube.com/watch?v=VLUMW0sR4Vk) showing what this post is all about. It isn't easy to see in the post â˜º.

Here we use the `rx' library to build up a regular expression for this. It is a bit easier to document than a raw regexp. Since we are matching \ in the pattern, there are some obligatory escaping \ characters in there too. All we need is to integrate this into font-lock. We define a function that will move the point to the end of the next match, and put properties on the match. We will go ahead and make the text clickable so we can access documentation and code easily. The tooltip will show the key-binding to run the command.

#+BEGIN_SRC emacs-lisp
(require 'rx)

(defvar elisp-symbol-keybinding-re
  (rx
   ;; opening \\[
   (eval "\\[")
   ;; one or more characters that are not ]
   (group (one-or-more (not (any "]"))))
   ;; The closing ]
   "]")
"Regexp for an elisp command keybinding syntax. \\[some-command]
Regexp group 1 matches `some-command'.")

(defun match-next-keybinding (&optional limit)
  "Move point to the end of the next expression matching
`elisp-symbol-keybinding-re', and put properties on the match
that shows the key sequence. Non-bound commands are not
fontified."
  (when (and (re-search-forward
	      elisp-symbol-keybinding-re
	      limit t)
	     (fboundp (intern (match-string 1))))
    (let* ((beg (match-beginning 0))
	   (end (match-end 0))
	   (s (match-string 0))
	   (command (match-string 1))
	   (describe-func `(lambda ()
		    "Run `describe-function' on the command."
		    (interactive)
		    (describe-function (intern ,command))))
	   (find-func `(lambda ()
		     "Run `find-function' on the command."
		     (interactive)
		     (find-function (intern ,command))))
	   (map (make-sparse-keymap)))

      ;; this is what gets run when you click on it.
      (define-key map [mouse-1] describe-func)
      (define-key map [s-mouse-1] find-func)
      ;; Here we define the text properties
      (add-text-properties
       beg end
       `(local-map ,map
	 mouse-face highlight
	 help-echo ,(format
		     "%s\n\nClick for documentation.\ns-mouse-1 to find function."
		     (substitute-command-keys s))
	 keybinding t)))))
#+END_SRC

Let's go ahead and make syntax for `some-command' too. This one seems simple enough we just write a regexp for it.

#+BEGIN_SRC emacs-lisp
(defun match-next-emacs-command (&optional limit)
  "Move point to the end of the next expression matching
`this-syntax', and put a tooltip on the match
that shows the key sequence. Works on commands and variables."
  (when (and (re-search-forward
	      "`\\([^']+\\)'"
	      limit t)
	     (or (boundp (intern (match-string 1)))
		 (fboundp (intern (match-string 1)))))
    (let* ((beg (match-beginning 0))
	   (end (match-end 0))
	   (s (match-string 0))
	   (command (match-string 1))
	   (describe-func
	    `(lambda ()
	       "Run `describe-function/variable' on the command."
	       (interactive)
	       (cond ((fboundp (intern ,command))
		      (describe-function (intern ,command)))
		     ((boundp (intern ,command))
		      (describe-variable (intern ,command))))))
	   (find-func `(lambda ()
		     "Run `find-function' on the command."
		     (interactive)
		     (find-function (intern ,command))))
	   (map (make-sparse-keymap)))

      ;; this is what gets run when you click on it.
      (define-key map [mouse-1] describe-func)
      (define-key map [s-mouse-1] find-func)
      ;; Here we define the text properties
      (add-text-properties
       beg end
       `(local-map ,map
	 mouse-face highlight
	 help-echo ,(format
		     "%s\n\nClick for documentation.%s"
		     (if (fboundp (intern command))
			 (substitute-command-keys (format "\\[%s]" command))
		       "Variable")
		     (if (fboundp (intern command))
			 "\ns-mouse-1 to find function."
		       ""))
	 keybinding t)))))
#+END_SRC

Now we need a way to turn them on and off. We do that here with a minor mode.

#+BEGIN_SRC emacs-lisp
(define-minor-mode emacs-keybinding-command-tooltip-mode
  "Fontify on emacs keybinding syntax. Adds a tooltip for
keybinding, and make the command clickable to get to the
documentation."
  :lighter " KB"
  (if emacs-keybinding-command-tooltip-mode
      ;; turn them on
      (font-lock-add-keywords
       nil
       '((match-next-keybinding 1 font-lock-constant-face)
	 (match-next-emacs-command 1 font-lock-constant-face)))
    ;; turn them off
    (font-lock-remove-keywords
     nil
     '((match-next-keybinding 1 font-lock-constant-face)
       (match-next-emacs-command 1 font-lock-constant-face))))
  (font-lock-fontify-buffer))
#+END_SRC

#+RESULTS:

Here we turn it on:
#+BEGIN_SRC emacs-lisp
(emacs-keybinding-command-tooltip-mode 1)
#+END_SRC

#+RESULTS:
: t

Here are some sample uses. You can use  \\[org-toggle-latex-overlays] to toggle latex overlays.

You can use \\[org-ref-helm-insert-cite-link]  to insert citations.

That more or less does it! I don't know if this is the canonical way to do this, but it works nicely here. You can also use overlays, but I found them a little confusing because they are not editable, and you have to toggle the minor mode to see them. Here we have unobtrusive tooltips. One downside is these won't export in any fashion in org-mode since it is not part of the syntax. It might be a good idea to adjust `font-lock-extra-managed-props' for this

It works for this syntax too: `helm', which is also commonly used in doc strings. This should be pretty handy in org-mode documents about Emacs!

* DONE Insert org-entities into org-mode with helm
  CLOSED: [2015-11-21 Sat 11:37]
  :PROPERTIES:
  :categories: emacs,helm,orgmode
  :date:     2015/11/21 11:37:33
  :updated:  2015/11/21 11:37:33
  :ID:       3F38CF6F-BEED-4B2E-85CD-61BB88934B2F
  :END:
org-mode has a lot of pre-defined entities (see http://kitchingroup.cheme.cmu.edu/blog/2013/10/03/Exporting-accented-characters-to-latex-from-org-mode/), otherwise known to me as non-ascii characters. I rarely remember what these are, and occasionally want to insert the LaTeX or HTML code, so here we build a helm command to show them to me, and allow me to select one for insertion. We generate the helm sources from org-entities below. It works pretty well!

#+BEGIN_SRC emacs-lisp
(defun helm-insert-org-entity ()
  "Helm interface to insert an entity from `org-entities'.
F1 inserts utf-8 character
F2 inserts entity code
F3 inserts LaTeX code (does not wrap in math-mode)
F4 inserts HTML code"
  (interactive)
  (helm :sources (reverse
		  (let ((sources '())
			toplevel
			secondlevel)
		    (dolist (element (append
				      '("* User" "** User entities")
				      org-entities-user org-entities))
		      (when (and (stringp element)
				 (s-starts-with? "* " element))
			(setq toplevel element))
		      (when (and (stringp element)
				 (s-starts-with? "** " element))
			(setq secondlevel element)
			(add-to-list
			 'sources
			 `((name . ,(concat
				     toplevel
				     (replace-regexp-in-string
				      "\\*\\*" " - " secondlevel)))
			   (candidates . nil)
			   (action . (("insert utf-8 char" . (lambda (candidate)
							       (insert (nth 6 candidate))))
				      ("insert org entity" . (lambda (candidate)
							   (insert (concat "\\" (car candidate)))))
				      ("insert latex" . (lambda (candidate)
							  (insert (nth 1 candidate))))
				      ("insert html" . (lambda (candidate)
							 (insert (nth 3 candidate)))))))))
		      (when (and element (listp element))
			(setf (cdr (assoc 'candidates (car sources)))
			      (append
			       (cdr (assoc 'candidates (car sources)))
			       (list (cons
				      (format "%10s %s" (nth 6 element) element)
				      element))))))
		    sources))))
#+END_SRC

#+RESULTS:
: helm-insert-org-entity

Now I can write things like the particle was 60 Ã… in diameter at a temperature of 600Â°C, leading to an expansion coefficient of Î±=0.2 Â± 0.01. It isn't quite as fast as knowing the keyboard shortcuts for those symbols, but a lot faster than looking them up then copy and pasting them. So far it seems like these export to HTML and LaTeX just fine, and they are more convenient and better looking than using the org-entities codes. This will make its way into jmax soon.


* DONE Asynchronously running python blocks in org-mode
  CLOSED: [2015-11-20 Fri 11:46]
  :PROPERTIES:
  :categories: emacs,python,orgmode
  :date:     2015/11/20 11:46:45
  :updated:  2015/11/20 19:30:57
  :ID:       C967694C-D12F-490C-B194-48DD146EF35E
  :END:
If you run long Python blocks from org-mode, you might want to keep working while it runs. Currently Emacs gets blocked and you have to wait patiently.  In this post we consider some ways to avoid this that run our code asynchronously, but still put results where they belong in the org-buffer.

This is a long post. You may want to see the video: https://www.youtube.com/watch?v=VDyoN8yipSE, or skip to the [[id:D8F2CBB5-31B2-4477-A363-E3C0063214DE][end]] where the best and final version is shown.

** The async module
   :PROPERTIES:
   :ID:       06A9E2E0-2403-4EB0-8F71-7A3827A48BAF
   :END:

Here we consider an approach that uses https://github.com/jwiegley/emacs-async module. The idea is to tangle the Python block at point to a temp file, then asynchronously run it. We capture the output and put it back in the buffer. We use a uuid to find the place to put the results in org-mode format. Here is the code that implements this idea.

#+BEGIN_SRC emacs-lisp
(require 'async)

(defun org-babel-async-execute ()
  "Run a python block at point asynchrously."
  (interactive)

  (let ((current-file (buffer-file-name))
	(uuid (org-id-uuid))
	(temporary-file-directory "./")
	(tempfile (make-temp-file "py-")))

    (org-babel-tangle '(4) tempfile)
    (org-babel-remove-result)
    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))

    (async-start
     ;; what to start
     `(lambda ()
	;; now we run the command then cleanup
	(prog1
	    (shell-command-to-string (format "python %s" ,tempfile))
	  (delete-file ,tempfile)))

     `(lambda (result)
	"Code that runs when the async function finishes."
	(save-window-excursion
	  (save-excursion
	    (save-restriction
	      (with-current-buffer (find-file-noselect ,current-file)
		(goto-char (point-min))
		(re-search-forward ,uuid)
		(beginning-of-line)
		(kill-line)
		(insert (mapconcat
			 (lambda (x)
			   (format ": %s" x))
			 (butlast (s-split "\n" result))
			 "\n"))))))))))
#+END_SRC

#+RESULTS:
: org-babel-async-execute

Here is a block to test it on. We can run the block, and keep on working while the code runs. The results seem to get inserted correctly at the right point even if I am in another window or frame! We don't get easy access to continuous output of the command. This wouldn't work if we close Emacs, but who does that?


#+BEGIN_SRC python
print 'hello world'
import time
time.sleep(5)

import os
print os.getcwd()
print time.asctime()
#+END_SRC

#+RESULTS:
: hello world
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: Fri Nov 20 10:17:53 2015

There are some limitations to this approach. One of them is it assumes the src block is a stand-alone block that will run on its own. That is usually how I run mine, but I could see having other modules that should be tangled out of a file too. I think the script is being run in the current working directory, so it probably will find any local imports it needs.

You don't get any intermediate feedback on this process. It seems to be possible to do that with a different approach that puts some output in a new buffer, e.g. with start-process. But, you still need some clever code like the async model to know when to insert the results back into this buffer. We consider Emacs processes and sentinels next.

** Emacs process approach with tangling
   :PROPERTIES:
   :ID:       B5CC69B3-CF29-41F3-8BE4-C1E711F66754
   :END:
We can start a process in Emacs, and attach a sentinel function to it that runs after the process completes. Here is an example of that. We still tangle the src-block here.

#+BEGIN_SRC emacs-lisp
(defun org-babel-async-execute ()
  (interactive)
  (let* ((current-file (buffer-file-name))
	(uuid (org-id-uuid))
	(temporary-file-directory "./")
	(tempfile (make-temp-file "py-"))
	(pbuffer (format "*%s*" uuid))
	process)

    (org-babel-tangle '(4) tempfile)
    (org-babel-remove-result)

    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))

    (setq process (start-process
		   uuid
		   pbuffer
		   "python"
		   tempfile))

    (set-process-sentinel
     process
     `(lambda (process event)
	(when (string= "finished\n" event)
	  (delete-file ,tempfile)
	  (save-window-excursion
	    (save-excursion
	      (save-restriction
		(with-current-buffer (find-file-noselect ,current-file)
		  (goto-char (point-min))
		  (re-search-forward ,uuid)
		  (beginning-of-line)
		  (kill-line)
		  (insert (mapconcat
			   (lambda (x)
			     (format ": %s" x))
			   (split-string
			    (with-current-buffer ,pbuffer (buffer-string))
			    "\n")
			   "\n")))))))
	(kill-buffer ,pbuffer)))))
#+END_SRC

#+RESULTS:
: org-babel-async-execute

#+BEGIN_SRC python
print 'hello world'
import time
time.sleep(10)

import os
print os.getcwd()
print time.asctime()
#+END_SRC

#+RESULTS:
: hello world
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: Fri Nov 20 10:20:01 2015
:

That works well from what I can see. There are some limitations. I doubt this will work if you use variables in the src block header. Next we consider an approach that does not do the tangling, and that will show us code output as it goes.

** Emacs process approach with no tangling
   :PROPERTIES:
   :ID:       D8F2CBB5-31B2-4477-A363-E3C0063214DE
   :END:
As an alternative to tangling to a file, here we just copy the code to a file and then run it. This allows us to use :var in the header to pass data in at run time. At the moment, this code only supports printed output from code blocks, not the value for :results.

#+BEGIN_SRC emacs-lisp
(defun org-babel-async-execute:python ()
  "Execute the python src-block at point asynchronously.
:var headers are supported.
:results output is all that is supported for output.

A new window will pop up showing you the output as it appears,
and the output in that window will be put in the RESULTS section
of the code block."
  (interactive)
  (let* ((current-file (buffer-file-name))
	 (uuid (org-id-uuid))
	 (code (org-element-property :value (org-element-context)))
	 (temporary-file-directory ".")
	 (tempfile (make-temp-file "py-"))
	 (pbuffer (format "*%s*" uuid))
	 (varcmds (org-babel-variable-assignments:python
		   (nth 2 (org-babel-get-src-block-info))))
	 process)

    ;; get rid of old results, and put a place-holder for the new results to
    ;; come.
    (org-babel-remove-result)

    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))

    ;; open the results buffer to see the results in.
    (switch-to-buffer-other-window pbuffer)

    ;; Create temp file containing the code.
    (with-temp-file tempfile
      ;; if there are :var headers insert them.
      (dolist (cmd varcmds)
	(insert cmd)
	(insert "\n"))
      (insert code))

    ;; run the code
    (setq process (start-process
		   uuid
		   pbuffer
		   "python"
		   tempfile))

    ;; when the process is done, run this code to put the results in the
    ;; org-mode buffer.
    (set-process-sentinel
     process
     `(lambda (process event)
	(save-window-excursion
	  (save-excursion
	    (save-restriction
	      (with-current-buffer (find-file-noselect ,current-file)
		(goto-char (point-min))
		(re-search-forward ,uuid)
		(beginning-of-line)
		(kill-line)
		(insert
		 (mapconcat
		  (lambda (x)
		    (format ": %s" x))
		  (butlast (split-string
			    (with-current-buffer
				,pbuffer
			      (buffer-string))
			    "\n"))
		  "\n"))))))
	;; delete the results buffer then delete the tempfile.
	;; finally, delete the process.
	(when (get-buffer ,pbuffer)
	  (kill-buffer ,pbuffer)
	  (delete-window))
	(delete-file ,tempfile)
	(delete-process process)))))
#+END_SRC

#+RESULTS:
: org-babel-async-execute:python

Let us try it out again.

#+BEGIN_SRC python :var data='(1  3)
print 'hello world'
import time
time.sleep(1)

for i in range(5):
    print i

    time.sleep(0.5)


import os
print os.getcwd()
print time.asctime()

print data

raise IOError('No file!')
#+END_SRC

#+RESULTS:
: hello world
: 0
: 1
: 2
: 3
: 4
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: Fri Nov 20 19:30:16 2015
: [1, 3]
: Traceback (most recent call last):
:   File "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/py-84344aa1", line 18, in <module>
:     raise IOError('No file!')
: IOError: No file!

It works fine for this simple example. We get to see the output as the code executes, which is a pleasant change from the usual way of running python blocks. There is some support for some header arguments, notably the :var header. I don't use :results value in Python, so for now only output is supported. We even support Exceptions in the output finally!

Maybe some org-moder's out there can try this and run it through some more rigorous paces?


* DONE Functional and display math in technical documents
  CLOSED: [2015-11-19 Thu 06:07]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/11/19 06:07:15
  :updated:  2015/11/19 14:43:12
  :ID:       C7BDC816-7C73-4F2E-977E-E86FF934E133
  :END:
I have been thinking about a way to have functional and readable mathematics in technical documents. It has always bothered me that I have to write a LaTeX version of an equation, and then a separate implementation of the equation in code somewhere. At least twice in my life these separate representations have not agreed!

One solution might be if my functional code could be converted to LaTeX easily. I explore one simple approach to this here. It is somewhat inspired by this work here http://oremacs.com/2015/01/23/eltex/ on writing LaTeX in emacs-lisp, and from my work with org-mode in mixing narrative text, LaTeX and code.

The idea is to use emacs-lisp for the code, so it is functional, but provide an alternative output for the /same code/ for a document conversion. In other words, we accept there is more than one version we need: a functional version for working, and a consumption version for presentation. We will generate the consumption version from the functional version.

I know emacs-lisp is not ideal for mathematics the way we are accustomed to seeing it, but it enables the idea I want to explore here so we will try it.

Here is the simplest example I could come up with for functional math. We can run it ourselves, and verify it is correct.

$1 + 2+ 4 = 6$

#+BEGIN_SRC emacs-lisp
(+ 1 2 3)
#+END_SRC

#+RESULTS:
: 6


Now, I can change the meaning of this code temporarily, so that it not only evaluates the form, but also represents the equation and result in LaTeX code. If this was incorporated into a preprocessor of the document, we could have a functional version representing our equations, in code form, and a presentation version generated from this version. The code that follows isn't how I would do this is in some production setting; it is only to show that you can /temporarily/ change the meaning of "+". In a production setting, there would just be (+ 1 2 3) in the text, and a preprocessor would find all the sexps in the text, and replace them with the export format using code like this. At least, that is what I am imagining. It might be feasible to do this already with inline org-babel calls and an org-mode export filter, but I didn't try it here. So, here is the proof of concept code.

#+BEGIN_SRC emacs-lisp :results raw
(cl-flet ((+ (lambda (&rest args)
	       (format
		"$%s = %s$"
		(mapconcat #'number-to-string args " + ")
		(eval `(+ ,@args))))))
  (+ 1 2 3))
#+END_SRC

#+RESULTS:
$1 + 2 + 3 = 6$



Here is an example that generates a fraction from a division.
#+BEGIN_SRC emacs-lisp :results raw
(cl-flet ((/ (lambda (&rest args)
	       (format
		"$\\frac{%s}{%s} = %s$"
		(car args)
		(mapconcat 'number-to-string (cdr args) " \\cdot ")
		(eval `(/ ,@args))))))
  (/ 1.0 2.0 3.0))
#+END_SRC

#+RESULTS:
$\frac{1.0}{2.0 \cdot 3.0} = 0.16666666666666666$

As a proof of concept, this idea looks feasible, but this implementation has some limitations. Getting this to a complete workable approach would require a lot of work, basically creating transformation functions for many, many kinds of mathematical functions, and a lot of other kinds of logic. For example, (+ 1 2 (+ 3 4)) would not render correctly with the codes above. It isn't even clear what it should render to. I think you want 1 + 2 + (3 + 4) as the rendered output.

Anyway, it is an interesting idea, one that blurs the lines between code and mathematics. We are so used to the equation representation of mathematics, rather than the code representation that being able to go back and forth seems like a good idea, especially when one is derived from the other.


* DONE Saving the current restriction and restoring it while following links
  CLOSED: [2015-10-24 Sat 13:41]
  :PROPERTIES:
  :ID:       881AD1B6-E4F3-4860-8734-BFB9BE613ABF
  :categories: emacs,orgmode
  :date:     2015/10/24 13:41:45
  :updated:  2015/10/25 07:09:15
  :END:

On the org-mode mailing list there has been some discussion about following id links. The issue is that if your buffer is narrowed, clicking on the link does not change the restriction to actually take you to the entry. This is debatably desirable. If I click on a link, I want it to go where it points. But, I might also like to go back to my narrowed view. So here consider how to save the state of narrowing, and restore it. We modify the function that opens an id link to save the restriction, and widen the buffer if necessary.

Saving the restriction seems easy, we just save a marker to point, and the point-min and point-max. We save the marker for a convenient way to get the buffer, and perhaps the actual point. We advise the C-c & function to restore the restriction after we leave it. This should fix the restriction in whatever buffer we undid it in.

Here is the code that seems to work for me. Thanks to Rasmus for the idea on saving the restriction data.

#+BEGIN_SRC emacs-lisp
(defvar *saved-restriction* nil
 "A global var containing the current restriction.
Returns (current-buffer point-min point-max")

(defun save-current-restriction ()
  "Save the current restriction at point."
  (setq *saved-restriction*
	(if (buffer-narrowed-p)
	    (list (current-buffer) (point-min) (point-max))
	  nil)))

(defun restore-saved-restriction ()
  "Restore the last saved restriction."
  (when *saved-restriction*
    (set-buffer (car *saved-restriction*))
    (narrow-to-region (nth 1 *saved-restriction*)
		      (nth 2 *saved-restriction*)))
  (setq *saved-restriction* nil))

;' actually modify this function to save the restriction, and widen if needed.
(defun org-id-open (id)
  "Go to the entry with id ID."
  (org-mark-ring-push)
  (let ((m (org-id-find id 'marker))
	cmd)
    (unless m
      (error "Cannot find entry with ID \"%s\"" id))
    ;; Use a buffer-switching command in analogy to finding files
    (setq cmd
	  (or
	   (cdr
	    (assq
	     (cdr (assq 'file org-link-frame-setup))
	     '((find-file . switch-to-buffer)
	       (find-file-other-window . switch-to-buffer-other-window)
	       (find-file-other-frame . switch-to-buffer-other-frame))))
	   'switch-to-buffer-other-window))
    (if (not (equal (current-buffer) (marker-buffer m)))
	(funcall cmd (marker-buffer m)))
    (save-current-restriction)
    (when (> m (point-max))
      (widen))
    (goto-char m)
    (move-marker m nil)
    (org-show-context)))


;; And we advise the function going back to restore the restriction.
(defadvice org-mark-ring-goto (after restore-my-restriction () activate)
  "Restore narrowing."
  (restore-saved-restriction))

#+END_SRC

#+RESULTS:
: org-mark-ring-goto

This seems to preserve restrictions in the current buffer and in other buffers, as long as I use C-c & to invoke org-mark-ring goto. I am not sure how easy it would be to make this work for all links. Each link has its own function for following so I am not sure we can easily get them all to do this unless there is some high level function to advise like org-mouse-down-mouse or something similar. It also has the limitation that the restoration only occurs using org-mark-ring-goto, unless you specifically run the  (restore-saved-restriction) function yourself. That could be made an interactive function for that purpose. Otherwise, this seems like a reasonable approach.


* DONE Line numbers in org-mode code blocks
  CLOSED: [2015-10-13 Tue 08:58]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/10/13 08:58:34
  :updated:  2015/10/13 08:58:34
  :ID:       D3E10CB6-964C-48D7-B375-B1CF7AA2A007
  :END:

Some of my students have wanted to show line numbers in code blocks. This is especially useful for when you run a Python block, and you get an error message with a line number in it. Right now, to figure out which line that is, you have to into the code block, type C-c ' to get into edit mode, and turn line numbers on. We look into how to achieve that here.

You may want to see the video here: https://www.youtube.com/watch?v=kinWijGzXms.

First, we need to get the region that is the code block. We can find some info in the org-element, but, the :begin and :end include lines we don't want, like the header lines, and the results. But, we can get the beginning, and maybe from there search forward to the block. Run this code block to see where the point goes.

#+name: boring-example
#+BEGIN_SRC emacs-lisp
;; a boring comment

(progn
  (+ 40 2))

(goto-char (org-element-property :begin (org-element-context)))
(re-search-forward (regexp-quote (org-element-property :value (org-element-context))))
(goto-char (match-beginning 0))
;; number of lines in block. The last carriage return doesn't count.
(1- (length (s-split "\n" (org-element-property :value (org-element-context)))))
#+END_SRC

#+RESULTS: boring-example
: 9

So, we can get the number of lines, and move the point to the first line. For numbers, we will use overlays. Here is a simple way to put a number at the beginning of a line.

#+BEGIN_SRC emacs-lisp
(let (ov)
  (beginning-of-line)
  (setq ov (make-overlay (point) (point)))
  (overlay-put ov 'before-string "1"))
#+END_SRC

#+RESULTS:
: 1

The next thing to do is make a function that puts a number at the beginning of a line. We might as well store these overlays in a variable, so they are easy to remove later. This is just for exploration of how to do it. Later we combine all these pieces together.

#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line (N)
 "Put an overlay at the beginning of a line."
  (beginning-of-line)
  (let (ov)
    (setq ov (make-overlay (point) (point)))
    (overlay-put ov 'before-string (format "%3s" (number-to-string N)))
    (add-to-list 'number-line-overlays ov)))

(number-line 4)
#+END_SRC

#+RESULTS:
| #<overlay from 1782 to 1782 in blog.org> |


That looks promising. Let's make a function to clear those overlays. It is so easy it may not even be worth writing.

#+BEGIN_SRC emacs-lisp
(defun number-line-clear ()
  (mapc 'delete-overlay number-line-overlays)
  (setq number-line-overlays '()))

(number-line-clear)
#+END_SRC

#+RESULTS:

Finally, we are ready to hack up the code block numbering code. The numbers will not automatically update, so we will write a function that numbers the block, but only temporarily. Any key press will get rid of the numbers so we can get back to work.  I am going to go ahead and make this a stand-alone function and block.

#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line-src-block ()
  (interactive)
  (save-excursion
    (let* ((src-block (org-element-context))
	   (nlines (- (length
		       (s-split
			"\n"
			(org-element-property :value src-block)))
		      1)))
      (goto-char (org-element-property :begin src-block))
      (re-search-forward (regexp-quote (org-element-property :value src-block)))
      (goto-char (match-beginning 0))

      (loop for i from 1 to nlines
	    do
	    (beginning-of-line)
	    (let (ov)
	      (setq ov (make-overlay (point) (point)))
	      (overlay-put ov 'before-string (format "%3s" (number-to-string i)))
	      (add-to-list 'number-line-overlays ov))
	    (next-line))))

  ;; now read a char to clear them
  (read-key "Press a key to clear numbers.")
  (mapc 'delete-overlay number-line-overlays)
  (setq number-line-overlays '()))

(number-line-src-block)
#+END_SRC

#+RESULTS:

I am not sure how to get the numbers to automatically update smoothly like they do in linum-mode. That code uses a lot of hooks to make updates work, and embeds them in a minor mode to get rid of them. It also puts them in the fringe I think, but it is not clear how that is done.

We could modify what happens after the numbers are put on, e.g. pressing numbers might jump to a line, or some other kind of functionality. I don't have a critical need for this right now, so I didn't explore it more. Let me know if you have any good ideas for it!


Let's try a variation of that code that allows us to type a number to jump to a line, or quit it.

#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line-src-block ()
  (interactive)
  (save-excursion
    (let* ((src-block (org-element-context))
	   (nlines (- (length
		       (s-split
			"\n"
			(org-element-property :value src-block)))
		      1)))
      (goto-char (org-element-property :begin src-block))
      (re-search-forward (regexp-quote (org-element-property :value src-block)))
      (goto-char (match-beginning 0))

      (loop for i from 1 to nlines
	    do
	    (beginning-of-line)
	    (let (ov)
	      (setq ov (make-overlay (point) (point)))
	      (overlay-put ov 'before-string (format "%3s" (number-to-string i)))
	      (add-to-list 'number-line-overlays ov))
	    (next-line))))

  (let ((entry (read-string "Jump to line number (enter to quit):")))
    (cond
     ((string-match "[0-9*]" entry)
      (progn
          (goto-char (org-element-property :begin (org-element-context)))
       (forward-line (string-to-number entry)))))
    (mapc 'delete-overlay number-line-overlays)
    (setq number-line-overlays '())))

(number-line-src-block)
#+END_SRC
#+RESULTS:

* DONE Automatic latex image toggling when cursor is on a fragment
  CLOSED: [2015-10-09 Fri 11:54]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/10/09 11:54:50
  :updated:  2015/10/09 11:54:50
  :ID:       916BC9DD-4E82-4BE0-A950-B4F20DFF2FA2
  :END:

There was a recent suggestion on the org-mode mailing list to make it possible to toggle individual equations in org-mode when the cursor is on them, and have them toggle back when the mouse is off. Presumably, this would let you edit the equation and see the result very easily.

The strategy to enable this is to use add a function to the post-command function hook. The function will store the last fragment/environment you were on, and compare it to where you are now.  If they are different the function will put the overlay back on the previous point, and do something appropriate at the current point, e.g. nothing if you are not on a fragment, or remove the overlay of the fragment you are on. The function will get run after every command, so we make sure we are in org-mode first!

Here are some example equations.

Here is a sentence with an equation $f^{2x}=3$ and another form \(e^x = 20\) in it.

Here is a standalone equation environment.

\begin{equation}
a + b \sqrt{5o}
\end{equation}

And now, \[15 + 7 = 12\],

It is easiest to see this in a video here: https://www.youtube.com/watch?v=E0s3PDBqsEc

#+BEGIN_SRC emacs-lisp
(defvar org-latex-fragment-last nil
  "Holds last fragment/environment you were on.")

(setq org-latex-fragment-last nil)

(defun org-latex-fragment-toggle ()
  "Toggle a latex fragment image "
  (and (eq 'org-mode major-mode)
       (let* ((el (org-element-context))
	      (el-type (car el)))
	 (cond
	  ;; were on a fragment and now on a new fragment
	  ((and
	    ;; fragment we were on
	    org-latex-fragment-last
	    ;; and are on a fragment now
	    (or
	     (eq 'latex-fragment el-type)
	     (eq 'latex-environment el-type))
	    ;; but not on the last one this is a little tricky. as you edit the
	    ;; fragment, it is not equal to the last one. We use the begin
	    ;; property which is less likely to change for the comparison.
	    (not (= (org-element-property :begin el)
		    (org-element-property :begin org-latex-fragment-last))))
	   ;; go back to last one and put image back
	   (save-excursion
	     (goto-char (org-element-property :begin org-latex-fragment-last))
	     (org-preview-latex-fragment))
	   ;; now remove current image
           (goto-char (org-element-property :begin el))
	   (let ((ov (loop for ov in org-latex-fragment-image-overlays
			   if
			   (and
			    (<= (overlay-start ov) (point))
			    (>= (overlay-end ov) (point)))
			   return ov)))
	     (when ov
	       (delete-overlaqy ov)))
	   ;; and save new fragment
	   (setq org-latex-fragment-last el))

	  ;; were on a fragment and now are not on a fragment
	  ((and
	    ;; not on a fragment now
	    (not (or
		  (eq 'latex-fragment el-type)
		  (eq 'latex-environment el-type)))
	    ;; but we were on one
	    org-latex-fragment-last)
	   ;; put image back on
	   (save-excursion
	     (goto-char (org-element-property :begin org-latex-fragment-last))
	     (org-preview-latex-fragment))
	   ;; unset last fragment
	   (setq org-latex-fragment-last nil))

	  ;; were not on a fragment, and now are
	  ((and
	    ;; we were not one one
	    (not org-latex-fragment-last)
	    ;; but now we are
	    (or
	     (eq 'latex-fragment el-type)
	     (eq 'latex-environment el-type)))
	   (goto-char (org-element-property :begin el))
           ;; remove image
	   (let ((ov (loop for ov in org-latex-fragment-image-overlays
			   if
			   (and
			    (<= (overlay-start ov) (point))
			    (>= (overlay-end ov) (point)))
			   return ov)))
	     (when ov
	       (delete-overlay ov)))
	   (setq org-latex-fragment-last el))))))


(add-hook 'post-command-hook 'org-latex-fragment-toggle)
#+END_SRC

#+RESULTS:
| org-latex-fragment-toggle | eldoc-schedule-timer |


I think there could be another way to do this with text properties, e.g. point-left and point-entered, but that would require those properties to be set on the fragments. I might try that approach another day.


* DONE COMPLETED A checkbox list in org-mode with one value
  CLOSED: [2015-10-07 Wed 11:56]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/10/05 19:15:25
  :updated:  2015/10/05 19:15:25
  :ID:       294F8531-9032-4114-B0B1-212235BCDE18
  :END:

A while ago I had a need for a checklist in org-mode where only one value would be checked at a time. Like a radio button in a browser form. That isn't as far as I know a feature yet, but it was not hard to achieve thanks to the org-element api.  My simple idea is to make a function that will be added to the org-checkbox-statistics-hook. The function will uncheck all the boxes, and recheck the one you just clicked with a hybrid of manipulating the cursor and inserting characters with org-element code. We will use an attribute on the checklist to indicate it is a "radio" list. This seems like a feature that might already exist, but I couldn't find it.

Here is the code we run. First, we make sure we are on a plain list that has an attr_org property of ":radio", that way this won't apply to all lists, just the radio lists. Then, we loop through each element in the structure, and if it is checked, we replace [X] with [ ]. Then, we reinsert the X and delete a space, which puts [X] where we originally clicked, or used C-c C-c. Finally, we add it to the hook, so it only gets run when a checkbox is changed via clicking with org-mouse, or C-c C-c. Of course, this doesn't work if you type X in the box.

#+BEGIN_SRC emacs-lisp
(require 'dash)
(defun check-hook-fn ()
  (when (-contains? (org-element-property
		     :attr_org
		     (org-element-property :parent (org-element-context)))
		    ":radio")
    (save-excursion
      (loop for el in (org-element-property :structure (org-element-context))
	    do
	    (goto-char (car el))
	    (when (re-search-forward "\\[X\\]" (line-end-position) t)
	      (replace-match "[ ]"))))
    (forward-char)
    (insert "X")
    (delete-char 1)))

(add-hook 'org-checkbox-statistics-hook 'check-hook-fn)
#+END_SRC

#+RESULTS:
| check-hook-fn |

Here is a regular checklist. You can check as many as you want.
- [X] one
- [X] two
- [ ] three

Now, here is a radio checklist. Only one item at a time can be checked. Nice!

#+attr_org: :radio
#+name: test
: hello world
: Fri Nov 20 06:14:45 2015

It is worth noting here that if we put a name on the list, it becomes an addressable data source. First we need this convenient function to get the data associated with a named list.

#+BEGIN_SRC emacs-lisp
(defun org-get-plain-list (name)
  "Get the org-element representation of a plain-list with NAME."
  (catch 'found
    (org-element-map
	(org-element-parse-buffer)
	'plain-list
      (lambda (plain-list)
	(when
	    (string= name (org-element-property :name plain-list))
	  (throw 'found plain-list))))))
#+END_SRC

#+RESULTS:
: org-get-plain-list

Now, let's use that to get the value of the checked item in the "test" list. We define the item as everything after the [X] and get it from a regular expression match.

#+BEGIN_SRC emacs-lisp
(defun get-radio-list-value (list-name)
  "Return the value of the checked item in a radio list."
  (save-excursion
    (loop for el in (org-element-property
		     :structure
		     (org-jump-to-plain-list list-name))
	  if (string= (nth 4 el) "[X]")
	  return (progn
		   (let ((item (buffer-substring (car el) (car (last el)))))
		     (string-match "\\[X\\]\\(.*\\)$" item)
		     (match-string 1 item))))))

(get-radio-list-value "test")
#+END_SRC

#+RESULTS:
:  c

Perfect. This has lots of potential applications. Data collection and quizzes come to mind, with associated ability to autograde and aggregate the data!


* DONE A framework for automated feedback with Python and org-mode
  CLOSED: [2015-10-03 Sat 20:23]
  :PROPERTIES:
  :categories: emacs,python
  :date:     2015/10/03 20:23:29
  :updated:  2015/10/03 20:29:00
  :ID:       7768E0FC-AB4E-40B7-9F32-DBFE19488B56
  :END:

[[http://docs.autolab.cs.cmu.edu][Autolab]] is an autograding service that automatically grades code assignments. It uses a program to evaluate a program on a secure virtual system. Using this requires you to run a server, and run code from students. I have never liked that because it is hard to sandbox code well enough to prevent malicious code from doing bad things. Autolab does it well, but it is a heavy solution. Here we explore a local version, one that is used to test for correctness, and not for grading. Here, if you are malicious, you reap what you sow...

The basic idea I am working towards is that Emacs will provide content to be learned (through org-mode) with active exercises. The exercises will involve a code block, and the user will run a command on their code (or an advised C-c C-c) that checks the solution for correctness. A user will be able to see the solution, and maybe get hints.

Suppose we have a problem to solve $e^x = 3$. This is a simple problem to solve, and here is a solution.

#+BEGIN_SRC python
from scipy.optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)

print solve()
#+END_SRC

#+RESULTS:
: [ 1.09861229]

We would like to test this for correctness. We code this in a function-based form because we will later use the function =solve= to test for correctness. Let's see how we could test it with a test function. We will use exec on a string representing our code to get it into our namespace. I don't see a security issue here. You are writing the code! Eventually, we will be passing code to the test framework this way from an org-mode source block.

#+BEGIN_SRC python
import unittest
TOLERANCE = 1e-5

s = '''from scipy.optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)[0]

print solve()'''

def test_solve(s):
    exec s in globals()
    if (abs(np.log(3) - solve()) <= TOLERANCE):
        print('Correct')
    else:
        print('incorrect')

test_solve(s)
#+END_SRC

#+RESULTS:
: 1.09861228867
: Correct

Next, we need to think about how we could generate an import statement from a code block name, import in python, and run a test function. We can assume that the test code will be in a file called "test_%s.py" on your python path. Here are the contents of test_solve.py.

#+BEGIN_SRC python :tangle test_solve.py
import numpy as np
TOLERANCE = 1e-5

def solve_solution():
    from scipy. optimize import fsolve
    import numpy as np

    def objective(x):
        return np.exp(x) - 3

    return fsolve(objective, 3)[0]


def test_solve(s):
    exec s in globals()
    if (abs(solve_solution() - solve()) <= TOLERANCE):
        print('Correct!')
    else:
        print('Incorrect')
#+END_SRC

#+RESULTS:

Now, we can import that, and use the functions. Here is the Python script we need to run to test it.

#+BEGIN_SRC python
import test_solve
test_solve.test_solve('''
from scipy. optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)[0]

print solve()''')
#+END_SRC

#+RESULTS:
: 1.09861228867
: Correct!

Now, an elisp block to do that. One way to do this is to just run a shell command passing the string to a python interpreter. This is a short way away from an Emacs command now.

#+BEGIN_SRC emacs-lisp
(let* ((string "import test_solve
test_solve.test_solve('''
from scipy. optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)[0]

print solve()''')"))
  (shell-command-to-string (format "python -c \"%s\"" string)))

#+END_SRC

#+RESULTS:
: 1.09861228867
: Correct!

Ok, now to wrap it all up in a function we can run from Emacs in a code block to test it. With the cursor in a code block, we get the name, and build the python code, and run it. The function is more complex than I anticipated because I end up  running the code block essentially twice, once to get a results block and once to get the test results. For short problems this is not an issue. I also add the test results in a way that is compatible with the current results.

#+BEGIN_SRC emacs-lisp
(defun check ()
  (interactive)
  (let* ((src-block (org-element-context))
	 (name (org-element-property :name src-block))
	 (code (org-element-property :value src-block))
         (end (org-element-property :end src-block))
	 (results)
	 (template (format "import test_%s
test_%s.test_%s('''%s''')" name name name code))
	 (output (format
		  "\n%s\n"
		  (s-join
		   "\n"
		   (mapcar
		    (lambda (s)
		      (if (s-starts-with? ":" s)
			  s
			(concat ": " s)))
		    (s-split
		     "\n"
		     (shell-command-to-string
		      (format "python -c \"%s\"" template))))))))
    ;; execute block as normal
    (org-babel-execute-src-block)
    ;; and add some output to the Results block
    (if (org-babel-where-is-src-block-result)
	(progn
	  (goto-char (org-babel-where-is-src-block-result))
	  (setq results (org-element-context))
	  ;; delete results line
          (kill-line)
	  ;;  delete the results
	  (setf (buffer-substring (org-element-property :begin results)
				  (org-element-property :post-affiliated results))
		"")
	  ;; paste results line back
          (yank)
	  ;; and the output from your code
          (insert output))
      (message "%s" output))))
#+END_SRC

#+RESULTS:
: check

Now, we use a named src-block so we can call M-x check in it, and check the answer.

#+name: solve
#+BEGIN_SRC python :results output
from scipy.optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)

print solve()
#+END_SRC

#+RESULTS: solve
: [ 1.09861229]
: Correct!
:

I would like to be able to provide a solution function that would show a user my solution they were tested against. Python provides the =inspect= module that can do this. Here is how we get the code in Python.

#+BEGIN_SRC python
import inspect
import test_solve

print inspect.getsource(test_solve.solve_solution)
#+END_SRC

#+RESULTS:
: def solve_solution():
:     from scipy. optimize import fsolve
:     import numpy as np
:
:     def objective(x):
:         return np.exp(x) - 3
:
:     return fsolve(objective, 3)[0]
:

This makes it easy to wrap up a function in emacs that will show this from at src block. We just get the block name, and build the python code and execute it here.

#+BEGIN_SRC emacs-lisp
(defun show-solution ()
  (interactive)
  (let* ((src-block (org-element-context))
	 (name (org-element-property :name src-block))
	 (template (format  "import inspect
import test_%s

print inspect.getsource(test_%s.%s_solution)" name name name)))
    (switch-to-buffer-other-window (get-buffer-create "solution"))
    (erase-buffer)
    (insert (shell-command-to-string
	     (format "python -c \"%s\"" template)))
    (python-mode)))
#+END_SRC

#+RESULTS:
: show-solution

That summarizes the main features. It allows me to write a test module that has some name conventions to define a solution function, and a test function. Emacs can generate some boilerplate code for different problem names, and run the test to give the user some feedback. Most of the code in this post would not be directly visible to a user, it would be buried in a python module somewhere on the path, and in elisp files providing the glue. I am not sure how much obfuscation you can put in the python files, e.g. just providing byte-compiled code, so it is less easy to just read it. That is not as big a deal when it is just a study guide/feedback system.

From an authoring point of view, this seems pretty good to me. It is feasible I think to write an org-source document like this with tangling for the test modules, and an export to org that does not have the solutions in it. The only subtle point might be needing to alter Python paths to find the test modules if they aren't installed via something like pip.


I think this is pretty flexible, and could handle problems that take arguments, e.g. write a function that sorts a list. Here is a simple example of that. First we write the test_sort.py file with a solution, and some tests.

#+BEGIN_SRC python :tangle test_sort.py
def sort_solution(LIST):
    return LIST.sort()

def test_sort(s):
    exec s in globals()
    if sort([3, 4, 2]) == [2, 3, 4]:
        print('passed test 1')
    if sort(['z', 'b']) == ['b', 'z']:
        print('passed test 2')
#+END_SRC


#+name: sort
#+BEGIN_SRC python
def sort(LIST):
    s = sorted(LIST)
    return s
#+END_SRC
#+RESULTS: sort
: passed test 1
: passed test 2
:

Maybe it would make sense to use unittests, or nose or some other testing framework if it makes writing the tests easier. Another day.


* DONE Upping my Emacs navigation game
  CLOSED: [2015-09-27 Sun 21:21]
  :PROPERTIES:
  :categories: emacs,hydra
  :date:     2015/09/27 21:21:51
  :updated:  2015/09/27 21:21:51
  :ID:       E2633C1C-36B4-46D1-B1CA-F4357D9561B8
  :END:

I have been trying to up my navigation game in Emacs, by which I mean I want to get my cursor where I want it with a minimal number of keystrokes, and preferrably no mouse actions. There are lots of little and big navigations I do a lot:
1. forward/backward by a character
2. forward/backward by a word/subword
3. forward/backward by a sentence
4. forward/backward by a line
5. to the beginning and end of a line
6. to the beginning and end of a sentence
7. to the beginning and end of a paragraph
8. to the beginning and end of a page
9. to the beginning and end of a buffer
10. scrolling up/down
11. into another window
12. back and forth to buffers

Occasionally, I want to save a location so I can easily get back to it. Not all of these are strictly speaking navigation in the usual sense, but they are things I do often enough. There are Emacs commands for all these, and keyboard shortcuts for many of them, but I don't use them often, and as a result I don't remember them either.

Here I develop a [[https://github.com/abo-abo/hydra][hydra]] that will provide these features. Hydra is a super amazing, menu prompting system that provides hints to remind you of what can be done, and to access it from a character. It is possible to pass numeric and universal arguments to the commands by typing -, a number, or C-u before pressing the character.

I want some commands to be repeatable, which we get with a "red" hydra, and some commands to exit on running, which we get with a "blue" head. So, here is an over-the-top hydra for navigation.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-navigate (:color red
                          :hint nil)
  "
_f_: forward-char       _w_: forward-word       _n_: next-line
_b_: backward-char      _W_: backward-word      _p_: previous-line
^ ^                     _o_: subword-right      _,_: beginning-of-line
^ ^                     _O_: subword-left       _._: end-of-line

_s_: forward sentence   _a_: forward paragraph  _g_: forward page
_S_: backward sentence  _A_: backward paragraph _G_: backward page

_h_: helm mini _B_: buffer list _i_: window
_<left>_: previous buffer   _<right>_: next buffer
_<up>_: scroll-up           _<down>_: scroll-down

_[_: backward-sexp _]_: forward-sexp
_<_ beginning of buffer _>_ end of buffer _m_: set mark _/_: jump to mark
"
  ("f" forward-char)
  ("b" backward-char)
  ("w" forward-word)
  ("W" backward-word)
  ("n" next-line)
  ("p" previous-line)
  ("o" subword-right)
  ("O" subword-left)
  ("s" forward-sentence)
  ("S" backward-sentence)
  ("a" forward-paragraph)
  ("A" backward-paragraph)
  ("g" forward-page)
  ("G" backward-page)
  ("<right>" next-buffer)
  ("<left>" previous-buffer)
  ("h" helm-mini :color blue)
  ("i" ace-window :color blue)
  ("m" org-mark-ring-push)
  ("/" org-mark-ring-goto :color blue)
  ("B" helm-buffers-list)
  ("<up>" scroll-up)
  ("<down>" scroll-down)
  ("<" beginning-of-buffer)
  (">" end-of-buffer)
  ("." end-of-line)
  ("[" backward-sexp)
  ("]" forward-sexp)
  ("," beginning-of-line)
  ("q" nil "quit" :color blue))

(global-set-key (kbd "s-n") 'hydra-navigate/body)
#+END_SRC

#+RESULTS:
: hydra-navigate/body

I basically like it. The menu is a little on the large side, but it makes for easy modal navigation in a buffer, to other windows, and other buffers. On the whole for moderate cursor movements, this results in basically equal keystrokes. For example, to move 3 characters forward, we have C-f C-f C-f or C-u 3 C-f, or s-n 3 f. The advantage (I think) is a single interface to all these navigation commands with hints on what to do.

There is still another level of navigation, which is related to navigation by searching. That is a whole different level of navigation I will work on another day!


* DONE COMPLETED A cursor goto hydra for emacs
  CLOSED: [2015-09-28 Mon 19:20]
  :PROPERTIES:
  :categories: emacs,hydra
  :date:     2015/09/28 16:38:11
  :updated:  2015/09/28 16:38:11
  :ID:       09A41060-4215-4AFB-A518-AC604C120C2F
  :END:

In the spirit of upping my navigation game, here we examine navigation by search like methods. You probably know about C-s with will search forward for a word, and C-r which will search backwards. This will get you to the start of a word pretty easily. It won't get you into a word though, you have to navigate to that, and it isn't too handy to get to a line, or window, or headline in an org-file. Each of these is an emacs command, which as with navigation I don't always remember. Today, we build a hydra to make this easy too.

We will use features from [[https://github.com/abo-abo/avy][avy]], and [[https://github.com/emacs-helm/helm][helm]], and some standard emacs features. =avy= is pretty neat. It provides an interface to jump to characters, words and subwords by pressing keys. To jump to a character that is visible on the screen, you invoke avy-goto-char and press the character you want to jump to. =avy= will overlay a sequence of keys you then type to jump to that character. It might be more convenient to jump to a pair of characters, which you do by invoking avy-goto-char-2. Similarly, there are commands to jump to the beginning of a word, and a subword, both with variations that allow you to specify the beginning letter of the word, or to get overlays on every word.

I spend most of my days in org-files, so I frequently want to jump to an org headline in the current buffer, or some headline in an org-file in my agenda. Helm provides a nice set of functions for this in helm-org-headlines and helm-org-agenda-files-headings. We can also use helm-multi-swoop-org to use the swoop search function in all open org-buffers with helm selection. Within a buffer, you might also use the search forward and backward capabilities, or the more advanced helm-occur or swiper-helm features.
Finally, I may want my cursor to go to another recent file, or open buffer.

The hydra we will develop here puts all of these commands a few keystrokes away, with a hint system to remind you what is possible. In addition to these "goto" commands, I add a character to switch to the navigation hydra we developed in the last [[http://kitchingroup.cheme.cmu.edu/blog/2015/09/27/Upping-my-Emacs-navigation-game/][post]] so I can switch to navigation if I change my mind. I also put two commands to store the current position before the goto command, and to return to that stored position conveniently. I bind this hydra to super-g, because the super key isn't used much on my Mac, and g reminds of "goto". So, here is my hydra code:

#+BEGIN_SRC emacs-lisp
(defhydra goto (:color blue :hint nil)
  "
Goto:
^Char^              ^Word^                ^org^                    ^search^
^^^^^^^^---------------------------------------------------------------------------
_c_: 2 chars        _w_: word by char     _h_: headline in buffer  _o_: helm-occur
_C_: char           _W_: some word        _a_: heading in agenda   _p_: helm-swiper
_L_: char in line   _s_: subword by char  _q_: swoop org buffers   _f_: search forward
^  ^                _S_: some subword     ^ ^                      _b_: search backward
-----------------------------------------------------------------------------------
_B_: helm-buffers       _l_: avy-goto-line
_m_: helm-mini          _i_: ace-window
_R_: helm-recentf

_n_: Navigate           _._: mark position _/_: jump to mark
"
  ("c" avy-goto-char-2)
  ("C" avy-goto-char)
  ("L" avy-goto-char-in-line)
  ("w" avy-goto-word-1)
  ;; jump to beginning of some word
  ("W" avy-goto-word-0)
  ;; jump to subword starting with a char
  ("s" avy-goto-subword-1)
  ;; jump to some subword
  ("S" avy-goto-subword-0)

  ("l" avy-goto-line)
  ("i" ace-window)

  ("h" helm-org-headlines)
  ("a" helm-org-agenda-files-headings)
  ("q" helm-multi-swoop-org)

  ("o" helm-occur)
  ("p" swiper-helm)

  ("f" isearch-forward)
  ("b" isearch-backward)

  ("." org-mark-ring-push :color red)
  ("/" org-mark-ring-goto :color blue)
  ("B" helm-buffers-list)
  ("m" helm-mini)
  ("R" helm-recentf)
  ("n" hydra-navigate/body))

(global-set-key (kbd "s-g") 'goto/body)
#+END_SRC

As with the last navigation hydra, this is a pretty massive set of options and takes up some decent screen space at the bottom om my emacs. They are mostly here to remind me that there are better navigation options, and with practice I suspect muscle memory will provide fast navigation tools with more precision and fewer keystrokes than simple navigation.


* DONE YAT - yet another template strategy
  CLOSED: [2015-11-01 Sun 14:12]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/11/01 14:12:34
  :updated:  2015/11/01 14:12:34
  :ID:       36BA44F6-BE53-4634-A1D7-F7641464C73A
  :END:

I have another need for a template that is dynamically evaluated. I previously wrote about this [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/26/Another-alternative-to-string-templates/][here]], and today I am going to do a variation of the theme. We will still use a syntax of $(expression), but a new approach to evaluating the expression. I saw this interesting function to evaluate and replace an s-expression in a buffer [[http://emacsredux.com/blog/2013/06/21/eval-and-replace/][Eval and Replace - Emacs Redux]]. I am going use that to replace a template expression in a string, with a little variation to avoid replacing non-sexp variations, e.g. $(. Here we go.

#+BEGIN_SRC emacs-lisp
(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (princ (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (concat "$" (current-kill 0))))))

(defun j-format (s)
  "Replace all instances of $(expression) in S with the evaluated
expression."
  (with-temp-buffer
    (insert s)
    (goto-char (point-min))
    (while (re-search-forward "$(" nil t)
      (backward-char)
      (when (sexp-at-point)
	;; get rid of the $
	(delete-char -1)
	;; go to the end of the sexp and then eval-and-replace it.
	(end-of-sexp)
	(eval-and-replace)))
    ;; return the formatted text.
    (buffer-string)))


(let ((some-var "You got me"))
  (j-format "Test of 4 + 5 = $(+ 4 5). $(  $(foobar). $(progn (setq x 5) \"\")
and then we have 2x=$(prin1 (* 2 x)).

some-var = $(print some-var)"))
#+END_SRC

#+RESULTS:
: Test of 4 + 5 = 9. $(  $(foobar).
: and then we have 2x=10.
:
: some-var = You got me

That seems pretty ok. I obviously have not tested it extensively, but it looks pretty promising.

* DONE Checking for email attachments before you send email
  CLOSED: [2015-09-04 Fri 19:03]
  :PROPERTIES:
  :categories: emacs,email
  :date:     2015/09/04 19:03:53
  :updated:  2015/09/04 19:04:15
  :ID:       0386FC97-C779-4B4F-8854-507753E2D27D
  :END:
Does this comic (http://www.phdcomics.com/comics/archive.php?comicid=1817) apply to you? Do you miss the Gmail feature that will alert you that it seems like you mention an attachment but there isn't one attached before it lets you send it? Let's make Emacs help us here. We will scan our emails for the word "attach", and if we see it, scan the email for evidence of an attachment. Then create a hook function that will prompt us if it appears we mention an attachment, but don't have one.

An attachment looks like this in my messages:
#+BEGIN_EXAMPLE
<#part type="image/png" filename="~/Desktop/wordcloud.png" disposition=attachment>
<#/part>
#+END_EXAMPLE

So, probably finding "<#part" in the buffer means I probably have an attachment. We will use the message-send-hook to run this function. Here is the code. Some brief testing from me seems to work fine! It is pretty simple, but probably good enough to save me from sending messages with no attachment, and not too intrusive for when no attachment is actually needed, e.g. in replies. Let me know if you have ideas for improvements.

#+BEGIN_SRC emacs-lisp
(defun email-says-attach-p ()
  "Return t if email suggests there could be an attachment."
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "attach" nil t)))

(defun email-has-attachment-p ()
  "Return t if the currently open email has an attachment"
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "<#part" nil t)))

(defun email-pre-send-check-attachment ()
  (when (and (email-says-attach-p)
	     (not (email-has-attachment-p)))
    (unless
	(y-or-n-p "Your email suggests you need an attachment, but no attachment was found. Send anyway?")
      (error "It seems an attachment is needed, but none was found. Aborting send."))))

(add-hook 'message-send-hook 'email-pre-send-check-attachment)
#+END_SRC

* DONE Author impact factors
  CLOSED: [2015-08-11 Tue 09:12]
  :PROPERTIES:
  :categories: bibliometrics
  :date:     2015/08/11 09:12:19
  :updated:  2015/08/11 09:12:19
  :ID:       6E3508B3-A5A0-4F3C-AE6B-58945AB3D6FC
  :END:

In this new letter http://pubs.acs.org/doi/pdf/10.1021/acs.jpclett.5b01527, the editors suggest a new "Author Impact Factor" as a way to measure the productivity and impact of an author independently of the journals they publish in. The AIF is defined for a year like this: take the paper published in two consecutive years, get the citations for those papers in the following year, and compute:

\(AIF = \frac{Y3 citations for papers_{Y1,Y2}}{Number of papers in Y1, Y2}\).

Here I do this for myself, using Scopus as the source of papers and citations. My Scopus ID is
scopusid:7004212771. First, we need to get the articles published in 2012 and 2013. Here is the query, and the results.

#+BEGIN_SRC python :results html
from scopus import *
from scopus.scopus_api import ScopusAbstract

s = ScopusSearch(query='au-id(7004212771) and (pubyear is 2012 or pubyear is 2013)',
                 fields='dc:identifier')

abstracts = [ScopusAbstract(eid) for eid in s.EIDS
             if ScopusAbstract(eid).aggregationType == 'Journal']

print('<ol>')
for ab in abstracts:
    print('<li>' + ab.html + '</li>')
print('</ol>')
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<ol>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Anita S. Lee</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=35603120700">John C. Eslick</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55772901000">David C. Miller</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84880986072&origin=inward">Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=6200180161">International Journal of Greenhouse Gas Control</a>, <b>18</b>, p. 68-74, (2013-10-01). <a href="http://dx.doi.org/10.1016/j.ijggc.2013.06.020">doi:10.1016/j.ijggc.2013.06.020</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569145100">Alexander P. Hallenbeck</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84881394200&origin=inward">Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=13057">Industrial and Engineering Chemistry Research</a>, <b>52(31)</b>, p. 10788-10794, (2013-08-07). <a href="http://dx.doi.org/10.1021/ie400582a">doi:10.1021/ie400582a</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55373026900">James X. Mao</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Anita S. Lee</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Hunaid B. Nulwala</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">David R. Luebke</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Krishnan Damodaran</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84873706643&origin=inward">Interactions in 1-ethyl-3-methyl imidazolium tetracyanoborate ion pair: Spectroscopic and density functional study</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=24642">Journal of Molecular Structure</a>, <b>1038</b>, p. 12-18, (2013-04-24). <a href="http://dx.doi.org/10.1016/j.molstruc.2013.01.046">doi:10.1016/j.molstruc.2013.01.046</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=26433085700">Federico Calle-Vallejo</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23479647900">Nilay G. Inoglu</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=25224517700">Hai-Yan Su</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=27667815700">JosÃ© I. MartÃ­nez</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=35491189200">Isabela C. Man</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7006205398">Marc T. M. Koper</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=9742604300">Jan Rossmeisl</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84876703352&origin=inward">Number of outer electrons as descriptor for adsorption processes on transition metals and their oxides</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=19700200838">Chemical Science</a>, <b>4(3)</b>, p. 1245-1249, (2013-03-01). <a href="http://dx.doi.org/10.1039/c2sc21601a">doi:10.1039/c2sc21601a</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Anita S. Lee</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84867809683&origin=inward">Chemical and molecular descriptors for the reactivity of amines with CO
                    2 </a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=13057">Industrial and Engineering Chemistry Research</a>, <b>51(42)</b>, p. 13609-13618, (2012-10-24). <a href="http://dx.doi.org/10.1021/ie301419q">doi:10.1021/ie301419q</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7201763336">Edward S. Rubin</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=27467500000">Hari Mantripragada</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55210428500">Aaron Marks</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=37081979100">Peter Versteeg</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84864914806&origin=inward">The outlook for improved carbon capture technology</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=27538">Progress in Energy and Combustion Science</a>, <b>38(5)</b>, p. 630-671, (2012-10-01). <a href="http://dx.doi.org/10.1016/j.pecs.2012.03.003">doi:10.1016/j.pecs.2012.03.003</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=52463103500">Sneha A. Akhade</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84865730756&origin=inward">Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=28134">Journal of Chemical Physics</a>, <b>137(8)</b>, Art. No. 084703, , (2012-08-28). <a href="http://dx.doi.org/10.1063/1.4746117">doi:10.1063/1.4746117</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=35787409400">James Landon</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55328415000">Ethan Demeter</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23479647900">Nilay InoÇ§lu</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=47962378000">Chris Keturakis</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7006804734">Israel E. Wachs</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8238710700">Relja VasiÄ‡</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24404182600">Anatoly I. Frenkel</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84864592302&origin=inward">Spectroscopic characterization of mixed Fe-Ni oxide electrocatalysts for the oxygen evolution reaction in alkaline electrolytes</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=19700188320">ACS Catalysis</a>, <b>2(8)</b>, p. 1793-1801, (2012-08-03). <a href="http://dx.doi.org/10.1021/cs3002644">doi:10.1021/cs3002644</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=54973276000">Robin Chao</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55308251800">Ratiporn Munprom</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=56347288000">Rumyana Petrova</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=12803603300">Kirk Gerdes</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004541416">Paul A. Salvador</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84863684845&origin=inward">Structure and relative thermal stability of mesoporous (La, Sr) MnO 3powders prepared using evaporation-induced self-assembly methods</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=20982">Journal of the American Ceramic Society</a>, <b>95(7)</b>, p. 2339-2346, (2012-07-01). <a href="http://dx.doi.org/10.1111/j.1551-2916.2012.05236.x">doi:10.1111/j.1551-2916.2012.05236.x</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84866142469&origin=inward">Preface: Trends in computational catalysis</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=21971">Topics in Catalysis</a>, <b>55(5-6)</b>, p. 227-228, (2012-06-01). <a href="http://dx.doi.org/10.1007/s11244-012-9808-0">doi:10.1007/s11244-012-9808-0</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=36472906200">W. Richard Alesi</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84861127526&origin=inward">Evaluation of a primary amine-functionalized ion-exchange resin for CO
                    2 capture</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=13057">Industrial and Engineering Chemistry Research</a>, <b>51(19)</b>, p. 6907-6915, (2012-05-16). <a href="http://dx.doi.org/10.1021/ie300452c">doi:10.1021/ie300452c</a>.</li>
</ol>
#+END_HTML

Now, we need to get the citing articles for each one of these, and only count them if they were published in 2014 or earlier. Each abstract has a cite_link in it, which points to the API url to get the articles citing it. Let's see what we are up against here. First, we see how many citations there are in total.

#+BEGIN_SRC python
from scopus import *
from scopus.scopus_api import get_encoded_text, ScopusAbstract
from scopus.my_scopus import MY_API_KEY

s = ScopusSearch(query='au-id(7004212771) and (pubyear is 2012 or pubyear is 2013)',
                 fields='dc:identifier')

abstracts = [ScopusAbstract(eid) for eid in s.EIDS
             if ScopusAbstract(eid).aggregationType == 'Journal']

import requests
import xml.etree.ElementTree as ET

TOTAL = 0
for ab in abstracts:
    xml = requests.get(ab.cite_link,
                       headers={'Accept': 'application/xml',
                                'X-ELS-APIKey': MY_API_KEY}).text.encode('utf-8')

    results = ET.fromstring(xml)
    N = int(get_encoded_text(results, 'opensearch:totalResults'))
    TOTAL += N
    print N

print '{} total citations'.format(TOTAL)
print TOTAL / float(11)
#+END_SRC

#+RESULTS:
#+begin_example
4
9
5
18
5
98
10
50
4
0
16
219 total citations
19.9090909091
#+end_example

Not bad looking, but some of those citations might be from 2015, and some of them might be self-citations.  Let's see about removing those. Usually, there are just 25 results per query, and some of the ones above have more than 25 results, so we will have to run a loop to get them all. For now, we just remove the citations from papers newer than the desired year It is a little tougher to remove the self-citations; that would require another request to Scopus to get authors and look for matches.

Here is some code that calculates my AIF for 2012, 2013 and 2014. The only issue I currently have with this code is the use of the abstract coverDate to get the publication year. I don't have a better way to do this, but I have seen a lot of cover dates that start on Jan 1 of a year, and that seems improbable to me. On the other hand, that might reflect a lot of submissions near the end of a year that just make it into the next one.

#+BEGIN_SRC python
from scopus import *
from scopus.scopus_api import get_encoded_text, ns, ScopusAbstract
from scopus.my_scopus import MY_API_KEY
import requests
import xml.etree.ElementTree as ET


QUERY = 'au-id(7004212771) and ((pubyear is {0}) or (pubyear is {1}))'

for YEAR in [2012, 2013, 2014]:

    print(QUERY.format(YEAR - 2, YEAR - 1))
    s = ScopusSearch(query=QUERY.format(YEAR - 2, YEAR - 1),
                     fields='dc:identifier')

    abstracts = [ScopusAbstract(eid) for eid in s.EIDS
                 if ScopusAbstract(eid).aggregationType == 'Journal']
    print '{0}-{1} papers'.format(YEAR - 2, YEAR - 1)
    print ' '.join(['doi:{}'.format(ab.doi) for ab in abstracts])
    TOTAL = 0 # citation count

    for ab in abstracts:
        xml = requests.get(ab.cite_link,
                           headers={'Accept': 'application/xml',
                                    'X-ELS-APIKey': MY_API_KEY}).text.encode('utf-8')

        results = ET.fromstring(xml)
        N = int(get_encoded_text(results, 'opensearch:totalResults'))

        start = 0
        count = 25

        while N > 0:
            xml = requests.get(ab.cite_link,
                               headers={'Accept': 'application/xml',
                                        'X-ELS-APIKey': MY_API_KEY},
                               params={'count': count,
                                       'start': start}).text.encode('utf-8')
            results = ET.fromstring(xml)

            start += count
            N -= count

            for el in results.findall('atom:entry/prism:coverDate', ns):
                year = int(el.text.split('-')[0])
                if year <= YEAR:
                    TOTAL += 1

    s = 'Author Impact Factor ({1}) = {0:1.3f} ({2} papers, {3} citations)\n'
    print(s.format(float(TOTAL) / len(abstracts),
                   YEAR,
                   len(abstracts),
                   TOTAL))
#+END_SRC

#+RESULTS:
#+begin_example
au-id(7004212771) and ((pubyear is 2010) or (pubyear is 2011))
2010-2011 papers
doi:10.1063/1.3631948 doi:10.1002/cctc.201000397 doi:10.1021/cs200039t doi:10.1063/1.3561287 doi:10.1002/cssc.201000056 doi:10.1149/1.3432440 doi:10.1103/PhysRevB.82.045414 doi:10.1016/j.fuel.2009.11.036 doi:10.1080/08927022.2010.481794
Author Impact Factor (2012) = 9.667 (9 papers, 87 citations)

au-id(7004212771) and ((pubyear is 2011) or (pubyear is 2012))
2011-2012 papers
doi:10.1021/ie301419q doi:10.1016/j.pecs.2012.03.003 doi:10.1063/1.4746117 doi:10.1021/cs3002644 doi:10.1111/j.1551-2916.2012.05236.x doi:10.1007/s11244-012-9808-0 doi:10.1021/ie300452c doi:10.1063/1.3631948 doi:10.1002/cctc.201000397 doi:10.1021/cs200039t doi:10.1063/1.3561287
Author Impact Factor (2013) = 14.000 (11 papers, 154 citations)

au-id(7004212771) and ((pubyear is 2012) or (pubyear is 2013))
2012-2013 papers
doi:10.1016/j.ijggc.2013.06.020 doi:10.1021/ie400582a doi:10.1016/j.molstruc.2013.01.046 doi:10.1039/c2sc21601a doi:10.1021/ie301419q doi:10.1016/j.pecs.2012.03.003 doi:10.1063/1.4746117 doi:10.1021/cs3002644 doi:10.1111/j.1551-2916.2012.05236.x doi:10.1007/s11244-012-9808-0 doi:10.1021/ie300452c
Author Impact Factor (2014) = 14.000 (11 papers, 154 citations)
#+end_example

Just a reminder of what these AIFs are. It is the ratio of the number of citations papers from two consecutive years (Y1 and Y2) have received in the next year Y3. These numbers suggest that on average my recent papers are getting 14 citations a year. I printed the DOIs above because I was skeptical that my AIF in 2013 and 2014 were identical, but it seems clear the papers are different, and it must be a coincidence that the number of citations is the same (I am still a bit skeptical though ;).

Is this a useful measure of author impact? That would take some study. The way this is defined it is a short-term impact which might be biased to some fields that have more than a three year time-frame before citations build up. That is fixed easily enough by increasing the window of publications, and/or counting citations two years out, for example. It is interesting this decouples the impact from the journals the articles are published in. I think this says I should be submitting my papers to higher impact journals though! My AIF exceeds the JIF of the journals I usually publish in.




* DONE Altmetrics meet my publications
  CLOSED: [2015-08-08 Sat 15:56]
  :PROPERTIES:
  :categories: publication,bibliometric
  :date:     2015/08/08 15:56:57
  :updated:  2015/08/08 15:56:57
  :ID:       36E056EB-05EE-4382-9646-B3D5B110EA69
  :END:
Altmetrics is an alternative to simple citation counts of articles. Altmetrics looks at how your papers are mentioned in Tweets, google+, blog posts, news, how many Mendeley users have the article, etc... They are partnering with publishers to provide additional metrics on your papers.

You can put some Altmetric badges on your papers so you can see how they are doing. In this post, we scrape out my papers from my orcid page, and add Altmetric badges to them. This is basically just a little snippet of html code that will put the Altmetric donut in the citation, which has some information about the number of times each paper is tweeted, etc...

#+BEGIN_HTML
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
#+END_HTML

So, here is a python script that will print some html results. We print each title with the Altmetric donut, and we add a Scopus Cited by count for each paper.

#+BEGIN_SRC python :results html
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})
results = resp.json()

data = []
TITLES, DOIs = [], []

badge = "<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='{doi}'></div>"
scopus_cite = "<img src=\"http://api.elsevier.com/content/abstract/citation-count?doi={doi}&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c\">"
html = '<a href="http://dx.doi.org/{doi}">{title}</a>'

print '<ol>'
for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    title = str(result['work-title']['title']['value'].encode('utf-8'))
    doi = 'None'

    for x in result.get('work-external-identifiers', []):
        for eid in result['work-external-identifiers']['work-external-identifier']:
            if eid['work-external-identifier-type'] == 'DOI':
                doi = str(eid['work-external-identifier-id']['value'].encode('utf-8'))

    # AIP journals tend to have a \n in the DOI, and the doi is the second line. we get
    # that here.
    if len(doi.split('\n')) == 2:
        doi = doi.split('\n')[1]

    pub_date = result.get('publication-date', None)
    if pub_date:
        year = pub_date.get('year', None).get('value').encode('utf-8')
    else:
        year = 'Unknown'

    # Try to minimize duplicate entries that are found
    dup = False
    if title.lower() in TITLES:
        dup = True
    if (doi != 'None'
        and doi.lower() in DOIs):
        dup = True

    if not dup and doi != 'None':
        # truncate title to first 50 characters
        print('<li>' + html.format(doi=doi, title=title)
              + badge.format(doi=doi) + scopus_cite.format(doi=doi)
              + '</li>\n')

    TITLES.append(title.lower())
    DOIs.append(doi.lower())

print '</ol>'
#+END_SRC

It is a little humbling to see these results! The Altmetric data shows a very different dimension than the citation metrics. It is hard to tell what impact these will have, but they give you another view of who is talking about your work.

#+RESULTS:
#+BEGIN_HTML
<ol>
<li><a href="http://dx.doi.org/10.1021/jp511426q">A Linear Response DFT+ U Study of Trends in the Oxygen Evolution Activity of Transition Metal Rutile Dioxides</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp511426q'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp511426q&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.4914093">Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.4914093'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4914093&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2015.02.011">Core level shifts in Cuâ€“Pd alloys as a function of bulk composition and structure</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2015.02.011'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2015.02.011&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/cs501585k">Estimating bulk-composition-dependent H2 adsorption energies on CuxPd1- x alloy (111) surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/cs501585k'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/cs501585k&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jp508805h">Probing the Coverage Dependence of Site and Adsorbate Configurational Correlations on (111) Surfaces of Late Transition Metals</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp508805h'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp508805h&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.catcom.2013.10.028'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ja5015986">Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ja5015986'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ja5015986&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/am4059149">Identifying Potential BO 2 Oxide Polymorphs for Epitaxial Growth Candidates</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/am4059149'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/am4059149&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1007/s11244-013-0166-3">Simulating temperature programmed desorption of oxygen on Pt(111) using DFT derived coverage dependent desorption barriers</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1007/s11244-013-0166-3'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1007/s11244-013-0166-3&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1039/c3ra47097k">Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/c3ra47097k'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/c3ra47097k&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jp507957n">Effects of concentration, crystal structure, magnetism, and electronic structure method on first-principles oxygen vacancy formation energy trends in perovskites</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp507957n'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp507957n&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ie400582a">Effects of O 2 and SO 2 on the Capture Capacity of a Primary-Amine Based Polymeric CO 2 Sorbent</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ie400582a'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ie400582a&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/http://dx.doi.org/10.1016/j.molstruc.2013.01.046">Interactions in 1-ethyl-3-methyl imidazolium tetracyanoborate ion pair: Spectroscopic and density functional study</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='http://dx.doi.org/10.1016/j.molstruc.2013.01.046'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=http://dx.doi.org/10.1016/j.molstruc.2013.01.046&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/http://dx.doi.org/10.1016/j.ijggc.2013.06.020">Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='http://dx.doi.org/10.1016/j.ijggc.2013.06.020'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=http://dx.doi.org/10.1016/j.ijggc.2013.06.020&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ie301419q">Chemical and Molecular Descriptors for the Reactivity of Amines with CO 2</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ie301419q'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ie301419q&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/cs3002644">Spectroscopic Characterization of Mixed Feâ€“Ni Oxide Electrocatalysts for the Oxygen Evolution Reaction in Alkaline Electrolytes</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/cs3002644'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/cs3002644&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.2172/1149701">Modeling Coverage Dependence in Surface Reaction Networks</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.2172/1149701'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.2172/1149701&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.pecs.2012.03.003">The outlook for improved carbon capture technology</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.pecs.2012.03.003'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.pecs.2012.03.003&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1111/j.1551-2916.2012.05236.x">Structure and Relative Thermal Stability of Mesoporous (La,Sr)MnO3 Powders Prepared Using Evaporation-Induced Self-Assembly Methods</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1111/j.1551-2916.2012.05236.x'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1111/j.1551-2916.2012.05236.x&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1007/s11244-012-9808-0">Preface: Trends in computational catalysis</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1007/s11244-012-9808-0'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1007/s11244-012-9808-0&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ie300452c">Evaluation of a Primary Amine-Functionalized Ion-Exchange Resin for CO2 Capture</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ie300452c'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ie300452c&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.4746117">Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.4746117'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4746117&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1039/9781849734776-00083">Coverage dependent adsorption properties of atomic adsorbates on late transition metal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/9781849734776-00083'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/9781849734776-00083&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1002/cctc.201000397">Universality in Oxygen Evolution Electrocatalysis on Oxide Surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1002/cctc.201000397'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1002/cctc.201000397&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.3570235">Preparation of Mesoporous La 0.8Sr 0.2MnO 3 infiltrated coatings in porous SOFC cathodes using evaporation-induced self-assembly methods</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.3570235'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.3570235&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/cs200039t">Identification of sulfur-tolerant bimetallic surfaces using dft parametrized models and atomistic thermodynamics</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/cs200039t'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/cs200039t&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.3631948">Effects of strain, d-band filling, and oxidation state on the bulk electronic structure of cubic 3d perovskites</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.3631948'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.3631948&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.3561287">Configurational correlations in the coverage dependent adsorption energies of oxygen atoms on late transition metal fcc(111) surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.3561287'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.3561287&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1002/cssc.201000056">CO2 Adsorption on Supported Molecular Amidine Systems on Activated Carbon</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1002/cssc.201000056'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1002/cssc.201000056&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.fuel.2009.11.036">Separation of CO2 from flue gas using electrochemical cells</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.fuel.2009.11.036'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.fuel.2009.11.036&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1080/08927022.2010.481794">New solid-state table: estimating d-band characteristics for transition metal atoms</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927022.2010.481794'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1080/08927022.2010.481794&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevB.82.045414">Simple model explaining and predicting coverage-dependent atomic adsorption energies on transition metal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevB.82.045414'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevB.82.045414&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.3432440">Electrochemical concentration of carbon dioxide from an oxygen/carbon dioxide containing gas stream</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.3432440'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.3432440&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1080/08927020902833137">Uncertainty and figure selection for DFT based cluster expansions for oxygen adsorption on Au and Pt (111) surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927020902833137'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1080/08927020902833137&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1080/08927020902833129">Sulphur poisoning of water-gas shift catalysts: Site blocking and electronic structure modification</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927020902833129'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1080/08927020902833129&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.3096964">Step decoration of chiral metal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.3096964'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.3096964&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2009.01.021">Relating the coverage dependence of oxygen adsorption on Au and Pt fcc(111) surfaces through adsorbate-induced surface electronic structure effects</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2009.01.021'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2009.01.021&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevLett.103.246102">Hydrogen Dissociation and Spillover on Individual Isolated Palladium Atoms</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevLett.103.246102'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevLett.103.246102&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevB.79.205412">Correlations in coverage-dependent atomic adsorption energies on Pd(111)</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevB.79.205412'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevB.79.205412&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.jcat.2008.11.020">Atomistic thermodynamics study of the adsorption and the effects of water-gas shift reactants on Cu catalysts under reaction conditions</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.jcat.2008.11.020'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.jcat.2008.11.020&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1117/12.776303">Rotational isomeric state theory applied to the stiffness prediction of an anion polymer electrolyte membrane</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1117/12.776303'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1117/12.776303&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1039/b608782p">Density functional theory studies of alloys in heterogeneous catalysis</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/b608782p'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/b608782p&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevB.77.075437">Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag3Pd(111) in oxygen atmospheres</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevB.77.075437'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevB.77.075437&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.2358292">Response to &quot;comment on 'Trends in the exchange current for hydrogen evolution' J. Electrochem. Soc., 152, J23 (2005) &quot;</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.2358292'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.2358292&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.1856988">Trends in the exchange current for hydrogen evolution</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.1856988'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.1856988&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.cattod.2005.04.008">Trends in the chemical properties of early transition metal carbide surfaces: A density functional study</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.cattod.2005.04.008'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.cattod.2005.04.008&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevLett.93.156801">Role of strain and ligand effects in the modification of the electronic and chemical properties of bimetallic surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevLett.93.156801'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevLett.93.156801&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jp047349j">Origin of the overpotential for oxygen reduction at a fuel-cell cathode</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp047349j'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp047349j&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.1737365">Modification of the surface electronic and chemical properties of Pt(111) by subsurface 3d transition metals</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.1737365'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.1737365&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2003.09.007">Elucidation of the active surface and origin of the weak metal-hydrogen bond on Ni/Pt(111) bimetallic surfaces: a surface science and density functional theory study</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2003.09.007'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2003.09.007&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2003.08.041">A four-point probe correlation of oxygen sensitivity to changes in surface resistivity of TiO2(001) and Pd-modified TiO2(001)</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2003.08.041'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2003.08.041&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/s0039-6028(02)02679-1">A comparison of gold and molybdenum nanoparticles on TiO2(110) 1 x 2 reconstructed single crystal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/s0039-6028(02)02679-1'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/s0039-6028(02)02679-1&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1073/pnas.072514399">H3PW12O40-functionalized tip for scanning tunneling microscopy</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1073/pnas.072514399'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1073/pnas.072514399&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jo00117a004">Preparation and Characterization of a Bis-Semiquinone: a Bidentate Dianion Biradical</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jo00117a004'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jo00117a004&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

</ol>
#+END_HTML

* DONE Running scientific instruments in Emacs and recording the results
  CLOSED: [2015-07-25 Sat 10:04]
  :PROPERTIES:
  :categories: emacs,orgmode,notebook
  :date:     2015/07/25 10:04:01
  :updated:  2015/07/25 10:04:01
  :ID:       9AC68550-391C-4CB5-897E-6AEBB2BA30C1
  :END:

Today we look at running a scientific instrument via http requests from Emacs and org-mode. We will use a Gamry Ref600 potentiostat because Gamry has very nicely provide a COM interface we can access via Python. This will be only a proof of concept to see what it is like. We will not consider any issues of security, etc..., only what is it like to do it.

The setup will look like this: we will run a flask web app that uses python to control the instrument via http requests. Why? Because I want to run the instrument from my Mac ;) and so far there are only Windows drivers for the instrument. So, we run the flask app on the Windows machine, and I run it from here on my Mac by sending requests. Flask takes care of converting requests to action using Python. You can see the [[id:5EB72A19-B9D3-4ABA-975F-61ACE16E0D87][Flask app here]].

Let's see what is online:
#+BEGIN_SRC sh
curl jkitchin-win.cheme.cmu.edu:5000/pstats
#+END_SRC

#+RESULTS:
: (u'REF600-13089',)

We have one potentiostat online with serial number 13089. I have a dummy cell connected to it which has a little resistor on it. So we can run a cyclic voltammogram and it should be a straight line. We have to know a bit about what is returned. We will get a json file back, and it will have the data in it. The data will be a list of lists. The data we want is in columns 1 and 3 (python indexing). Obviously you need some prior knowledge of what data comes back to use this. That would come from reading some documentation.

#+BEGIN_SRC python
import requests
import numpy as np
import matplotlib.pyplot as plt

resp = requests.get('http://jkitchin-win.cheme.cmu.edu:5000/cv?endv=0.25&startv=-0.25')

dj = resp.json()
data = np.array(dj['data'])

plt.plot(data[:, 1], data[:, 3])
plt.xlabel('Voltage (V)')
plt.ylabel('Current (A)')
plt.tight_layout()
plt.savefig('cv-1.png')
#+END_SRC

#+RESULTS:


[[./cv-1.png]]
Well, there you have it. Possibly the first Gamry Ref600 to ever have been driven from a Mac ;) Let me be more explicit about that; I could /also/ run this from Linux, an iPad, etc... You could do this in a browser, or in an IPython notebook, or in Matlab, among many other possibilities. You could write a script in perl, shell, ruby, emacs-lisp, or any other language that supports http requests.

I am not sure why the graph is not perfectly linear, maybe there is some capacitive charging that starts out. The resistance based on the current at 0.2V is about 2000 ohms, which is in good agreement with what is listed on the board the dummy cell is on.

** Summary thoughts
   :PROPERTIES:
   :ID:       DCC8BFE6-0BA2-4046-BE7B-E71DABC668E8
   :END:
There are a host of interesting issues one eventually has to consider here including security, but also error management and debugging. I hacked something like an http api here by running flask on the windows machine running the instrument. That is a layer of abstraction on an abstraction to start with. I think later instruments are likely to run these webservers themselves on small dedicated computers, e.g. via a Raspberry pi or Arduino chipset. It is not obvious how sophisticated you can make this with respect to triggering different instruments, etc...

In running this, my "notebook" was blocked while the experiment ran. It is possible to run things asynchronously, and sometimes that would make sense. In the example here, we have provided a very limited set of functions to "run" the potentiostat. It was only a proof of concept to get a sense for what it is like. In practice a fuller set of functions would be implemented. Another point to consider is how the data comes back from the potentiostat. We used json here because it is convenient, but we could just as well send files, and other sorts of data too.

This lays out the possibility to walk up to an instrument with an electronic notebook, setup and run the experiment, capture the results in the notebook and take it back to the office for analysis. Pretty cool.

** Flask app
   :PROPERTIES:
   :ID:       5EB72A19-B9D3-4ABA-975F-61ACE16E0D87
   :END:

So, here is my flask app. We setup a few routes using get requests to do things like get a list of the potentiostats online, and to run a cyclic voltamogram. As a side note, after this post is over, I am turning off the app, so you won't be able to repeat the codes ;) This is not a beautiful, secure or error tolerant code. It works enough for a proof of concept of simple experiments.

#+BEGIN_SRC python :tangle ~/Dropbox/python/gamry/gamry_flask.py
from flask import Flask, request, jsonify
import time

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/pstats')
def get_pstats():
    import win32com.client as client
    devices = client.Dispatch('GamryCOM.GamryDeviceList')
    result = str(devices.EnumSections())
    return result

@app.route('/close_pstat')
def close():
    import win32com.client as client
    devicelist = client.Dispatch('GamryCOM.GamryDeviceList')

    x = devicelist.EnumSections()[0]
    pstat = client.Dispatch('GamryCOM.GamryPstat')
    pstat.Init(x)

    pstat.Close()


def run_ramp(Sinit,  # start value
             Sfinal, # end value
             ScanRate=1,
             SampleRate=0.01,
             CtrlMode=1,  # GamryCOM.PstatMode
             fname=None):
    '''We assume the first device is the one you want.
    '''
    import win32com.client as client
    import numpy as np
    devicelist = client.Dispatch('GamryCOM.GamryDeviceList')

    x = devicelist.EnumSections()[0]

    pstat = client.Dispatch('GamryCOM.GamryPstat')
    pstat.Init(x)

    pstat.Open()

    dtaqcpiv=client.Dispatch('GamryCOM.GamryDtaqCpiv')
    dtaqcpiv.Init(pstat)

    sigramp=client.Dispatch('GamryCOM.GamrySignalRamp')
    sigramp.Init(pstat, Sinit, Sfinal, ScanRate, SampleRate, CtrlMode)

    pstat.SetSignal(sigramp)
    pstat.SetCell(1) # 1 == GamryCOM.CellOn

    try:
        dtaqcpiv.Run(True)
    except Exception as e:
        pstat.Close()
        raise

    # NOTE:  The comtypes example in this same directory illustrates the use of com
    # notification events.  The comtypes package is recommended as an alternative
    # to win32com.
    time.sleep(2) # just wait sufficiently long for the acquisition to complete.

    acquired_points = []
    count = 1
    while count > 0:
        count, points = dtaqcpiv.Cook(10)
        # The columns exposed by GamryDtaq.Cook vary by dtaq and are
        # documented in the Toolkit Reference Manual.
        acquired_points.extend(zip(*points))

    acquired_points = np.array(acquired_points)
    if fname is not None:
        np.savetxt(fname, acquired_points)

    pstat.Close()
    return jsonify({'data': acquired_points.tolist()})

@app.route('/cv')
def run_cv():
    result = str(request.values)
    startv = float(request.values.get('startv', -0.1))
    endv = float(request.values.get('endv', 0.1))
    scanrate = float(request.values.get('scanrate', 1.0))
    samplerate = float(request.values.get('samplerate', 0.01))

    data = run_ramp(startv, endv, scanrate, samplerate)
    return data


if __name__ == '__main__':
    app.run(host='jkitchin-win.cheme.cmu.edu', port=5000, debug=True)
#+END_SRC

#+RESULTS:
* DONE Indexing text in screenshots so they are searchable
  CLOSED: [2015-07-24 Fri 07:43]
  :PROPERTIES:
  :ID:       E08BF332-B853-4EE5-9C1B-B70EA6D69F89
  :categories: search,image
  :date:     2015/07/24 07:43:08
  :updated:  2015/07/24 07:43:08
  :END:

I had an interesting conversation with someone yesterday about using screenshots to document a process. This has an appeal of simplicity, since it is agnostic to the process, but I wondered about the long-term utility. If the documentation is valuable, you would like to search it in the future, and we so far have limited capability to search images. But, if there is important text in the image, we might be able to recognize the text, and use it to index the images. Then they would become searchable at least for the text in the image. Don't get me wrong, it would be better if we could store that text directly, but suppose that just isn't possible, maybe because it is all stored in some kind of gui, or it is locked up in proprietary software. Here we explore the potential utility of this. We only explore getting text out of images here, not the actual indexing part. See this [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/06/Indexing-headlines-in-org-files-with-swish-e-with-laser-sharp-results/][post]] for how we could integrate this into an actual index and search tool.

First we need an OCR engine. Tesseract[[https://github.com/tesseract-ocr/tesseract][ (tesseract-ocr/tesseract)]] is supposed to be pretty good, and it easily installs via brew:
#+BEGIN_SRC sh
brew install tesseract
#+END_SRC

#+BEGIN_SRC emacs-lisp
(shell-command-to-string "tesseract -v")
#+END_SRC

#+RESULTS:
: tesseract 3.02.02
:  leptonica-1.72
:   libjpeg 8d : libpng 1.6.17 : libtiff 4.0.3 : zlib 1.2.5
:

We will test it on some screenshots taken with the default settings on my Mac. Here is an example. This example has text in color boxes, and some shadowing on the left side because another window was near it and that is some OS effect.

#+attr_org: :width 300
[[./screenshots/date-23-07-2015-time-19-56-52.png]]

And here is the simplest text extraction.

#+BEGIN_SRC sh
tesseract ./screenshots/date-23-07-2015-time-19-56-52.png test
cat test.txt
rm test.txt
#+END_SRC

#+RESULTS:
#+begin_example
M. ~ an an. -.2... nuIunIrv- I.nd=dÂ¢wn, a.....=.-p. u|u.=u_x. van" bar imam-

smm-ry ~ nu... ma, Camilla man Qu-In lui. Sdlwnu u._-. /-x/mu



master node q)l9amesh.chemc.cmn.edn up 9: days, mas, n nsersv

cutï¬‚mltc nude: men): :1

bpxoc node sum 17 dmln , o.1s,u.:n up
cuxque node state: n17 dawn

tuxqng jobs: 207 max, m2 nmmnq. as queued
aggregate laud: 799.55

#+end_example

That is not too good. I am skeptical it would be useful for anything. This [[http://vbridge.co.uk/2012/11/05/how-we-tuned-tesseract-to-perform-as-well-as-a-commercial-ocr-package/][page]] suggests improvements can be made with image clean up, but that image is pretty clear to me. There is a little shadow on the left side, but otherwise it is very readable to me. Let us try doubling the size of the image. Maybe that will help. Imagemagick lets us resize the image pretty easily.

#+BEGIN_SRC sh
convert -resize 200% ./screenshots/date-23-07-2015-time-19-56-52.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
#+END_SRC

#+RESULTS:
#+begin_example
- 2D Node status summary. Rnd=down, Groun=up, BIuÂ¢=boot. Vdlow bur indium --



Summlry - Hnï¬‚nr Mods, Compuh Nodu, Quuue, Land, Soï¬wan Ric:-as, /dzc/maul

master node gilqnmesh.cheme.cmu.edu up 91 days, 10:45, 11 users, .'

compute nodes total: 31

bproc node state: 17 down , 0-16,18-30 up
torque node state: n17 down

torque jobs: 207 total, 102 running, 88 queued
aggregate load: 799.55

#+end_example


That is a very remarkable improvement! This looks very useful, and could even be used for indexing. Interestingly, the white text on colored backgrounds does not do as well. That could be important to remember in designing the GUI front end if you have any say in it.  Let's try a few others.


#+attr_org: :width 300
[[./screenshots/date-23-07-2015-time-20-01-43.png]]

#+BEGIN_SRC sh
convert -resize 200% ./screenshots/date-23-07-2015-time-20-01-43.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
#+END_SRC

#+RESULTS:
: Fllbn V Q I-"Ind a repository...
:
: tesseract
: Tesseract Open Source OCR Enghe (main repository)
: Updated 43 minutes ago
:

That is also pretty good. Again, the text on colored backgrounds is less good than that on a white background. And one more from Twitter.

#+attr_org: :width 300
[[./screenshots/date-23-07-2015-time-20-05-59.png]]

#+BEGIN_SRC sh
convert -resize 200% ./screenshots/date-23-07-2015-time-20-05-59.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
#+END_SRC

#+RESULTS:
: chEnected AIchE .-.ChEnected - 5h
: C h E AlChE Academy: Take AlChEâ€˜s Pneumatic Conveying 0! Bulk Solids Course and
: learn practical design principles. r1m.ag/|IJcN
:

Overall pretty good. I am pretty convinced that the right screenshots could be an easy way to document some processes conveniently and that they could be searched in the future. Some testing would need to be done on how to do the OCR, and it does not appear that one recipe will work for all images.

Nevertheless, a program could pretty easily be developed to index a directory of screenshots, do the OCR on each image, and index the resulting text so it can be searched. It is even conceivable that several indexes could be made using different OCR methods that might work better for different types of images. Another improvement would be if some metadata could be associated with the screenshot including what instrument it is a shot of, who took it, etc... This starts to move in a direction that requires dedicated screenshot tools, and away from the simplicity of the PrintScreen button, but it adds value to the data that makes it easier to find later.

The beauty of the screenshot is that it is what you saw at the time, and it captures things as they were. It doesn't capture anything "behind the scenes" or off-screen of course, so there is certainly room to lose information this way. A careful analysis of what information is captured and what is lost would be important to assess the long-term value of capturing the process this way as opposed to any other way. There certainly is a balance of how much effort it takes to capture it and the value of the information in the future, and cost to rerun it if it isn't found in the future.

* DONE A sudo org-link and sh block
  CLOSED: [2015-07-17 Fri 12:42]
  :PROPERTIES:
  :categories: emacs,babel,orgmode
  :date:     2015/07/17 12:42:34
  :updated:  2015/07/17 12:42:34
  :ID:       68DB63AA-A625-4724-82AD-A581DE302A0B
  :END:
Shell blocks in org-mode are pretty useful, but they are a little limited in that it is not obvious how to run a sudo command in them.

So for example, this gives me a permission denied error.
#+BEGIN_SRC sh
ls /var/audit
#+END_SRC

One way to get around this is to create an org-mode link like this one:

#+BEGIN_SRC emacs-lisp :results silent
;http://stackoverflow.com/questions/2472273/how-do-i-run-a-sudo-command-in-emacs
(org-add-link-type
 "sudo"
 (lambda (cmd)
   "Run CMD with sudo."
   (shell-command
    (concat "echo " (shell-quote-argument (read-passwd "Password? "))
	    " | sudo -S " cmd))))
#+END_SRC

Now you can create a link like [[sudo:ls /var/audit]], and when you click on it you will be prompted for a password, and then you will see a buffer containing the output. To get an actual sudo code block, you need a new org babel library. Here is an example of what it might look like. Tangle this file to generate the library. Note: This is a lightly modified version of ob-emacs-lisp.el, and I have not tested it very thoroughly.


#+BEGIN_SRC emacs-lisp :tangle ob-sudo.el
;;; ob-sudo.el --- An org-mode source block to run shell commands as sudo

;;; Commentary:
;; Runs the block of code as a shell command with sudo.

;;; Code:

(defun org-babel-execute:sudo (body params)
  "Run BODY as a shell command using sudo."
  (let* ((passwd (shell-quote-argument (read-passwd "Password? ")))
	 (result (shell-command-to-string
		  (concat "echo " passwd
			  " | sudo -S " body))))
    ;; this is verbatim from ob-emacs-lisp
    (org-babel-result-cond (cdr (assoc :result-params params))
      (let ((print-level nil)
	    (print-length nil))
	(if (or (member "scalar" (cdr (assoc :result-params params)))
		(member "verbatim" (cdr (assoc :result-params params))))
	    (format "%S" result)
	  (format "%s" result)))
      (org-babel-reassemble-table
       result
       (org-babel-pick-name (cdr (assoc :colname-names params))
			    (cdr (assoc :colnames params)))
       (org-babel-pick-name (cdr (assoc :rowname-names params))
			    (cdr (assoc :rownames params)))))))

(provide 'ob-sudo)
;;; ob-sudo.el ends here

#+END_SRC

Let us add the current dir to our path so we can load it. If you use this a lot, you should put the library on your permanent path.

#+BEGIN_SRC emacs-lisp :results silent
(add-to-list 'load-path (expand-file-name "."))
#+END_SRC

Now, add the sudo "language" to org-babel-load-languages.

#+BEGIN_SRC emacs-lisp :results silent
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (matlab . t)
   (sqlite . t)
   (ruby . t)
   (perl . t)
   (org . t)
   (dot . t)
   (plantuml . t)
   (R . t)
   (sudo . t)))
#+END_SRC

#+RESULTS:

And, here it is in action. Hopefully I am not giving away some important information here!

#+BEGIN_SRC sudo
ls /var/audit
#+END_SRC

#+RESULTS:
#+begin_example
20141106003522.20141110021519
20141110021548.crash_recovery
20141112154126.crash_recovery
20141119201541.20141122145259
20141122145317.20141124214930
20141124215000.crash_recovery
20141126062011.20141202192451
20141202192507.crash_recovery
20141210133306.crash_recovery
20141225181819.20150106015256
20150106015325.20150111010018
20150111010121.crash_recovery
20150115195518.20150115200101
20150115200110.crash_recovery
20150123061227.20150215123411
20150215123454.crash_recovery
20150225004740.20150310201600
20150310201633.20150314214730
20150314214807.crash_recovery
20150323145600.20150329170647
20150329170721.crash_recovery
20150407215846.20150413000423
20150413000438.20150421122044
20150421122104.20150518122545
20150518122616.20150518124432
20150518124432.20150518124513
20150518124513.20150518125437
20150518125437.20150518125935
20150518125935.20150518132111
20150518132111.20150531202621
20150531202719.20150601123612
20150601123612.20150601124932
20150601124932.20150601125151
20150601125151.20150601125555
20150601125555.20150601131947
20150601131947.20150601132421
20150601132421.20150601133735
20150601133735.20150601140740
20150601140740.20150601154012
20150601154012.20150601155125
20150601155125.20150601155215
20150601155215.20150601160937
20150601160937.crash_recovery
20150613061543.20150614054541
20150614054541.20150625165357
20150625165432.20150625200623
20150625200623.20150628042242
20150628042242.20150628103628
20150628103628.20150630052100
20150630052100.20150701232519
20150702005345.20150710203212
20150710203226.not_terminated
current
#+end_example

Summary thoughts: I will reiterate again I have not tested this a lot, I was mostly interested in trying to make a new sh block with sudo support. Let me know if it has issues for you, and make sure you have backups of things it could mess up!
* DONE Acronym minor mode for Emacs
  CLOSED: [2015-07-09 Thu 08:04]
  :PROPERTIES:
  :categories: emacs,tooltip, video
  :date:     2015/07/09 08:04:40
  :updated:  2015/07/09 08:04:40
  :ID:       5BE445D5-5FEE-4E1E-8DDB-A277F618D457
  :END:

Three letter acronyms (TLA) are pretty common, as are other kinds of acronyms, e.g. ferromagnetic (FM), anti-ferromagnetic (AFM), National Security Agency (NSA), even [[https://www.gnu.org/fun/jokes/gnuemacs.acro.exp.html][Escape-Meta-Alt-Control-Shift]] (EMACS) etc... in technical documents. As you get away from the definition, it can get hard to remember what they are, so here we develop a minor mode that will put a tooltip over acronyms that hopefully shows what they mean.

You can see this in action here: https://www.youtube.com/watch?v=2G2isMO6E2c

When we turn the mode on, it will scan the buffer looking for an acronym pattern, deduce its likely meaning, and put tooltips on every subsequent use of the acronym. The pattern we will look for is a sequence of uppercase letters surrounded by parentheses. We will assume that if we find N uppercase letters, that the previous N words contain the definition of the acronym. This is pretty approximate, but it is not likely to be that wrong. Then, we will use button-lock to put the tooltips on all subsequent instances of acronyms. We don't want flyspell interfering with the tooltips, so we remove the overlays if they are there.

Unlike previous examples where we just use button-lock, here we wrap the feature into a minor mode that you can turn on and off. Note, you cannot add new acronyms and have them have tooltips. You have to refresh the buttons.

Here is the minor mode code. We use the interesting rx package to build the regular expression. It is more verbose, but a little easier to read than a straight regexp like (concat "\\<" (match-string 1) "\\>") in my opinion.




#+BEGIN_SRC emacs-lisp
(make-variable-buffer-local
 (defvar *acronym-buttons* '() "list of acronym buttons"))

(require 'rx)

(defun highlight-acronyms ()
  (save-excursion
    (let ((case-fold-search nil))
      (goto-char (point-min))
      (while (re-search-forward "(\\([A-Z]+\\))" nil t)
	(when flyspell-mode
	  (flyspell-delete-region-overlays (match-beginning 1)
					   (match-end 1)))
	(let* ((acronym (match-string 1))
	       (p (point))
	       (definition (save-excursion
			     (goto-char (match-beginning 1))
			     (backward-word (length acronym))
			     (buffer-substring (point) p))))
	  (add-to-list '*acronym-buttons*
		       (button-lock-set-button
			;; (rx word-start acronym word-end)
			(concat "\\<" acronym "\\>")
			nil
			:help-echo definition)))))
    ;; now highlight undefined acronyms, which are two or more capital letters.
    (goto-char (point-min))
    (let ((case-fold-search nil)
	  (m) (b) (e))
      (while (re-search-forward "[^(]\\<\\([A-Z]\\{2,\\}+\\)\\>[^)]" nil t)
	(setq m (match-string 1)
	      b (match-beginning 1)
	      e (match-end 1))
	(unless (string-match
		 (concat
		  ;; some org capitalized non-acronyms
		  "DONE\\|TODO\\|RESULTS\\|END\\|BEGIN\\|SRC\\|"
		  "CAPTION\\|"
		  (s-join
		   "\\|"
		   (mapcar 'button-lock-button-pattern *acronym-buttons*)))
		 m)

	  (when flyspell-mode
	    (flyspell-delete-region-overlays b e))
	  (add-text-properties
	   b e
	   '(help-echo "Undefined acronym"
		       font-lock-face '(:foreground "red")
		       undefined-acronym t)))))))


(defun remove-acronym-buttons ()
  "Remove buttons and undefined acronyms."
  ;; this is a littly clumsy to just get rid of all properties, but it is pretty
  ;; easy.
  (save-excursion
    (goto-char (point-min))
    (let ((b) (e))
      (while (setq b (next-single-property-change
		      (point) 'undefined-acronym))
	(goto-char b)
	(setq
	 e
	 (goto-char
	  (next-single-property-change
	   (point) 'undefined-acronym)))
	(set-text-properties b e nil))))
  (dolist (button *acronym-buttons*)
    (button-lock-unset-button button))
  (setq *acronym-buttons* '()))


(defun refresh-acronyms ()
  "Refresh acronym tooltips in buffer."
  (interactive)
  (remove-acronym-buttons)
  (highlight-acronyms))


;;;###autoload
(define-minor-mode acronym-mode
  "Put definitions on acronyms."
  :lighter " AM"
  (if acronym-mode
      (highlight-acronyms)
    (remove-acronym-buttons)))


(provide 'acronym-mode)

#+END_SRC

#+RESULTS:
: acronym-mode

(remove-acronym-buttons)
There it is. Now any time we have an acronym like EMACS we can mouse over it, or type C-h . on the acronym to see how it was previously defined. If you don't like it, you can turn it off!

For some reason, undefined acronyms UA are made red, and have the undefined-acronym property, but the tooltips do not appear there. DFT
* DONE Indexing headlines in org files with swish-e with laser-sharp results
  CLOSED: [2015-07-06 Mon 11:04]
  :PROPERTIES:
  :categories: emacs,swishe,orgmode
  :date:     2015/07/06 11:04:43
  :updated:  2015/07/06 11:04:43
  :ID:       9E9CDF08-29F6-4886-B874-5FFA13879EB7
  :END:

So far, it looks like swish-e is able to do some pretty focused searches on specific content types. However, the return results are not actually that sharp; in the way we have been using swish-e, it can only tell us the document path that matches, not where in the document the match is. To fix that, we need a new approach to what a "document" is, and a new approach to indexing. We will finally use the "-s prog" option in swish-e which runs an external program that prints stuff to stdout for swish-e to index. We will treat each headline in an org file as a "document" but rather than have the path to the file, we will put an org-mode link there that will take us right to the point of interest.

You can see this in action here: https://www.youtube.com/watch?v=bTwXtEb5Ng8

Basically, we need a program to output chunks like this for each headline in an org-file:
#+BEGIN_EXAMPLE
Path-Name: [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/ase-db.org") (goto-char 1))]]
Content-Length: 247
Document-Type: XML*

<headline><title>Using the ase database module</title><properties><FILE>/Users/jkitchin/blogofile-jkitchin.github.com/_blog/ase-db.org</FILE><BLOCKED></BLOCKED><categories>python, ase</categories><CATEGORY>ase-db</CATEGORY></properties></headline>
#+END_EXAMPLE

Then we need to tell swish-e to run the program and index its output. Here is the program to do that.

#+BEGIN_SRC emacs-lisp :tangle swish-org-headlines.el :tangle-mode (identity #o755)
:;exec emacs -batch -l $0 "$@"
(require 'org)
(require 'xml)
(require 'cl)

(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/f-20140828.716")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/s-20140910.334")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/dash-20141201.2206")
(require 'f)

(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\""
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 " "))
     "")))

(defmacro tag (name attributes &rest body)
  "macro to create an xml tag with NAME, ATTRIBUTES. BODY is executed in the tag."
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	    ,@body)
	   (print-tag ,name nil t)))

(defun headline-xml (headline)
  "Return xml representation of an element HEADLINE."
  (let ((title (org-element-property :title headline))
	(properties (save-excursion
		      (goto-char
		       (org-element-property :begin headline))
		      (org-entry-properties))))
    (tag 'headline ()
	 (tag 'title () (xml-escape-string (mapconcat 'identity title " ")))
	 (when properties
	   (tag 'properties ()
		(mapconcat
		 'identity
		 (loop for (p . v) in properties
		       collect (tag p () (xml-escape-string v)))
		 ""))))))

(defun headline-document (headline)
  "Return the headline \"document\" for swish-e to index."
  (let ((xml (replace-regexp-in-string
	      "[^[:ascii:]]" ""
	      (headline-xml headline))))
    (format "Path-Name: [[elisp:(progn (find-file \"%s\") (goto-char %s) (show-children))][link]]
Content-Length: %s
Document-Type: XML*

%s" (buffer-file-name)
(org-element-property :begin headline)
(length xml)
xml)))

(defun process-file (fname)
  "Print the `headline-document' for each headline in FNAME."
  (with-current-buffer (find-file-noselect fname)
    (mapconcat 'identity
	       (org-element-map (org-element-parse-buffer)
		   'headline
		 (lambda (headline)
		   (princ (headline-document headline))))
	       "")))

;; Here is the main work in the script.
(loop for dir in '("/Users/jkitchin/blogofile-jkitchin.github.com/_blog")
      do
      (loop for fname in (f-entries
			  dir
			  (lambda (x)
			    (string=  "org"  (file-name-extension x)))
			  t)
	    do (ignore-errors
		 (princ (process-file fname)))))
#+END_SRC

Now we need a configuration file:

#+BEGIN_SRC text :tangle swish-org-headlines.conf
# Example configuration file

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org-headlines.swish-e

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
#+END_SRC


And we run the indexer, I did this in an actual shell. For some reason, it was not possible to run here. The output is pretty useful though, as it tells you what MetaNames are searchable.

#+BEGIN_SRC sh
swish-e -c swish-org-headlines.conf -S prog -i ./swish-org-headlines.el
#+END_SRC



Ok, now for the proof in the approach!

#+BEGIN_SRC sh :results raw
swish-e -f index-org-headlines.swish-e -w headline=generating
#+END_SRC

#+RESULTS:
# SWISH format: 2.4.7
# Search words: headline=generating
# Removed stopwords:
# Number of hits: 9
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/separate-bib.org") (goto-char 1) (show-children))][link]] "separate-bib.org") (goto-char 1) (show-children))][link]]" 393
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 158456) (show-children))][link]] "blog-2014.org") (goto-char 158456) (show-children))][link]]" 229
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 272383) (show-children))][link]] "blog-2014.org") (goto-char 272383) (show-children))][link]]" 400
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 158456) (show-children))][link]] "blog-2014.org") (goto-char 158456) (show-children))][link]]" 229
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 448965) (show-children))][link]] "blog.org") (goto-char 448965) (show-children))][link]]" 389
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 575) (show-children))][link]] "org-db.org") (goto-char 575) (show-children))][link]]" 204
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 575) (show-children))][link]] "org-db.org") (goto-char 575) (show-children))][link]]" 204
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/separate-bib.org") (goto-char 1) (show-children))][link]] "separate-bib.org") (goto-char 1) (show-children))][link]]" 393
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 272383) (show-children))][link]] "blog-2014.org") (goto-char 272383) (show-children))][link]]" 400
.


#+BEGIN_SRC sh :results org raw
swish-e -f index-org-headlines.swish-e -w todo=TODO
#+END_SRC

#+RESULTS:
# SWISH format: 2.4.7
# Search words: todo=TODO
# Removed stopwords:
# Number of hits: 14
# Search time: 0.000 seconds
# Run time: 0.010 seconds
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 16933) (show-children))][link]] "blog.org") (goto-char 16933) (show-children))][link]]" 342
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-children))][link]] "blog-2014.org") (goto-char 61231) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-children))][link]] "blog-2014.org") (goto-char 60802) (show-children))][link]]" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-children))][link]] "blog-2014.org") (goto-char 60289) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-children))][link]] "blog-2014.org") (goto-char 61568) (show-children))][link]]" 246
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-children))][link]] "blog-2014.org") (goto-char 61231) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-children))][link]] "blog-2014.org") (goto-char 60802) (show-children))][link]]" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-children))][link]] "blog-2014.org") (goto-char 60289) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 632875) (show-children))][link]] "blog.org") (goto-char 632875) (show-children))][link]]" 266
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 529123) (show-children))][link]] "blog.org") (goto-char 529123) (show-children))][link]]" 202
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 529087) (show-children))][link]] "blog.org") (goto-char 529087) (show-children))][link]]" 206
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 518108) (show-children))][link]] "blog.org") (goto-char 518108) (show-children))][link]]" 280
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 30559) (show-children))][link]] "blog.org") (goto-char 30559) (show-children))][link]]" 337
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-children))][link]] "blog-2014.org") (goto-char 61568) (show-children))][link]]" 246
.


** Summary thoughts
   :PROPERTIES:
   :ID:       2C301F05-61BC-4169-BD01-D43A44DDFB6C
   :END:
This could be super useful for a lot of different elements: headlines, src-blocks, links, tables, paragraphs are the main ones that come to mind. You could have pretty focused searches that go straight to the matches!

* DONE An xml representation of an org document for indexing with swish-e
  CLOSED: [2015-07-04 Sat 11:49]
  :PROPERTIES:
  :categories: emacs,search
  :date:     2015/07/04 11:49:23
  :updated:  2015/07/04 19:34:22
  :ID:       AFC2B767-11DE-4B46-AC70-A3AB9FAA59B9
  :END:

Swish-e can index xml data, and enable searching by tag. Here we push our org-mode indexing idea a little further. Initially we indexed org files as text. Then, we exported it to html, and indexed the html. That enabled some richer searching. Now, we will create an xml representation of the org file for indexing. This will enable us to use a custom tag system and search for specific text in tables, or src-blocks, or in headlines, or for headlines with certain tags, todo state or properties.

Incidentally, this is a general strategy for indexing arbitrary files. You just make an xml representation of the file containing the data to be indexed, and use swish-e to index that xml.

Let us start with code to generate xml. I adapted this from some code in [[http://landoflisp.com][Land Of Lisp]]. First, a function that simply prints a tag with attributes.

#+BEGIN_SRC emacs-lisp
(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\""
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 " "))
     "")))

(print-tag 'html '((color . "blue") (label . "test")))
#+END_SRC

#+RESULTS:
: <html color="blue" label="test">

XML tags almost always come in pairs. We define a macro to make this happen here. The macro prints the opening tag, evaluates the body, and prints the closing body. Note that the body may contain other tags, or a string. The string should be escaped to avoid illegal xml characters.

#+BEGIN_SRC emacs-lisp
(defmacro tag (name attributes &rest body)
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

;; example usage
(tag "xml" '((test . "id"))
     (tag "body" nil
	  (tag "p" nil (xml-escape-string "paragraph & < 1"))
	  (tag "p" nil "paragraph 2")))
#+END_SRC

#+RESULTS:
: <xml test="id"><body><p>paragraph &amp; &lt; 1</p><p>paragraph 2</p></body></xml>

Now, we can use this to get an xml representation of the source blocks, e.g.

#+BEGIN_SRC emacs-lisp
(mapconcat 'identity
	   (org-element-map
	       (org-element-parse-buffer)
	       'src-block
	     (lambda (element)
	       (tag
		'src-block
		`((language . ,(org-element-property :language element)))
		(tag 'contents ()
		     (xml-escape-string
		      (org-element-property :value element))))))
	   "")
#+END_SRC

#+RESULTS:
#+begin_example
<src-block language="emacs-lisp"><contents>(defun print-tag (name attrs &amp;optional closingp)
  &quot;Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead.&quot;
  (format
   &quot;&lt;%s%s%s&gt;&quot;
   (if closingp &quot;/&quot; &quot;&quot;)
   name
   (if (and attrs (not closingp))
       (concat
	&quot; &quot;
	(mapconcat
	 (lambda (x)
	   (format &quot;%s=\&quot;%s\&quot;&quot;
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 &quot; &quot;))
     &quot;&quot;)))

(print-tag &apos;html &apos;((color . &quot;blue&quot;) (label . &quot;test&quot;)))
</contents></src-block><src-block language="emacs-lisp"><contents>(defmacro tag (name attributes &amp;rest body)
  `(format &quot;%s%s%s&quot;
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

(tag &quot;xml&quot; &apos;((test . &quot;id&quot;))
     (tag &quot;body&quot; nil
	  (tag &quot;p&quot; nil (xml-escape-string &quot;paragraph &amp; &lt; 1&quot;))
	  (tag &quot;p&quot; nil &quot;paragraph 2&quot;)))
</contents></src-block><src-block language="emacs-lisp"><contents>(mapconcat &apos;identity
	   (org-element-map
	       (org-element-parse-buffer)
	       &apos;src-block
	     (lambda (element)
	       (tag
		&apos;src-block
		`((language . ,(org-element-property :language element)))
		(tag &apos;contents ()
		     (xml-escape-string
		      (org-element-property :value element))))))
	   &quot;&quot;)
</contents></src-block><src-block language="emacs-lisp"><contents>(let ((xml (tag &apos;root `((filename . ,(buffer-file-name))
			(indexed-on . ,(current-time-string)))
		;; map the headlines
		(mapconcat
		 &apos;identity
		 (org-map-entries
		  (lambda ()
		    (let* ((tags (org-get-tags))
			   (heading-components (org-heading-components))
			   (title (nth 4 heading-components))
			   (level (nth 0 heading-components))
			   (properties (org-entry-properties))
			   (elem (org-element-at-point))
			   (bp (org-element-property :contents-begin elem))
			   (ep (org-element-property :contents-end elem))
			   (content (buffer-substring bp ep)))
		      (tag &apos;heading `((level . ,level))
			   (tag &apos;title () (xml-escape-string title))
			   (tag &apos;tags () (mapconcat &apos;identity tags &quot; &quot;))
			   (tag &apos;properties ()
				(mapconcat
				 (lambda (x)
				   (tag &apos;property `((label . (car ,x))) (cdr x)))
				 properties
				 &quot;&quot;))
			   (tag &apos;content ()
				(format &quot;%s&quot; (xml-escape-string content)))))))
		 &quot;&quot;)

		;; map specific element types
		(tag &apos;source-blocks ()
		     (mapconcat
		      &apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &apos;src-block
			(lambda (element)
			  (tag &apos;src-block
			       `((language .
					   ,(org-element-property
					     :language element)))
			       (tag &apos;contents ()
				    (xml-escape-string
				     (org-element-property :value element)))))) &quot;&quot;))

		(tag &apos;tables ()
		     (mapconcat
		      &apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &apos;table
			(lambda (element)
			  (tag &apos;table ()
			       (when (org-element-property :caption element)
				 (tag &apos;caption ()
				(caaar (org-element-property :caption element))))
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &quot;&quot;))

		(tag &apos;paragraphs ()
		     (mapconcat
		      &apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &apos;paragraph
			(lambda (element)
			  (tag &apos;paragraph ()
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &quot;&quot;
		      ))
		)))
  (with-temp-file &quot;org2xml.xml&quot;
    (insert xml)))
</contents></src-block><src-block language="emacs-lisp"><contents>(xml-parse-file &quot;org2xml.xml&quot;)
</contents></src-block>
#+end_example

So, finally we can map the entries to get some information about them, e.g. the tags, properties, todo state, etc... Then we create xml representing all that information so we can have a more precise search. Instead of looking for a word, we can specify that the word be in a property for example. Then, we make xml representations of the tables, src-blocks and paragraphs.

I am going to follow the example [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html/][here]] that we worked out before on html and create a filter function that takes an org-file and spits out xml at the command line.
#+BEGIN_SRC emacs-lisp :tangle org2xml.el :tangle-mode (identity #o755)
:;exec emacs -batch -l $0 -f main "$@"
(require 'org)
(require 'xml)

(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead.
You should use `xml-escape-string' on text going into the attributes to avoid errors."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\"" (car x) (cdr x)))
	   attrs
	   " "))
     "")))

(defmacro tag (name attributes &rest body)
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

(defun main ()
  (find-file (car command-line-args-left))
  (princ (tag 'root `((filename . ,(buffer-file-name))
		      (indexed-on . ,(current-time-string)))
	      ;; map the headlines
	      (mapconcat
	       'identity
	       (org-map-entries
		(lambda ()
		  (let* ((tags (org-get-tags))
			 (heading-components (org-heading-components))
			 (todo (nth 2 heading-components))
			 (headline (nth 4 heading-components))
			 (thislevel (nth 0 heading-components))
			 (properties (org-entry-properties)))
		    (tag 'heading `((level . ,thislevel))
			 (tag 'headline () (xml-escape-string headline))
			 (tag 'tags () (mapconcat 'identity tags " "))
			 (when todo
			   (tag 'todo () todo))
			 (tag 'properties ()
			      (mapconcat
			       (lambda (x)
				 (tag 'property `((name . ,(xml-escape-string (car x))))
				      (xml-escape-string (cdr x))))
			       properties
			       ""))))))
	       "")

	      ;; get file keywords, TITLE, authors, etc...
	      (tag 'file-keywords ()
		   (mapconcat 'identity
			      (org-element-map (org-element-parse-buffer 'element) 'keyword
				(lambda (keyword)
				  (tag (xml-escape-string (org-element-property :key keyword)) ()
				       (xml-escape-string (org-element-property :value keyword)))))
			      ""))

	      ;; map specific element types
	      (tag 'source-blocks ()
		   (mapconcat
		    'identity
		    (org-element-map
			(org-element-parse-buffer)
			'src-block
		      (lambda (element)
			(tag 'src-block
			     `((language .
					 ,(org-element-property
					   :language element)))
			     (tag 'contents ()
				  (xml-escape-string
				   (org-element-property :value element)))))) ""))

	      (tag 'tables ()
		   (mapconcat
		    'identity
		    (org-element-map
			(org-element-parse-buffer)
			'table
		      (lambda (element)
			(tag 'table ()
			     (when (org-element-property :caption element)
			       (tag 'caption ()
				    (format
				     "%s"
				     (org-element-property
				      :caption element))))
			     (xml-escape-string
			      (buffer-substring
			       (org-element-property :contents-begin element)
			       (org-element-property :contents-end element))))))
		    ""))

	      (tag 'paragraphs ()
		   (mapconcat
		    'identity
		    (org-element-map
			(org-element-parse-buffer)
			'paragraph
		      (lambda (element)
			(tag 'paragraph ()
			     (xml-escape-string
			      (buffer-substring
			       (org-element-property :contents-begin element)
			       (org-element-property :contents-end element))))))
		    ""
		    )))))
#+END_SRC

We could do more, e.g. links, or images, but this is pretty good for now. Now, let's configure a swish indexer. We instruct swish-e to use some metanames, and attributes so we can search on them later.

#+BEGIN_SRC text :tangle swish-org2xml.conf
# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com/_site

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org2xml.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the HTML parser.
IndexContents XML* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/org2xml.el

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
#+END_SRC

And now, run the index command. I did this at the command line. There might be some problems with the script as there were some warnings about non-zero exits, but there was only a few so we ignore them for now.

#+BEGIN_SRC sh
swish-e -c swish-org2xml.conf
#+END_SRC


** Examples of searching for org-files
   :PROPERTIES:
   :ID:       64A78153-F6E6-4A24-9410-928411B5667C
   :END:
*** Files with words in the filename
    :PROPERTIES:
    :ID:       BA000A1D-09AC-4482-BBF8-7FD644BBA862
    :END:
Here we look for filenames with the word "Extracting" in them.

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w root.filename=Extracting
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: root.filename=Extracting
: # Removed stopwords:
: # Number of hits: 2
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/19/Extracting-bibtex-file-from-an-org-buffer.org "Extracting-bibtex-file-from-an-org-buffer.org" 6094
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
: .

Or, thanks to the date being in the path, we can find by year, How about July of 2012?
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w root.filename="(2012/07)"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: root.filename=(2012/07)
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2012/07/15/Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org "Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org" 311
: .

Interesting we have to use the parentheses here.

*** DONE Files with headlines containing a word
    CLOSED: [2015-07-04 Sat 16:39]
    :PROPERTIES:
    :date:     2015/07/04 16:39:02
    :updated:  2015/07/04 16:39:02
    :ID:       1F818AB5-4BB5-48B2-89EB-A9362B0C97D5
    :END:
Now, lets find documents with "Compiled" in a heading title with level=2
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w heading.level=2 title=Compiled -m5
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: heading.level=2 title=Compiled
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
: .

*** Headlines marked TODO
    :PROPERTIES:
    :ID:       4CE3A814-C1A9-4061-BF96-A066D240DC32
    :END:
We can find documents with headlines marked TODO:
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e  -w "todo=TODO" -m 5
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: todo=TODO
# Removed stopwords:
# Number of hits: 12
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-01-27-Clocking-your-time-in-org-mode/blog.org "blog.org" 134160
624 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/A-dynamic-snippet-for-a-task-due-7-days-from-now.org "A-dynamic-snippet-for-a-task-due-7-days-from-now.org" 2587
425 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/END.org "END.org" 1531
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/02/01/Handling-multiple-selections-in-helm.org "Handling-multiple-selections-in-helm.org" 3290
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/01/30/More-adventures-in-helm---more-than-one-action.org "More-adventures-in-helm---more-than-one-action.org" 3236
.
#+end_example

*** For a table
    :PROPERTIES:
    :ID:       07C2AF01-4E02-4007-8C08-3972E5D867D8
    :END:
so2-capacity-1

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w table="energy"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: table=energy
: # Removed stopwords:
: # Number of hits: 2
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
: 633 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/07/04/Estimating-uncertainties-in-equations-of-state.org "Estimating-uncertainties-in-equations-of-state.org" 3117
: .

*** Tagged headlines
    :PROPERTIES:
    :ID:       923F83C6-C1ED-4147-B303-4E5A8F1BBD11
    :END:
Find entries with a "slide" tag.
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w "tags=slide"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: tags=slide
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.009 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
: .

Evidently there is one file where I talk about slides in org-show.

*** Headlines with a property
    :PROPERTIES:
    :ID:       685D1980-FA0C-4B29-9300-BC0DFF8C1F84
    :END:
Here I find documents with headlines that have thermodynamics in the property "categories".
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w "property.label=categories property=thermodynamics"
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: property.label=categories property=thermodynamics
# Removed stopwords:
# Number of hits: 10
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/01/Water-gas-shift-equilibria-via-the-NIST-Webbook.org "Water-gas-shift-equilibria-via-the-NIST-Webbook.org" 10789
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook.org "Gibbs-energy-minimization-and-the-NIST-webbook.org" 5441
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org "Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org" 6155
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/27/Reading-parameter-database-text-files-in-python.org "Reading-parameter-database-text-files-in-python.org" 3947
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org "The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org" 8230
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture.org "Calculating-a-bubble-point-pressure-of-a-mixture.org" 3203
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/15/The-equal-area-method-for-the-van-der-Waals-equation.org "The-equal-area-method-for-the-van-der-Waals-equation.org" 5737
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org "Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org" 5210
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions.org "Constrained-minimization-to-find-equilibrium-compositions.org" 5666
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/09/23/Generating-an-atomic-stoichiometric-matrix.org "Generating-an-atomic-stoichiometric-matrix.org" 3487
.
#+end_example

That seems about right, according to http://kitchingroup.cheme.cmu.edu/categories.html there are 9 documents. I am not sure why they don't totally agree, but I can live with it.

Here are documents containing headlines with the property "TOTAL_ENERGY"
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w property.label=TOTAL_ENERGY
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: property.label=TOTAL_ENERGY
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.008 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
: .

*** Documents with a Python source block containing a word
    :PROPERTIES:
    :ID:       C746AB3E-CCB5-4A0B-970A-AAFAC4BCAD65
    :END:
Find org files with diffusion in a python source block.
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w src-block.language=python -w src-block=diffusion
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: src-block.language=python src-block=diffusion
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.011 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/04/02/Transient-diffusion---partial-differential-equations.org "Transient-diffusion---partial-differential-equations.org" 3660
: .

*** An org-file with a UUID
    :PROPERTIES:
    :ID:       B95621BD-F117-4E30-895C-5DD4EA67DD8F
    :END:

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w  property="(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: property=(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/11/23/Machine-gradable-quizzes-in-emacs+org-modex.org "Machine-gradable-quizzes-in-emacs+org-modex.org" 5743
: .

Interesting, again the parentheses are necessary to find a match. I think because of the dashes. The next example is similar, but finds an entry with that bibtex key in a CUSTOM_ID property.

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w  property="(mantina-2008-first-princ)"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: property=(mantina-2008-first-princ)
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.010 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
: .

** Summary
   :PROPERTIES:
   :ID:       8F4A8D8A-C515-42FC-BB45-D0BE9B0A4C58
   :END:
This is pretty cool. There are still some bugs to work out in the indexing filter I think, but this demonstrates you can index org-files, and have pretty refined searches to find your files. There is still some thinking to do on how to schedule an incremental indexing, and whether we need more or better metanames. The indexing is not fast, but that is probably because I am running this through a FileFilter, rather than the -s prog option in swish-e. This is super promising to me though. Imagine building an agenda from files found with TODO headlines in them; a global todo list! Or, grabbing contacts from wherever they are.  No more losing files you have not used in a while. Find all documents containing a citation. With some extra work, you could index links, citations, [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/02/Pyparsing-meets-Emacs-to-find-chemical-formulas/][chemical formulas]], or other types of identifiable content.

The logical conclusion of this work might be an ox-swish-e-xml export engine to render the org-file into xml, rather than the script I used here. It would be really great to get some refined output, e.g. rather than just get matching documents, get location information so you could open the document to the matching element. That might be out of reach for swish-e, but could be in reach for other programs like Sphinx that are more integrated with a database. There is a very interesting project here: https://github.com/wvxvw/sphinx-mode to integrate org-mode with the Sphinx search (http://sphinxsearch.com) engine.
* DONE Pyparsing meets Emacs to find chemical formulas
  CLOSED: [2015-07-02 Thu 12:22]
  :PROPERTIES:
  :categories: python,emacs
  :date:     2015/07/02 12:22:57
  :updated:  2015/07/02 12:38:04
  :ID:       A16BCD97-2704-4A84-A288-820D9CE21002
  :END:

see the video: https://www.youtube.com/watch?v=sjxS9m8QCoo

Today we expand the concepts of clickable text and merge an idea from Python with Emacs. Here we will use Python to find chemical formulas in the buffer, and then highlight them with Emacs.  We will use pyparsing to find the chemical formulas and then use them to create a pattern for button-lock. I chose this approach because regular expressions are hard to use on the most general kinds of chemical formulas, and a (possibly recursive) parser should be better equipped to handle this. I adapted an [[https://pyparsing.wikispaces.com/file/view/chemicalFormulas.py/31041705/chemicalFormulas.py][example]] grammar to match simple chemical formulas, i.e. ones that do not have any parentheses, or charges different than + or -. I think something like this could be done in Emacs, but I am not as familiar with this kind of parsing in Emacs.

Basically, we treat a formula as a group of one or more Elements that have an optional number following them. Spoiler alert: This mostly works, but in the end I conclude there is a clear benefit to a markup language for chemical formulas. Here is an example usage of a parser:

#+BEGIN_SRC python
# adapted from [[https://pyparsing.wikispaces.com/file/view/chemicalFormulas.py/31041705/chemicalFormulas.py]]

from pyparsing import *

element = oneOf( """H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No""" )

integer = Word(nums)
elementRef = Group(element + Optional(integer))
chemicalFormula = (WordStart(alphas.upper())
                   + OneOrMore(elementRef).leaveWhitespace()
                   + Optional(Or([Literal("-"),
                                  Literal("+")]))
                   + WordEnd(alphas + nums + "-+"))


s = '''Water is  H2O or OH2  not h2O, methane is CH4 and of course there is PtCl4.
What about H+ and OH-? and carbon or Carbon or H2SO4?

Is this C6H6? or C2H5OH?

and a lot of elements:
H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No'''

matches = []
for match, start, stop in chemicalFormula.scanString(s):
   matches.append(s[start:stop])

print sorted(matches, key=lambda x: len(x), reverse=True)
#+END_SRC
#+RESULTS:
: ['C2H5OH', 'PtCl4', 'H2SO4', 'C6H6', 'H2O', 'OH2', 'CH4', 'OH-', 'Uub', 'Uut', 'Uuq', 'Uup', 'Uuh', 'Uus', 'Uuo', 'H+', 'He', 'Li', 'Be', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'Cl', 'Ar', 'Ca', 'Sc', 'Ti', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'Xe', 'Cs', 'Ba', 'Lu', 'Hf', 'Ta', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Ac', 'Th', 'Pa', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'O', 'H', 'B', 'C', 'N', 'O', 'F', 'P', 'S', 'K', 'V', 'Y', 'I', 'W', 'U']

That is pretty good. If the string was actually our buffer, we could use those to create a regexp to put text-properties on them. The trick is how to get the buffer string to the Python function, and then get back usable information in lisp. We actually explored this [[http://kitchingroup.cheme.cmu.edu/blog/2015/05/16/Python-data-structures-to-lisp/][before]]! Rather than use that, we will just create the lisp output manually since this is a simple list of strings.

The first thing we should do is work out a Python script that will output the lisp results we want, which are the found formulas (I tried getting the start and stop positions, but I don't think they map onto the buffer positions very well). Here it is. We set it up as a command line tool that takes a string. We use set to get a unique list, then sort the list by length so we try matching the longest patterns first. There are a few subtle differences in this script and the example above because of some odd false hits I unsuccessfully tried to get rid of.

#+BEGIN_SRC python :tangle parse_chemical_formulas.py :tangle-mode (identity #o755) :shebang #!/usr/bin/env python
import sys
from pyparsing import *

element_string =  """H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No"""
element = oneOf([x for x in element_string.split()])

integer = Word(nums)
elementRef = Group(element + Optional(integer))
chemicalFormula = (WordStart(alphas.upper()).leaveWhitespace()
                   + OneOrMore(elementRef).leaveWhitespace()
                   + Optional(Or([Literal("-"),
                                  Literal("+")])).leaveWhitespace()
                   + WordEnd(alphas + alphas.lower() + nums + "-+").leaveWhitespace())

s = sys.stdin.read().strip()

matches = []
for match, start, stop in chemicalFormula.scanString(s):
   matches.append(s[start:stop])
matches = list(set(matches))
matches.sort(key=lambda x: len(x), reverse=True)

print "'(" + ' '.join(["\"{}\"".format(m) for m in matches]) + ')'
#+END_SRC

#+RESULTS:

Now we can test this:

#+BEGIN_SRC sh
echo "Water is H2O, methane is CH4 and of course PtCl4, what about H+ and OH-? and carbon or Carbon. Water is H2O not h2o or mH2o, methane is CH4 and of course PtCl4, what about H+ and OH-? carbon, Carbon and SRC, or H2SO4? Is this C6H6? Ethanol is C2H5OH in a sentence.

 C2H5OH firs con

This is CH3OH

H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No
" | ./parse_chemical_formulas.py
#+END_SRC
#+RESULTS:
: '("C2H5OH" "CH3OH" "PtCl4" "H2SO4" "C6H6" "CH4" "OH-" "Uub" "Uuq" "Uup" "Uus" "Uuo" "Uuh" "H2O" "Uut" "Ru" "Re" "Rf" "Rg" "Ra" "Rb" "Rn" "Rh" "Be" "Ba" "Bh" "Bi" "Bk" "Br" "Ho" "Os" "Es" "Hg" "Ge" "Gd" "Ga" "Pr" "Pt" "Pu" "Pb" "Pa" "Pd" "Cd" "Po" "Pm" "Hs" "Hf" "He" "Md" "Mg" "Mo" "Mn" "Mt" "Zn" "H+" "Eu" "Zr" "Er" "Ni" "No" "Na" "Nb" "Nd" "Ne" "Np" "Fr" "Fe" "Fm" "Sr" "Kr" "Si" "Sn" "Sm" "Sc" "Sb" "Sg" "Se" "Co" "Cm" "Cl" "Ca" "Cf" "Ce" "Xe" "Tm" "Cs" "Cr" "Cu" "La" "Li" "Tl" "Lu" "Lr" "Th" "Ti" "Te" "Tb" "Tc" "Ta" "Yb" "Db" "Dy" "Ds" "Ac" "Ag" "Ir" "Am" "Al" "As" "Ar" "Au" "At" "In" "H" "P" "C" "K" "O" "S" "W" "B" "F" "N" "V" "I" "U" "Y")

That seems to work great. Now, we have a list of chemical formulas. Now, the Emacs side to call that function. We do not use regexp-opt here because I found it optimizes too much, and doesn't always match the formulas. We want explicit matches on each formula.

#+BEGIN_SRC emacs-lisp
(defun shell-command-on-region-to-string (start end command)
  (with-output-to-string
    (shell-command-on-region start end command standard-output)))

(read (shell-command-on-region-to-string
        (point-min) (point-max)
        "./parse_chemical_formulas.py"))
#+END_SRC

#+RESULTS:
| quote | (C2H5OH ext; t CH3OH PtCl4 H2SO4 the   fir C6H6 CH4 OH- OH2 Uub  co Uuq Uup Uus Uuo Uuh ord H2O Uut Ru Re Rf Rg Ra Rb Rn Rh Be Ba Bh Bi Bk Br Ho Os Es Hg Ge Gd Ga Pr  t Pt Pu Pb Pa Pd Cd Po Pm Hs Hf He Md Mg Mo Mn Mt Zn H+ Eu Zr Er Ni No Na Nb Nd Ne Np Fr Fe Fm Sr Kr Si Sn Sm Sc Sb Sg Se Co Cm Cl Ca Cf Ce Xe Tm Cs Cr Cu La Li Tl Lu Lr Th Ti Te Tb Tc as Ta Yb Db Dy Ds In Ac Ag Ir Am Al As Ar Au At n H P l t C r K O S W w B F N V   I U Y e i) |


That is certainly less than perfect, you can see a few false hits that are not too easy to understand, e.g. why is "fir" or "the " or "as"  in the list? They don't even start with an uppercase letter. One day maybe I will figure it out. I assume it is a logic flaw in my parser. Until then, let's go ahead and make the text functional, so it looks up the formula in the NIST webbook. The regexp is a little funny, we have to add word-boundaries to each formula to avoid some funny, bad matches.

#+BEGIN_SRC emacs-lisp :results silent
(defvar chemical-formula-button nil "store button for removal later.")

(require 'nist-webbook)
(setq chemical-formula-button
      (button-lock-set-button
       (mapconcat
	(lambda (formula)
	  (concat "\\<" (regexp-quote formula) "\\>"))
	(eval (read (shell-command-on-region-to-string
		     (point-min) (point-max)
		     "./parse_chemical_formulas.py")))
	"\\|")
       (lambda () (interactive)
	 (nist-webbook-formula
	  (get-surrounding-text-with-property
	   'chemical-formula)))
       :face '((:underline t) (:background "gray80"))
       :help-echo "A chemical formula"
       :additional-property 'chemical-formula))
#+END_SRC

Here are a few tests: CH4, C2H5OH, C6H6. C(CH3)4. C6H6 is benzene. As you can see our pattern lacks context; the first word of the sentence is "as" not the symbol for arsenic. Also, our parser does not consider formulas with parentheses in them. Whenever I refer to myself, I mean myself, and not the element iodine. There are a few weird matchs I just don't understand, like firs d t x rn lac? These do not seem to match anything, and I wonder how they are getting in the list. I think this really shows that it would be useful to use some light markup for chemical formulas which would a) provide context, and b) enhance parsing accuracy. In LaTeX you would use \ce{I} to indicate that is iodine, and not a reference to myself. That is more clear than saying I use I in chemical reactions ;) And it also clarifies sentences like the letter W is used to represent tungsten as the symbol \ce{W}.

Nevertheless, we can click on the formulas, and get something to happen that is potentially useful. Is this actually useful? Conceptually yes, I think it could be, but clearly the parsing is not recognizing formulas perfectly. Sending the buffer to a dedicated program that can return a list of matches to highlight in Emacs is a good idea, especially if it is not easy to build in Emacs, or if a proven solution already exists.


Finally, we can remove the highlighted text like this. That was the reason for saving the button earlier!

#+BEGIN_SRC emacs-lisp
(when chemical-formula-button
  (button-lock-unset-button chemical-formula-button)
  (setq chemical-formula-button nil))
#+END_SRC

#+RESULTS:

* DONE Getting Emacs to read to me
  CLOSED: [2015-06-29 Mon 14:56]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/06/29 14:56:16
  :updated:  2015/06/29 14:56:16
  :ID:       C4A6E3CB-F07C-4C80-9CE3-BE80ADD6EEDC
  :END:

I thought it would be interesting to have Emacs read text on the screen. Why? Sometimes I get tired of reading ;) Seriously though, this has applications in accessibility, learning to read, translation, taking a break from looking at the screen, reading emails out loud, fun and games, etc... Seems like a worthwhile endeavor!

You may want to see this video: https://www.youtube.com/watch?v=8bgS8yDSkXw to hear how it works.

On a Mac, it turns out to be easy to get a voice with a little applescript:

#+BEGIN_SRC emacs-lisp
(do-applescript "say \"Hello John\" using \"Victoria\"")
#+END_SRC

#+RESULTS:

Interesting idea to integrate some feedback into Emacs-lisp functions! at least if you are on a Mac. All we need are some interactive functions that grab text, and pass them to the applescript with an appropriate amount of escaping any quotes and backslashes.

Here is a function to speak the word at point, or selected region, or the text passed to the function:

#+BEGIN_SRC emacs-lisp
(defvar words-voice "Vicki"
  "Mac voice to use for speaking.")

(defun words-speak (&optional text)
  "Speak word at point or region. Mac only."
  (interactive)
  (unless text
    (setq text (if (use-region-p)
		   (buffer-substring
		    (region-beginning) (region-end))
		 (thing-at-point 'word))))
  ;; escape some special applescript chars
  (setq text (replace-regexp-in-string "\\\\" "\\\\\\\\" text))
  (setq text (replace-regexp-in-string "\"" "\\\\\"" text))
  (do-applescript
   (format
    "say \"%s\" using \"%s\""
    text
    words-voice)))
#+END_SRC

#+RESULTS:
: words-speak

Now we can write:

#+BEGIN_SRC emacs-lisp
(words-speak "Hello John")
#+END_SRC

#+RESULTS:

One reason I wrote this is to read org-files to me. So, now we write some functions to read words, sentences and paragraphs. These are all syntactic units in Emacs. We write code to enable us to read the next or previous units with the prefix args. Finally,  we bind the commands to some keys and a hydra for fun.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)

(defun mac-say-word (&optional arg)
  "Speak word at point. With ARG, go forward ARG words."
  (interactive "P")
  ;; arg can be (4), 4, "-", or -1. we handle these like this.
  (let ((newarg))
    (when arg
      (setq newarg (cond
		    ((listp arg)
		     (round (log (car arg) 4)))
		    ((and (stringp arg) (string= "-" arg))
		     ((< 0 arg) arg)
		     -1)
		    (t arg)))
      (forward-word newarg))
    (when (thing-at-point 'word)
      (words-speak (thing-at-point 'word)))))

(defun mac-say-sentence (&optional arg)
  "Speak sentence at point. With ARG, go forward ARG sentences."
  (interactive "P")
  ;; arg can be (4), 4, "-", or -1. we handle these like this.
  (let ((newarg))
    (when arg
      (setq newarg (cond
		    ((listp arg)
		     (round (log (car arg) 4)))
		    ((and (stringp arg) (string= "-" arg))
		     ((< 0 arg) arg)
		     -1)
		    (t arg)))
      (forward-sentence newarg)
      (when (< 0 newarg) (forward-word)))
    (when (thing-at-point 'sentence)
      (words-speak (thing-at-point 'sentence)))))

(defun mac-say-paragraph (&optional arg)
  "Speak paragraph at point. With ARG, go forward ARG paragraphs."
  (interactive "P")
  ;; arg can be (4), 4, "-", or -1. we handle these like this.
  (let ((newarg))
    (when arg
      (setq newarg (cond
		    ((listp arg)
		     (round (log (car arg) 4)))
		    ((and (stringp arg) (string= "-" arg))
		     ((< 0 arg) arg)
		     -1)
		    (t arg)))
      (forward-paragraph newarg)
      (when (< 0 newarg) (forward-word)))
    (when (thing-at-point 'paragraph)
      (words-speak (thing-at-point 'paragraph)))))
#+END_SRC

#+RESULTS:
: mac-say-paragraph

Now for some key-bindings. I will make a hydra that allows repeating commands, and a keymap for more direct function calls.

#+BEGIN_SRC emacs-lisp

(defhydra mac-speak (:color red)
  "word speak"
  ("w" (progn (mac-say-word) (forward-word)) "Next word")
  ("W" (mac-say-word -1) "Previous word")
  ("s" (progn (mac-say-sentence) (forward-sentence)(forward-word)) "Next sentence")
  ("S" (mac-say-sentence -1) "Previous sentence")
  ("p" (progn (mac-say-paragraph) (forward-paragraph)) "Next paragraph")
  ("P" (mac-say-paragraph -1) "Previous paragraph"))

(define-prefix-command 'mac-speak-keymap)
(define-key mac-speak-keymap (vector ?w) 'mac-say-word)
(define-key mac-speak-keymap (vector ?s) 'mac-say-sentence)
(define-key mac-speak-keymap (vector ?p) 'mac-say-paragraph)
(define-key mac-speak-keymap (vector ?h) 'mac-speak/body)
(global-set-key (kbd "\C-xr") 'mac-speak-keymap)
#+END_SRC

#+RESULTS:
: mac-speak-keymap

Now, I can navigate text and have my Mac read it to me. It isn't quite like hearing a real person read it, but it is not too bad either. When you need a break from reading, this might be a nice tool!

* DONE Get spoken definitions from the Meriam dictionary
  CLOSED: [2015-06-30 Tue 11:26]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/06/30 11:26:41
  :updated:  2015/06/30 11:26:41
  :ID:       CB589D9A-F7E8-493D-B080-E35989FFE496
  :END:
Now that I can get [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/29/Getting-Emacs-to-read-to-me/][Emacs to speak words]], here is a new application of the idea. We use it to speak the definition of the word at point. We look up the definition here:
http://www.dictionaryapi.com/account/index.htm

You may want to head straight to the video to see how this works here: https://www.youtube.com/watch?v=m529gXMrXZA


I had to get an API key for this. I suppose this key should be secret, but it could only be secure by obscurity in any kind of webapp and I don't anticipate using this much so here are the keys I got for the dictionary and thesaurus.

Key (Dictionary): 64f0950a-03b9-4315-9ba5-a73a964251ed
Key (Thesaurus): ff0e39e2-b31f-4f17-833c-24e2875aad5d

#+BEGIN_SRC emacs-lisp
(with-current-buffer
    (url-retrieve-synchronously
     (format
      "http://www.dictionaryapi.com/api/v1/references/collegiate/xml/%s?key=%s"
      "synchronous"
      "64f0950a-03b9-4315-9ba5-a73a964251ed"))
  (buffer-substring url-http-end-of-headers (point-max)))
#+END_SRC

#+RESULTS:
:
: <?xml version="1.0" encoding="utf-8" ?>
: <entry_list version="1.0">
:	<entry id="synchronous"><ew>synchronous</ew><subj>AE-4b#CP-5#TL-5</subj><hw>syn*chro*nous</hw><sound><wav>synchr14.wav</wav><wpr>!siN-kru-nus</wpr></sound><pr>ËˆsiÅ‹-krÉ™-nÉ™s, Ëˆsin-</pr><fl>adjective</fl><et>Late Latin <it>synchronos,</it> from Greek, from <it>syn-</it> + <it>chronos</it> time</et><def><date>1669</date> <sn>1</sn> <dt>:happening, existing, or arising at precisely the same time</dt> <sn>2</sn> <dt>:recurring or operating at exactly the same periods</dt> <sn>3</sn> <dt>:involving or indicating <fw>synchronism</fw></dt> <sn>4 a</sn> <dt>:having the same period</dt> <sd>also</sd> <dt>:having the same period and phase</dt>  <sn>b</sn> <dt>:<sx>geostationary</sx></dt> <sn>5</sn> <dt>:of, used in, or being digital communication (as between computers) in which a common timing signal is established that dictates when individual bits can be transmitted and which allows for very high rates of data transfer</dt><ss>contemporary</ss></def><uro><ure>syn*chro*nous*ly</ure> <fl>adverb</fl></uro><uro><ure>syn*chro*nous*ness</ure> <fl>noun</fl></uro></entry>
:	<entry id="synchronous motor"><ew>synchronous motor</ew><subj>ME#EE</subj><hw>synchronous motor</hw><fl>noun</fl><def><date>1897</date><dt>:an electric motor having a speed strictly proportional to the frequency of the operating current</dt></def></entry>
: </entry_list>

The idea is to query the url, get some xml back, and collect the definitions from it. Then, construct a string of the word, the number of definitions, then the definitions, and say it.

#+BEGIN_SRC emacs-lisp
(defun speak-definition ()
  (interactive)
  (let* ((keyword (thing-at-point 'word))
	 (api-key "64f0950a-03b9-4315-9ba5-a73a964251ed")
	 (xml (with-current-buffer
		  (url-retrieve-synchronously
		   (format
		    "http://www.dictionaryapi.com/api/v1/references/collegiate/xml/%s?key=%s"
		    keyword
		    api-key))
		(xml-parse-region url-http-end-of-headers (point-max))))
	 (entries (xml-get-children (car xml) 'entry))
	 (nentries (length entries))
	 (defs (loop for entry in entries
		     collect (car (xml-get-children entry 'def))))
	 (definition (format
		      "%s"
		      (concat
		       (format "%s has %s definition%s. "
			       keyword
			       nentries
			       (if (or (= 0 nentries)
				       (> nentries 1))
				   "s"
				 ""))
		       (mapconcat
			'identity
			(loop for element in
			      (loop for def in defs
				    collect (car (xml-get-children def 'dt)))
			      for i from 1
			      collect (format "%s %s" i (car (xml-node-children element))))
			" ")))))
    (message definition)
    (do-applescript
     (format
      "say \"%s\"" definition))))
#+END_SRC

#+RESULTS:
: speak-definition

Let us try this out on a few words: asynchronous  synchronous  flibbity

I guess this would be helpful sometimes ;)

* DONE Spoken translations in Emacs
  CLOSED: [2015-07-01 Wed 11:42]
  :PROPERTIES:
  :categories: emacs,speech
  :date:     2015/07/01 11:42:28
  :updated:  2015/07/01 11:42:28
  :ID:       D0361050-540A-4734-A25A-1B27C7DA3ED4
  :END:

Finally, continuing our experiments with computer speech for fun, let us try a translation of text to another language that is then spoken. Here is a free translator that has the courtesy to reply with json with the translated text in it. http://mymemory.translated.net/api/get?q=Hello%20World!&langpair=en|de I had to download a German voice called Anna, then get some translated text.

As with previous posts, there is a video: https://www.youtube.com/watch?v=8CBKnahE0ak. I am trying ScreenFlow for these (instead of Camtasia), and I still have not quite mastered the aspect ratio, so the videos still look a little odd.

As a reminder, we have this easy way to speak text in applescript. If you are on Linux, check out [[https://wiki.archlinux.org/index.php/Festival][Festival]] and on windows you may find some inspiration [[http://stackoverflow.com/questions/1040655/ms-speech-from-command-line][here]].

#+BEGIN_SRC emacs-lisp
(do-applescript "say \"Hello. My name is John. I am glad to meet you.\"")
#+END_SRC

#+RESULTS:

You can retrieve json data of the translated text, and then we can use it in our [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/29/Getting-Emacs-to-read-to-me/][word-speak]] function we previously developed. Here is an example in in German.
#+BEGIN_SRC emacs-lisp :results code
(let* ((words-voice "Anna")
       (text "Hello. My name is John. I am glad to meet you.")
       (url (format "http://mymemory.translated.net/api/get?q=%s!&langpair=en|de"
		    text))
       (json (with-current-buffer
		 (url-retrieve-synchronously url)
	       (json-read-from-string
		(buffer-substring url-http-end-of-headers (point-max)))))
       (translated-text (cdr (assoc 'translatedText (cdr (assoc 'responseData json))))))
  (words-speak translated-text)
  translated-text)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
"Hallo. Mein Name ist John. Ich freue mich, Sie kennen zu lernen.!"
#+END_SRC


How about Chinese? Again, I downloaded a Chinese voice called "Ting-Ting".
#+BEGIN_SRC emacs-lisp :results code
(let* ((words-voice "Ting-Ting")
       (text "Hello. My name is John. I am glad to meet you.")
       (url (format "http://mymemory.translated.net/api/get?q=%s!&langpair=en|zh"
		    text))
       (json (with-current-buffer
		 (url-retrieve-synchronously url)
	       (json-read-from-string
		(buffer-substring url-http-end-of-headers (point-max)))))
       (translated-text (cdr (assoc 'translatedText (cdr (assoc 'responseData json))))))
  (words-speak translated-text)
  translated-text)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
"ä½ å¥½ã€‚æˆ‘çš„åå­—æ˜¯çº¦ç¿°ã€‚æˆ‘å¾ˆé«˜å…´è§åˆ°ä½ ã€‚!"
#+END_SRC

So, can any Chinese readers and listeners confirm if the text translates correctly, and if Ting-Ting said it correctly? Hopefully it is good enough to make some sense and be useful!

* DONE Serializing an Atoms object in xml
  CLOSED: [2015-06-28 Sun 12:26]
  :PROPERTIES:
  :categories: python,xml,ase
  :date:     2015/06/28 12:26:00
  :updated:  2015/06/28 12:26:00
  :ID:       AC6C0329-5C40-4F29-8980-287E8B1579B0
  :END:
I have a future need to serialize an Atoms object from [[https://wiki.fysik.dtu.dk/ase/][ase]] as XML. I would use json usually, but I want to use a program that will index xml. I have previously used [[https://pypi.python.org/pypi/pyxser/1.5.2-r2][pyxser]] for this, but I recall it being difficult to install, and it does not pip install on my Mac. So, here we look at [[https://pypi.python.org/pypi/xmlwitch/0.2.1][xmlwitch]] which does pip install ;). This package does some serious magic with context managers.

One thing I am not sure about here is the best way to represent numbers and lists/arrays. I am using repr here, and assuming you would want to read this back in to Python where this could simply be eval'ed. Some alternatives would be to convert them to lists, or save them as arrays of xml elements.

#+BEGIN_SRC python
from ase.data.g2 import data
from ase.structure import molecule
import xmlwitch

atoms = molecule('H2O')

def serialize_atoms(atoms):
    'Return an xml string of an ATOMS object.'
    xml = xmlwitch.Builder(version='1.0', encoding='utf-8')

    with xml.atoms():
        for atom in atoms:
            with xml.atom(index=repr(atom.index)):
                xml.symbol(atom.symbol)
                xml.position(repr(atom.position))
                xml.magmom(repr(atom.magmom))
                xml.mass(repr(atom.mass))
                xml.momentum(repr(atom.momentum))
                xml.number(repr(atom.number))
        xml.cell(repr(atoms.cell))
        xml.pbc(repr(atoms.pbc))
    return xml

atoms_xml = serialize_atoms(atoms)
print atoms_xml

with open('atoms.xml', 'w') as f:
    f.write(str(atoms_xml))
#+END_SRC

#+RESULTS:
#+begin_example
<?xml version="1.0" encoding="utf-8"?>
<atoms>
  <atom index="0">
    <symbol>O</symbol>
    <position>array([ 0.      ,  0.      ,  0.119262])</position>
    <magmom>0.0</magmom>
    <mass>15.9994</mass>
    <momentum>array([ 0.,  0.,  0.])</momentum>
    <number>8</number>
  </atom>
  <atom index="1">
    <symbol>H</symbol>
    <position>array([ 0.      ,  0.763239, -0.477047])</position>
    <magmom>0.0</magmom>
    <mass>1.0079400000000001</mass>
    <momentum>array([ 0.,  0.,  0.])</momentum>
    <number>1</number>
  </atom>
  <atom index="2">
    <symbol>H</symbol>
    <position>array([ 0.      , -0.763239, -0.477047])</position>
    <magmom>0.0</magmom>
    <mass>1.0079400000000001</mass>
    <momentum>array([ 0.,  0.,  0.])</momentum>
    <number>1</number>
  </atom>
  <cell>array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])</cell>
  <pbc>array([False, False, False], dtype=bool)</pbc>
</atoms>
#+end_example

Now, we can try reading that file. I am going to use emacs-lisp here for fun, and compute the formula.

#+BEGIN_SRC emacs-lisp
(let* ((xml (car (xml-parse-file "atoms.xml")))
       (atoms (xml-get-children xml 'atom))
       (symbol-elements (mapcar (lambda (atom)
				  (car (xml-get-children atom 'symbol)))
				atoms))
       (symbols (mapcar (lambda (x)
			  (car (xml-node-children x)))
			symbol-elements)))
  (mapconcat (lambda (c)
	       (format "%s%s" (car c)
		       (if (= 1 (cdr c))
			   ""
			 (cdr c))))
	     (loop for sym in (-uniq symbols)
		   collect (cons
			    sym
			    (-count (lambda (x) (string= x sym)) symbols)))
	     ""))
#+END_SRC

#+RESULTS:
: OH2

Here is a (misleadingly) concise way to do this in Python. It is so short thanks to there being a Counter that does what we want, and some pretty nice list comprehension!

#+BEGIN_SRC python
import xml.etree.ElementTree as ET
from collections import Counter
with open('atoms.xml') as f:
    xml = ET.fromstring(f.read())

counts = Counter([el.text for el in xml.findall('atom/symbol')])

print ''.join(['{0}{1}'.format(a,b) if b>1 else a for a,b in counts.iteritems()])
#+END_SRC

#+RESULTS:
: H2O

And finally a test on reading a unit cell.

#+BEGIN_SRC python
import xml.etree.ElementTree as ET
from numpy import array

with open('atoms.xml') as f:
    xml = ET.fromstring(f.read())

print eval(xml.find('cell').text)
#+END_SRC

#+RESULTS:
: [[ 1.  0.  0.]
:  [ 0.  1.  0.]
:  [ 0.  0.  1.]]

That seems to work but, yeah, you won't want to read untrusted xml with that! See http://stupidpythonideas.blogspot.com/2013/11/repr-eval-bad-idea.html. It might be better (although not necessarily more secure) to use pickle or some other serialization strategy for this.

* DONE Clickable text for learning environments
  CLOSED: [2015-06-26 Fri 11:22]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/06/26 11:22:17
  :updated:  2015/06/26 11:22:17
  :ID:       1732251C-BBED-465D-9F7B-44016A5B3392
  :END:

One use for clickable text is in educational texts, or technical documents where you want easy access to glossaries for jargon or new words, or other context specific information. Here we consider some approaches to highlight words in an Emacs buffer that are defined in a glossary, to give them tooltips and make them clickable.

You may want to see the video of this in action, the blog post does not do it justice: http://www.youtube.com/watch?v=Ogavyl_QXiU

We assume we have a [[*Glossary]] in the current document that has the words we want to highlight as headlines.  Here is a somewhat hacky way to get the list of keywords (hacky because we use cdr to get rid of the Glossary in the list). Our glossary only has two terms: INCAR and KPOINTS.

#+BEGIN_SRC emacs-lisp
(save-excursion
    (org-open-link-from-string "[[*Glossary]]")
    (cdr  (org-map-entries (lambda ()
			     (nth 4 (org-heading-components)))
			   nil 'tree)))
#+END_SRC

#+RESULTS:
| INCAR | KPOINTS |

We can use that list to make the regexp for button lock with regexp-opt like we did before. We illustrate two ideas here for the highlighted text. One is a dynamic tooltip, which we calculate on the fly and use to display the contents of the glossary heading when you mouse over the word or call local help from the keyboard (C-h .). Second, when you click on the word, you jump to the section in the glossary, and you can readily jump back with C-c & (Thanks org-mode!).

#+BEGIN_SRC emacs-lisp
(defun highlight-glossary-words ()
  (button-lock-set-button
   (regexp-opt (save-excursion
		 (org-open-link-from-string "[[*Glossary]]")
		 (cdr  (org-map-entries
			(lambda ()
			  (nth 4 (org-heading-components)))
			nil 'tree))))
   (lambda ()
     "Jump to definition."
     (interactive)
     (let ((keyword (get-surrounding-text-with-property 'glossary)))
       (org-open-link-from-string (format "[[*%s]]" keyword))))
   :additional-property 'glossary
   :face '((:background "gray80") (:underline t))
   :help-echo (lambda (window object position)
		(save-excursion
		  (goto-char position)
		  (save-restriction
		    (org-open-link-from-string
		     (format "[[*%s]]" (get-surrounding-text-with-property 'glossary)))
		    (org-narrow-to-subtree)
		    (buffer-string))))))

(highlight-glossary-words)
#+END_SRC

#+RESULTS:
| \(?:INCAR\ | KPOINTS\) | (0 (quote (face ((:background gray80) (:underline t)) keymap (keymap (mouse-3 lambda nil (interactive) (message-box done)) (mouse-1 lambda nil Jump to definition. (interactive) (let ((keyword (get-surrounding-text-with-property (quote glossary)))) (org-open-link-from-string (format [[*%s]] keyword))))) button-lock t glossary t mouse-face button-lock-mouse-face help-echo (lambda (window object position) (save-excursion (goto-char position) (save-restriction (org-open-link-from-string (format [[*%s]] (get-surrounding-text-with-property (quote glossary)))) (org-narrow-to-subtree) (buffer-string)))) rear-nonsticky t)) append) |

That is pretty cool. You might want something a little smarter for the tooltip, e.g. just the first line of the headline, but this works fine for this little example. I noticed that flyspell seems to get the tooltip in KPOINTS, sometimes, when it thinks it is misspelled.

It might take some local variables to make this work only in this just a file, rather than in every file. Alternatively, you could define a function that opens the file and then applies this.

** Glossary
   :PROPERTIES:
   :ID:       B52BB371-0AD9-4FDE-A392-50D4E29C2391
   :END:
*** INCAR
    :PROPERTIES:
    :ID:       6CFAE313-B479-427E-BF38-F89F4532BC6E
    :END:
The file containing all the input parameters for VASP.



*** KPOINTS
    :PROPERTIES:
    :ID:       B4439C45-DFB9-4D77-B567-FD0CE7B52D08
    :END:
The file containing the definitions of the kpoint grid.

See http://cms.mpi.univie.ac.at/vasp/vasp/KPOINTS_file.html


* DONE Integrating swish-e and Emacs
  CLOSED: [2015-06-25 Thu 10:37]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/06/25 10:37:05
  :updated:  2015/06/25 11:10:22
  :ID:       1E09B0E0-BA4C-4188-A930-C80113A69AAC
  :END:

[[http://swish-e.org][swish-e]] is a software package that indexes files on your computer, and then allows you to search the index. Spotlight on my Mac is not working too well (sometimes not at all), and I want some more flexibility so today we try getting swish-e up and running and integrated with Emacs. I don't know that swish-e is the best tool for this available, but it has been on my radar a /long/ time (probably since 2003 from this [[http://joshr.com/src/docs/HowToIndexAnything.pdf][article]]), and it was easy to setup and use.

I use homebrew, so installation was this simple:

#+BEGIN_SRC sh
brew install swish-e
#+END_SRC

To test things out, I will only index org-files. I have these all over the place, and they are not all in my org-mode agenda. So, finding them quickly would be awesome.

#+BEGIN_SRC text :tangle ~/.swish-e/swish.conf
# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox
IndexDir "/Users/jkitchin/Box Sync"
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/.swish-e/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

# Otherwise, use the HTML parser
DefaultContents HTML*

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
#+END_SRC

Now, we create our index.

#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish.conf
#+END_SRC

#+RESULTS:
#+begin_example
Indexing Data Source: "File-System"
Indexing "/Users/jkitchin/Dropbox"
Indexing "/Users/jkitchin/Box Sync"
Indexing "/Users/jkitchin/blogofile-jkitchin.github.com"
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 130,109 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: ...  Writing word text:  10%  Writing word text:  20%  Writing word text:  30%  Writing word text:  40%  Writing word text:  50%  Writing word text:  60%  Writing word text:  70%  Writing word text:  80%  Writing word text:  90%  Writing word text: 100%  Writing word text: Complete
  Writing word hash: ...  Writing word hash:  10%  Writing word hash:  20%  Writing word hash:  30%  Writing word hash:  40%  Writing word hash:  50%  Writing word hash:  60%  Writing word hash:  70%  Writing word hash:  80%  Writing word hash:  90%  Writing word hash: 100%  Writing word hash: Complete
  Writing word data: ...  Writing word data:   9%  Writing word data:  19%  Writing word data:  29%  Writing word data:  39%  Writing word data:  49%  Writing word data:  59%  Writing word data:  69%  Writing word data:  79%  Writing word data:  89%  Writing word data:  99%  Writing word data: Complete
130,109 unique words indexed.
Sorting property: swishdocpath                            Sorting property: swishtitle                              Sorting property: swishdocsize                            Sorting property: swishlastmodified                       4 properties sorted.
3,208 files indexed.  54,104,974 total bytes.  8,038,594 total words.
Elapsed time: 00:00:16 CPU time: 00:00:13
Indexing done!
#+end_example


Now an example search. I have been looking into the Energy frontier research centers, and I want to find my notes on it. Here is a little query. I use a special output format to keep things simple for the parsing later, just the rank and path, separated by a tab.

#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index.swish-e -x '%r\t%p\n' -w efrc
#+END_SRC
#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: efrc
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	/Users/jkitchin/Dropbox/org-mode/journal.org
471	/Users/jkitchin/Dropbox/org-mode/proposals.org
.
#+end_example

Now, for the integration with Emacs. We just get that output in a string, split it, and get the parts we want.  I think I will use helm to provide a selection buffer to these results. We need a list of cons cells (string . candidate). Then we write an interactive helm function. We provide two sources. One for the initial query, and another to start a new search, in case you don't find what you want.

#+BEGIN_SRC emacs-lisp
(defun helm-swish-e-candidates (query)
  "Generate a list of cons cells (swish-e result . path)."
  (let* ((result (shell-command-to-string
		  (format "swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"
			  (shell-quote-argument query))))
	 (lines (s-split "\n" result t))
	 (candidates '()))
    (loop for line in lines
	  unless (or  (s-starts-with? "#" line)
		      (s-starts-with? "." line))
	  collect (cons line (cdr (s-split "\t" line))))))


(defun helm-swish-e (query)
  "Run a swish-e query and provide helm selection buffer of the results."
  (interactive "sQuery: ")
  (helm :sources `(((name . ,(format "swish-e: %s" query))
		    (candidates . ,(helm-swish-e-candidates query))
		    (action . (("open" . (lambda (f)
					   (find-file (car f)))))))
		   ((name . "New search")
		    (dummy)
		    (action . (("search" . (lambda (f)
					     (helm-swish-e helm-pattern)))))))))
#+END_SRC

#+RESULTS:
: helm-swish-e

Now I can run M-x helm-swish-e and enter "efrc AND computing infrastructure" to find org files containing those words, then press enter to find the file. Nice and easy. I have not tested the query syntax very fully, but so far it is working fine!

* DONE Conditional hydra menus
  CLOSED: [2015-06-24 Wed 07:31]
  :PROPERTIES:
  :categories: emacs,hydra
  :date:     2015/06/24 07:31:41
  :updated:  2015/06/24 07:31:41
  :ID:       FF7EF38A-518B-49E4-A6EE-05A6D2BF6C38
  :END:

Usually the [[https://github.com/abo-abo/hydra][hydra]] menu is hard coded in the defhydra macro. Sometimes, you would like conditional options, that is, depending on some condition we get different options /when we run the hydra/ and not when it was defined. This is an open [[https://github.com/abo-abo/hydra/issues/86][issue]] in hydra. Here we explore a way to achieve that. The idea is to construct the code for the hydra, then eval it, and run the hydra. In this example we make the conditional menu depend on whether we are on an even or odd numbered line. I use the `' syntax for defining the list of code. ` is a variation of ' (quote) that enables you to use the , operator to evaluate that element while in data mode. So, here is our first idea:

#+BEGIN_SRC emacs-lisp
(defun my-hydra-1 ()
  (interactive)
  (eval
   `(defhydra my-hydra-1 (:color blue) "My hydra"
      ,(if (evenp (line-number-at-pos))
	   '("e" (message-box "Even line") "Even")
	 '("o" (message-box "Odd line") "Odd"))
      ,(when t '("a" (message-box "always true") "always"))
      ;; This does not work. you must return a legitimate hydra menu item
      ;;      ,(when nil '("n" (message-box "never") "never"))
      ))
  (my-hydra-1/body))

(my-hydra-1)
(my-hydra-1)
#+END_SRC

#+RESULTS:
: my-hydra

As long as it is not expensive to compute the conditionals, this seems like an easy enough way to get conditional options in a hydra. One limitation of the previous approach is our menu conditionals must return a hydra menu, and not nil. Here is an alternative approach to writing the function that solves the issue of the nil return in the last function. Here we build up the code list using append. It might seem like a macro should be used here, but I have not figured out how to get the macro to run the conditionals at the run-time. Note, we cannot use funcall on the defhydra because that is a macro.

#+BEGIN_SRC emacs-lisp
(defun my-hydra-2 ()
  (interactive)
  (let ((conditionals '((if (evenp (line-number-at-pos))
			    '("e" (message-box "Even second") "Even")
			  '("o" (message-box "Odd second") "Odd"))
			(when t '("a" (message-box "always true") "always"))
			(when nil '("n" (message-box "never") "never")))))
    (eval
     (append
      '(defhydra my-hydra-2 (:color blue) "My hydra")
      (loop for cond in conditionals
	    with result = (eval cond)
	    if (eval cond)
	    collect (eval cond))))
    (my-hydra-2/body)))

(my-hydra-2)
(my-hydra-2)
#+END_SRC

#+RESULTS:

That works too. Let us try another type of syntax where the conditional statements have a cons cell with a conditional statement, and a hydra menu option for when the statement is true. This is functionally similar to our first method, but has some advantages in brevity and less quoting. We add a conditional hint here too (at some expense of additional quoting).

#+BEGIN_SRC emacs-lisp
(defun my-hydra-3 ()
  (interactive)
  (let ((conditionals
	 `(((evenp (line-number-at-pos)) . ("e" (message-box "Even second") ,(format "Even: %s" (line-number-at-pos))))
	   ((oddp (line-number-at-pos)) . ("o" (message-box "Odd second") ,(format "Odd: %s" (line-number-at-pos))))
	   (t . ("a" (message-box "always true") "always"))
	   (nil . ("n" (message-box "never") "never")))))
    (eval
     (append
      '(defhydra my-hydra-3 (:color blue) "My hydra")
      (loop for cond in conditionals
	    if (eval (car  cond))
	    collect (cdr cond))))
    (my-hydra-3/body)))

(my-hydra-3)
(my-hydra-3)
#+END_SRC

I cannot figure out how to abstract this much further. There is a little redundancy in names, e.g. in the defhydra and at the end, but it is not too bad, which would usually be handled by a macro. I tried some defmacros to try this, but I could not figure out how to get the conditionals to expand at the right times, which is at run time, and not at macro expansion time. I need a macro that generates a function that has the call to defhydra in it! Maybe next year ;)

** failed macro attempt :noexport:
   :PROPERTIES:
   :ID:       13FDE358-33D1-4A65-975F-9F5CFC84A237
   :END:
#+BEGIN_SRC emacs-lisp
(defmacro cond-hydra (name color sname &rest conditionals)
  `(let ((conditionals (list ,@conditionals)))
     (eval
      (append
       (defhydra ,name ,color ,sname)
       ,(loop for cond in conditionals
	      if (eval (car  cond))
	      collect (cdr cond))))
     (funcall ,(intern (format "%s/body" name)))))


(cond-hydra
 hyd-3 (:color blue) "true-hyd"
 ((evenp (line-number-at-pos)) . ("e" (message-box "Even second") (format "Even: %s" (line-number-at-pos))))
 ((oddp (line-number-at-pos)) . ("o" (message-box "Odd second") (format "Odd: %s" (line-number-at-pos))))
 (t . ("a" (message-box "always true") "always"))
 (nil . ("n" (message-box "never") "never")))

(hyd-3/body)
#+END_SRC

* DONE Clickable org-contacts in text files
  CLOSED: [2015-06-22 Mon 13:07]
  :PROPERTIES:
  :categories: orgmode,contacts
  :date:     2015/06/22 13:07:03
  :updated:  2015/06/22 13:07:03
  :ID:       29FA1E3D-4E22-4110-AC8A-4497203BB0C0
  :END:

Continuing my adventures with clickable text (See [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/21/Clickable-email-addresses-in-emacs/][clickable email addresses]] and [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/18/Clickable-links-for-Twitter-handles-in-Emacs/][clickable twitter handles]]), here we consider how to get clickable names that are also in my org-contacts database. The goal is to have these names highlighted and clickable so that when I click on them I get a hydra menu of actions, e.g. to open the contact, email them, etc... We will again use button-lock to do the action. We will construct a fairly large regexp to match all the names in the org-contacts database. This turns out to be very easy using the regexp-opt function.

First, I formalize the code I used last time to get text around the point that has a text-property. We will use that to get the text that has been highlighted by button-lock.

#+BEGIN_SRC emacs-lisp
(defun get-surrounding-text-with-property (property)
  "Return text surrounding point with the text-property PROPERTY."
  (let ((start) (end))
    (when (get-text-property (point) property)
      (save-excursion
	(while (get-text-property (point) property)
	  (backward-char))
	(forward-char)
	(setq start (point))
	(while (get-text-property (point) property)
	  (forward-char))
	(setq end (point)))
      (buffer-substring start end))))
#+END_SRC

#+RESULTS:
: get-surrounding-text-with-property

I want to use nicknames that are defined in my org-contacts database. We first try to return an assoc lookup, then the slower approach of looping through the entries to find a matching nickname.

#+BEGIN_SRC emacs-lisp
(defun get-contact-from-name-or-nickname (name-or-nickname)
  "Return a contact from the org-contacts database for NAME-OR-NICKNAME."
  (or
   (assoc name-or-nickname (org-contacts-db))
   ;; no assoc, so now we have to find a nickname
   (catch 'contact
     (dolist (contact (org-contacts-db))
       (when (-contains? (s-split "," (or (cdr (assoc "NICKNAMES" (caddr contact))) " ")) name-or-nickname)
	 (throw 'contact contact))))))
#+END_SRC

#+RESULTS:
: get-contact-from-name-or-nickname

Now, let us write a hydra function that will be our menu of actions. For some reason, when you click on a highlighted text the mouse moves to the end of the text, so in our hydra function we move back a char, and then get the info. Basically, we get the name, then get the contact, and extract what we need from there. Here we provide functionality to open a contact, email a contact or open the url of the contact (if it exists). I also want a conditional hydra, which doesn't seem to be an option yet, so we we roll our own here. Basically, we construct the code for a hydra, and only add a menu option to open the url if we find one in the contact. We will have to eval the code returned from this function to get the hydra body, and then call the body function in the action function for the highlighted text.

#+BEGIN_SRC emacs-lisp
(defun conditional-hydra-actions ()
  "Construct code to create a hydra with conditional options."
  (let ((code  '(defhydra org-contacts (:color blue)
		  "Org contacts")))
    (setq code
	  (append
	   code
	   '(("o" (progn
		    (backward-char)
		    (let* ((name (get-surrounding-text-with-property 'org-contact))
			   (contact (get-contact-from-name-or-nickname name))
			   (contact-marker (nth 1 contact)))
		      (switch-to-buffer (marker-buffer contact-marker))
		      (goto-char (marker-position contact-marker))
		      (show-subtree)))
	      "Open contact"))))

    (setq code
	  (append
	   code '(("e" (progn
			 (backward-char)
			 (let* ((name (get-surrounding-text-with-property 'org-contact))
				(contact (get-contact-from-name-or-nickname name))
				(email (cdr (assoc "EMAIL" (caddr contact))))))
			 (mu4e~compose-mail email))
		   "Email contact"))))

    ;; conditional menu for opening a URL
    (let* ((name (get-surrounding-text-with-property 'org-contact))
	   (contact (assoc name (org-contacts-db)))
	   (url (cdr (assoc "URL" (caddr contact)))))
      (when url
	(setq code
	      (append
	       code '(("w" (progn
			     (backward-char)
			     (let* ((name (get-surrounding-text-with-property 'org-contact))
				    (contact (get-contact-from-name-or-nickname name))
				    (url (cdr (assoc "URL" (caddr contact)))))
			       (if url
				   (browse-url url)
				 (message "No url found."))))
		       "Open in browser"))))))
    code))
#+END_SRC

#+RESULTS:
: conditional-hydra-actions

I also want to have nicknames in this list, because sometimes I don't use the full names in my contact database. These are stored in a comma-separated property called NICKNAMES in entries that have them. A subtle point here is that it complicates looking up the contact in the database. Normally, I can get this by a simple assoc lookup. For the nicknames, that will fail, so we need a back up method. Now, the highlighting code. You can make the regexp by passing a list of strings to match to regexp-opt. We get our list of strings from:

#+BEGIN_SRC emacs-lisp
(append
 (mapcar 'car (org-contacts-db))
 (let ((nicknames '()))
   (dolist (contact (org-contacts-db))
     (when (assoc "NICKNAMES" (caddr contact))
       (setq nicknames
	     (append nicknames (s-split "," (cdr (assoc "NICKNAMES" (caddr contact))))))))
   nicknames))
#+END_SRC

I am not going to show them here to protect my contacts ;). Now, we create the function that highlights the contacts. and add it as a hook function to text-mode-hook.

#+BEGIN_SRC emacs-lisp
(defun highlight-org-contacts ()
  (button-lock-set-button
   (regexp-opt
    (append
     (mapcar 'car (org-contacts-db))
     (let ((nicknames '()))
       (dolist (contact (org-contacts-db))
	 (when (assoc "NICKNAMES" (caddr contact))
	   (setq nicknames
		 (append
		  nicknames
		  (s-split "," (cdr (assoc "NICKNAMES" (caddr contact))))))))
       nicknames)))
   (lambda ()
     (interactive)
     (eval (conditional-hydra-actions))
     (org-contacts/body))
   :face '((:background "MistyRose1")
	   (:underline t))
   :help-echo (format "An org contact")
   :keyboard-binding (kbd "RET")
   :additional-property 'org-contact))

(add-hook 'text-mode-hook 'highlight-org-contacts)
#+END_SRC

That does it. Now, whenever I open a text-based file, the names that are in my contacts are highlighted and actionable. This should be useful for meeting notes, etc...

* DONE Clickable email addresses in emacs
  CLOSED: [2015-06-21 Sun 16:42]
  :PROPERTIES:
  :categories: emacs,email
  :date:     2015/06/21 16:42:40
  :updated:  2015/06/21 16:42:40
  :ID:       7C21DF2B-42AC-45B4-90C9-98FEFE4CEB38
  :END:

There are clickable mailto:jkitchin@andrew.cmu.edu links in org-mode, but standalone email addresses like jkitchin@cmu.edu are just ordinary text. Here, I want to explore using clickable text instead. I will use the button-lock package for this. I borrowed an email regexp from [[http://www.emacswiki.org/emacs/RegularExpression][EmacsWiki: Regular Expression]] for this. The idea is to define a regular expression for an email address, and use it to make the emails clickable.

I am still not sure what the canonical way to get the value of the text that was highlighted. Here we use the :additional-property feature to set a property to t, and then use that property to get the characters that have a non-nil "email-address" property. It seems clunky, but it works. The main action is to compose an email in mu4e (my preferred email program in emacs). You could also put a call to helm here, or to a hydra for other options.

I make the email addresses stand out a little by giving them a gray background, and a tooltip so you can see why they are highlighted. I also bind RET so I don't have to use the mouse. Don't forget you can type C-h . to see the local help instead of mousing over it! Finally, we add a text-mode hook so this will get loaded when we open a text file (or one with a mode derived from text-moe like org-mode).

#+BEGIN_SRC emacs-lisp
(defun highlight-email-addresses ()
  "Add button to email address. Clicking or RET will open a compose email window."
  (button-lock-set-button
   "\\w+\\(\\.\\w+\\)?@\\(\\w\\|\\.\\)+"
   (lambda ()
     (interactive)
     (let ((start) (end) (email-address))
       (while (get-text-property (point) 'email-address)
	 (backward-char))
       (forward-char)
       (setq start (point))
       (while (get-text-property (point) 'email-address)
	 (forward-char))
       (setq end (point))
       (setq email-address (buffer-substring start end))
       (mu4e~compose-mail email-address)))
     :face '((:background "gray80") (:underline t))
     :help-echo "click to send mu4e email"
     :keyboard-binding (kbd "RET")
     :additional-property 'email-address))

(add-hook 'text-mode-hook 'highlight-email-addresses)
#+END_SRC

That doesn't look too bad. Now, anytime I open an org-mode file with an email address in it, the address is highlighted in light gray, and underlined. I can click on it or put the cursor on it and press return and I get a compose email window open, with the email address pre-filled in! I am sure this will have some other applications.

* DONE A python version of the s-exp bibtex entry
  CLOSED: [2015-06-11 Thu 10:02]
  :PROPERTIES:
  :categories: Python,ref,bibtex
  :date:     2015/06/11 10:02:33
  :updated:  2015/06/11 10:02:33
  :ID:       64E630AC-E0CA-437F-A1F2-0EB4A824EF19
  :END:

In this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/][post]] we explored representing a bibtex entry in lisp s-exp notation, and showed interesting things that enables. Here, I explore something similar in Python. The s-exp notation in Python is really more like tuples. It looks almost identical, except we need a lot of commas for the Python syntax. One significant difference in Python is we need to define the functions in advance because otherwise the function symbols are undefined. Similar to lisp, we can define the field functions at run-time in a loop. We have to use an eval statement, which some Pythonistas find distasteful, but it is not that different to me than what we did in lisp.

The syntax for "executing" the data structure is quite different than in lisp, because this data is /not/ code in Python. Instead, we have to deconstruct the data, knowing that the function is the first object, and it takes the remaining arguments in the tuple.

Here is the proof of concept:

#+BEGIN_SRC python
def article(bibtex_key, *args):
    "Return the bibtex formatted entry"
    return ',\n'.join(['@article{{{0}}}'.format(bibtex_key)] +[arg[0](arg[1]) for arg in args[0]] + ['}'])

fields = ("author", "title", "journal", "pages", "number", "doi", "url", "eprint", "year")

for f in fields:
    locals()[f] = eval ('lambda x: "  {0} = {{{1}}}".format("' + f + '", x)')

entry = (article, "hallenbeck-2013-effec-o2",
         (author, "Hallenbeck, Alexander P. and Kitchin, John R."),
	 (title, "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"),
	 (journal, "Industrial \& Engineering Chemistry Research"),
	 (pages, "10788-10794"),
         (year, 2013),
	 (number, 31),
	 (doi, "10.1021/ie400582a"),
	 (url, "http://pubs.acs.org/doi/abs/10.1021/ie400582a"),
	 (eprint, "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))


print entry[0](entry[1], entry[2:])
#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \& Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
#+end_example

Here is an approach that avoids using eval, and instead uses a function to generate a function.

#+BEGIN_SRC python
def article(bibtex_key, *args):
    "Return the bibtex formatted entry"
    return ',\n'.join(['@article{{{0}}}'.format(bibtex_key)] +[arg[0](arg[1]) for arg in args[0]] + ['}'])

fields = ("author", "title", "journal", "pages", "number", "doi", "url", "eprint", "year")

def make_func(field):
    return lambda x: '  {0} = {{{1}}}'.format(field, x)

for f in fields:
    locals()[f] = make_func(f)

entry = (article, "hallenbeck-2013-effec-o2",
         (author, "Hallenbeck, Alexander P. and Kitchin, John R."),
         (title, "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"),
         (journal, "Industrial \& Engineering Chemistry Research"),
         (pages, "10788-10794"),
         (year, 2013),
         (number, 31),
         (doi, "10.1021/ie400582a"),
         (url, "http://pubs.acs.org/doi/abs/10.1021/ie400582a"),
         (eprint, "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))


print entry[0](entry[1], entry[2:])

#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \& Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
#+end_example


We can still get specific fields out. Since we used a tuple here, it is not quite as nice as using a dictionary, but it is neither too bad, and it can be wrapped in a reasonably convenient function.

#+BEGIN_SRC python
def article(bibtex_key, *args):
    "Return the bibtex formatted entry"
    return ',\n'.join(['@article{{{0}}}'.format(bibtex_key)] +[arg[0](arg[1]) for arg in args[0]] + ['}'])

fields = ("author", "title", "journal", "pages", "number", "doi", "url", "eprint", "year")

for f in fields:
    locals()[f] = eval ('lambda x: "  {0} = {{{1}}}".format("' + f + '", x)')

entry = (article, "hallenbeck-2013-effec-o2",
         (author, "Hallenbeck, Alexander P. and Kitchin, John R."),
	 (title, "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"),
	 (journal, "Industrial \& Engineering Chemistry Research"),
	 (pages, "10788-10794"),
         (year, 2013),
	 (number, 31),
	 (doi, "10.1021/ie400582a"),
	 (url, "http://pubs.acs.org/doi/abs/10.1021/ie400582a"),
	 (eprint, "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))


for field in entry[2:]:
    if field[0] == author:
        print field

def get_field(entry, field):
    for element in entry[2:]:
        if element[0] == field:
            return element[1]
    else:
        return None

print get_field(entry, title)
print get_field(entry, "bad")
#+END_SRC

#+RESULTS:
: (<function <lambda> at 0x1005975f0>, 'Hallenbeck, Alexander P. and Kitchin, John R.')
: Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent
: None

So, it seems Python can do some things like lisp in treating functions like first-class objects that can be used as functions, or keys. I still like the lisp s-exp better, but this is an interesting idea for Python too.

* DONE A sexp version of a bibtex entry
  CLOSED: [2015-06-10 Wed 08:54]
  :PROPERTIES:
  :categories: bibtex,lisp
  :date:     2015/06/10 08:54:00
  :updated:  2015/06/10 08:54:00
  :ID:       73E360E8-082B-4557-939D-B05B77200155
  :END:

Below you see a typical bibtex entry. Today we explore an alternate approach to represent the information (data) in that entry as s-expressions, i.e. as a lisp data structure. Why? because it seems like an interesting exploration!

#+BEGIN_SRC bibtex
@article{hallenbeck-2013-effec-o2,
  author =	 "Hallenbeck, Alexander P. and Kitchin, John R.",
  title =	 {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a
                  primary-amine based polymeric \ce{CO_2} sorbent},
  keywords =	 {RUA, orgmode},
  journal =	 "Industrial \& Engineering Chemistry Research",
  pages =	 "10788-10794",
  year =	 2013,
  volume =	 {52},
  number =	 {31},
  doi =		 "10.1021/ie400582a",
  url =		 "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
  eprint =	 "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
#+END_SRC

Here is what that same data structure might look like as a sexp-based lisp data structure.
#+BEGIN_SRC emacs-lisp
(article "hallenbeck-2013-effec-o2"
	 (author "Hallenbeck, Alexander P. and Kitchin, John R.")
	 (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
	 (journal "Industrial \& Engineering Chemistry Research")
	 (pages "10788-10794")
         (year 2013)
	 (number 31)
	 (doi "10.1021/ie400582a")
	 (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
	 (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))
#+END_SRC

We can retrieve data from the sexp form pretty easily. Here we get the authors.
#+BEGIN_SRC emacs-lisp
(let* ((art '(article "hallenbeck-2013-effec-o2"
		      (author "Hallenbeck, Alexander P. and Kitchin, John R.")
		      (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		      (journal "Industrial \& Engineering Chemistry Research")
		      (pages "10788-10794")
		      (year 2013)
		      (number 31)
		      (doi "10.1021/ie400582a")
		      (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		      (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a")))
       (fields (cddr art)))
  (cadr (assoc 'author fields)))
#+END_SRC

#+RESULTS:
: Hallenbeck, Alexander P. and Kitchin, John R.

That is simple enough you might just write a little function to streamline it like this, and return a formatted string.

#+BEGIN_SRC emacs-lisp
(defun get-article-field (article field)
  "Return value of FIELD in ARTICLE."
  (cadr (assoc field (cddr article))))

(let ((art '(article "hallenbeck-2013-effec-o2"
		     (author "Hallenbeck, Alexander P. and Kitchin, John R.")
		     (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		     (journal "Industrial \& Engineering Chemistry Research")
		     (pages "10788-10794")
		     (year 2013)
		     (number 31)
		     (doi "10.1021/ie400582a")
		     (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		     (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
  (format "%s, doi:%s (%s)"
	  (get-article-field art 'author)
	  (get-article-field art 'doi)
	  (get-article-field art 'year)))

#+END_SRC

#+RESULTS:
: Hallenbeck, Alexander P. and Kitchin, John R., doi:10.1021/ie400582a (2013)

You might be wondering, why is that even a little bit interesting? One reason is that it looks a little like what lisp returns after parsing an xml file. Another is, the data structure looks kind of like data, but it is also some code, if article was defined as a function!  Let us consider what this might look like. I use a macro to define the field functions since in this case they all do the same thing, and these simply return a string with the field-name and value in curly brackets. We eval the macro to make sure it defines the function. I define an article function that wraps the fields in @bibtex-key{fields}, which defines a bibtex entry.

#+BEGIN_SRC emacs-lisp
(defmacro make-field (field-name)
  "define a field that returns a string"
  `(defun ,(intern field-name) (content)
     (format "  %s = {%s}" ,field-name content)))

(loop for field in '("author" "title" "journal" "pages" "number" "doi" "url" "eprint" "year")
  do (eval `(make-field ,field)))

(defun article (bibtex-key &rest fields)
  (concat
   (format "@article{%s,\n" bibtex-key)
   (mapconcat (lambda (field) (eval field)) fields ",\n")
   "\n}\n"))

(article "hallenbeck-2013-effec-o2"
	 (author "Hallenbeck, Alexander P. and Kitchin, John R.")
	 (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
	 (journal "Industrial \& Engineering Chemistry Research")
	 (pages "10788-10794")
	 (number 31)
         (year 2013)
	 (doi "10.1021/ie400582a")
	 (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
	 (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))
#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2,
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent},
  journal = {Industrial & Engineering Chemistry Research},
  pages = {10788-10794},
  number = {31},
  year = {2013},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a}
}
#+end_example

Wow. We /executed/ our data structure, and got a bibtex entry! That seems moderately interesting to me. Next is an example of taking the same data structure and rendering it as xml. This is some lispy wizardry, rather than use a macro to define functions, I temporarily define functions within a cl-flet macro, which I have to collect as a list of code. Then, I eval the list. This feels pretty odd, but seems like a lispy kind of thing to do.

#+BEGIN_SRC emacs-lisp
(eval
 (list 'cl-flet
       (append (loop for field in '("author" "title" "journal" "pages"
				      "number" "doi" "url" "eprint" "year")
		       collect (list (intern field)
				     '(content)
				     `(format "  <%s>%s</%s>" ,field content ,field)))
	       '((article (bibtex-key &rest fields)
			  (concat
			   (format
			    "<article bibtex-key=\"%s\">\n" bibtex-key)
			   (mapconcat (lambda (field) (eval field)) fields "\n")
			   "\n</article>")))
	       )
       ;; body of cl-flet
       '(article "hallenbeck-2013-effec-o2"
		(author "Hallenbeck, Alexander P. and Kitchin, John R.")
		(title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		(journal "Industrial \& Engineering Chemistry Research")
		(pages "10788-10794")
		(number 31)
		(year 2013)
		(doi "10.1021/ie400582a")
		(url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		(eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
#+END_SRC

#+RESULTS:
#+begin_example
<article bibtex-key="hallenbeck-2013-effec-o2">
  <author>Hallenbeck, Alexander P. and Kitchin, John R.</author>
  <title>Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent</title>
  <journal>Industrial & Engineering Chemistry Research</journal>
  <pages>10788-10794</pages>
  <number>31</number>
  <year>2013</year>
  <doi>10.1021/ie400582a</doi>
  <url>http://pubs.acs.org/doi/abs/10.1021/ie400582a</url>
  <eprint>http://pubs.acs.org/doi/pdf/10.1021/ie400582a</eprint>
</article>
#+end_example

Prefer json? No problem, just reformat the functions!

#+BEGIN_SRC emacs-lisp
(eval
 (list 'cl-flet
       (append (loop for field in '("author" "title" "journal" "pages"
				      "number" "doi" "url" "eprint" "year")
		       collect (list (intern field)
				     '(content)
				     `(format "   \"%s\": \"%s\"" ,field content)))
	       '((article (bibtex-key &rest fields)
			  (concat
			   (format
			    "{\"article\":\n  {\"bibtex-key\": \"%s\",\n" bibtex-key)
			   (mapconcat (lambda (field) (eval field)) fields ",\n")
			   "}\n}"))))
       ;; body of cl-flet
       '(article "hallenbeck-2013-effec-o2"
		(author "Hallenbeck, Alexander P. and Kitchin, John R.")
		(title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		(journal "Industrial \& Engineering Chemistry Research")
		(pages "10788-10794")
		(number 31)
		(year 2013)
		(doi "10.1021/ie400582a")
		(url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		(eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
#+END_SRC

#+RESULTS:
#+begin_example
{"article":
  {"bibtex-key": "hallenbeck-2013-effec-o2",
   "author": "Hallenbeck, Alexander P. and Kitchin, John R.",
   "title": "Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent",
   "journal": "Industrial & Engineering Chemistry Research",
   "pages": "10788-10794",
   "number": "31",
   "year": "2013",
   "doi": "10.1021/ie400582a",
   "url": "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
   "eprint": "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"}
}
#+end_example

Is this useful? Great question. I don't plan to convert by bibtex files to sexp format anytime soon ;) The format I used above is just a simple one. It might be desirable to include individual authors instead of an author string, and maybe support attributes to establish an author order. An author structure might be more complex to include scientific ids like an orcid, alternative names, etc... Finally, the s-exp data structure is super easy to use in lisp, but other languages would have parse it into some native structure the way they parse json or xml. There is limited support for s-expressions in most other non-lispy languages.

I like the idea of data representation as code, and its conversion to some other kind of format. It is subtle here, but notice we /never/ had to write a parser for the sexp notation. That /already exists as the lisp interpreter/. We did write code to use the data, and convert the data. The sexp notation is pretty easy to write, in contrast to the xml or json representations. Some interesting issues might be what to do with fields that are not defined, perhaps a macro would be used on the fly, or in the cl-flet definition. It is hard to imagine doing these things in another language than lisp!

* DONE Converting a DOI to other scientific identifiers in Pubmed
  CLOSED: [2015-06-09 Tue 07:29]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/09 07:29:08
  :updated:  2015/06/09 07:29:08
  :ID:       F9F7D351-50F6-4917-9F20-D89F7CD6EA73
  :END:

Sometimes it is useful to convert a DOI to another type of identifier. For example, in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/][post]] we converted a DOI to a Scopus EID, and in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/][one]] we got the WOS accession number from a DOI. Today, we consider how to get Pubmed identifiers. Pubmed provides an API for this purpose:

http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/

We will use the DOI tool. According to the documentation, we need to form a URL like this:

DOI: http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195

We will call our tool "org-ref" and use the value of user-mail-address. The URL above returns XML, so we can parse it, and then extract the identifiers. This is a simple http GET request, which we can construct using url-retrieve-synchronously. Here is what we get.

#+BEGIN_SRC emacs-lisp :results value code
(let* ((url-request-method "GET")
       (doi"10.1093/nar/gks1195")
       (my-tool "org-ref")
       (url (format "http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&email=%s&ids=%s"
                    my-tool
                    user-mail-address
                    doi))
       (xml (with-current-buffer  (url-retrieve-synchronously url)
		(xml-parse-region url-http-end-of-headers (point-max)))))
xml)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((pmcids
  ((status . "ok"))
  "\n"
  (request
   ((idtype . "doi")
    (dois . "")
    (versions . "yes")
    (showaiid . "no"))
   "\n"
   (echo nil "tool=org-ref;email=jkitchin%40andrew.cmu.edu;ids=10.1093%2Fnar%2Fgks1195")
   "\n")
  "\n"
  (record
   ((requested-id . "10.1093/NAR/GKS1195")
    (pmcid . "PMC3531190")
    (pmid . "23193287")
    (doi . "10.1093/nar/gks1195"))
   (versions nil
	     (version
	      ((pmcid . "PMC3531190.1")
	       (current . "true")))))
  "\n"))
#+END_SRC

The parsed xml is now just an emacs-lisp data structure. We need to get the record, and then get the attributes of it to extract the identifiers. Next, we create a plist of the identifiers. For fun, we add the Scopus EID and WOS accession number from the previous posts too.

#+BEGIN_SRC emacs-lisp :results value code
(let* ((url-request-method "GET")
       (doi"10.1093/nar/gks1195")
       (my-tool "org-ref")
       (url (format "http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&email=%s&ids=%s"
                    my-tool
                    user-mail-address
                    doi))
       (xml (car (with-current-buffer  (url-retrieve-synchronously url)
		   (xml-parse-region url-http-end-of-headers (point-max)))))
       (record (first  (xml-get-children xml 'record)))
       (doi (xml-get-attribute record 'doi))
       (pmcid (xml-get-attribute record 'pmcid))
       (pmid (xml-get-attribute record 'pmid)))
  (list :doi doi :pmid pmid :pmcid pmcid :eid (scopus-doi-to-eid doi) :wos (wos-doi-to-accession-number doi)))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(:doi "10.1093/nar/gks1195" :pmid "23193287" :pmcid "PMC3531190" :eid "2-s2.0-80053651587" :wos "000312893300006")
#+END_SRC

Well, there you have it, four new scientific document ids from one DOI. /Of course/ we have defined org-mode links for each one of these:

doi:10.1093/nar/gks1195

pmid:23193287

pmcid:PMC3531190

eid:2-s2.0-80053651587

wos:000312893300006

I have not tested this on too many DOIs yet. Not all of them are indexed by Pubmed.

* DONE Getting a WOS Accession number from a DOI
  CLOSED: [2015-06-08 Mon 11:23]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/08 11:23:33
  :updated:  2015/06/09 07:25:39
  :ID:       49F33C44-CD70-4B36-8C80-8CA11A9DEC57
  :END:
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/][post]] we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j is redirected to
http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44. You can see the wos:000225079300029 in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.

#+BEGIN_SRC emacs-lisp
(cdr (assoc "KeyUT" (url-parse-query-string (url-filename (url-generic-parse-url  "http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44")))))
#+END_SRC

#+RESULTS:
| WOS:000225079300029 |

It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).

#+BEGIN_SRC emacs-lisp
(defvar *wos-redirect* nil)
(defvar *wos-waiting* nil)

(defun wos-get-wos-redirect (url)
  "Return final redirect url for open-url"
  (setq *wos-waiting* t)
  (url-retrieve
   url
   (lambda (status)
     (setq *wos-redirect* (car (last status)))
     (setq *wos-waiting* nil)))
  (while *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(defun wos-doi-to-accession-number (doi)
  "Return a WOS Accession number for a DOI."
  (let* ((open-url (concat "http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/" doi))
	 (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
		 (assoc
		  "KeyUT"
		  (url-parse-query-string
		   (url-filename
		    (url-generic-parse-url redirect)))))
    4)))

(concat "wos:" (wos-doi-to-accession-number "10.1021/jp047349j"))
#+END_SRC

#+RESULTS:
: wos:000225079300029

I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:

http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029

http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029

That might turn out to be handy at some point.

* DONE Getting a Scopus EID from a DOI
  CLOSED: [2015-06-07 Sun 16:29]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/07 16:29:05
  :updated:  2015/06/07 16:54:38
  :ID:       5E2032BB-1E74-4427-AFBA-59790A848789
  :END:
[[http://www.scopus.com][Scopus]] is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: http://dev.elsevier.com/myapikey.html and set *scopus-api-key* in Emacs to use this code.

Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:

Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial & Engineering Chemistry Research, 52:10788-10794 (2013)

With the EID, we can construct a URL to the Scopus document page:
#+BEGIN_SRC emacs-lisp
(let ((eid "2-s2.0-84881394200"))
  (format "http://www.scopus.com/record/display.url?eid=%s&origin=resultslist" eid))
#+END_SRC

#+RESULTS:
: http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist

We can construct a URL to citing documents:
#+BEGIN_SRC emacs-lisp
(let ((eid "2-s2.0-84881394200"))
  (format "http://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=%s&src=s&imp=t&sot=cite&sdt=a&sl=0&origin=recordpage" eid))
#+END_SRC

#+RESULTS:
: http://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=2-s2.0-84881394200&src=s&imp=t&sot=cite&sdt=a&sl=0&origin=recordpage

And there are three types of related document urls we can create: by author, keyword or references.

By authors:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat "http://www.scopus.com/search/submit/mlt.url"
                  "?eid=%s&src=s&all=true&origin=recordpage"
                  "&method=aut&zone=relatedDocuments")
            eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments

By keywords:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat "http://www.scopus.com/search/submit/mlt.url"
                  "?eid=%s&src=s&all=true&origin=recordpage"
                  "&method=key&zone=relatedDocuments")
          eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments

And by references:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat  "http://www.scopus.com/search/submit/mlt.url?"
                   "eid=%s&src=s&all=true&origin=recordpage"
                   "&method=ref&zone=relatedDocuments")
           eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments

We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, /not/ the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is doi:10.1021/ie400582a.

The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.

I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.

#+BEGIN_SRC emacs-lisp
(let* ((doi "10.1021/ie400582a")
       (url-request-method "GET")
       (url-mime-accept-string "application/json")
       (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					 '("field" . "eid")))
       (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
       (json-object-type 'plist)
       (json-data (with-current-buffer  (url-retrieve-synchronously url)
		    (json-read-from-string
		     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data :search-results) :entry) 0) :eid))
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.

#+BEGIN_SRC emacs-lisp
(defun scopus-doi-to-eid-json (doi)
  "Return a parsed xml from the Scopus article retrieval api for DOI.
This does not always seem to work for the most recent DOIs."
  (let* ((url-request-method "GET")
	 (url-mime-accept-string "application/json")
	 (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					   '("field" . "eid")))
	 (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
	 (json-object-type 'plist)
	 (json-data (with-current-buffer  (url-retrieve-synchronously url)
		      (json-read-from-string
		       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data :search-results) :entry) 0) :eid)))

(scopus-doi-to-eid "10.1021/ie400582a")
#+END_SRC

XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.

#+BEGIN_SRC emacs-lisp
(let* ((doi "10.1021/ie400582a")
       (url-request-method "GET")
       (url-mime-accept-string "application/xml")
       (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					 '("field" . "eid")))
       (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
       (xml (with-current-buffer  (url-retrieve-synchronously url)
	      (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

Now we wrap this in a function for reusability.
#+BEGIN_SRC emacs-lisp
(defun scopus-doi-to-eid (doi)
  "Get a Scopus eid from a DOI."
  (let* ((url-request-method "GET")
	 (url-mime-accept-string "application/xml")
	 (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					   '("field" . "eid")))
	 (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
	 (xml (with-current-buffer  (url-retrieve-synchronously url)
		(xml-parse-region url-http-end-of-headers (point-max))))
	 (results (car xml))
	 (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid "10.1021/ie400582a")
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

This code is wrapped up in [[https://github.com/jkitchin/org-ref/blob/master/scopus.el][org-ref/scopus.el]]. It provides a new org-mode eid link, e.g. eid:2-s2.0-84881394200 which is functional and provides access to the citing and related article Scopus pages for that eid.

There are also new links and functions for a [[scopus-search:alloy Au segregation]] and [[scopus-advanced-search:auth(kitchin) and title(segregation)]].

Let's not forget the scopusid:7004212771 link to Scopus Author pages.

Now you can use org-mode for reproducible scientific literature searching in Scopus!


* DONE Python data structures to lisp
  CLOSED: [2015-05-16 Sat 10:48]
  :PROPERTIES:
  :categories: python,emacs,lisp
  :date:     2015/05/16 10:47:59
  :updated:  2015/05/16 10:47:59
  :ID:       9B99890D-B059-4B53-928C-03D0069E3449
  :END:
I have an idea in mind that would use the output of python scripts in lisp functions. Xah Lee posted an [[http://ergoemacs.org/emacs/elisp_perl_wrapper.html][idea for writing emacs commands in scripting languages]]. In this post I want to explore an extension of the idea, where a Python script will return output that can be read in Lisp, e.g. we can convert a Python list to a lisp list, or a dictionary to an a-list or p-list. I can already see that simple data structures will be "simple", and arbitrary data structures will offer a lot of challenges, e.g. nested lists or dictionaries...

If I could add some custom functions to the basic builtin types in Python, then I could use another approach to format python objects as lisp data types. This isn't recommended by Pythonistas, but I guess they don't want to use lisp as much as I do ;) I found this approach to modifying builtins:

http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a

We use that almost verbatim here to get what I want. This is a super low level way to add functions to the builtins. I add some simple formatting to floats, ints and strings. I add a more complex recursive formatting function to lists, tuples and dictionaries. A dictionary can be represented as an alist or plist. Both examples are shown, but I leave the alist version commented out. Finally, we add a lispify function to numpy arrays.

#+BEGIN_SRC python :tangle pylisp.py
import ctypes as c

class PyObject_HEAD(c.Structure):
    _fields_ = [('HEAD', c.c_ubyte * (object.__basicsize__ -
                                      c.sizeof(c.c_void_p))),
                ('ob_type', c.c_void_p)]

_get_dict = c.pythonapi._PyObject_GetDictPtr
_get_dict.restype = c.POINTER(c.py_object)
_get_dict.argtypes = [c.py_object]

def get_dict(object):
    return _get_dict(object).contents.value

import collections
import numpy as np

def lispify(L):
    "Convert a Python object L to a lisp representation."
    if (isinstance(L, str)
        or isinstance(L, float)
        or isinstance(L, int)):
        return L.lisp()
    elif (isinstance(L, list)
          or isinstance(L, tuple)
          or isinstance(L, np.ndarray)):
        s = []
        for element in L:
            s += [element.lisp]
        return '(' + ' '.join(s) + ')'
    elif isinstance(L, dict):
        s = []
        for key in L:
            # alist format
            # s += ["({0} . {1})".format(key, L[key].lisp())]
            # plist
            s += [":{0} {1}".format(key, L[key].lisp)]
        return '(' + ' '.join(s) + ')'

get_dict(str)['lisp'] = property(lambda s:'"{}"'.format(str(s)))
get_dict(float)['lisp'] = property(lambda f:'{}'.format(str(f)))
get_dict(int)['lisp'] = property(lambda f:'{}'.format(str(f)))


get_dict(list)['lisp'] = property(lispify)
get_dict(tuple)['lisp'] = property(lispify)
get_dict(dict)['lisp'] = property(lispify)
get_dict(np.ndarray)['lisp'] = property(lispify)
#+END_SRC

#+RESULTS:

Let us test these out.
#+BEGIN_SRC python
from pylisp import *
a = 4.5
print int(a).lisp
print a.lisp
print "test".lisp

print [1, 2, 3].lisp
print (1, 2, 3).lisp

print [[1, 3], (5, 6)].lisp

print {"a": 5}.lisp
print [[1, 3], (5, 6), {"a": 5, "b": "test"}].lisp


A = np.array([1, 3, 4])
print A.lisp
print ({"tree": [5, 6]}, ["a", 4, "list"], 5, 2.0 / 3.0).lisp
#+END_SRC

#+RESULTS:
#+begin_example
4
4.5
"test"
(1 2 3)
(1 2 3)
((1 3) (5 6))
(:a 5)
((1 3) (5 6) (:a 5 :b "test"))
(1 3 4)
((:tree (5 6)) ("a" 4 "list") 5 0.666666666667)
#+end_example


Now, is that better than a single lisp function with a lot of conditionals to handle each type? I am not sure. This seems to work pretty well.


Here is how I imagine using this idea. We would have some emacs-lisp variables and use them to dynamically generate a python script. We run the python script, capturing the output, and read it back in as a lisp data structure. Here is a simple kind of example that generates a dictionary.

#+BEGIN_SRC emacs-lisp :results code
(let* ((elisp-var 6)
       (result)
      (script (format "
from pylisp import *
print {x: [2*y for y in range(x)] for x in range(1, %s)}.lisp()
" elisp-var)))

  ;; start a python process
  (run-python)
  (setq result (read (python-shell-send-string-no-output
   script)))
  (plist-get result :5))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(0 2 4 6 8)
#+END_SRC

That seems to work pretty well. One alternative idea to this is [[https://github.com/pinard/Pymacs][Pymacs]], which I have written about [[http://kitchingroup.cheme.cmu.edu/blog/2014/10/19/Using-Pymacs-to-integrate-Python-into-Emacs/][before]]. This project isn't currently under active development, and I ran into some difficulties with it before.

Here we can solve the problem I previously posed and get the result back as an elisp float, and then reuse the result

#+BEGIN_SRC emacs-lisp
(let* ((myvar 3)
       (script (format "from pylisp import *
from scipy.optimize import fsolve
def objective(x):
    return x - 5

ans, = fsolve(objective, %s)
print ans.lisp()" myvar)))
  (run-python)
  (setq result (read (python-shell-send-string-no-output
		       script)))
  (- 5 result))
#+END_SRC

#+RESULTS:
: 0.0

Bottom line: we can write python code in lisp functions that are dynamically updated, execute them, and get lisp data structures back for simple data types. I think that could be useful in some applications, where it is easier to do parsing/analysis in Python, but you want to do something else that is easier in Lisp.

* DONE Another approach to embedding org-source in html
  CLOSED: [2015-05-09 Sat 19:19]
  :PROPERTIES:
  :date:     2015/05/09 19:19:10
  :updated:  2015/05/10 09:34:55
  :categories: orgmode, data
  :ID:       72B06FD0-1700-4EC1-9E4D-ED99DE6A6CE1
  :END:
In this [[http://kitchingroup.cheme.cmu.edu/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts/][post]] I examined a way to embed the org-source in a comment in the html of the post, and developed a reasonably convenient way to extract the source in emacs. One downside of the approach was the need to escape at least the dashes, and then unescape them on extraction. I came across another idea, which is to put the org-source in base64 encoded form in a [[http://en.wikipedia.org/wiki/Data_URI_scheme][data uri]].

First let us see what the encoding means:

#+BEGIN_SRC emacs-lisp
(base64-encode-string "<!-- test-->")
#+END_SRC
#+RESULTS:
: PCEtLSB0ZXN0LS0+

And decoding:

#+BEGIN_SRC emacs-lisp
(base64-decode-string "PCEtLSB0ZXN0LS0+")
#+END_SRC

#+RESULTS:
: <!-- test-->

The encoding looks random, but it is reversible. More importantly, it probably will not have any html like characters in it that need escaped. The idea of a data uri is that the data it serves is embedded in the URL href attribute. This is basically how to make a data uri. We give the url here a class so we can find it later.
#+BEGIN_EXAMPLE
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>
#+END_EXAMPLE

Here is the actual html for the browser. If you click on it, your browser automatically decodes it for you!
#+BEGIN_HTML
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>
#+END_HTML

So, during the blog publish step, we just need to add this little step to the html generation, and it will be included as a data uri. Here is the function that generates the data uri for us, and example of using it. The encoded source is not at all attractive to look at it, but you almost never need to look at it, it is invisible in the browser. Interestingly, if you click on the link, you will see the org source right in your browser!

#+BEGIN_SRC emacs-lisp  :results html
(defun source-data-uri (source)
  "Encode the string in SOURCE to a data uri."
  (format
   "<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,%s\">source</a>"
   (base64-encode-string source)))

(source-data-uri (buffer-string))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBBbm90aGVyIGFwcHJvYWNoIHRvIGVtYmVkZGluZyBvcmctc291cmNlIGluIGh0bWwKSW4gdGhp
cyBbW2h0dHA6Ly9raXRjaGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4t
YWx0ZXJuYXRpdmUtYXBwcm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0
cy9dW3Bvc3RdXSBJIGV4YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEg
Y29tbWVudCBpbiB0aGUgaHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFi
bHkgY29udmVuaWVudCB3YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93
bnNpZGUgb2YgdGhlIGFwcHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhl
IGRhc2hlcywgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNy
b3NzIGFub3RoZXIgaWRlYSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2
NCBlbmNvZGVkIGZvcm0gaW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9V
Uklfc2NoZW1lXVtkYXRhIHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGlu
ZyBtZWFuczoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8
IS0tIHRlc3QtLT4iKQojK0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFu
ZCBkZWNvZGluZzoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5n
ICJQQ0V0TFNCMFpYTjBMUzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+
CgpBbmQgdGhpcyBpcyBiYXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0
aGUgdXJsIGhlcmUgYSBjbGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFN
UExFCjxhIGNsYXNzPSJvcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9FWEFNUExF
CgpIZXJlIGlzIHRoZSBhY3R1YWwgaHRtbCBmb3IgdGhlIGJyb3dzZXI6IAojK0JFR0lOX0hUTUwK
PGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFT
Q0lJO2Jhc2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0hUTUwKClNvLCBk
dXJpbmcgdGhlIGJsb2cgcHVibGlzaCBzdGVwLCB3ZSBqdXN0IG5lZWQgdG8gYWRkIHRoaXMgbGl0
dGxlIHN0ZXAgdG8gdGhlIGh0bWwgZ2VuZXJhdGlvbiwgYW5kIGl0IHdpbGwgYmUgaW5jbHVkZWQg
YXMgYSBkYXRhIHVyaS4gSGVyZSBpcyB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIGRh
dGEgdXJpIGZvciB1cywgYW5kIGV4YW1wbGUgb2YgdXNpbmcgaXQ6CgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIiBkb3dubG9hZD1cInNvdXJjZS5vcmdcIj5zb3VyY2U8L2E+IiAK
ICAgKGJhc2U2NC1lbmNvZGUtc3RyaW5nIHNvdXJjZSkpKQoKKHNvdXJjZS1kYXRhLXVyaSAoYnVm
ZmVyLXN0cmluZykpCiMrRU5EX1NSQwoKCgoKCgoK" download="source.org">source</a>
#+END_HTML

Now, we integrate it into the blogofile function:

#+BEGIN_SRC emacs-lisp
(defun bf-get-post-html ()
  "Return a string containing the YAML header, the post html, my
copyright line, and a link to the org-source code."
  (interactive)
  (let ((org-source (buffer-string))
	(url-to-org (bf-get-url-to-org-source))
	(yaml (bf-get-YAML-heading))
	(body (bf-get-HTML)))

    (with-temp-buffer
      (insert yaml)
      (insert body)
      (insert
       (format "<p>Copyright (C) %s by John Kitchin. See the <a href=\"/copying.html\">License</a> for information about copying.<p>"
	       (format-time-string "%Y")))
      (insert (format "<p><a href=\"%s\">org-mode source</a><p>"
		      url-to-org))
      (insert (format "<p>Org-mode version = %s</p>" (org-version)))
      ;; this is the only new code we need to add.
      (insert (source-data-uri org-source))
      ;; return value
      (buffer-string))))
#+END_SRC

Now we need a new adaptation of the grab-org-source function. We still need a regexp search to get the source, and we still need to decode it.

#+BEGIN_SRC emacs-lisp
(defun grab-org-source (url)
  "Extract org-source from URL to a buffer named *grab-org-source*."
  (interactive "sURL: ")
  (switch-to-buffer (get-buffer-create "*grab-org-source*"))
  (erase-buffer)
  (org-mode)
  (insert
   (with-current-buffer
       (url-retrieve-synchronously url)
     (let (start)
       (re-search-forward
	"<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,\\([^\"]*\\)\\\">" nil t)
       (base64-decode-string  (match-string 1))))))
#+END_SRC

What else could we do with this? One idea would be to generate data uris for each code block that you could open in your browser. For example, here we generate a list of data uris for each code block in the buffer. We don't take care to label them or make it easy to see what they are, but if you click on one, you should see a plain text version of the block. If this is done a lot, it might even make sense to change the mime type to download the code in some native app.

#+BEGIN_SRC emacs-lisp :results html
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (src-block)
    (source-data-uri (org-element-property :value src-block))))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
(<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBMUzArIikK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIHNvdXJjZS1kYXRhLXVyaSAoc291cmNlKQogICJFbmNvZGUgdGhlIHN0cmluZyBpbiBT
T1VSQ0UgdG8gYSBkYXRhIHVyaS4iCiAgKGZvcm1hdAogICAiPGEgY2xhc3M9XCJvcmctc291cmNl
XCIgaHJlZj1cImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jhc2U2NCwlc1wiPnNv
dXJjZTwvYT4iCiAgIChiYXNlNjQtZW5jb2RlLXN0cmluZyBzb3VyY2UpKSkKCihzb3VyY2UtZGF0
YS11cmkgKGJ1ZmZlci1zdHJpbmcpKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGJmLWdldC1wb3N0LWh0bWwgKCkKICAiUmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcg
dGhlIFlBTUwgaGVhZGVyLCB0aGUgcG9zdCBodG1sLCBteQpjb3B5cmlnaHQgbGluZSwgYW5kIGEg
bGluayB0byB0aGUgb3JnLXNvdXJjZSBjb2RlLiIKICAoaW50ZXJhY3RpdmUpCiAgKGxldCAoKG9y
Zy1zb3VyY2UgKGJ1ZmZlci1zdHJpbmcpKQoJKHVybC10by1vcmcgKGJmLWdldC11cmwtdG8tb3Jn
LXNvdXJjZSkpCgkoeWFtbCAoYmYtZ2V0LVlBTUwtaGVhZGluZykpCgkoYm9keSAoYmYtZ2V0LUhU
TUwpKSkKCiAgICAod2l0aC10ZW1wLWJ1ZmZlcgogICAgICAoaW5zZXJ0IHlhbWwpCiAgICAgIChp
bnNlcnQgYm9keSkKICAgICAgKGluc2VydAogICAgICAgKGZvcm1hdCAiPHA+Q29weXJpZ2h0IChD
KSAlcyBieSBKb2huIEtpdGNoaW4uIFNlZSB0aGUgPGEgaHJlZj1cIi9jb3B5aW5nLmh0bWxcIj5M
aWNlbnNlPC9hPiBmb3IgaW5mb3JtYXRpb24gYWJvdXQgY29weWluZy48cD4iCgkgICAgICAgKGZv
cm1hdC10aW1lLXN0cmluZyAiJVkiKSkpCiAgICAgIChpbnNlcnQgKGZvcm1hdCAiPHA+PGEgaHJl
Zj1cIiVzXCI+b3JnLW1vZGUgc291cmNlPC9hPjxwPiIKCQkgICAgICB1cmwtdG8tb3JnKSkKICAg
ICAgKGluc2VydCAoZm9ybWF0ICI8cD5PcmctbW9kZSB2ZXJzaW9uID0gJXM8L3A+IiAob3JnLXZl
cnNpb24pKSkKICAgICAgOzsgdGhpcyBpcyB0aGUgb25seSBuZXcgY29kZSB3ZSBuZWVkIHRvIGFk
ZC4KICAgICAgKGluc2VydCAoc291cmNlLWRhdGEtdXJpIG9yZy1zb3VyY2UpKQogICAgICA7OyBy
ZXR1cm4gdmFsdWUKICAgICAgKGJ1ZmZlci1zdHJpbmcpKSkpCg==">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGdyYWItb3JnLXNvdXJjZSAodXJsKQogICJFeHRyYWN0IG9yZy1zb3VyY2UgZnJvbSBV
UkwgdG8gYSBidWZmZXIgbmFtZWQgKmdyYWItb3JnLXNvdXJjZSouIgogIChpbnRlcmFjdGl2ZSAi
c1VSTDogIikKICAoc3dpdGNoLXRvLWJ1ZmZlciAoZ2V0LWJ1ZmZlci1jcmVhdGUgIipncmFiLW9y
Zy1zb3VyY2UqIikpCiAgKGVyYXNlLWJ1ZmZlcikKICAob3JnLW1vZGUpCiAgKGluc2VydAogICAo
d2l0aC1jdXJyZW50LWJ1ZmZlcgogICAgICAgKHVybC1yZXRyaWV2ZS1zeW5jaHJvbm91c2x5IHVy
bCkKICAgICAobGV0IChzdGFydCkKICAgICAgIChyZS1zZWFyY2gtZm9yd2FyZAoJIjxhIGNsYXNz
PVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSTti
YXNlNjQsXFwoW15cIl0qXFwpXFxcIj4iIG5pbCB0KQogICAgICAgKGJhc2U2NC1kZWNvZGUtc3Ry
aW5nICAobWF0Y2gtc3RyaW5nIDEpKSkpKSkK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KG9yZy1lbGVtZW50LW1hcCAob3JnLWVsZW1lbnQtcGFyc2UtYnVmZmVyKSAnc3JjLWJsb2NrCiAg
KGxhbWJkYSAoc3JjLWJsb2NrKQogICAgKHNvdXJjZS1kYXRhLXVyaSAob3JnLWVsZW1lbnQtcHJv
cGVydHkgOnZhbHVlIHNyYy1ibG9jaykpKSkK">source</a>)
#+END_HTML


I am not sure if this is better or worse than the other approach. I have not tested it very thoroughly, but it seems like it should work pretty generally. I imagine you could also embed other kinds of files in the html, if for some reason you did not want to put the files on your server. Overall this seems to lack some elegance in searching for data, e.g. like [[http://en.wikipedia.org/wiki/Embedded_RDF][RDF]] or [[http://en.wikipedia.org/wiki/RDFa][RDFa]] is supposed to enable, but it might be a step in that direction, using org-mode and Emacs as the editor.


* DONE Commenting in org-files
  CLOSED: [2015-04-24 Fri 12:41]
  :PROPERTIES:
  :categories: org
  :date:     2015/04/24 12:41:39
  :updated:  2015/11/19 09:22:50
  :ID:       C2A4B0E4-4743-48EE-9E48-60328761F56A
  :END:
There was an interesting discussion on the org-mode mail list about putting comments in org files. Eric Fraga suggested using inline tasks, and customizing the export of them so they make a footnote, or use the todonotes package (suggested by Marcin Borkowski). Here is Eric's export. A big advantage of this is integration with the Agenda, so you can see what there is todo in your document.

#+begin_src emacs-lisp
  (setq org-inlinetask-export-templates
        '((latex "%s\\footnote{%s\\\\ %s}\\marginpar{\\fbox{\\thefootnote}}"
                 '((unless
                       (eq todo "")
                     (format "\\fbox{\\textsc{%s%s}}" todo priority))
                   heading content))))
#+end_src

Eric Abrahamsen suggested an idea to use a link syntax. I like the idea a lot, so here we develop some ideas. A link has two parts, the path, and description. A simple comment would just be a simple link, probably in double square brackets so you can have spaces in your comment. [[comment:Why do you think there are only two parts]] It might be feasible to use [[comment:Why do you quote mark?][the description to "mark text" that the comment refers to]]. The remaining question is what functionality should our link have when you click on it, and how to export it. For functionality, a click will show the comment in the minibuffer and offer to delete it. For export, for now we will make it export with todonotes in LaTeX, and as a red COMMENT with a tooltip in html. To use this, you need to have the LaTeX package todonotes included in your org file.
#+LATEX_HEADER: \usepackage{todonotes}

Here is our comment link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "comment"
 (lambda (linkstring)
   (let ((elm (org-element-context))
         (use-dialog-box nil))
     (when (y-or-n-p "Delete comment? ")
       (setf (buffer-substring
	      (org-element-property :begin elm)
	      (org-element-property :end elm))
	     (cond
	      ((org-element-property :contents-begin elm)
	       (buffer-substring
		(org-element-property :contents-begin elm)
		(org-element-property :contents-end elm)))
	      (t
	       ""))))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'html)
     (format "<font color=\"red\"><abbr title=\"%s\" color=\"red\">COMMENT</abbr></font> %s" keyword (or desc "")))
    ((eq format 'latex)
     (format "\\todo{%s}{%s}" keyword (or desc ""))))))
#+END_SRC


It would be convenient to have a quick function for adding a comment to some highlighted text.

#+BEGIN_SRC emacs-lisp
(defun add-comment (begin end)
  (interactive "r")
  (if (region-active-p)
      (let ((selected-text (buffer-substring begin end)))
	(setf (buffer-substring begin end)
	      (format "[[comment:%s][%s]]"
		      (read-input "Comment: ") selected-text)))
  (insert (format  "[[comment:%s]]" (read-input "Comment: ")))))
#+END_SRC

Test 1: [[comment:test comment]]

[[comment:You seem to have forgotten Test 2][Test 2]]

That is it. I could see a few other enhancements that might be very useful, e.g. a command to list all the comments, remove all the comments, etc... I am pretty satisfied with this for now though.

** An updated approach to comments.
   :PROPERTIES:
   :ID:       99003E6D-7A27-435D-8333-BB67DCB63D0A
   :END:
Rainer asked about making some comments inline. It would be nice if a single link syntax could accommodate both styles of comments. I previously developed an approach to extend links with attributes (http://kitchingroup.cheme.cmu.edu/blog/2015/02/05/Extending-the-org-mode-link-syntax-with-attributes/), which I will reuse here for that purpose. The idea is to add an ":inline" attribute to change the export behavior. We only modify the LaTeX export here.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "comment"
 ;;  follow function
(lambda (linkstring)
   (let ((elm (org-element-context))
         (use-dialog-box nil))
     (when (y-or-n-p "Delete comment? ")
       (setf (buffer-substring
	      (org-element-property :begin elm)
	      (org-element-property :end elm))
	     (cond
	      ((org-element-property :contents-begin elm)
	       (buffer-substring
		(org-element-property :contents-begin elm)
		(org-element-property :contents-end elm)))
	      (t
	       ""))))))
 ;; format function
 (lambda (path description format)
   (let* ((data (read (concat "(" path ")")))
	  (head (car data))
	  (plist (cdr data)))
     (cond
      ((eq format 'html)
       (format "<font color=\"red\"><abbr title=\"%s\" color=\"red\">COMMENT</abbr></font> %s" path (or description "")))
      ((eq format 'latex)
       (format "\\todo%s{%s}%s"
	       (if (-contains? data :inline) "[inline]" "")
	       (mapconcat (lambda (s)
			    (format "%s" s))
			  (-remove-item :inline data) " ")
	       (if description (format "{%s}" description) "")))))))
#+END_SRC

Here are some examples of the syntax:
#+BEGIN_EXAMPLE
[[comment: :inline the rest of your text]]

[[comment:Some text you want to highlight]]

[[comment:Some text you want to highlight :inline]]
#+END_EXAMPLE

It doesn't matter where the :inline attribute is added. This seems to work pretty well.

We can modify our convenience function to allow us to use a prefix arg to make the comment inline. Here is one way to do it.

#+BEGIN_SRC emacs-lisp
(defun add-comment (begin end &optional arg)
  "Comment the region. With a prefix ARG, make the comment inline."
  (interactive (list (region-beginning)
		     (region-end)
		     current-prefix-arg))
  (let ((inline (if arg ":inline " "")))
	(if (region-active-p)
	    (let ((selected-text (buffer-substring begin end)))
	      (setf (buffer-substring begin end)
		    (format
		     "[[comment:%s%s][%s]]"
		     inline
		     (read-input "Comment: ") selected-text)))
	  (insert (format
		   "[[comment:%s%s]]"
		   inline
		   (read-input "Comment: "))))))
#+END_SRC

#+RESULTS:
: add-comment

Test [[comment:a new regular comment][text]] to  [[comment::inline an inline comment][comment]] on.

* DONE Extending the org-mode link syntax with attributes
  CLOSED: [2015-04-20 Mon 12:55]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/02/05 10:06:25
  :updated:  2015/04/20 12:56:35
  :ID:       9450B07D-872A-4E5A-AF00-39F70FD246CE
  :END:
I make super heavy use of links in org-mode. I use them extensively in org-ref to create functional citations. One detail that has never been very satisfactory is the need for pre/post text in citations. I don't need that capability often, but it seems important to some. I have implemented a kind of clunky solution where I use the description part of a link with the pre/post text separated by a ::. Although that works, I dislike the way it looks, the need to parse it, and that the description covers the link.

#+BEGIN_EXAMPLE
[[cite:key][pre text::post text]]
#+END_EXAMPLE

Some [[https://lists.gnu.org/archive/html/emacs-orgmode/2010-08/msg00404.html][time ago]] there was a suggestion of how to extend the link syntax, which was to my knowledge never implemented. Here is the proposed syntax:
#+BEGIN_EXAMPLE
$[link http://google.com
         :last-followed [2009-02-25 Wed 02:00]
         :label "click here for evil search engine"
         :export-label "click here for nice search engine"]
#+END_EXAMPLE

This is interesting because this syntax suggests the link has attributes which can be updated.

We will show here how to implement part of this idea with the existing link syntax. We will make a link that has attributes like that. The basic idea is to simply incorporate the attributes into the path, and use lisp to read them. We will wrap the link path in parentheses and read that as a lisp data structure. So, a link like [[link:key :pre "some pre text" :post "some post text"]] will be parsed as:

#+BEGIN_SRC emacs-lisp
(read "(key :pre \"some pre text\" :post \"some post text\")")
#+END_SRC

#+RESULTS:
| key | :pre | some pre text | :post | some post text |

The car of that list is the key, and the cdr contains the attributes. The quotes are necessary here to make sure all the text is correctly parsed as a single element for each attribute. So, here is an example link

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "slink"
 ;;  follow function
 (lambda (path)
   (let* ((data (read (format "(%s)" path)))
	  (head (car data))
	  (plist (cdr data))
	  (link (org-element-context))
	  (begin (org-element-property :begin link))
	  (end (org-element-property :end link)))
     (setq plist (plist-put plist :last-clicked (current-time-string)))
     (save-excursion
     (setf (buffer-substring begin end) "")
     (goto-char begin)
     (insert (format "[[slink:%s %s]]" head
         (substring (format "%S" plist) 1 -1))))))
 ;; format function
 (lambda (path description backend)
   (let* ((data (read (concat "(" path ")")))
	  (head (car data))
	  (plist (cdr data)))
     (format "\\%s[%s][%s]{%s}"
             (plist-get plist :type)
	     (plist-get plist :pre)
	     (plist-get plist :post)
             head))))
#+END_SRC

Now, each time I click on this link, the time stamp gets updated.

[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Mon Apr 20 12:54:40 2015"]]

#+BEGIN_EXAMPLE
[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Thu Feb  5 09:31:15 2015"]]
#+END_EXAMPLE


And, the generic export of this link is:

#+BEGIN_EXAMPLE
\cite[See for example][page 47]{kitchin-2010}
#+END_EXAMPLE

Is this a good idea? I am not using this for anything right now. Sometimes my version of org-mode has trouble recognizing that is a link. It is strange, as I am typing, sometimes it flashes in and out of being recognized as a link. Anyway, it is an interesting idea!

* DONE Using the Scopus api with xml output
  CLOSED: [2015-04-06 Mon 09:36]
  :PROPERTIES:
  :categories: python,xml,scopus
  :date:     2015/04/06 09:35:57
  :updated:  2015/04/06 09:35:57
  :ID:       E17317AE-AFF5-472A-A623-7E48AAA6940E
  :END:
According to http://api.elsevier.com/documentation/AbstractRetrievalAPI.wadl, the native form of the Scopus abstract document is xml, and the full abstract cannot always be represented  as json. So... I am going to just bite the bullet and learn to deal with the xml. This is a companion post to http://kitchingroup.cheme.cmu.edu/blog/2015/04/04/Making-highly-linked-bibliographies-from-the-Scopus-API/. Most of the code in this post gets tangled out to scopus_xml.py. I know it is not totally robust yet, but I have been using it for a lot of analysis, and it works pretty well so far.

This is another long post, with code that probably runs off screen. You can see the end result of what we do in this post here:  http://kitchingroup.cheme.cmu.edu/publications.html.


We start with a general function to return an xml elementtree. We build in some caching to avoid downloading things we already have; this is slow, and there are limits on how many times you can download.

#+BEGIN_SRC python :tangle scopus_xml.py
import requests
import os
import xml.etree.ElementTree as ET

from my_scopus import MY_API_KEY

def get_abstract_info(EID, refresh=False):
    'Get and save the json data for EID.'
    base = 'scopus-xml/get_abstract_info'
    if not os.path.exists(base):
        os.makedirs(base)

    fname = '{0}/{1}'.format(base, EID)
    if os.path.exists(fname) and not refresh:
        with open(fname) as f:
            return ET.fromstring(f.read())

    # Otherwise retrieve and save results
    url = ("http://api.elsevier.com/content/abstract/eid/" + EID + '?view=META_ABS')
    resp = requests.get(url,
                    headers={'Accept':'application/xml',
                             'X-ELS-APIKey': MY_API_KEY})
    with open(fname, 'w') as f:
        f.write(resp.text.encode('utf-8'))

    results = ET.fromstring(resp.text.encode('utf-8'))

    return results
#+END_SRC

Next, we do some introspection to see what we have.

#+BEGIN_SRC python :results html
from scopus_xml import *
#results = get_abstract_info('2-s2.0-84896759135')
:   File "<string>", line 7
    (template (format import
                           ^
SyntaxError: EOF while scanning triple-quoted string literal
/bin/bash: -c: line 7: syntax error near unexpected token `'''%s''''
/bin/bash: -c: line 7: `test_%s.test_%s('''%s''')" name name name code)))'

#results = get_abstract_info('2-s2.0-84924911828')
results = get_abstract_info('2-s2.0-84901638552')
for el in results:
    print el.tag
    for el1 in el:
        print '  -->',el1.tag
    print
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata
  --> {http://prismstandard.org/namespaces/basic/2.0/}url
  --> {http://purl.org/dc/elements/1.1/}identifier
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}eid
  --> {http://prismstandard.org/namespaces/basic/2.0/}doi
  --> {http://purl.org/dc/elements/1.1/}title
  --> {http://prismstandard.org/namespaces/basic/2.0/}aggregationType
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}srctype
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}citedby-count
  --> {http://prismstandard.org/namespaces/basic/2.0/}publicationName
  --> {http://purl.org/dc/elements/1.1/}publisher
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}source-id
  --> {http://prismstandard.org/namespaces/basic/2.0/}issn
  --> {http://prismstandard.org/namespaces/basic/2.0/}volume
  --> {http://prismstandard.org/namespaces/basic/2.0/}startingPage
  --> {http://prismstandard.org/namespaces/basic/2.0/}endingPage
  --> {http://prismstandard.org/namespaces/basic/2.0/}pageRange
  --> {http://prismstandard.org/namespaces/basic/2.0/}coverDate
  --> {http://purl.org/dc/elements/1.1/}creator
  --> {http://purl.org/dc/elements/1.1/}description
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link

{http://www.elsevier.com/xml/svapi/abstract/dtd}affiliation
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}affilname

{http://www.elsevier.com/xml/svapi/abstract/dtd}authors
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}author
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}author

#+END_HTML

Now, some examples for myself to see how to get things.

#+BEGIN_SRC python :results html
from scopus_xml import *

results = get_abstract_info('2-s2.0-84901638552')

coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}srctype').text
print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}source-id').text

#authors = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors')
#for author in results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors'):
#    print author.find('{http://www.elsevier.com/xml/ani/common}indexed-name').text

for creator in coredata.find('{http://purl.org/dc/elements/1.1/}creator'):
    print creator.attrib

print coredata.find('{http://purl.org/dc/elements/1.1/}title').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}publicationName').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}coverDate').text
print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}citedby-count').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi').text

for link in coredata.findall('{http://www.elsevier.com/xml/svapi/abstract/dtd}link'):
    if link.attrib['rel'] == 'scopus':
        print link.attrib['href']
    else:
        print link.attrib['href']

# alternative xpath to get the link
print coredata.find("./{http://www.elsevier.com/xml/svapi/abstract/dtd}link/[@rel='scopus']").attrib['href']
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
j
22746
{'auid': '55569461200', 'seq': '1'}
Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces
Catalysis Communications
52
60-64
2014-07-05
2
10.1016/j.catcom.2013.10.028
http://api.elsevier.com/content/abstract/scopus_id/84901638552
http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward
http://api.elsevier.com/content/search/scopus?query=refeid%282-s2.0-84901638552%29
http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward
#+END_HTML

That is basically it. In the next sections, we basically recreate the previous functions from scopus.py using the xml data.

** Authors
   :PROPERTIES:
   :ID:       197795D3-1848-4767-B1DD-1B6F4E7D5639
   :END:
#+BEGIN_SRC python :tangle scopus_xml.py
def get_author_link(EID):
    results = get_abstract_info(EID)
    authors = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors')
    if authors is None:
        return 'No authors found'
    s = []

    for author in authors:
        name = author.find('{http://www.elsevier.com/xml/ani/common}indexed-name').text
        auid = author.attrib['auid']
        s += ['<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId={0}">{1}</a>'.format(auid, name)]

    return ', '.join(s)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from scopus_xml import *
print get_author_link('2-s2.0-84896759135')
print get_author_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
: <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8724572500">Thompson R.L.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=22981503200">Shi W.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6506329719">Albenze E.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23004637900">Kusuma V.A.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55676869000">Hopkinson D.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Damodaran K.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Lee A.S.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">Luebke D.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Nulwala H.</a>
: <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>

** Journal
   :PROPERTIES:
   :ID:       E50DEEF6-F06F-4750-B919-2B0E5410D0C4
   :END:

#+BEGIN_SRC python :tangle scopus_xml.py
def get_journal_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

    journal = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}publicationName').text
    sid = coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}source-id').text
    s = '<a href="http://www.scopus.com/source/sourceInfo.url?sourceId={sid}">{journal}</a>'

    return s.format(sid=sid, journal=journal)
#+END_SRC

#+BEGIN_SRC python
from scopus_xml import *
print get_journal_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
: <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>

** DOI link
   :PROPERTIES:
   :ID:       A0D82B96-8BD2-4092-8F6A-6778F5982645
   :END:

#+BEGIN_SRC python :tangle scopus_xml.py
def get_doi_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    doi = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi')
    if doi is not None: doi = doi.text
    s = '<a href="http://dx.doi.org/{doi}">doi:{doi}</a>'
    return s.format(doi=doi)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_doi_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>
#+END_HTML

** Abstract link
   :PROPERTIES:
   :ID:       6DCAB269-7BE1-4EF6-BDDB-75229A3BC3AA
   :END:

#+BEGIN_SRC python  :tangle scopus_xml.py
def get_abstract_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

    data = get_abstract_info(EID)

    title = coredata.find('{http://purl.org/dc/elements/1.1/}title').text.encode('utf-8')
    link = coredata.find("./{http://www.elsevier.com/xml/svapi/abstract/dtd}link/[@rel='scopus']").attrib['href'].encode('utf-8')
    s = '<a href="{link}">{title}</a>'
    return s.format(link=link, title=title)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_abstract_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a>
#+END_HTML

** Citation image
   :PROPERTIES:
   :ID:       52A543A8-6296-43F4-9536-670E941737B9
   :END:

#+BEGIN_SRC python :tangle scopus_xml.py
def get_cite_img_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    doi = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi')
    if doi is not None: doi = doi.text
    s = '<img src="http://api.elsevier.com/content/abstract/citation-count?doi={doi}&httpAccept=image/jpeg&apiKey={apikey}"></img>'

    return s.format(doi=doi, apikey=MY_API_KEY, cite_link=None)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_cite_img_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

** Getting it all together
   :PROPERTIES:
   :ID:       D7517A22-24BF-4250-A3C0-12F8697FBA90
   :END:

#+BEGIN_SRC python :tangle scopus_xml.py
def get_html_citation(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    s = '{authors}, <i>{title}</i>, {journal}, <b>{volume}{issue}</b>, {pages}, ({year}), {doi}, {cites}.'

    issue = ''
    if coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}issueIdentifier') is not None:
        issue = '({})'.format(    coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}issueIdentifier').text)

    volume = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume')
    if volume is not None:
        volume = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume').text
    else:
        volume = 'None'

    pages = ''
    if coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange') is not None:
        pages = 'p. ' + coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange').text
    elif coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}article-number') is not None:
        pages = coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}article-number').text
    else:
        pages = 'no pages found'


    year = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}coverDate').text

    return s.format(authors=get_author_link(EID),
                    title=get_abstract_link(EID),
                    journal=get_journal_link(EID),
                    volume=volume,
                    issue=issue,
                    pages=pages,
                    year=year,
                    doi=get_doi_link(EID),
                    cites=get_cite_img_link(EID))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus_xml import *
print '<ol>'
print '<li>',get_html_citation('2-s2.0-84896759135'),'</li>'
print
print '<li>',get_html_citation('2-s2.0-84924911828'),'</li>'
print
print '<li>',get_html_citation('2-s2.0-84901638552'),'</li>'
print '</ol>'
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<ol>
<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8724572500">Thompson R.L.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=22981503200">Shi W.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6506329719">Albenze E.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23004637900">Kusuma V.A.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55676869000">Hopkinson D.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Damodaran K.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Lee A.S.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">Luebke D.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Nulwala H.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84896759135&origin=inward">Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=21100199840">RSC Advances</a>, <b>4(25)</b>, p. 12748-12755, (2014-03-17), <a href="http://dx.doi.org/10.1039/c3ra47097k">doi:10.1039/c3ra47097k</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/c3ra47097k&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>

<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924911828&origin=inward">Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=28134">Journal of Chemical Physics</a>, <b>142(10)</b>, 104703, (2015-03-14), <a href="http://dx.doi.org/10.1063/1.4914093">doi:10.1063/1.4914093</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4914093&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>

<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>
</ol>
#+END_HTML


** Finally getting my documents
   :PROPERTIES:
   :ID:       52D1A722-6A3B-4A3C-9BF1-37AB4833DB8E
   :END:

Here we get the EIDs from a search query. We use these in the next section to get a new bibliography.

#+BEGIN_SRC python :results value
import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=eid,aggregationType&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

return [[str(r['eid']), str(r['prism:aggregationType'])] for r in results['search-results']["entry"] if str(r['prism:aggregationType']) == 'Journal']
#+END_SRC


#+tblname: my-eids
| 2-s2.0-84924911828 | Journal |
| 2-s2.0-84923164062 | Journal |
| 2-s2.0-84924778427 | Journal |
| 2-s2.0-84924130725 | Journal |
| 2-s2.0-84901638552 | Journal |
| 2-s2.0-84898934670 | Journal |
| 2-s2.0-84896759135 | Journal |
| 2-s2.0-84896380535 | Journal |
| 2-s2.0-84896585411 | Journal |
| 2-s2.0-84916613197 | Journal |
| 2-s2.0-84908637059 | Journal |
| 2-s2.0-84880986072 | Journal |
| 2-s2.0-84881394200 | Journal |
| 2-s2.0-84873706643 | Journal |
| 2-s2.0-84876703352 | Journal |
| 2-s2.0-84867809683 | Journal |
| 2-s2.0-84864914806 | Journal |
| 2-s2.0-84865730756 | Journal |
| 2-s2.0-84864592302 | Journal |
| 2-s2.0-84863684845 | Journal |
| 2-s2.0-84866142469 | Journal |
| 2-s2.0-84861127526 | Journal |
| 2-s2.0-80052944171 | Journal |
| 2-s2.0-80051809046 | Journal |
| 2-s2.0-79953651013 | Journal |
| 2-s2.0-79952860396 | Journal |
| 2-s2.0-77956568341 | Journal |
| 2-s2.0-77954747189 | Journal |
| 2-s2.0-77956693843 | Journal |
| 2-s2.0-77949916234 | Journal |
| 2-s2.0-77955464573 | Journal |
| 2-s2.0-72049114200 | Journal |
| 2-s2.0-73149124752 | Journal |
| 2-s2.0-73149109096 | Journal |
| 2-s2.0-67449106405 | Journal |
| 2-s2.0-63649114440 | Journal |
| 2-s2.0-60849113132 | Journal |
| 2-s2.0-58649114498 | Journal |
| 2-s2.0-40949100780 | Journal |
| 2-s2.0-33750804660 | Journal |
| 2-s2.0-20544467859 | Journal |
| 2-s2.0-15744396507 | Journal |
| 2-s2.0-9744261716  | Journal |
| 2-s2.0-13444307808 | Journal |
| 2-s2.0-3042820285  | Journal |
| 2-s2.0-2942640180  | Journal |
| 2-s2.0-0142023762  | Journal |
| 2-s2.0-0141924604  | Journal |
| 2-s2.0-0037368024  | Journal |
| 2-s2.0-0037197884  | Journal |

** And my html bibliography
   :PROPERTIES:
   :ID:       64E0034D-3A57-4EB1-B264-8147E3F0FA43
   :END:
This generates my blog bibliography page..
#+BEGIN_SRC python
from scopus.scopus_xml import *

import requests
import json
from scopus.my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=eid,aggregationType&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

data = [[str(r['eid']), str(r['prism:aggregationType'])] for r in
        results['search-results']["entry"] if str(r['prism:aggregationType']) == 'Journal']


with open('../publications.html.mako', 'w') as f:
    f.write('''<%inherit file="_templates/site.mako" />
<article class="page_box">
<%self:filter chain="markdown">

<h1>Online collections of our work</h1>
Pick your favorite:
<ul>
<li><a href="http://orcid.org/0000-0003-2625-9232">orcid:0000-0003-2625-9232</a></li>

<li><a href="http://www.researcherid.com/rid/A-2363-2010">researcherid:A-2363-2010</a></li>

<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a></li>

<li><a href="https://scholar.google.com/citations?user=jD_4h7sAAAAJ">Google Scholar</a></li>

<li><a href="https://www.researchgate.net/profile/John_Kitchin">Research Gate</a></li>

<li><a href="https://www.growkudos.com/profiles/40205">Kudos</a></li>
</ul>

<h1>Publications</h1>
The authors are linked to their Scopus page, the title linked to the Scopus abstract, the journal linked to the Scopus journal page, and the DOI is linked to http://dx.doi.org which normally redirects you to the journal page.

<ol reversed="reversed">
''')

    for eid,type in data:
        f.write('<li>{}</li>'.format(get_html_citation(eid)))
    f.write('''</ol>

</%self:filter>
</article>
''')
#+END_SRC

#+RESULTS:

** Summary
   :PROPERTIES:
   :ID:       4E0AD2BE-968B-4723-B80F-5F1645CF5DFB
   :END:
The XML format is not that intuitive to me. It takes some practice writing robust code, e.g. sometimes the find command does not find anything, and then there is not text attribute to get, so you should check for success on finding things. Also, some text is unicode, and you have to take care to encode it, which my library does not do uniformly. Finally, not all journals have things like volume or issue. My formatting code is not super flexible, so these bibliography entries show None in them occasionally. Still, it is not too bad, and this enables a lot of analysis of your publications, as well as displaying them in different ways. See the result of this page here: http://kitchingroup.cheme.cmu.edu/publications.html

* DONE Making highly linked bibliographies from the Scopus API
  CLOSED: [2015-04-04 Sat 11:32]
  :PROPERTIES:
  :categories: python,scopus
  :date:     2015/04/04 11:32:05
  :updated:  2015/04/04 11:32:05
  :ID:       B783FE71-2F85-493E-8F1C-89D2AF1F8166
  :END:

A given article entry in a bibliography might have the following kinds of links in it. I think we can generate these from a Scopus query.

- Author page: http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771
- [[https://www.scopus.com/record/display.url?eid=2-s2.0-84901638552&origin=resultslist&sort=plf-f&src=s&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a50&sot=autdocs&sdt=autdocs&sl=17&s=AU-ID%287004212771%29&relpos=4&relpos=4&citeCnt=2&searchTerm=][Document page]]
- Journal page: http://www.scopus.com/source/sourceInfo.url?sourceId=22746&origin=resultslist
- [[https://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=2-s2.0-84901638552&src=s&imp=t&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a230&sot=cite&sdt=a&sl=0&origin=resultslist&editSaveSearch=&txGid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a23][Cited by]]
- http://dx.doi.org/10.1016/j.catcom.2013.10.028
- [[https://www.scopus.com/results/citedbyresults.url?sort=r-f&src=s&mltEid=2-s2.0-84901638552&mltType=ref&mltAll=t&imp=t&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a290&sot=mlt&sdt=mlt&sl=730&s=REFEID%28%28%222-s2.0-79953651013%22%29+OR+%28%222-s2.0-84855602300%22%29+OR+%28%222-s2.0-33750453016%22%29+OR+%28%222-s2.0-33645349847%22%29+OR+%28%222-s2.0-0034814842%22%29+OR+%28%222-s2.0-77955464573%22%29+OR+%28%222-s2.0-13444307808%22%29+OR+%28%222-s2.0-53349153662%22%29+OR+%28%222-s2.0-80051809046%22%29+OR+%28%222-s2.0-84876703352%22%29+OR+%28%222-s2.0-80053316882%22%29+OR+%28%222-s2.0-83255187152%22%29+OR+%28%222-s2.0-80052944171%22%29+OR+%28%222-s2.0-84865730756%22%29+OR+%28%222-s2.0-0000778362%22%29+OR+%28%222-s2.0-60349090198%22%29+OR+%28%222-s2.0-2442537377%22%29+OR+%28%222-s2.0-0030190741%22%29+OR+%28%222-s2.0-25744460922%22%29+OR+%28%222-s2.0-0011236321%22%29+OR+%28%222-s2.0-4243943295%22%29+OR+%28%222-s2.0-4944232881%22%29+OR+%28%222-s2.0-1842816907%22%29+OR+%28%222-s2.0-33646343022%22%29+OR+%28%222-s2.0-4143079428%22%29+OR+%28%222-s2.0-77954807118%22%29+OR+%28%222-s2.0-11544320930%22%29%29+AND+NOT+EID+%282-s2.0-84901638552%29&origin=resultslist&txGid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a29][Related articles]]

We are going to look at the document above, with eid=2-s2.0-84901638552. This is another long post, so here is a teaser of what we are doing. For this eid, we want to generate an html entry where each part of the entry is clickable. Here is what we will be able to do by the end of this post:

#+BEGIN_SRC python :results html
from scopus import *

print '<ol>', get_html('2-s2.0-84901638552'), '</ol>'
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<ol> <li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>.</li> </ol>
#+END_HTML

In this post, we work out code that works for this document. This code in the form shown here might not work on all entries, e.g. for ones that are in press and are missing data, or for APS journals that have no page range. Later, I will fix those so this is more robust. To minimize repeating the code below, I create a python module here called [[./scopus.py]].  Tangle it out with elisp:org-babel-tangle. As in the last [[http://kitchingroup.cheme.cmu.edu/blog/2015/04/03/Getting-data-from-the-Scopus-API/][post]], I am not sharing my API key here, since it is not clear if that key is private or not.

I like json, so we use that data format here. XML would be more robust, as the Scopus site admits not all of the data can be turned into the json format, but for now we stick to json for its simplicity.

#+BEGIN_SRC python :tangle scopus.py
import requests
import json, os
from my_scopus import MY_API_KEY

def get_abstract_info(EID, refresh=False):
    'Get and save the json data for EID.'
    base = 'scopus-data/get_abstract_info'
    if not os.path.exists(base):
        os.makedirs(base)

    fname = '{0}/{1}'.format(base, EID)
    if os.path.exists(fname) and not refresh:
        with open(fname) as f:
            return json.loads(f.read())

    # Otherwise retrieve and save results
    url = ("http://api.elsevier.com/content/abstract/eid/" + EID)
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})
    results = json.loads(resp.text.encode('utf-8'))
    with open(fname, 'w') as f:
        f.write(json.dumps(results))

    return results
#+END_SRC

** Author pages
   :PROPERTIES:
   :ID:       AF498AF5-DD03-4EA1-B40B-F997CB417A0C
   :END:
Here, we generate the html that will make each author a clickable link that goes to their Scopus ID author page.

#+BEGIN_SRC python :tangle scopus.py

def get_author_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    html = '<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId={0}">{1}</a>'
    authors = [html.format(auid, name) for auid, name in
               zip([x['@auid'] for x in result['authors']['author']],
                   [x['ce:indexed-name'] for x in result['authors']['author']])]

    return ','.join(authors)

#+END_SRC


#+BEGIN_SRC python :results html
from scopus import *
print get_author_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>
#+END_HTML

** Journal link
   :PROPERTIES:
   :ID:       B3B70785-A734-41AA-AB02-3F85C8231E0C
   :END:
The most important pieces of information we need is the journal name and the source-id from the coredata.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']
print result['coredata']['source-id']
print result['coredata']['prism:publicationName']
#+END_SRC

#+RESULTS:
: 22746
: Catalysis Communications

#+BEGIN_SRC python :tangle scopus.py
def get_journal_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    sid = result['coredata']['source-id']
    journal = result['coredata']['prism:publicationName']
    s = '<a href="http://www.scopus.com/source/sourceInfo.url?sourceId={sid}">{journal}</a>'

    return s.format(sid=sid, journal=journal)

#+END_SRC

#+BEGIN_SRC python :results html
from scopus import *
print get_journal_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>
#+END_HTML

** DOI link
   :PROPERTIES:
   :ID:       8F5C7977-7D3A-40D3-B9B3-72D7DF9450D9
   :END:
It would be helpful to have a doi link, which is actually independent of Scopus so people without Scopus access can still access information.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']
print result['coredata']['prism:doi']
#+END_SRC

#+RESULTS:
: 10.1016/j.catcom.2013.10.028

#+BEGIN_SRC python :tangle scopus.py
def get_doi_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    s = '<a href="http://dx.doi.org/{doi}">doi:{doi}</a>'
    return s.format(doi=result['coredata']['prism:doi'])
#+END_SRC


#+BEGIN_SRC python :results html
from scopus import *
print get_doi_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>
#+END_HTML

** Citation count image
   :PROPERTIES:
   :ID:       122AB58C-A014-4719-8299-A4136C8D30A2
   :END:
It is nice to show impact of a paper by showing the citations. These change with time, so a static view is not ideal. Scopus provides a way to get an image they generate that should update when viewed. We need the doi to get that.

#+BEGIN_SRC python :tangle scopus.py
def get_cite_img_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    s = '<img src="http://api.elsevier.com/content/abstract/citation-count?doi={doi}&httpAccept=image/jpeg&apiKey={apikey}"></img>'
    return s.format(doi=result['coredata']['prism:doi'].strip(), apikey=MY_API_KEY)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus import *
print get_cite_img_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

** The document link
   :PROPERTIES:
   :ID:       4545F399-9D6D-474A-B7C7-34ED917BA6BE
   :END:
The document link is sort of buried in the coredata. It seems like & has been replaced by &amp; in the json data so we have to do a clunky fix here.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']

print result['coredata']['dc:title']
for ref in result['coredata']['link']:
    if ref['@rel'] == 'scopus':
        print ref['@href'].replace('&amp;', '&')
        break
#+END_SRC

#+RESULTS:
: Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces
: http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward

#+BEGIN_SRC python :tangle scopus.py
def get_abstract_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    title = result['coredata']['dc:title']
    for ref in result['coredata']['link']:
        if ref['@rel'] == 'scopus':
            link = ref['@href'].replace('&amp;', '&')

    s = '<a href="{link}">{title}</a>'
    return s.format(link=link, title=title)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus import *
print get_abstract_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a>
#+END_HTML

** Putting it all together
   :PROPERTIES:
   :ID:       2C3DA761-6D40-462D-995F-AF4E6D895E4E
   :END:
Our goal is ultimately an html formatted citation where nearly every piece is a hyperlink to additional information, e.g. each author is linked to their page, the title is linked to the scopus document page, the journal is linked to the scopus journal page, a DOI link, and an image of the number of citations. Here it is.

#+BEGIN_SRC python :tangle scopus.py
def get_html(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']

    s = '<li>{authors}, <i>{title}</i>, {journal}, <b>{volume}{issue}</b>, p. {pages}, ({year}), {doi}, {cites}.</li>'

    issue = ''
    if result['coredata'].get('prism:issue'):
        issue = '({})'.format(result['coredata'].get('prism:issue'))
    return s.format(authors=get_author_link(EID),
                    title=get_abstract_link(EID),
                    journal=get_journal_link(EID),
                    volume=result['coredata'].get('prism:volume'),
                    issue=issue,
                    pages=result['coredata'].get('prism:pageRange'),
                    year=result['coredata'].get('prism:coverDate'),
                    doi=get_doi_link(EID),
                    cites=get_cite_img_link(EID))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :results html
from scopus import *
print get_html('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>.</li>
#+END_HTML


Well, that is the end for now. We have a reusable function that generates a nice HTML formatted citation that links out to many different resources. Why aren't all citations on the web this helpful?
* DONE Getting data from the Scopus API
  CLOSED: [2015-04-03 Fri 15:17]
  :PROPERTIES:
  :categories: python,scopus
  :date:     2015/04/03 15:17:27
  :updated:  2015/04/03 15:19:45
  :ID:       44327E81-6DBF-45DF-A8E2-4A368A24D80F
  :END:

I have been exploring the Scopus API (http://dev.elsevier.com/index.html) lately. This is a RESTful API that allows you to retrieve data about publications via http requests, i.e. from a script. This service is not free; you need to be at an institution that has a Scopus license.

Scopus is very good at finding your papers, and associating them with a Scopus ID. You don't have to do anything to get one, they make it. I have a Scopus ID (http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771) that has all this data via the web, but I wanted to get this data in a tabular form I could use and analyze. Sure you can download a CSV file from that page and analyze that, but I want to script it. I am just like that ;) To use the API, you need to get an API key (http://www.developers.elsevier.com/action/devprojects). I still cannot figure out if this key is "private" so I am not going to share mine here. I have stored it in a python file called my_scopus.py, and I will import it in these examples.

The code below is "wide", so apologies in advance that some of it will run out of the usual area it belongs.

** About me from Scopus
   :PROPERTIES:
   :ID:       80B6A144-C9F5-4E6A-80F0-32B8E409B75B
   :END:
There is an author API that provides a metrics view of a Scopus ID. Here this shows there are about 77 documents for me, cited about 3028 times. Why do I say "about"? Apparently there are two different databases that Scopus uses, one for the web, and one for this API, and they do not return the same data. It is close, but not the same. The API database includes thing that are published after 1995, and it may not be updated as quickly as the web database. For example the web page reports 79 documents and 3143 citations. In the next sections we will use the search API, which returns the same information as what is on the web. Here we just illustrate how to setup an http request in Python. I like json output, so we ask for it.

#+BEGIN_SRC python
import requests
import json
from my_scopus import MY_API_KEY

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18"
        }
    ]
}
#+end_example

** Get my documents from Scopus
   :PROPERTIES:
   :ID:       14FCDF13-CAA1-40E5-8EC8-1A76B2213517
   :END:
To find my documents, we will use the Search API, http://api.elsevier.com/documentation/SCOPUSSearchAPI.wadl. We specify a Scopus ID, and to limit the quantity of data that comes back we specify that we want the dc:identifier field, which corresponds to the scopus id for each document. We will use that in the next section to get info for each document.

#+name: identifiers
#+BEGIN_SRC python :results value
import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=dc:identifier&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

return [[str(r['dc:identifier'])] for r in results['search-results']["entry"]]
#+END_SRC

#+RESULTS: identifiers
| SCOPUS_ID:84924911828 |
| SCOPUS_ID:84923164062 |
| SCOPUS_ID:84924778427 |
| SCOPUS_ID:84924130725 |
| SCOPUS_ID:84901638552 |
| SCOPUS_ID:84898934670 |
| SCOPUS_ID:84896759135 |
| SCOPUS_ID:84896380535 |
| SCOPUS_ID:84896585411 |
| SCOPUS_ID:84916613197 |
| SCOPUS_ID:84908637059 |
| SCOPUS_ID:84880986072 |
| SCOPUS_ID:84881394200 |
| SCOPUS_ID:84873706643 |
| SCOPUS_ID:84876703352 |
| SCOPUS_ID:84872843990 |
| SCOPUS_ID:84872872509 |
| SCOPUS_ID:84872845400 |
| SCOPUS_ID:84872841108 |
| SCOPUS_ID:84872855250 |
| SCOPUS_ID:84872864754 |
| SCOPUS_ID:84886483703 |
| SCOPUS_ID:84872854676 |
| SCOPUS_ID:84867809683 |
| SCOPUS_ID:84864914806 |
| SCOPUS_ID:84865730756 |
| SCOPUS_ID:84864592302 |
| SCOPUS_ID:84863684845 |
| SCOPUS_ID:84866142469 |
| SCOPUS_ID:84861127526 |
| SCOPUS_ID:84857224144 |
| SCOPUS_ID:84857197729 |
| SCOPUS_ID:84856818654 |
| SCOPUS_ID:80052944171 |
| SCOPUS_ID:80051860134 |
| SCOPUS_ID:80051809046 |
| SCOPUS_ID:79953651013 |
| SCOPUS_ID:79952860396 |
| SCOPUS_ID:79951537083 |
| SCOPUS_ID:79251517782 |
| SCOPUS_ID:77956568341 |
| SCOPUS_ID:77954747189 |
| SCOPUS_ID:77956693843 |
| SCOPUS_ID:77949916234 |
| SCOPUS_ID:77955464573 |
| SCOPUS_ID:72049114200 |
| SCOPUS_ID:78649528829 |
| SCOPUS_ID:78649504144 |
| SCOPUS_ID:77952266872 |
| SCOPUS_ID:73149124752 |
| SCOPUS_ID:73149109096 |
| SCOPUS_ID:67449106405 |
| SCOPUS_ID:63649114440 |
| SCOPUS_ID:60849113132 |
| SCOPUS_ID:58649114498 |
| SCOPUS_ID:79952218110 |
| SCOPUS_ID:79952292116 |
| SCOPUS_ID:78049295221 |
| SCOPUS_ID:79952296916 |
| SCOPUS_ID:79952225819 |
| SCOPUS_ID:78049231913 |
| SCOPUS_ID:79952234104 |
| SCOPUS_ID:79952301915 |
| SCOPUS_ID:45149129361 |
| SCOPUS_ID:40949100780 |
| SCOPUS_ID:37349101648 |
| SCOPUS_ID:58049109348 |
| SCOPUS_ID:33750804660 |
| SCOPUS_ID:33645645065 |
| SCOPUS_ID:20544467859 |
| SCOPUS_ID:15744396507 |
| SCOPUS_ID:9744261716  |
| SCOPUS_ID:13444307808 |
| SCOPUS_ID:3042820285  |
| SCOPUS_ID:2942640180  |
| SCOPUS_ID:0142023762  |
| SCOPUS_ID:0141924604  |
| SCOPUS_ID:0037368024  |
| SCOPUS_ID:0037197884  |


** Retrieve info for a document
   :PROPERTIES:
   :ID:       19AC10EC-983F-489F-9409-BD25A15AFD5C
   :END:
Here, we work out how to retrieve data for a document. We use the Abstract API (http://api.elsevier.com/documentation/AbstractRetrievalAPI.wadl). We again use a field to limit the amount of data. Here is an example that works for an article. Scopus also lists books and conferences so, we will see how that works later. Note the unicode stuff. I was getting some errors about non-ascii characters causing the json file not to read, and then issues in constructing the string. This was only a problem for some entries.

#+BEGIN_SRC python
import requests
import json
from my_scopus import MY_API_KEY

def get_scopus_info(SCOPUS_ID):
    url = ("http://api.elsevier.com/content/abstract/scopus_id/"
          + SCOPUS_ID
          + "?field=authors,title,publicationName,volume,issueIdentifier,"
          + "prism:pageRange,coverDate,article-number,doi,citedby-count,prism:aggregationType")
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})
    results = json.loads(resp.text.encode('utf-8'))

    fstring = '{authors}, {title}, {journal}, {volume}, {articlenum}, ({date}). {doi} (cited {cites} times).\n'
    return fstring.format(authors=', '.join([au['ce:indexed-name'] for au in results['abstracts-retrieval-response']['authors']['author']]),
                          title=results['abstracts-retrieval-response']['coredata']['dc:title'].encode('utf-8'),
                          journal=results['abstracts-retrieval-response']['coredata']['prism:publicationName'].encode('utf-8'),
                          volume=results['abstracts-retrieval-response']['coredata']['prism:volume'].encode('utf-8'),
                          articlenum=(results['abstracts-retrieval-response']['coredata'].get('prism:pageRange') or
                              results['abstracts-retrieval-response']['coredata'].get('article-number')).encode('utf-8'),
                          date=results['abstracts-retrieval-response']['coredata']['prism:coverDate'].encode('utf-8'),
                          doi='doi:' + results['abstracts-retrieval-response']['coredata']['prism:doi'].encode('utf-8'),
                          cites=int(results['abstracts-retrieval-response']['coredata']['citedby-count'].encode('utf-8')))



print get_scopus_info('SCOPUS_ID:0037368024')
#+END_SRC

#+RESULTS:
: Kitchin J.R., Barteau M.A., Chen J.G., A comparison of gold and molybdenum nanoparticles on TiO2(1 1 0) 1 Ã— 2 reconstructed single crystal surfaces, Surface Science, 526, 323-331, (2003-03-01). doi:10.1016/S0039-6028(02)02679-1 (cited 27 times).
:


** Get information for all documents
   :PROPERTIES:
   :ID:       0B4E5C59-5A5E-4851-94D2-3DC2614E2131
   :END:
We will use the data we previously got in the long list of Scopus IDs. A few subtle points here are that I made that a nested list so it would print as a column, and so we will have to index each entry to get the scopus id. Also, it seems that some entries generate json that cannot be parsed by python, so we wrap this in a try block and skip those entries. We need to check for the entry being a Journal article, to avoid errors with our format string. We also need to accomodate journals that do not have page ranges, but have artice numbers instead. Finally, we will format each entry so there is some html code for it.

#+BEGIN_SRC python :var scopus_ids=identifiers :results html
import requests
import json
import textwrap
from my_scopus import MY_API_KEY

def get_scopus_info(SCOPUS_ID):
    url = ("http://api.elsevier.com/content/abstract/scopus_id/"
          + SCOPUS_ID
          + "?field=authors,title,publicationName,volume,issueIdentifier,"
          + "prism:pageRange,coverDate,article-number,doi,citedby-count,prism:aggregationType")
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

    return json.loads(resp.text.encode('utf-8'))


i = 0
for sid in scopus_ids:
    # some entries seem to have json parse errors, so we catch those
    try:
        results = get_scopus_info(sid[0])  # index 0 because the input data is a 2d array
        if results['abstracts-retrieval-response']['coredata']['prism:aggregationType'] == 'Journal':
            i += 1
            fstring = '{authors}, {title}, {journal}, {volume}, {articlenum}, ({date}). <a href="http://dx.doi.org/{doi}">{doi}</a> (cited {cites} times)\n\n'

            s = fstring.format(authors=', '.join([au['ce:indexed-name'].encode('utf-8') for au in results['abstracts-retrieval-response']['authors']['author']]),
                               title=results['abstracts-retrieval-response']['coredata']['dc:title'].encode('utf-8'),
                               journal=results['abstracts-retrieval-response']['coredata']['prism:publicationName'].encode('utf-8'),
                               volume=results['abstracts-retrieval-response']['coredata'].get('prism:volume', 'None').encode('utf-8'),
                               articlenum=str((results['abstracts-retrieval-response']['coredata'].get('prism:pageRange') or
                                           results['abstracts-retrieval-response']['coredata'].get('article-number'))).encode('utf-8'),
                               date=results['abstracts-retrieval-response']['coredata']['prism:coverDate'].encode('utf-8'),
                               doi='doi:' + results['abstracts-retrieval-response']['coredata']['prism:doi'].encode('utf-8'),
                               cites=int(results['abstracts-retrieval-response']['coredata']['citedby-count'].encode('utf-8')))
            print '{0:3d}. {1}<br>'.format(i, s)
    except:
        print '{0:3d}. {1}'.format(i, sid)
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
  1. Xu Z., Kitchin J.R., Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides, Journal of Chemical Physics, 142, 104703, (2015-03-14). <a href="http://dx.doi.org/doi:10.1063/1.4914093">doi:10.1063/1.4914093</a> (cited 0 times)

<br>
  2. Boes J.R., Gumuslu G., Miller J.B., Gellman A.J., Kitchin J.R., Estimating bulk-composition-dependent H2 adsorption energies on CuxPd1- x alloy (111) surfaces, ACS Catalysis, 5, 1020-1026, (2015-02-06). <a href="http://dx.doi.org/doi:10.1021/cs501585k">doi:10.1021/cs501585k</a> (cited 0 times)

<br>
  3. Boes J.R., Kondratyuk P., Yin C., Miller J.B., Gellman A.J., Kitchin J.R., Core level shifts in Cu-Pd alloys as a function of bulk composition and structure, Surface Science, None, None, (2015-01-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2015.02.011">doi:10.1016/j.susc.2015.02.011</a> (cited 0 times)

<br>
  4. Xu Z., Rossmeisl J., Kitchin J.R., A linear response DFT+U study of trends in the oxygen evolution activity of transition metal rutile dioxides, Journal of Physical Chemistry C, 119, 4827-4833, (2015-01-01). <a href="http://dx.doi.org/doi:10.1021/jp511426q">doi:10.1021/jp511426q</a> (cited 0 times)

<br>
  5. Xu Z., Kitchin J.R., Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces, Catalysis Communications, 52, 60-64, (2014-07-05). <a href="http://dx.doi.org/doi:10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a> (cited 2 times)

<br>
  6. Demeter E.L., Hilburg S.L., Washburn N.R., Collins T.J., Kitchin J.R., Electrocatalytic oxygen evolution with an immobilized TAML activator, Journal of the American Chemical Society, 136, 5603-5606, (2014-04-16). <a href="http://dx.doi.org/doi:10.1021/ja5015986">doi:10.1021/ja5015986</a> (cited 4 times)

<br>
  7. Thompson R.L., Shi W., Albenze E., Kusuma V.A., Hopkinson D., Damodaran K., Lee A.S., Kitchin J.R., Luebke D.R., Nulwala H., Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids, RSC Advances, 4, 12748-12755, (2014-03-17). <a href="http://dx.doi.org/doi:10.1039/c3ra47097k">doi:10.1039/c3ra47097k</a> (cited 1 times)

<br>
  8. Mehta P., Salvador P.A., Kitchin J.R., Identifying potential BO2 oxide polymorphs for epitaxial growth candidates, ACS Applied Materials and Interfaces, 6, 3630-3639, (2014-03-12). <a href="http://dx.doi.org/doi:10.1021/am4059149">doi:10.1021/am4059149</a> (cited 0 times)

<br>
  9. Miller S.D., Pushkarev V.V., Gellman A.J., Kitchin J.R., Simulating temperature programmed desorption of oxygen on Pt(111) using DFT derived coverage dependent desorption barriers, Topics in Catalysis, 57, 106-117, (2014-02-01). <a href="http://dx.doi.org/doi:10.1007/s11244-013-0166-3">doi:10.1007/s11244-013-0166-3</a> (cited 2 times)

<br>
 10. Curnan M.T., Kitchin J.R., Effects of concentration, crystal structure, magnetism, and electronic structure method on first-principles oxygen vacancy formation energy trends in perovskites, Journal of Physical Chemistry C, 118, 28776-28790, (2014-01-01). <a href="http://dx.doi.org/doi:10.1021/jp507957n">doi:10.1021/jp507957n</a> (cited 2 times)

<br>
 11. Xu Z., Kitchin J.R., Probing the coverage dependence of site and adsorbate configurational correlations on (111) surfaces of late transition metals, Journal of Physical Chemistry C, 118, 25597-25602, (2014-01-01). <a href="http://dx.doi.org/doi:10.1021/jp508805h">doi:10.1021/jp508805h</a> (cited 0 times)

<br>
 12. Lee A.S., Eslick J.C., Miller D.C., Kitchin J.R., Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach, International Journal of Greenhouse Gas Control, 18, 68-74, (2013-10-01). <a href="http://dx.doi.org/doi:10.1016/j.ijggc.2013.06.020">doi:10.1016/j.ijggc.2013.06.020</a> (cited 3 times)

<br>
 13. Hallenbeck A.P., Kitchin J.R., Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent, Industrial and Engineering Chemistry Research, 52, 10788-10794, (2013-08-07). <a href="http://dx.doi.org/doi:10.1021/ie400582a">doi:10.1021/ie400582a</a> (cited 7 times)

<br>
 13. ['SCOPUS_ID:84873706643']
 14. Calle-Vallejo F., Inoglu N.G., Su H.-Y., Martinez J.I., Man I.C., Koper M.T.M., Kitchin J.R., Rossmeisl J., Number of outer electrons as descriptor for adsorption processes on transition metals and their oxides, Chemical Science, 4, 1245-1249, (2013-03-01). <a href="http://dx.doi.org/doi:10.1039/c2sc21601a">doi:10.1039/c2sc21601a</a> (cited 16 times)

<br>
 15. Lee A.S., Kitchin J.R., Chemical and molecular descriptors for the reactivity of amines with CO
                    2 , Industrial and Engineering Chemistry Research, 51, 13609-13618, (2012-10-24). <a href="http://dx.doi.org/doi:10.1021/ie301419q">doi:10.1021/ie301419q</a> (cited 3 times)

<br>
 16. Rubin E.S., Mantripragada H., Marks A., Versteeg P., Kitchin J., The outlook for improved carbon capture technology, Progress in Energy and Combustion Science, 38, 630-671, (2012-10-01). <a href="http://dx.doi.org/doi:10.1016/j.pecs.2012.03.003">doi:10.1016/j.pecs.2012.03.003</a> (cited 91 times)

<br>
 17. Akhade S.A., Kitchin J.R., Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces, Journal of Chemical Physics, 137, 084703, (2012-08-28). <a href="http://dx.doi.org/doi:10.1063/1.4746117">doi:10.1063/1.4746117</a> (cited 8 times)

<br>
 18. Landon J., Demeter E., Inoglu N., Keturakis C., Wachs I.E., Vasic R., Frenkel A.I., Kitchin J.R., Spectroscopic characterization of mixed Fe-Ni oxide electrocatalysts for the oxygen evolution reaction in alkaline electrolytes, ACS Catalysis, 2, 1793-1801, (2012-08-03). <a href="http://dx.doi.org/doi:10.1021/cs3002644">doi:10.1021/cs3002644</a> (cited 39 times)

<br>
 19. Chao R., Munprom R., Petrova R., Gerdes K., Kitchin J.R., Salvador P.A., Structure and relative thermal stability of mesoporous (La, Sr) MnO 3powders prepared using evaporation-induced self-assembly methods, Journal of the American Ceramic Society, 95, 2339-2346, (2012-07-01). <a href="http://dx.doi.org/doi:10.1111/j.1551-2916.2012.05236.x">doi:10.1111/j.1551-2916.2012.05236.x</a> (cited 4 times)

<br>
 20. Kitchin J., Preface: Trends in computational catalysis, Topics in Catalysis, 55, 227-228, (2012-06-01). <a href="http://dx.doi.org/doi:10.1007/s11244-012-9808-0">doi:10.1007/s11244-012-9808-0</a> (cited 0 times)

<br>
 21. Alesi W.R., Kitchin J.R., Evaluation of a primary amine-functionalized ion-exchange resin for CO
                    2 capture, Industrial and Engineering Chemistry Research, 51, 6907-6915, (2012-05-16). <a href="http://dx.doi.org/doi:10.1021/ie300452c">doi:10.1021/ie300452c</a> (cited 15 times)

<br>
 22. Akhade S.A., Kitchin J.R., Effects of strain, d-band filling, and oxidation state on the bulk electronic structure of cubic 3d perovskites, Journal of Chemical Physics, 135, 104702, (2011-09-14). <a href="http://dx.doi.org/doi:10.1063/1.3631948">doi:10.1063/1.3631948</a> (cited 3 times)

<br>
 23. Man I.C., Su H.-Y., Calle-Vallejo F., Hansen H.A., Martinez J.I., Inoglu N.G., Kitchin J., Jaramillo T.F., Norskov J.K., Rossmeisl J., Universality in Oxygen Evolution Electrocatalysis on Oxide Surfaces, ChemCatChem, 3, 1159-1165, (2011-07-11). <a href="http://dx.doi.org/doi:10.1002/cctc.201000397">doi:10.1002/cctc.201000397</a> (cited 199 times)

<br>
 24. Inoglu N., Kitchin J.R., Identification of sulfur-tolerant bimetallic surfaces using dft parametrized models and atomistic thermodynamics, ACS Catalysis, 1, 399-407, (2011-04-01). <a href="http://dx.doi.org/doi:10.1021/cs200039t">doi:10.1021/cs200039t</a> (cited 9 times)

<br>
 25. Miller S.D., Inoglu N., Kitchin J.R., Configurational correlations in the coverage dependent adsorption energies of oxygen atoms on late transition metal fcc(111) surfaces, Journal of Chemical Physics, 134, 104709, (2011-03-14). <a href="http://dx.doi.org/doi:10.1063/1.3561287">doi:10.1063/1.3561287</a> (cited 16 times)

<br>
 26. Alesi Jr. W.R., Gray M., Kitchin J.R., CO2 adsorption on supported molecular amidine systems on activated carbon, ChemSusChem, 3, 948-956, (2010-08-01). <a href="http://dx.doi.org/doi:10.1002/cssc.201000056">doi:10.1002/cssc.201000056</a> (cited 18 times)

<br>
 27. Landon J., Kitchin J.R., Electrochemical concentration of carbon dioxide from an oxygen/carbon dioxide containing gas stream, Journal of the Electrochemical Society, 157, None, (2010-07-23). <a href="http://dx.doi.org/doi:10.1149/1.3432440">doi:10.1149/1.3432440</a> (cited 3 times)

<br>
 28. Inoglu N., Kitchin J.R., Simple model explaining and predicting coverage-dependent atomic adsorption energies on transition metal surfaces, Physical Review B - Condensed Matter and Materials Physics, 82, 045414, (2010-07-16). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.82.045414">doi:10.1103/PhysRevB.82.045414</a> (cited 14 times)

<br>
 29. Pennline H.W., Granite E.J., Luebke D.R., Kitchin J.R., Landon J., Weiland L.M., Separation of CO2 from flue gas using electrochemical cells, Fuel, 89, 1307-1314, (2010-06-01). <a href="http://dx.doi.org/doi:10.1016/j.fuel.2009.11.036">doi:10.1016/j.fuel.2009.11.036</a> (cited 20 times)

<br>
 30. Inoglu N., Kitchin J.R., New solid-state table: Estimating d-band characteristics for transition metal atoms, Molecular Simulation, 36, 633-638, (2010-06-01). <a href="http://dx.doi.org/doi:10.1080/08927022.2010.481794">doi:10.1080/08927022.2010.481794</a> (cited 16 times)

<br>
 31. Tierney H.L., Baber A.E., Kitchin J.R., Sykes E.C.H., Hydrogen dissociation and spillover on individual isolated palladium atoms, Physical Review Letters, 103, 246102, (2009-12-10). <a href="http://dx.doi.org/doi:10.1103/PhysRevLett.103.246102">doi:10.1103/PhysRevLett.103.246102</a> (cited 45 times)

<br>
 32. Miller S.D., Kitchin J.R., Uncertainty and figure selection for DFT based cluster expansions for oxygen adsorption on Au and Pt (111) surfaces, Molecular Simulation, 35, 920-927, (2009-09-01). <a href="http://dx.doi.org/doi:10.1080/08927020902833137">doi:10.1080/08927020902833137</a> (cited 14 times)

<br>
 33. Inolu N., Kitchin J.R., Sulphur poisoning of water-gas shift catalysts: Site blocking and electronic structure modification, Molecular Simulation, 35, 936-941, (2009-09-01). <a href="http://dx.doi.org/doi:10.1080/08927020902833129">doi:10.1080/08927020902833129</a> (cited 6 times)

<br>
 34. Kitchin J.R., Correlations in coverage-dependent atomic adsorption energies on Pd(111), Physical Review B - Condensed Matter and Materials Physics, 79, 205412, (2009-05-01). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.79.205412">doi:10.1103/PhysRevB.79.205412</a> (cited 26 times)

<br>
 35. Han J.W., Kitchin J.R., Sholl D.S., Step decoration of chiral metal surfaces, Journal of Chemical Physics, 130, 124710, (2009-04-08). <a href="http://dx.doi.org/doi:10.1063/1.3096964">doi:10.1063/1.3096964</a> (cited 11 times)

<br>
 36. Miller S.D., Kitchin J.R., Relating the coverage dependence of oxygen adsorption on Au and Pt fcc(1 1 1) surfaces through adsorbate-induced surface electronic structure effects, Surface Science, 603, 794-801, (2009-03-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2009.01.021">doi:10.1016/j.susc.2009.01.021</a> (cited 39 times)

<br>
 37. Inoglu N., Kitchin J.R., Atomistic thermodynamics study of the adsorption and the effects of water-gas shift reactants on Cu catalysts under reaction conditions, Journal of Catalysis, 261, 188-194, (2009-01-25). <a href="http://dx.doi.org/doi:10.1016/j.jcat.2008.11.020">doi:10.1016/j.jcat.2008.11.020</a> (cited 20 times)

<br>
 38. Kitchin J.R., Reuter K., Scheffler M., Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag3 Pd(111) in oxygen atmospheres, Physical Review B - Condensed Matter and Materials Physics, 77, 075437, (2008-02-29). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.77.075437">doi:10.1103/PhysRevB.77.075437</a> (cited 49 times)

<br>
 39. Norskov J.K., Bligaard T., Logadottir A., Kitchin J.R., Chen J.G., Pandelov S., Stimming U., Response to "comment on 'trends in the exchange current for hydrogen evolution' [J. Electrochem. Soc., 152, J23 (2005)]", Journal of the Electrochemical Society, 153, 054612JES, (2006-11-14). <a href="http://dx.doi.org/doi:10.1149/1.2358292">doi:10.1149/1.2358292</a> (cited 9 times)

<br>
 40. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Trends in the chemical properties of early transition metal carbide surfaces: A density functional study, Catalysis Today, 105, 66-73, (2005-07-15). <a href="http://dx.doi.org/doi:10.1016/j.cattod.2005.04.008">doi:10.1016/j.cattod.2005.04.008</a> (cited 70 times)

<br>
 41. Norskov J.K., Bligaard T., Logadottir A., Kitchin J.R., Chen J.G., Pandelov S., Stimming U., Trends in the exchange current for hydrogen evolution, Journal of the Electrochemical Society, 152, None, (2005-04-07). <a href="http://dx.doi.org/doi:10.1149/1.1856988">doi:10.1149/1.1856988</a> (cited 282 times)

<br>
 42. Norskov J.K., Rossmeisl J., Logadottir A., Lindqvist L., Kitchin J.R., Bligaard T., Jonsson H., Origin of the overpotential for oxygen reduction at a fuel-cell cathode, Journal of Physical Chemistry B, 108, 17886-17892, (2004-11-18). <a href="http://dx.doi.org/doi:10.1021/jp047349j">doi:10.1021/jp047349j</a> (cited 1055 times)

<br>
 43. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Role of strain and ligand effects in the modification of the electronic and chemical Properties of bimetallic surfaces, Physical Review Letters, 93, None, (2004-10-08). <a href="http://dx.doi.org/doi:10.1103/PhysRevLett.93.156801">doi:10.1103/PhysRevLett.93.156801</a> (cited 361 times)

<br>
 44. Mhadeshwar A.B., Kitchin J.R., Barteau M.A., Vlachos D.G., The role of adsorbate-adsorbate interactions in the rate controlling step and the most abundant reaction intermediate of NH 3 decomposition on RU, Catalysis Letters, 96, 13-22, (2004-07-01). <a href="http://dx.doi.org/doi:10.1023/B:CATL.0000029523.22277.e1">doi:10.1023/B:CATL.0000029523.22277.e1</a> (cited 45 times)

<br>
 45. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Modification of the surface electronic and chemical properties of Pt(111) by subsurface 3d transition metals, Journal of Chemical Physics, 120, 10240-10246, (2004-06-01). <a href="http://dx.doi.org/doi:10.1063/1.1737365">doi:10.1063/1.1737365</a> (cited 443 times)

<br>
 46. McCormick J.R., Kitchin J.R., Barteau M.A., Chen J.G., A four-point probe correlation of oxygen sensitivity to changes in surface resistivity of TiO2(0 0 1) and Pd-modified TiO2(0 0 1), Surface Science, 545, None, (2003-11-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2003.08.041">doi:10.1016/j.susc.2003.08.041</a> (cited 11 times)

<br>
 47. Kitchin J.R., Khan N.A., Barteau M.A., Chen J.G., Yakshinskiy B., Madey T.E., Elucidation of the active surface and origin of the weak metal-hydrogen bond on Ni/Pt(1 1 1) bimetallic surfaces: A surface science and density functional theory study, Surface Science, 544, 295-308, (2003-10-20). <a href="http://dx.doi.org/doi:10.1016/j.susc.2003.09.007">doi:10.1016/j.susc.2003.09.007</a> (cited 108 times)

<br>
 48. Kitchin J.R., Barteau M.A., Chen J.G., A comparison of gold and molybdenum nanoparticles on TiO2(1 1 0) 1 Ã— 2 reconstructed single crystal surfaces, Surface Science, 526, 323-331, (2003-03-01). <a href="http://dx.doi.org/doi:10.1016/S0039-6028(02)02679-1">doi:10.1016/S0039-6028(02)02679-1</a> (cited 27 times)

<br>
 49. Song I.K., Kitchin J.R., Barteau M.A., H3PW12O40-functionalized tip for scanning tunneling microscopy, Proceedings of the National Academy of Sciences of the United States of America, 99, 6471-6475, (2002-04-30). <a href="http://dx.doi.org/doi:10.1073/pnas.072514399">doi:10.1073/pnas.072514399</a> (cited 12 times)

<br>
#+END_HTML

** Summary thoughts
   :PROPERTIES:
   :ID:       1E32EF23-9BC4-412C-9DD4-FFFC5DD3CAAC
   :END:
I see a lot of potential here for analytics on publications, generation of bibliography files, etc... Instead of retrieving this data every time, it would make much more sense to cache it, e.g. writing each result to a file that could then be used locally, and much faster. The downside of that is, the citations would not be updated in those files. The upside is, you could fix the titles so they are properly marked up. I do not know what the issues with some of the json files was. Some of them were unicode issues. Some other day I will try to track down the other ones.

The entries could be made a lot more functional than this. Each author could be turned into a link back to the scopus author page, for example, the title could be linked to the scopus abstract page, etc... The citations could be a button that automatically updates (like the one in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/30/1000+-citations-for-fuel-cell-paper-on-the-oxygen-reduction-reaction/][post]]). That is another exercise, for another day!


* DONE The orcid api and generating a bibtex file from it
  CLOSED: [2015-03-28 Sat 14:22]
  :PROPERTIES:
  :categories: python,orcid
  :date:     2015/03/28 14:21:59
  :updated:  2015/03/28 14:21:59
  :ID:       7E82C2D9-A5D1-49B8-86F7-8A54753368B7
  :END:

I found this interesting package [[https://pypi.python.org/pypi/orcid-python][orcid-python 0.1 : Python Package Index]]. Unfortunately, it seems to have some issues and it did not work for me. But, the idea is pretty simple, there is a restful API (see http://members.orcid.org/api/tutorial-retrieve-data-public-api-curl-12-and-earlier) that we can use to retrieve data. We explore that a bit here.

I have an orcid:0000-0003-2625-9232 which contains my data. First, we just retrieve some basic information using Python.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232",
                    headers={'Accept':'application/orcid+json'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC
#+RESULTS:
#+begin_example
{
    "message-version": "1.1",
    "orcid-profile": {
        "client-type": null,
        "group-type": null,
        "orcid": null,
        "orcid-activities": {
            "affiliations": null
        },
        "orcid-bio": {
            "applications": null,
            "contact-details": {
                "address": {
                    "country": {
                        "value": "US",
                        "visibility": null
                    }
                },
                "email": []
            },
            "delegation": null,
            "external-identifiers": {
                "external-identifier": [
                    {
                        "external-id-common-name": {
                            "value": "ResearcherID"
                        },
                        "external-id-orcid": {
                            "host": "orcid.org",
                            "path": "0000-0001-7707-4137",
                            "uri": "http://orcid.org/0000-0001-7707-4137",
                            "value": null
                        },
                        "external-id-reference": {
                            "value": "A-2363-2010"
                        },
                        "external-id-url": {
                            "value": "http://www.researcherid.com/rid/A-2363-2010"
                        }
                    },
                    {
                        "external-id-common-name": {
                            "value": "Scopus Author ID"
                        },
                        "external-id-orcid": {
                            "host": "orcid.org",
                            "path": "0000-0002-5982-8983",
                            "uri": "http://orcid.org/0000-0002-5982-8983",
                            "value": null
                        },
                        "external-id-reference": {
                            "value": "7004212771"
                        },
                        "external-id-url": {
                            "value": "http://www.scopus.com/inward/authorDetails.url?authorID=7004212771&partnerID=MN8TOARS"
                        }
                    }
                ],
                "visibility": null
            },
            "keywords": {
                "keyword": [
                    {
                        "value": "Computational catalysis, electrochemistry, CO2 capture"
                    }
                ],
                "visibility": null
            },
            "personal-details": {
                "family-name": {
                    "value": "Kitchin"
                },
                "given-names": {
                    "value": "John"
                }
            },
            "researcher-urls": {
                "researcher-url": [
                    {
                        "url": {
                            "value": "http://kitchingroup.cheme.cmu.edu"
                        },
                        "url-name": {
                            "value": "Research website"
                        }
                    }
                ],
                "visibility": null
            },
            "scope": null
        },
        "orcid-history": {
            "claimed": {
                "value": true
            },
            "completion-date": {
                "value": 1376581428004
            },
            "creation-method": "WEBSITE",
            "last-modified-date": {
                "value": 1427557747595
            },
            "source": null,
            "submission-date": {
                "value": 1376581211104
            },
            "visibility": null
        },
        "orcid-identifier": {
            "host": "orcid.org",
            "path": "0000-0003-2625-9232",
            "uri": "http://orcid.org/0000-0003-2625-9232",
            "value": null
        },
        "orcid-preferences": {
            "locale": "EN"
        },
        "type": "USER"
    }
}
#+end_example

That information is not too interesting, but it would allow you to scrape out my website, scopus id, and researcher id. Next, we look at the publications orcid knows about for me. These are integrated from a few sources, notably my researcherid:A-2363-2010, scopusid:7004212771, and http://crossref.org.  The next code block prints the bibtex entry for the first few entries. The bibtex entries are not too well formed, and would need some cleaning, but it is a pretty good start.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})

results = resp.json()
for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    print result['work-citation']['citation'].encode('utf-8') + '\n'
    if i == 2:
        break
#+END_SRC

#+RESULTS:
: @article{Xu_2015,doi = {10.1021/jp511426q},url = {http://dx.doi.org/10.1021/jp511426q},year = 2015,month = {mar},publisher = {American Chemical Society ({ACS})},volume = {119},number = {9},pages = {4827--4833},author = {Zhongnan Xu and Jan Rossmeisl and John R. Kitchin},title = { A Linear Response {DFT}$\mathplus$ U Study of Trends in the Oxygen Evolution Activity of Transition Metal Rutile Dioxides },journal = {J. Phys. Chem. C}}
:
: @article{Xu_2015,doi = {10.1063/1.4914093},url = {http://dx.doi.org/10.1063/1.4914093},year = 2015,month = {mar},publisher = {{AIP} Publishing},volume = {142},number = {10},pages = {104703},author = {Zhongnan Xu and John R. Kitchin},title = {Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides},journal = {J. Chem. Phys.}}
:
: @article{Boes_2015,doi = {10.1016/j.susc.2015.02.011},url = {http://dx.doi.org/10.1016/j.susc.2015.02.011},year = 2015,month = {mar},publisher = {Elsevier {BV}},author = {Jacob Boes and Peter Kondratyuk and Chunrong Yin and James B. Miller and Andrew J. Gellman and John R. Kitchin},title = {Core level shifts in Cu{\textendash}Pd alloys as a function of bulk composition and structure},journal = {Surface Science}}
:

Let us look at a tabular form of that data so it is sortable. We attempt to remove some duplicates based on the title and doi. The duplicates come about because there is more than one source where this data is pulled from. This is a little tricky, we do a case insensitive title comparison, but that still fails if the titles have different white space in them, e.g. "111" vs "1 1 1", and different sources do that. Also, the DOIs are sometimes missing, and sometimes have different cases, and sometimes are not correct. This code tries to fix most of those issues.

#+BEGIN_SRC python :results org
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})
results = resp.json()

data = []
TITLES, DOIs = [], []

for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    title = str(result['work-title']['title']['value'].encode('utf-8'))
    doi = 'None'

    for x in result.get('work-external-identifiers', []):
        for eid in result['work-external-identifiers']['work-external-identifier']:
            if eid['work-external-identifier-type'] == 'DOI':
                doi = str(eid['work-external-identifier-id']['value'].encode('utf-8'))

    # AIP journals tend to have a \n in the DOI, and the doi is the second line. we get
    # that here.
    if len(doi.split('\n')) == 2:
        doi = doi.split('\n')[1]

    pub_date = result.get('publication-date', None)
    if pub_date:
        year = pub_date.get('year', None).get('value').encode('utf-8')
    else:
        year = 'Unknown'

    # Try to minimize duplicate entries that are found
    dup = False
    if title.lower() in TITLES:
        dup = True
    if (doi != 'None'
        and doi.lower() in DOIs):
        dup = True

    if not dup:
        # truncate title to first 50 characters
        print('| {3} | {0}  | {1} | [[doi:{2}]]|'.format(title[0:50], year, doi, result['work-type']))

    TITLES.append(title.lower())
    DOIs.append(doi.lower())
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
| JOURNAL_ARTICLE  | A Linear Response DFT+ U Study of Trends in the Ox | 2015 | [[doi:10.1021/jp511426q]]                                |
| JOURNAL_ARTICLE  | Relationships between the surface electronic and c | 2015 | [[doi:10.1063/1.4914093]]                                |
| JOURNAL_ARTICLE  | Core level shifts in Cuâ€“Pd alloys as a function    | 2015 | [[doi:10.1016/j.susc.2015.02.011]]                       |
| JOURNAL_ARTICLE  | Estimating bulk-composition-dependent H2 adsorptio | 2015 | [[doi:10.1021/cs501585k]]                                |
| JOURNAL_ARTICLE  | Probing the Coverage Dependence of Site and Adsorb | 2014 | [[doi:10.1021/jp508805h]]                                |
| JOURNAL_ARTICLE  | Relating the electronic structure and reactivity o | 2014 | [[doi:10.1016/j.catcom.2013.10.028]]                     |
| JOURNAL_ARTICLE  | Electrocatalytic Oxygen Evolution with an Immobili | 2014 | [[doi:10.1021/ja5015986]]                                |
| JOURNAL_ARTICLE  | Identifying Potential BO 2 Oxide Polymorphs for Ep | 2014 | [[doi:10.1021/am4059149]]                                |
| JOURNAL_ARTICLE  | Simulating temperature programmed desorption of ox | 2014 | [[doi:10.1007/s11244-013-0166-3]]                        |
| JOURNAL_ARTICLE  | Probing the effect of electron donation on CO2 abs | 2014 | [[doi:10.1039/c3ra47097k]]                               |
| JOURNAL_ARTICLE  | Effects of concentration, crystal structure, magne | 2014 | [[doi:10.1021/jp507957n]]                                |
| JOURNAL_ARTICLE  | Effects of O 2 and SO 2 on the Capture Capacity of | 2013 | [[doi:10.1021/ie400582a]]                                |
| JOURNAL_ARTICLE  | Number of outer electrons as descriptor for adsorp | 2013 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Interactions in 1-ethyl-3-methyl imidazolium tetra | 2013 | [[doi:http://dx.doi.org/10.1016/j.molstruc.2013.01.046]] |
| JOURNAL_ARTICLE  | Comparisons of amine solvents for post-combustion  | 2013 | [[doi:http://dx.doi.org/10.1016/j.ijggc.2013.06.020]]    |
| JOURNAL_ARTICLE  | Chemical and Molecular Descriptors for the Reactiv | 2012 | [[doi:10.1021/ie301419q]]                                |
| JOURNAL_ARTICLE  | Spectroscopic Characterization of Mixed Feâ€“Ni Ox   | 2012 | [[doi:10.1021/cs3002644]]                                |
| REPORT           | Modeling Coverage Dependence in Surface Reaction N | 2012 | [[doi:10.2172/1149701]]                                  |
| CONFERENCE_PAPER | Vibrational spectroscopy characterization of CO2-i | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | The role of electrolytes in the oxygen evolution r | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | The outlook for improved carbon capture technology | 2012 | [[doi:10.1016/j.pecs.2012.03.003]]                       |
| JOURNAL_ARTICLE  | Structure and Relative Thermal Stability of Mesopo | 2012 | [[doi:10.1111/j.1551-2916.2012.05236.x]]                 |
| JOURNAL_ARTICLE  | Preface: Trends in computational catalysis         | 2012 | [[doi:10.1007/s11244-012-9808-0]]                        |
| CONFERENCE_PAPER | Exergetic analysis of chemical looping reforming   | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Evaluation of a Primary Amine-Functionalized Ion-E | 2012 | [[doi:10.1021/ie300452c]]                                |
| CONFERENCE_PAPER | Electrocatalytic water oxidation using iron-center | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Effects of strain, d-band filling, and oxidation s | 2012 | [[doi:10.1063/1.4746117]]                                |
| BOOK             | Coverage dependent adsorption properties of atomic | 2012 | [[doi:10.1039/9781849734776-00083]]                      |
| CONFERENCE_PAPER | Comparisons of solvents for post-combustion CO2 ca | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Characterization of an ion exchange resin for CO2  | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Assessing the ability of using first principles to | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Universality in Oxygen Evolution Electrocatalysis  | 2011 | [[doi:10.1002/cctc.201000397]]                           |
| CONFERENCE_PAPER | The effect of CO 2 partial pressure on capture wit | 2011 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Preparation of Mesoporous La 0.8Sr 0.2MnO 3 infilt | 2011 | [[doi:10.1149/1.3570235]]                                |
| JOURNAL_ARTICLE  | Identification of sulfur-tolerant bimetallic surfa | 2011 | [[doi:10.1021/cs200039t]]                                |
| JOURNAL_ARTICLE  | Effects of strain, d-band filling, and oxidation s | 2011 | [[doi:10.1063/1.3631948]]                                |
| CONFERENCE_PAPER | Determining the conditions necessary for optimal C | 2011 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Configurational correlations in the coverage depen | 2011 | [[doi:10.1063/1.3561287]]                                |
| CONFERENCE_PAPER | An electronic structure based understanding of ami | 2011 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | CO2 Adsorption on Supported Molecular Amidine Syst | 2010 | [[doi:10.1002/cssc.201000056]]                           |
| JOURNAL_ARTICLE  | Separation of CO2 from flue gas using electrochemi | 2010 | [[doi:10.1016/j.fuel.2009.11.036]]                       |
| JOURNAL_ARTICLE  | New solid-state table: estimating d-band character | 2010 | [[doi:10.1080/08927022.2010.481794]]                     |
| JOURNAL_ARTICLE  | Simple model explaining and predicting coverage-de | 2010 | [[doi:10.1103/PhysRevB.82.045414]]                       |
| CONFERENCE_PAPER | Intrinsic and extrinsic factors associated with CO | 2010 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Electrochemical concentration of carbon dioxide fr | 2010 | [[doi:10.1149/1.3432440]]                                |
| CONFERENCE_PAPER | Catalyzing the catalyst: Hydrogen dissociation and | 2010 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Uncertainty and figure selection for DFT based clu | 2009 | [[doi:10.1080/08927020902833137]]                        |
| JOURNAL_ARTICLE  | Sulphur poisoning of water-gas shift catalysts: Si | 2009 | [[doi:10.1080/08927020902833129]]                        |
| JOURNAL_ARTICLE  | Step decoration of chiral metal surfaces           | 2009 | [[doi:10.1063/1.3096964]]                                |
| JOURNAL_ARTICLE  | Relating the coverage dependence of oxygen adsorpt | 2009 | [[doi:10.1016/j.susc.2009.01.021]]                       |
| JOURNAL_ARTICLE  | Hydrogen Dissociation and Spillover on Individual  | 2009 | [[doi:10.1103/PhysRevLett.103.246102]]                   |
| JOURNAL_ARTICLE  | Correlations in coverage-dependent atomic adsorpti | 2009 | [[doi:10.1103/PhysRevB.79.205412]]                       |
| CONFERENCE_PAPER | Catalyzing the catalyst: Novel pathways to hydroge | 2009 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Atomistic thermodynamics study of the adsorption a | 2009 | [[doi:10.1016/j.jcat.2008.11.020]]                       |
| CONFERENCE_PAPER | Ancillary oxygen-fired combustion using electroche | 2009 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Adsorbate Cu interactions and catalyst morphologie | 2009 | [[doi:None]]                                             |
| CONFERENCE_PAPER | <title>Rotational isomeric state theory applied to | 2008 | [[doi:10.1117/12.776303]]                                |
| CONFERENCE_PAPER | The effect of hydration on the adsorption of carbo | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt-decorated electrocatalysts for direct alcohol f | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | PEM-based electrochemical separation of gases      | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | First principles, atomistic thermodynamics for sul | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Evaluating uncertainty in Ab initio phase diagrams | 2008 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | ENVR 1-Basic research needs to assure a secure ene | 2008 | [[doi:None]]                                             |
| OTHER            | Density functional theory studies of alloys in het | 2008 | [[doi:10.1039/b608782p]]                                 |
| JOURNAL_ARTICLE  | Alloy surface segregation in reactive environments | 2008 | [[doi:10.1103/PhysRevB.77.075437]]                       |
| CONFERENCE_PAPER | A first principles evaluation of the role of subst | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt nanoparticle electrocatalyst synthesis for dire | 2007 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt nanoparticle anode electrocatalysts for direct  | 2007 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Response to &quot;comment on 'Trends in the exchan | 2006 | [[doi:10.1149/1.2358292]]                                |
| JOURNAL_ARTICLE  | Trends in the exchange current for hydrogen evolut | 2005 | [[doi:10.1149/1.1856988]]                                |
| JOURNAL_ARTICLE  | Trends in the chemical properties of early transit | 2005 | [[doi:10.1016/j.cattod.2005.04.008]]                     |
| CONFERENCE_PAPER | Alloy surface segregation in reactive environments | 2005 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | The role of adsorbate-adsorbate interactions in th | 2004 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Role of strain and ligand effects in the modificat | 2004 | [[doi:10.1103/PhysRevLett.93.156801]]                    |
| JOURNAL_ARTICLE  | Origin of the overpotential for oxygen reduction a | 2004 | [[doi:10.1021/jp047349j]]                                |
| JOURNAL_ARTICLE  | Modification of the surface electronic and chemica | 2004 | [[doi:10.1063/1.1737365]]                                |
| JOURNAL_ARTICLE  | Elucidation of the active surface and origin of th | 2003 | [[doi:10.1016/j.susc.2003.09.007]]                       |
| JOURNAL_ARTICLE  | A four-point probe correlation of oxygen sensitivi | 2003 | [[doi:10.1016/j.susc.2003.08.041]]                       |
| JOURNAL_ARTICLE  | A comparison of gold and molybdenum nanoparticles  | 2003 | [[doi:10.1016/s0039-6028(02)02679-1]]                    |
| JOURNAL_ARTICLE  | H3PW12O40-functionalized tip for scanning tunnelin | 2002 | [[doi:10.1073/pnas.072514399]]                           |
| JOURNAL_ARTICLE  | Preparation of paramagnetic ligands for coordinati | 1997 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Preparation and Characterization of a Bis-Semiquin | 1995 | [[doi:10.1021/jo00117a004]]                              |
| JOURNAL_ARTICLE  | SYNTHESIS AND CHARACTERIZATION OF TRISEMIQUINONE L | 1995 | [[doi:None]]                                             |
#+END_SRC

Not too bad. Clearly we could do a lot more work to fine tune exactly what data we retrieve, and then what to do with it. The tools are all here to do that.

* DONE Restarting org-babel sessions in org-mode more effectively
  CLOSED: [2015-03-19 Thu 18:53]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/03/19 18:53:18
  :updated:  2015/03/19 18:53:18
  :ID:       B2EEBFF6-7E57-49D7-BDE3-EC9CA9571864
  :END:

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/12/Making-org-mode-Python-sessions-look-better/][post]] I eliminated one annoying problem with sessions, which was getting rid of extraneous Python interpreter characters in the output. Another thing that has bothered me is when you close Emacs, or even the session buffer, the session is, of course, lost. That means when you reopen the file, you have to run each block in order to continue your work. There does not seem to be a selective way to do this in org. So, in this post, we consider a simple approach to automate that. We want a function that will run all the blocks in a current session that are above the current point.


The idea is we will go to the beginning of the buffer, find all blocks that match the language of the block we are in, and in the session, and execute them. We can tell if a block is in a session by looking at the :parameters property of the block. Interestingly, if a block is not in a session, then session will be "none", if it is in an unnamed session, session will be nil, and otherwise, session will be the session name.

| scenario        | :session value |
|-----------------+----------------|
| no session      | "none"         |
| unnamed session | nil            |
| named session   | "name"         |

Here is a function for testing if a block is in a session.

#+BEGIN_SRC emacs-lisp
(defun src-block-in-session-p (&optional name)
  "Return if src-block is in a session of NAME.
NAME may be nil for unnamed sessions."
  (let* ((info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (body (nth 1 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))

    (cond
     ;; unnamed session, both name and session are nil
     ((and (null session)
	   (null name))
      t)
     ;; Matching name and session
     ((and
       (stringp name)
       (stringp session)
       (string= name session))
      t)
     ;; no match
     (t nil))))
#+END_SRC

Now, we need to get some information about the current point and block. We will want to run blocks that start before the current point, but not after. We will use org-element-map to find code blocks, and when the language and session of a code block matches the current block, and the block starts at a point earlier than the current point, then we will go to that block, and run it. Here is that code.

#+BEGIN_SRC emacs-lisp
(defun org-babel-restart-session-to-point (&optional arg)
  "Restart session up to the src-block in the current point.
Goes to beginning of buffer and executes each code block with
`org-babel-execute-src-block' that has the same language and
session as the current block. ARG has same meaning as in
`org-babel-execute-src-block'."
  (interactive "P")
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (let* ((current-point (point-marker))
	 (info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
	;; goto start of block
        (goto-char (match-beginning 0))
	(let* ((this-info (org-babel-get-src-block-info))
	       (this-lang (nth 0 this-info))
	       (this-params (nth 2 this-info))
	       (this-session (cdr (assoc :session this-params))))
	    (when
		(and
		 (< (point) (marker-position current-point))
		 (string= lang this-lang)
		 (src-block-in-session-p session))
	      (org-babel-execute-src-block arg)))
	;; move forward so we can find the next block
	(forward-line)))))
#+END_SRC


In the course of testing this, I found this function a little helpful to kill the current session so we start fresh.

#+BEGIN_SRC emacs-lisp
(defun org-babel-kill-session ()
  "Kill session for current code block."
  (interactive)
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (save-window-excursion
    (org-babel-switch-to-session)
    (kill-buffer)))
#+END_SRC

And also this one to remove all results in the buffer. This not at all selective, it removes results for session and non-session blocks.

#+BEGIN_SRC emacs-lisp
(defun org-babel-remove-result-buffer ()
  "Remove results from every code block in buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward org-babel-src-block-regexp nil t)
      (org-babel-remove-result))))
#+END_SRC

Ok, now for some testing. The rest of this post is pretty boring, just some blocks of mixed session and non-session to see if they get run. Skip to the [[*Summary]].

#+BEGIN_SRC python :session test  :var d=4
def f(x):
    y = 4 * x
    return y

print(f(d))
#+END_SRC

#+RESULTS:
: 16

Let us put a non-session block in this buffer for testing.

#+BEGIN_SRC python
a = 5
print(a)
#+END_SRC

Now, some more named session blocks.
#+BEGIN_SRC python :session test
print f(5)
#+END_SRC

#+RESULTS:
: 20

#+BEGIN_SRC python :session test
print 'ok'
#+END_SRC

#+RESULTS:
: ok

#+BEGIN_SRC python :session test
print 2
#+END_SRC

#+RESULTS:
: 2

An unnamed session that should not get run in restarting the named test session.

#+BEGIN_SRC python :session
print 886
#+END_SRC


#+BEGIN_SRC python :session test
print f(6)
#+END_SRC

#+RESULTS:
: 24

** Summary
   :PROPERTIES:
   :ID:       02F1E4AE-0C9D-4644-B141-61C1000E5A2E
   :END:
This works pretty well so far.  It would be nice to consider making C-c C-c do this automatically, if the session does not exist, and maybe to take a prefix arg that would restart the session. Maybe on another day ;)

* DONE Clickable links for Twitter handles in Emacs
  CLOSED: [2015-03-18 Wed 12:20]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/03/18 12:20:18
  :updated:  2015/03/18 12:21:53
  :ID:       3210A92B-6E90-4BD3-8C54-C739B169F496
  :END:

Org-mode has clickable links, and they are awesome. You can make your own links, for example here is a link for twitter handles that opens a browser to the handle, and exports as an html link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type "twitter"
 (lambda (handle)
   (browse-url (concat "http://twitter.com/" handle)))
 (lambda (path desc backend)
   (format "<a href=\"http://twitter.com/%s\">%s</a>" path path)))
#+END_SRC

Check it out here: twitter:johnkitchin.

There is another alternative to make clickable text, and that is the button-lock package. You define a regular expression for the text you want to be clickable, and a function to run when it is clicked. Here is an example.

#+BEGIN_SRC emacs-lisp :results silent
(require 'button-lock)
(global-button-lock-mode)

(button-lock-set-button
 "@\\([-a-zA-Z0-9_:]*\\)"
 (lambda ()
   (interactive)
   (re-search-backward "@")
   (re-search-forward  "@\\([a-zA-Z0-9_]*\\)")
   (let* ((handle (match-string-no-properties 1)))
     (browse-url (concat "http://twitter.com/" handle))))
 :face '(:foreground "red"  :underline t))
#+END_SRC

Check it out: @johnkitchin. Of course, you can make your clicking function more sophisticated, e.g. to give you a [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/22/org-mode-links-meet-hydra/][menu of options]], e.g. to send a tweet to someone, or open the web page, or look them up in your org-contacts. The differences between this and an org-mode link are that this works in any mode, and it has no export in org-mode, so it will go as plain text. Since this is just a feature for Emacs though, that should be fine.

* DONE Update on org-ref - it is now all emacs-lisp
  CLOSED: [2015-03-16 Mon 08:51]
  :PROPERTIES:
  :categories: emacs,orgmode,orgref
  :date:     2015/03/16 08:51:50
  :updated:  2015/03/16 08:51:50
  :ID:       EED832FC-3EF1-4EAB-B010-9E5D292D52D5
  :END:

The [[https://github.com/jkitchin/org-ref][org-ref]] code is finally all in emacs-lisp! This should make it much easier to install, and is another step closer to getting org-ref into MELPA. Previously, I had written the most significant code in org-mode source blocks that were intended to be tangled out. I found this was not really portable, because what gets tangled depends on your org-mode setup. I had to specifically set example blocks to not tangle, or org-ref would not work for other people, and if I forgot to set a block to tangle, it also would not work for others. That should not happen again now, since there is no more tangling.


There are some relatively new features in org-ref:
1. New colored org-ref links to differentiate them from other
   org-links. Citations are greenish, refs and labels are maroonish.
2. Context messages about links. With your cursor on a cite, ref or label link
   you will get a context message, e.g. a formatted citation, some context about
   the label a ref refers to, or a count of the labels in the mini-buffer.
3. There is now an org-ref menu in the Org menu.
4. There is a new org-ref-help function that opens an org-file of org-ref
   documentation.
5. Pretty thorough integration of helm throughout org-ref, and some integration
   of hydra.
6. A few utility libraries: doi-utils, isbn, wos, pubmed, arxiv, jmax-bibtex, sci-id,
   x2bib. Not all these are new, but if you didn't know about them, check them out.
7. Cask integration. This mostly provides access to testing and dependencies
   right now. org-ref is also now tested continuously at
   https://travis-ci.org/jkitchin/org-ref.

org-ref is basically feature complete I think (which is to say that once again, I do not have any big ideas for new features ;). There are some places where it could be refactored a little, e.g. there are some bibtex only functions in org-ref.el that really should go into jmax-bibtex.el (which also could be renamed). This is a very low priority though, because things are working fine as far as I can tell.

What does it need before going into MELPA? Probably some tests would be a good idea. On Travis, all that is really tested is that it loads with no errors. I would like to see some stability on my end, e.g. at least a week where no commits get made, and no errors are reported. And finally, I would like to make sure I have some time to handle issues that come up when a broader audience is trying it out.

My target date to get this in MELPA is June 1, 2015. Try out the new org-ref, and let me know how it goes!
* DONE Putting link references to lines of code in a source block
  CLOSED: [2014-04-22 Tue 20:59]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/04/22 20:59:30
  :updated:  2014/04/22 20:59:30
  :ID:       4026DAB0-E1CC-4FFC-87C9-CC2E70B65C2B
  :END:
I keep forgetting about this interesting gem of a feature in org-mode code blocks. You can put references to specific lines of code outside the block!
http://orgmode.org/manual/Literal-examples.html#Literal-examples

The following code block has some references in it that we can refer to later:
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC


In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]] jumps to point-min.

To make this work with python we have to make a slight change to the reference format in the header.

#+BEGIN_EXAMPLE
#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC
#+END_EXAMPLE

#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC

#+RESULTS:
: 0
: 1
: 2
: 3
: 4


In line [[(for)]] we initialize the loop, and in line [[(body)]] we run it.
* DONE Drag images and files onto org-mode and insert a link to them
  CLOSED: [2015-07-10 Fri 16:11]
  :PROPERTIES:
  :categories: emacs,video
  :date:     2015/07/10 16:11:43
  :updated:  2015/07/10 16:11:43
  :ID:       889145D5-1077-4D15-8F57-FB38E72E7C91
  :END:
I want to drag and drop an image onto an org mode file and get a link to that file. This would be used for finding images in Finder, and then dragging them to the Emacs buffer. There is [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/org-download.el][org-download.el]] which looks like it should do something like this too, but it did not work out of the box for me, and I want to add a few wrinkles to it. For a simple drag-n-drop, I just want the link to appear. With ctrl-drag-n-drop I want to add an attr_org line to set the image size, add a caption line, insert the image at the beginning of the line where the mouse cursor is, put the cursor on the caption line and then refresh the inline images in org-mode so the image is immediately visible.

While we are at let us also make it possible to drag file links onto org-files, instead of having the files open. Again, for a simple drag-n-drop, I want a link inserted. For ctrl-drag-n-drop we open the file, and for Meta (alt) drag-n-drop, we insert an attachfile link. You can also define s-drag-n-drop (Super/command) and C-s and M-s drag-n-drop if you can think of things to do with that.

Here is the code to make those things happen. Or watch the video: https://www.youtube.com/watch?v=ahqKXbBVjpQ

#+BEGIN_SRC emacs-lisp
(defun my-dnd-func (event)
  (interactive "e")
  (goto-char (nth 1 (event-start event)))
  (x-focus-frame nil)
  (let* ((payload (car (last event)))
	 (type (car payload))
	 (fname (cadr payload))
	 (img-regexp "\\(png\\|jp[e]?g\\)\\>"))
    (cond
     ;; insert image link
     ((and  (eq 'drag-n-drop (car event))
	    (eq 'file type)
	    (string-match img-regexp fname))
      (insert (format "[[%s]]" fname))
      (org-display-inline-images t t))
     ;; insert image link with caption
     ((and  (eq 'C-drag-n-drop (car event))
	    (eq 'file type)
	    (string-match img-regexp fname))
      (insert "#+ATTR_ORG: :width 300\n")
      (insert (concat  "#+CAPTION: " (read-input "Caption: ") "\n"))
      (insert (format "[[%s]]" fname))
      (org-display-inline-images t t))
     ;; C-drag-n-drop to open a file
     ((and  (eq 'C-drag-n-drop (car event))
	    (eq 'file type))
      (find-file fname))
     ((and (eq 'M-drag-n-drop (car event))
	   (eq 'file type))
      (insert (format "[[attachfile:%s]]" fname)))
     ;; regular drag and drop on file
     ((eq 'file type)
      (insert (format "[[%s]]\n" fname)))
     (t
      (error "I am not equipped for dnd on %s" payload)))))


(define-key org-mode-map (kbd "<drag-n-drop>") 'my-dnd-func)
(define-key org-mode-map (kbd "<C-drag-n-drop>") 'my-dnd-func)
(define-key org-mode-map (kbd "<M-drag-n-drop>") 'my-dnd-func)
#+END_SRC

#+RESULTS:
: my-dnd-func

[[/Users/jkitchin/blogofile-jkitchin.github.com/_blog/jkitchin.json]]
[[attachfile:/Users/jkitchin/blogofile-jkitchin.github.com/_blog/jkitchin.json]]

[[file:///Users/jkitchin/blogofile-jkitchin.github.com/_blog/Au-icosahedron-3.png][Au-icosahedron-3.png]]
* DONE Clickable telephone numbers in mu4e messages
  CLOSED: [2015-11-04 Wed 12:45]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/11/04 12:45:12
  :updated:  2015/11/04 12:45:12
  :ID:       44CC71D4-67F5-42D7-A406-6111EB2B1592
  :END:
We recently updated our university phone system to a VoIP system that uses Cisco Jabber. I am excited about that because finally I can make phone calls from Emacs with a little applescript automation! So, spoiler alert, this post mostly only applies to Macs, unless you know how to automate a Jabber client to make calls. How to make the telephone numbers clickable is general though, and could be used to do other things as well.

#+BEGIN_SRC emacs-lisp
(defun cisco-call (phone-number)
  (interactive "sPhone number: ")
  (do-applescript
   (format "tell application \"Cisco Jabber\"
	activate
	tell application \"System Events\" to keystroke \"n\" using {shift down, command down}
	tell application \"System Events\" to keystroke \"%s\"
	tell application \"System Events\" to key code 36 #return
end tell" phone-number)))
#+END_SRC

#+RESULTS:
: cisco-call

I would like to go a step further, and make clickable phone numbers in my Emacs buffers. Let's take a look at some options.

** org-mode phone link
   :PROPERTIES:
   :ID:       C991340A-6FB3-49B0-8F51-5889CA6FA3C6
   :END:
This is a no-brainer approach. We can define an org-mode link that runs the cisco-call function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "phone"
 (lambda (phone-number)
   (cisco-call phone-number)))
#+END_SRC

#+RESULTS:
| lambda | (phone-number) | (cisco-call phone-number) |

This makes simple link that just calls the number in the path of the link.

** Clickable text with button-lock
   :PROPERTIES:
   :ID:       CDFAF38E-85E6-4043-A725-1B3FA19CAC67
   :END:
I have used the button-lock package very often to make clickable text. Here we use it to highlight phone numbers matching a regular expression that seems to match most US numbers. This seems to work great in org-mode buffers.

#+BEGIN_SRC emacs-lisp
(require 'rx)

(defvar highlight-phone-numbers nil
 "Button for `highlight-phone-numbers'")

(defun highlight-phone-numbers ()
  "Make phone numbers of the following types clickable:
  (xxx) xxx-xxxx
  xxx.xxx.xxx
  xxxxxxxxxx
  xxx-xxx-xxxx"
  (interactive)
  (let ((inhibit-read-only t))
    (setq highlight-phone-numbers
	  (button-lock-set-button
	   (rx
	    ;; optional () around area code
	    (optional "(")
	    (= 3 digit)
	    (optional ")")
	    ;; delimiters
	    (or (optional "-")
		(optional ".")
		(optional " "))
	    (= 3 digit)
	    (or (optional "-")
		(optional ".")
		(optional " "))
	    (= 4 digit))
	   (lambda ()
	     (interactive)
	     (cisco-call (get-surrounding-text-with-property 'phone-number)))
	   :face '((:background "Darkolivegreen2")
		   (:underline t))
	   :help-echo "click to call"
	   :keyboard-binding (kbd "RET")
	   :additional-property 'phone-number))))

(add-hook 'text-mode 'highlight-phone-numbers)
#+END_SRC

#+RESULTS:
| highlight-phone-numbers |

** Phone numbers in mu4e messages
   :PROPERTIES:
   :ID:       B2621A28-0856-4096-9873-E305F4A733E7
   :END:
For some reason, the button-lock package doesn't seem to work in mu4e message buffers, Maybe it is because . The highlight-regexp package does work though, so for these special buffers we use a new approach. We will just put text properties where we want them, and use those properties to make the text clickable.

The messages are in read-only buffers, but we can inhibit that so we can modify the properties. All we need to do is create a little key map as a copy of the existing map, define some keys on it, then search through the buffer adding properties to every phone number we find. I wrote a function that does that, and put that function in a hook to run each time I open a message. Whammo, now I have clickable phone numbers in email! It works pretty well for me.

#+BEGIN_SRC emacs-lisp
(defface mu4e-phone-face
  '((t (:foreground "SteelBlue4" :background "Darkolivegreen2" :underline t)))
  "Phone number directive face.")

(defun mu4e-highlight-phone-numbers ()
  "Make phone numbers clickable in mu4e-view buffers."
  (interactive)
  (let ((phone-regex (rx
		      ;; optional () around area code
		      (optional "(")
		      (= 3 digit)
		      (optional ")")
		      ;; delimiters
		      (or (optional "-")
			  (optional ".")
			  (optional " "))
		      (= 3 digit)
		      (or (optional "-")
			  (optional ".")
			  (optional " "))
		      (= 4 digit))))
    (save-excursion
      (let ((inhibit-read-only t))
	(goto-char (point-min))
	(while (re-search-forward phone-regex nil t)
	  (let ((map (copy-keymap mu4e-view-mode-map))
		(start (match-beginning 0))
		(end (match-end 0)))

	    ;; set file to be clickable to open the source
	    (define-key map [mouse-1]
	      `(lambda ()
		 (interactive)
		 (cisco-call ,(match-string 0))))

	    ;; let letter c also make the call
	    (define-key map "c"
	       `(lambda ()
		 (interactive)
		 (cisco-call ,(match-string 0))))

	    (set-text-properties
	     start end
	     `(local-map, map
			  face mu4e-phone-face
			  mouse-face highlight
			  help-echo "mouse-1: click to call"))))))))

(add-hook 'mu4e-view-mode-hook 'mu4e-highlight-phone-numbers)
#+END_SRC

** Summary
   :PROPERTIES:
   :ID:       CDB4AECF-0247-47B4-AB94-284731E5D139
   :END:
That works pretty well for me overall. The phone number regex is not perfect, e.g. it makes any 10 digit number clickable, and it doesn't recognize international numbers. I am not sure I can call those through the Jabber client anyway. This is purely convenience for me to easily make calls from emails, or other kinds of documents I might read in Emacs.

I don't use phone calls very often, but an interesting thing might be to open a phone log in org-mode, or open the contact that has that phone number to log that you called them, and provide some notes for them. Alternatively, open a new capture for a phone log that could be refiled later.
