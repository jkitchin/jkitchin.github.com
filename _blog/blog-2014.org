* DONE Send email to a list of users
  CLOSED: [2014-02-04 Tue 11:36]
  :PROPERTIES:
  :categories: emacs, emacs-lisp
  :date:     2014/01/13 18:41:55
  :updated:  2014/01/13 18:42:59
  :END:

I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapcar to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.

#+BEGIN_SRC emacs-lisp
(defun send-mail (userid password)
  "send email to userid@andrew.cmu.edu containing their password"
  (interactive)
  (mail)
  (mail-to)
  (insert (format "%s@andrew.cmu.edu" userid))
  (mail-subject)
  (insert "[06-640] account information")
  (mail-text)
  (insert (format "
An account has been created on gilgamesh.cheme.cmu.edu
userid: %s
password: %s" userid password))
  (mail-send-and-exit))

(send-mail "jkitchin" "trustme99")
#+END_SRC

#+RESULTS:

That worked well. I ran the block and got the email.

Now, suppose I have this data:
#+tblname: users
| userid | password  |
|--------+-----------|
| user1  | trustme99 |
| user2  | foolme99  |
| user3  | blameme99 |

We can pass that to a source block as a list of lists that will look like this:
#+BEGIN_EXAMPLE
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
#+END_EXAMPLE

Then, we can use a mapcar to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.

#+BEGIN_SRC emacs-lisp :var data=users
(defun fun (a b)
  (princ (format "user: %s\npassword: %s\n" a b)))

(mapcar (lambda (x) (fun (car x) (cadr x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:

#+BEGIN_SRC emacs-lisp :var data=users
(defun fun (a b)
  (princ (format "user: %s\npassword: %s\n" a b)))

(mapcar (lambda (x) (fun (nth 0 x) (nth 1 x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99



* DONE Making org-mode links to files in Emacs packages
  CLOSED: [2014-01-19 Sun 15:23]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/01/19 12:42:27
  :updated:  2014/01/19 15:27:48
  :END:
Today I will make a new org-mode link that lets me make links to files inside of Emacs packages. These files may be installed in different places on different systems (e.g. in the system directory, in ELPA directories, or in custom directories), so we need a way to construct paths to them. The application of this is eventually I hope to have some emacs packages of documentation, and I would like to have links between the packages that work no matter how they are installed.

I want a syntax that looks like pkg:rainbow-mode==rainbow-mode-pkg.el. We will have a function that parses that to get the package, and the path to the file in the package. Emacs has a function to find the path to the file that defines a library. I chose == because it seems unlikely that would be a string in a package or path.

#+BEGIN_SRC emacs-lisp :results value
(locate-library "rainbow-mode")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode.elc

We can use that to construct the path to where we want. Say we want the file named "rainbow-mode-pkg.el"

#+BEGIN_SRC emacs-lisp :results value
(expand-file-name
 "rainbow-mode-pkg.el"
 (file-name-directory (locate-library "rainbow-mode")))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode-pkg.el

In org-mode links, the link path gets passed to a function. We can split the string like this to get the package and relative path we are referring to.

#+BEGIN_SRC emacs-lisp :results value
(split-string "rainbow-mode==rainbow-mode-pkg.el" "==")
#+END_SRC

#+RESULTS:
| rainbow-mode | rainbow-mode-pkg.el |

That is all of the pieces we need to construct the link function. Here it is.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg"
 (lambda (path)
   (let ((pkg) (relpath)
	 (splitpath (split-string path "==")))
     (setq pkg (car splitpath))
     (setq relpath (nth 1 splitpath))
     (find-file (expand-file-name
		 relpath
		 (file-name-directory (locate-library pkg)))))))
#+END_SRC

#+RESULTS:

pkg:rainbow-mode==rainbow-mode-pkg.el

This works too, but you have to use auctex-pkg as the package name.

pkg:auctex-pkg==doc/intro.texi

I think that is because locate-library looks for the /file/ a library is defined in. That is not quite the same as the root directory of a package. It turns out to be a little more complicated to find that. Below is some code I hacked up looking at the package.el code. First let us examine some pieces.

This gives us information about an installed package.

#+BEGIN_SRC emacs-lisp :results value
(assq 'auctex package-alist)
#+END_SRC

#+RESULTS:
: (auctex . [(11 87 2) nil Integrated environment for *TeX*])

We can get the version of the package like this

#+BEGIN_SRC emacs-lisp :results value
(package-version-join (package-desc-vers (cdr (assq 'auctex package-alist))))
#+END_SRC

#+RESULTS:
: 11.87.2

Ok, finally, we get the directory where it is installed like this:

#+BEGIN_SRC emacs-lisp :results value
(package--dir "auctex" "11.87.2")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Note that in some places we use a package symbol, and in other places a string name.Putting that together, we have this block to get the install-dir of a package. If we have a package symbol we can get the path like this.

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg 'auctex)
       (pkg-name (symbol-name pkg)) ; convert symbol to string
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Usually, we will have a string though. We just have to make it a symbol with the =intern= function.

#+BEGIN_SRC emacs-lisp :results value
(setq pkg-name "auctex")
(setq pkg (intern pkg-name))
(setq desc (cdr (assq pkg package-alist)))
#+END_SRC

#+RESULTS:
: [(11 87 2) nil "Integrated environment for *TeX*"]

Now, we have all the pieces to get the path from a package name in a string:

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg-name "auctex")
       (pkg (intern pkg-name))
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Let us use that to rewrite the link, and address a few other limitations. We will  use =org-open-link-from-string= so we can use org-link syntax in the path part of the link, e.g. to open a file at a line, or headline. Here is our new link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg2"
 (lambda (path)
   (let ((pkg) (relpath) (pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (let* ((pkg-symbol (intern pkg-name)) ;convert string to pkg
			  (desc (cdr (assq pkg-symbol package-alist)))
			  (version (package-version-join (package-desc-vers desc)))
			  (pkg-dir (package--dir pkg-name version)))
		     pkg-dir))
     (setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

Now, we can do all of these:
pkg2:auctex==doc/faq.texi
pkg2:auctex==doc/faq.texi::should
pkg2:auctex==doc/faq.texi::10
[[pkg2:auctex==doc/faq.texi::first place]]

Awesome!

Just for fun, I made a toy package called =package1= in my elpa directory. That package has an org file in it. Now, I can test out the following links:

pkg2:package1==intro.org

pkg2:package1==intro.org::*Miscellaneous

[[pkg2:package1==intro.org::*subheading with words]]

pkg2:package1==intro.org::#install-section

pkg2:package1==intro.org::intro-target

They all work! That works for packages installed via the package manager. However, when I try this with my custom installed org-mode, it does not work. If I run (describe-package 'org) I see that org is a build in package, and that there is an alternate version available. It does not point to my org-installation.

pkg2:org==doc/library-of-babel.org

#+BEGIN_SRC emacs-lisp
(princ (locate-library "org"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/org.elc

#+BEGIN_SRC emacs-lisp
(princ (package-installed-p "org"))
#+END_SRC

#+RESULTS:
: nil

Obviously, we need to check if the package is installed via package.el, or if we should look somewhere else. Let us take a final stab at this. Let us review the challenge.

#+BEGIN_SRC emacs-lisp
(print (locate-library "auctex"))
(print (locate-library "auctex-autoloads"))
#+END_SRC

#+RESULTS:
:
: nil
:
: "c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/auctex-autoloads.el"

We may have to check for a package-autoloads. Ww can wrap that in an =or= macro, which will return the first non-nil result.

#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "auctex"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/

Doing this on the org package shows that this points to a lisp directory.
#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "org"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/

So, let's try a final link function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg3"
 (lambda (path)
   (let ((pkg-name) (relpath)(pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (file-name-directory
		    (or (locate-library pkg-name)
			(locate-library (format "%s-autoloads" pkg-name)))))
(setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

#+RESULTS:

Now, we just have to make sure to use the right relative path. This link opens up an org-file in my installed version of org-mode: pkg3:org==../doc/library-of-babel.org

I don't know if there is a more clever way to create these links. There are two parts to them: 1) the package, and 2) the relative path. The link syntax isn't that rich to do it without parsing the linkpath.

* DONE Alternatives to long complex format statements in emacs-lisp
  CLOSED: [2014-02-03 Mon 10:43]
 :PROPERTIES:
 :categories: emacs-lisp
 :date:     2014/01/20 09:50:26
 :updated:  2014/01/20 09:50:26
 :END:
At one point I had a string I wanted to fill in with a bunch of variables.

#+BEGIN_SRC emacs-lisp
(insert (format"
 :PROPERTIES:
  :Custom_ID: %s
  :AUTHOR: %s
  :JOURNAL: %s
  :YEAR: %s
  :VOLUME: %s
  :PAGES: %s
  :DOI: %s
  :URL: %s
 :END:
[[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"
key author journal year volume pages doi url key jorg-bib-pdf-directory key ))
#+END_SRC

I find that very difficult to use, because it is tedious to make sure all the variables are in the right order, and it is difficult to change later. In Python, you would be able to put named expansions in, e.g. {author} and then used named arguments. That does not exist as far as I know in emacs-lisp.

Below is an alternatme approach that uses concat to construct this string.

#+BEGIN_SRC emacs-lisp :results value
(let ((key "kitchin-2014")
      (author "Kitchin, J. R.")
      (journal "HACS")
      (year "2014")
      (volume "1")
      (pages "1--10")
      (doi "10.1.1.109/hacs.1.10")
      (url "http://hacs.org/10.1.1.109/hacs.1.10")
      (jorg-bib-pdf-directory "/home/jkitchin/pdfs"))

(concat "
 :PROPERTIES:
  :Custom_ID: " key "
  :AUTHOR: " author "
  :JOURNAL: " journal "
  :YEAR: " year "
  :VOLUME: " volume "
  :PAGES: " pages "
  :DOI: " doi "
  :URL: " url "
 :END:
[[cite:" key "]] [[file:" jorg-bib-pdf-directory "/" key ".pdf][pdf]]\n\n"))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is kind of interesting. It is a little tedious to use all the quotes. It seems like there should be soemthing like named expansions. Let us write one of our own. We will use a regular expression to find {:keyword} and a plist. There is a regexp to match this, and then we can take the characters from position 1 to the second to last character as the keyword. That is not beautiful to me, but it works here. Then we just get the keyword from the plist. The keywords in a plist are symbols, and we will have strings. We have to use the =intern= function to convert them to symbols.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s plist)
  "expand a template containing {:keyword} with the definitions in plist"
  (replace-regexp-in-string "{\\(:[^}]+\\)}"
			    (lambda (arg)
			      (let ((keyword (intern (substring arg 1 -1))))
				(format "%s" (plist-get plist keyword)))) s))

(let ((template "
 :PROPERTIES:
  :Custom_ID: {:key}
  :AUTHOR: {:author}
  :JOURNAL: {:journal}
  :YEAR: {:year}
  :VOLUME: {:volume}
  :PAGES: {:pages}
  :DOI: {:doi}
  :URL: {:url}
 :END:
[[cite:{:key}]] [[file:{:pdf-dir}/{:key}.pdf][pdf]]\n\n"))

(expand-template template
		 '(:key "kitchin-2014"
			:author "Kitchin, J. R."
			:journal "HACS"
			:year 2014
			:volume 1
			:pages "1--10"
			:doi "10.1.1.109/hacs.1.10"
			:url "http://hacs.org/10.1.1.109/hacs.1.10"
			:pdf-dir "/home/jkitchin/pdfs")))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is pretty close to what I am used to from python! I am surprised there aren't other solutions for this around. I looked, and couldn't find them.

* DONE Another alternative to string templates
  CLOSED: [2014-02-03 Mon 10:43]
  :PROPERTIES:
  :categories: emacs-lisp
  :date:     2014/01/26 09:56:45
  :updated:  2014/01/26 09:56:45
  :END:

In the [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/][last post]] I explored a way to expand a string template that was
more readable than the usual format. Today I look at another approach
where I use sexp expansions to accomplish the same thing. The idea is
to embed lisp expressions and replace them by what they evaluate to.

In emacs-lisp, if we have a command in a string, we can "read" it, and
then eval it.

Here we get the user-full-name:
#+BEGIN_SRC emacs-lisp :results value
(eval (read "user-full-name"))
#+END_SRC

#+RESULTS:
: John Kitchin

We can use this on variables too.
#+BEGIN_SRC emacs-lisp :results value
(setq some-variable "test")
(eval (read "some-variable"))
#+END_SRC

#+RESULTS:
: test

So, if we use a syntax to identify what to replace, we can substitute
in the values. Let us try %() as the syntax.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %() with the eval of its contents"
  (replace-regexp-in-string "%(\\([^)]+\\))"
			    (lambda (arg)
			      (format "%s" (eval (read (substring arg 2 -1))))) s))


(let ((key "kitchin-2014")
      (author "Kitchin, J. R.")
      (journal "HACS")
      (year "2014")
      (volume "1")
      (pages "1--10")
      (doi "10.1.1.109/hacs.1.10")
      (url "http://hacs.org/10.1.1.109/hacs.1.10")
      (pdf-dir "/home/jkitchin/pdfs")
      (template "
 :PROPERTIES:
  :Custom_ID: %(key)
  :AUTHOR: %(author
  :JOURNAL: %(journal)
  :YEAR: %(year)
  :VOLUME: %(volume)
  :PAGES: %(pages)
  :DOI: %(doi)
  :URL: %(url)
 :END:
[[cite:%(key)]] [[file:%(pdf-dir)/%(key).pdf][pdf]]\n\n"))

(expand-template template))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is pretty nice. I like it better than the plist expansion I used
before. Presumably these variables would already be defined somewhere
in your code.

I thought of trying this on a more complex expansion, and discovered a
weakness in the regexp that finds the expansion values. It turns out
to be simpler to use %{} as the delimiter than %(), because you may
want nested parentheses. The regexp above does not correctly match
sets of parentheses.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
			    (lambda (arg)
			      (let ((sexp (substring arg 2 -1)))
				(format "%s" (eval (read sexp))))) s))

(expand-template "2 * 2 = %{(* 2 2)}")
#+END_SRC

#+RESULTS:
: 2 * 2 = 4


I am not sure this is a desirable way to make a template, with
multiline code to be expanded, but at least this works!

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
			    (lambda (arg)
			      (let ((sexp (substring arg 2 -1)))
				(format "%s" (eval (read sexp))))) s))

(expand-template "The result is %{(progn
  (if (> 4 3)
      'true
    'false))}")
#+END_SRC

#+RESULTS:
: The result is true

The regexp used in the expansion is not very robust. In particular if
there is a } in the code, it will probably fail because the regexp
does not match closing } correctly. Fixing that is beyond me right
now!

* DONE Language specific default headers for code blocks in org-mode
  CLOSED: [2014-01-27 Mon 13:44]
  :PROPERTIES:
  :categories: org-mode, emacs-lisp
  :date:     2014/01/26 12:06:12
  :updated:  2014/01/26 12:06:12
  :END:

I use code blocks in org-mode /a lot/. I usually code in Python, and
in Python I usually write code that prints output which I want to see. So I almost always
want the code blocks to return the output, and not the value of the
last function. I have set my default header args like this:
#+BEGIN_SRC emacs-lisp
org-babel-default-header-args
#+END_SRC

#+RESULTS:
| (:exports . both) | (:results . replace output) | (:session . none) | (:cache . no) | (:noweb . no) | (:hlines . no) | (:tangle . no) |

However, I would prefer that emacs-lisp blocks use value for the
results. I know I can get that by putting  =:results value=  in the
code block header, but that annoys me. I learned today from
http://orgmode.org/worg/org-contrib/babel/header-args.html that you
can make language specific default headers!

This code in my init file sets emacs-lisp specific default headers:
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:emacs-lisp
      (cons '(:results . "value")
	    (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC

That way I do not have type =:results value= at the top of every elisp
block. Of course, if I want the output I could specify =:results
output= in the block.

#+begin_src emacs-lisp
org-babel-default-header-args:emacs-lisp
#+end_src

#+RESULTS:
| (:results . value) | (:exports . both) | (:session . none) | (:cache . no) | (:noweb . no) | (:hlines . no) | (:tangle . no) |

Problem solved!

On a related note, I find I write so many blocks of python and elisp I
added these templates:
#+BEGIN_SRC emacs-lisp
;; add <p for python expansion
(add-to-list 'org-structure-template-alist
             '("p" "#+BEGIN_SRC python\n?\n#+END_SRC" "<src lang=\"python\">\n?\n</src>"))

;; add <el for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))
#+END_SRC

I probably could have also coded the :results header into those
too. They add a tidbit of convenience so I do not have to type python
or emacs-lisp after expanding a source block with <s.

* DONE Clocking your time in org-mode
  CLOSED: [2014-01-27 Mon 13:53]
  :LOGBOOK:
  CLOCK: [2014-01-26 Sun 13:08]--[2014-01-26 Sun 13:16] =>  0:08
  CLOCK: [2014-01-26 Sun 13:04]--[2014-01-26 Sun 13:06] =>  0:02
  CLOCK: [2014-01-26 Sun 12:07]--[2014-01-26 Sun 12:10] =>  0:03
  :END:
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/01/27 13:46:21
  :updated:  2014/01/27 13:53:03
  :END:


I have some need for tracking how much time I spend on certain jobs,
e.g. committees, etc... because 1) I have to report this
information, 2) I need a better idea of how much time some things
take.  Org-mode supports the idea of "clocking in to a task". You run
(org-clock-in) in a heading, and it stores a time stamp. You do your
work in that heading, and when done, you (org-clock-out).

You can summarize your time with (org-clock-report) which puts a dynamic block in your file like this.

#+BEGIN: clocktable :maxlevel 2 :scope subtree :link t
#+CAPTION: Clock summary at [2014-01-26 Sun 13:36]
| Headline                       | Time   |      |
|--------------------------------+--------+------|
| *Total time*                   | *0:24* |      |
|--------------------------------+--------+------|
| [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::Clocking%20your%20time%20in%20org-mode][Clocking your time in org-mode]] | 0:24   |      |
| \__ [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::work%20in%20subheadings][work in subheadings]]        |        | 0:06 |
| \__ [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::Using%20clocking%20effectively][Using clocking effectively]] |        | 0:05 |
#+END:

You can update it by putting your cursor in the #+BEGIN line, and pressing C-c C-c.

** work in subheadings
   :LOGBOOK:
   CLOCK: [2014-01-26 Sun 13:02]--[2014-01-26 Sun 13:04] =>  0:02
   CLOCK: [2014-01-26 Sun 13:00]--[2014-01-26 Sun 13:02] =>  0:02
   CLOCK: [2014-01-26 Sun 12:11]--[2014-01-26 Sun 12:13] =>  0:02
   CLOCK: [2014-01-26 Sun 12:11]--[2014-01-26 Sun 12:11] =>  0:00
   :END:
It seems that the clock-in mechanism works on the heading you are
in. So whenever you clock in, it is specific to that heading. If you
clock-in more than once, multiple CLOCK entries are stored, unless you
modify org-clock-into-drawer. It seems like you probably want these CLOCK entries in a drawer, so you should put this in your init.el file:
#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
#+END_SRC

** Clock in to the right task
By default, (org-clock-in) creates clocks-in to the current headline. Org-mode seems to store a list of recently clocked tasks. You can access them by typing C-u C-c C-x C-i. You will be given some choices of which task to clock in to. You can switch to another task by doing this too.

** Using clocking effectively
   :LOGBOOK:
   CLOCK: [2014-01-26 Sun 13:31]--[2014-01-26 Sun 13:36] =>  0:05
   :END:
It will take some discipline and practice to use this effectively. It appears you can clock in any heading, and then use the clock report to aggregate all the times into one summary. That report can have a variety of scopes, from subtree to file. In that case, if you keep all relevant task information to a project in a file, you just clock in wherever you work in that file, and let the report keep track of it for you.

You could use this to track the amount of time you spend reviewing manuscripts, or doing work for a committee. You just need to remember to actually use it!

It might be interesting to setup code that would automatically clock in when you open a file, and then clock out when  you close it. Probably this would be done with hooks.

There is a nice [[http://sachachua.com/blog/wp-content/uploads/2014/01/2014-01-06-Tracking-time-with-Org-mode.png][map]] of using org-mode for clocking time [[http://sachachua.com/blog/wp-content/uploads/2014/01/2014-01-06-Tracking-time-with-Org-mode.png][here]].

* DONE Using tags to filter lists in Python
  CLOSED: [2014-01-29 Wed 12:52]
  :PROPERTIES:
  :categories: python
  :date:     2014/01/29 12:52:51
  :updated:  2014/01/29 12:52:53
  :END:

Suppose you have a collection of items in a list, and you want to filter the list based on some properties of the items, and then accumulate some other property on the filtered items. We will look at some strategies for this here.

The particular application is that I have a list of courses that make up a curriculum, and I want to summarize the curriculum in a variety of ways. For example, I might want to know how many Gen Ed courses there are, or how many math, chemistry, biology and physics courses there are. I may want to know how may units overall are required.

A course will be represented by a class, which simply holds the data about the course. Here we consider the course number (which is really a string), the number of units of the course, and what category the course fits into. There will be 7 categories here: chemistry, biology, physics, math, engineering, general education, and free elective.

We will use some binary math to represent the categories. Essentially we define tags as if they are binary numbers, and then we can use binary operators to tell if an item is tagged a particular way. We use & to do a logical AND between a variable and a TAG. If it comes out True, the variable has that tag.

This works basically by defining a TAG like a binary number, e.g. TAG1 = 100,
TAG2 = 010, TAG3 = 001. Then, if you have a number like 110, you know it is tagged with TAG1 and TAG2, but not TAG3. We can figure that out with code too.
#+BEGIN_EXAMPLE
100 & 110 = 100 = 1
010 & 110 = 010 = 2
#+END_EXAMPLE

#+BEGIN_SRC python
print 1 & 3
print 2 & 3
#+END_SRC

#+RESULTS:
: 1
: 2

Let us try out an example. The easiest way to define the tags, is as powers of two.
#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010

# Now define a variable that is "tagged"
a = TAG1
print a & TAG1 # remember that 0 = False, everything else is true
print a & TAG2
#+END_SRC

#+RESULTS:
: 1
: 0

We can use multiple tags by adding them together.

#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010
TAG3 = 2**2  # 001

# Now define a variable that is "tagged"
a = TAG1 + TAG2  # 1 + 2 = 3 = 110 in binary
print a & TAG1
print a & TAG2
print a & TAG3
#+END_SRC

#+RESULTS:
: 1
: 2
: 0

You can see that the variable is not tagged by TAG3, but is tagged with TAG1 and TAG2. We might want to tag an item with more than one tag.  We create groups of tags by simply adding them together. We can still check if a variable has a particular tag like we did before.

#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010
TAG3 = 2**2  # 001

# Now define a variable that is "tagged"
a = TAG1 + TAG2  # 1 + 2 = 3 = 110 in binary
print a & TAG1
print a & TAG2
print a & TAG3
#+END_SRC

#+RESULTS:
: 1
: 2
: 0

It is trickier to say if a variable is tagged with a particular set of tags. Let us consider why. The binary representation of TAG1 + TAG2 is 110. The binary representation of TAG2 + TAG3 is 011. If we simply consider (TAG1 + TAG2) & (TAG2 & TAG3) we get 010. That actually tells us that we do not have a match, because 010 is not equal to (TAG2 & TAG3 = 011). In other words, the logical AND of the tag with some sum of tags is equal to the sum of tags when there is a match. So, we can check if that is the case with an equality comparison.

#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010
TAG3 = 2**2  # 001

# Now define a variable that is "tagged"
a = TAG1 + TAG2  # 1 + 2 = 3 = 110 in binary
print (a & (TAG1 + TAG2)) == TAG1 + TAG2
print (a & (TAG1 + TAG3)) == TAG1 + TAG3
print (a & (TAG2 + TAG3)) == TAG2 + TAG3
#+END_SRC

#+RESULTS:
: True
: False
: False

Ok, enough binary math, let us see an application. Below we create a set of tags indicating the category a course falls into, a class definition to store course data in attributes of an object, and a list of courses. Then, we show some examples of list comprehension filtering based on the tags to summarize properties of the list. The logical comparisons are simple below, as the courses are not multiply tagged at this point.

#+BEGIN_SRC python
CHEMISTRY = 2**0
BIOLOGY = 2**1
PHYSICS = 2**2
MATH = 2**3
ENGINEERING = 2**4
GENED = 2**5
FREE = 2**6

class Course:
    '''simple container for course information'''
    def __init__(self, number, units, category):
        self.number = number
        self.units = units
        self.category = category
    def __repr__(self):
        return self.number


courses = [Course('09-105', 9, CHEMISTRY),
           Course('09-106', 9, CHEMISTRY),
           Course('33-105', 12, PHYSICS),
           Course('33-106', 12, PHYSICS),
           Course('21-120', 10, MATH),
           Course('21-122', 10, MATH),
           Course('21-259', 10, MATH),
           Course('06-100', 12, ENGINEERING),
           Course('xx-xxx', 9, GENED),
           Course('xx-xxx', 9, FREE),
           Course('03-232', 9, BIOLOGY)]

# print the total units
print ' Total units = {0}'.format(sum([x.units for x in courses]))

# get units of math required
math_units = sum([x.units  for x in courses if x.category & MATH])

# get total units of math, chemistry, physics and biology a | b is a
# logical OR. This gives a prescription for tagged with MATH OR
# CHEMISTRY OR PHYSICS OR BIOLOGY
BASIC_MS = MATH | CHEMISTRY | PHYSICS | BIOLOGY

# total units in those categories
basic_math_science = sum([x.units for x in courses if x.category & BASIC_MS])

print 'We require {0} units of math out of {1} units of basic math and science courses.'.format(math_units, basic_math_science)

# We are required to have at least 96 units of Math and Sciences.
print 'We are compliant on number of Math and science: ',basic_math_science >= 96
#+END_SRC

#+RESULTS:
:  Total units = 111
: We require 30 units of math out of 81 units of basic math and science courses.
: We are compliant on number of Math and science:  False

That is all for this example. With more data for each course, you could see what courses are taken in what semesters, how many units are in each semester, maybe create a prerequisite map, and view the curriculum by categories of courses, etc...


* DONE Printing unicode characters in Python strings
  CLOSED: [2014-02-02 Sun 12:18]
  :PROPERTIES:
  :categories: python,unicode
  :date:     2014/02/02 12:18:16
  :updated:  2014/02/02 12:18:16
  :END:

Are you tired of printing strings like this:
#+BEGIN_SRC python :results output
print 'The volume is {0} Angstrom^3'.format(125)
#+END_SRC

#+RESULTS:
: The volume is 125 Angstrom^3

Wish you could get Å in your string? That is the unicode character
U+212B. We can get that to print in Python, but we have to create it
in a unicode string, and print the string properly encoded. Let us try
it out.

#+BEGIN_SRC python :results output
print u'\u212B'.encode('utf-8')
#+END_SRC

#+RESULTS:
: Å

We use u'' to indicate a unicode string. Note we have to encode the
string to print it, or will get this error:

#+BEGIN_EXAMPLE
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character u'\u212b' in position 0: ordinal not in range(128)
#+END_EXAMPLE

Do more, do more, we wish we could! Unicode also supports some
superscripted and subscripted numbers
(http://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts). Let
us see that in action.

#+BEGIN_SRC python :results output
print u'\u212B\u00B3'.encode('utf-8')
#+END_SRC

#+RESULTS:
: Å³

Pretty sweet. The code is not all that readable if you aren't fluent
in unicode, but if it was buried in some library it would just print
something nice looking. We can use this to print chemical formulas
too.

#+BEGIN_SRC python  :results output
print u'''The chemical formula of water is H\u2082O.
Water dissociates into H\u207A and OH\u207B'''.encode('utf-8')
#+END_SRC

#+RESULTS:
=The chemical formula of water is H₂O.
Water dissociates into H⁺ and OH⁻

There are other encodings too. See the symbols here: http://en.wikipedia.org/wiki/Number_Forms
#+BEGIN_SRC python  :results output
print u'1/4 or \u00BC'.encode('latin-1')
#+END_SRC

#+RESULTS:
: 1/4 or ¼

That seems like:

#+BEGIN_SRC python :results output
print u'A good idea\u00AE'.encode('latin-1')
#+END_SRC

#+RESULTS:
: A good idea®

I can not tell how you know exactly what encoding to use. If you use
utf-8 in the example above, you get a stray character in front of the
desired trademark symbol. Still, it is interesting you can get
prettier symbols!

* DONE Using YAML in python for structured data
  CLOSED: [2014-02-03 Mon 09:36]
  :PROPERTIES:
  :categories: python,yaml,template
  :date:     2014/02/03 09:36:29
  :updated:  2014/02/03 09:36:29
  :END:
[[http://www.yaml.org/][YAML]] is a data format that is most text, with some indentation. It is like JSON, but without the braces. What is important here is that you can read a yaml document into a python dictionary. Here is an example of reading a yaml string so you can see the format.

#+BEGIN_SRC python :results output
import yaml
document = """
a: 1
b:
  c: 3
  d: 4
"""
print yaml.load(document)
#+END_SRC

#+RESULTS:
: {'a': 1, 'b': {'c': 3, 'd': 4}}

Everything indented by the same level is grouped in its own dictionary. If we put that string into a file ([[./test.yaml]]), we can read that in to python like this.

#+BEGIN_SRC python
import yaml
document = open('test.yaml').read()
print yaml.load(document)
#+END_SRC

#+RESULTS:
: {'a': 1, 'b': {'c': 3, 'd': 4}}

That example is pretty trivial. What I want to do is have  yaml file that represents a course syllabus. Then, if I had a set of these files, I could write code to analyze the collection of syllabi. For example, to figure out how many units of particular category there are. Alternatively, I could create different representations of the document, e.g. a pdf or html file for students or accreditation boards. Below is a YAML representtion of an ABET syllabus. It is pretty readable for a person.

#+BEGIN_SRC python :results output replace
import yaml
document = """
course:
  course-number: 06-364
  title: Chemical Reaction Engineering
  units: 9
  description: Fundamental concepts in the kinetic modeling of chemical reactions, the treatment and analysis of rate data. Multiple reactions and reaction mechanisms. Analysis and design of ideal and non-ideal reactor systems. Energy effects and mass transfer in reactor systems. Introductory principles in heterogeneous catalysis.

  textbook: H. S. Fogler, Elements of Chemical Reaction Engineering, 4th edition, Prentice Hall, New York, 2006.
  prerequisites: [06-321, 06-323, 09-347]
  required: Yes

  goals:
    goal1:
      description: To analyze kinetic data and obtain rate laws
      outcomes: [a, k]
      criteria: [A, F]
    goal2:
      description: To develop a mechanism that is consistent with an experimental rate law
    goal3:
      description: To understand the behavior of different reactor types when they are used either individually or in combination
    goal4:
      description: To choose a reactor and determine its size for a given application
    goal5:
      description: To work with mass and energy balances in the design of non-isothermal reactors
    goal6:
      description: To understand the importance of selectivity and know the strategies that are commonly used in maximizing yields
    goal7:
      description: To effectively use mathematical software in the design of reactors and analysis of data

  topics:
    - Conversion and reactor sizing
    - Rate laws and stoichiometry
    - Isothermal reactor design
    - Collection and analysis of rate data
    - Multiple reactions and selectivity
    - Non-elementary reaction kinetics
    - Non-isothermal reactor design
    - Unsteady operation of reactors
    - Catalysis and catalytic reactors
"""
with open('06-364.yaml', 'w') as f:
    f.write(document)

print yaml.load(document)
#+END_SRC

#+RESULTS:
: {'course': {'description': 'Fundamental concepts in the kinetic modeling of chemical reactions, the treatment and analysis of rate data. Multiple reactions and reaction mechanisms. Analysis and design of ideal and non-ideal reactor systems. Energy effects and mass transfer in reactor systems. Introductory principles in heterogeneous catalysis.', 'title': 'Chemical Reaction Engineering', 'prerequisites': ['06-321', '06-323', '09-347'], 'topics': ['Conversion and reactor sizing', 'Rate laws and stoichiometry', 'Isothermal reactor design', 'Collection and analysis of rate data', 'Multiple reactions and selectivity', 'Non-elementary reaction kinetics', 'Non-isothermal reactor design', 'Unsteady operation of reactors', 'Catalysis and catalytic reactors'], 'required': True, 'textbook': 'H. S. Fogler, Elements of Chemical Reaction Engineering, 4th edition, Prentice Hall, New York, 2006.', 'goals': {'goal6': {'description': 'To understand the importance of selectivity and know the strategies that are commonly used in maximizing yields'}, 'goal7': {'description': 'To effectively use mathematical software in the design of reactors and analysis of data'}, 'goal4': {'description': 'To choose a reactor and determine its size for a given application'}, 'goal5': {'description': 'To work with mass and energy balances in the design of non-isothermal reactors'}, 'goal2': {'description': 'To develop a mechanism that is consistent with an experimental rate law'}, 'goal3': {'description': 'To understand the behavior of different reactor types when they are used either individually or in combination'}, 'goal1': {'outcomes': ['a', 'k'], 'description': 'To analyze kinetic data and obtain rate laws', 'criteria': ['A', 'F']}}, 'units': 9, 'course-number': '06-364'}}




You can see here the whole document is now stored as a dictionary. You
might ask why? I have the following interests:
1. If I have a set of these files, I could loop through them and
   generate some kind of summary, e.g. total units of some category.
2. I could generate a consistent format using a template.

Let us explore the template. We will generate a LaTeX document using
the Cheetah template engine (http://www.cheetahtemplate.org/). I have also used [[http://www.makotemplates.org/][Mako]], and [[http://jinja.pocoo.org/][jinja]]. A
template is a fancy string that has code in that can be evaluated and
substituted at generation time. We use this to replace elements of the
template with data from our yaml document.  Below I created a template
that generates a LaTeX document.

#+BEGIN_SRC python
import yaml
from Cheetah.Template import Template

with open('06-364.yaml', 'r') as f:
    document = yaml.load(f.read())

data = document['course']

template = r'''\documentclass{article}
\renewcommand{\abstractname}{Course Description}

\begin{document}
\title{$data['course-number'] $data['title']}
\maketitle
\begin{abstract}
$data['description']
\end{abstract}

\textbf{Required:} $data['required']

\textbf{Prerequisites:} #echo ', '.join($data['prerequisites'])

{\textbf{Textbook:} $data['textbook']

\section{Course goals}
\begin{enumerate}
#for $goal in $data['goals']
\item $data['goals'][$goal]['description'] \label{$goal}
#end for
\end{enumerate}

\section{Topics}
\begin{itemize}
#for $topic in $data['topics']
\item $topic
#end for
\end{itemize}
\end{document}'''

t = Template(template, searchList=locals())

#import sys; sys.exit()
with open('06-364.tex', 'w') as f:
    f.write(t.respond())
#+END_SRC

#+RESULTS:
: None

You can see the results of the tex file here: [[./06-364.tex]], and the
corresponding pdf here: [[./06-364.pdf]]. It is not spectacular by any
means, but if I had 16 of these to create, this sure would be
convenient! And if we need some other format, we just make a new template!

Some notes about this:
1. The course goals are not in the order defined in the yaml file. That is not too surprising, since dictionaries do not preserve order.
2. Yes in yaml apparently is read in as a boolean, so in the pdf, it is printed as True.
3. I have not thought about how to prepare a table that maps student outcomes (a-k in ABET) to the course goals
4. It would be nice if there were links in the pdf to other syllabi, e.g. the prerequisites. See http://ctan.mirrorcatalogs.com/macros/latex/required/tools/xr.pdf


* DONE Reproducing the research
  CLOSED: [2014-02-04 Tue 08:34]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/02/04 07:26:18
  :updated:  2014/02/04 07:26:18
  :END:
We have over the past year published a few papers using org-mode. You can find one of them here: http://pubs.acs.org/doi/abs/10.1021/ie400582a. There is a corresponding [[http://pubs.acs.org/doi/suppl/10.1021/ie400582a/suppl_file/ie400582a_si_001.pdf][supporting information]] file that is freely available, which contains within it an org-mode file that documents our work, and that contains the data in it. In this post, I want to explore how easy it is to access that data, and use it. First, download the file:

#+BEGIN_SRC sh
wget http://pubs.acs.org/doi/suppl/10.1021/ie400582a/suppl_file/ie400582a_si_001.pdf
#+END_SRC

#+RESULTS:

Then, open it in Acrobat Reader, and extract the org-file. I saved it as [[./supporting-information.org]]. In that file, there is a table of data that is the SO_2 adsorption and desorption capacity of a resin as a function of cycles. The table is named =so2-capacity-1=.

Here is how simple it is to grab that data, and use it. We need to use this header in our source block:
#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=supporting-information.org:so2-capacity-1
#+END_EXAMPLE

In the block, =data= will be a list of lists. I like to convert it into a numpy array, so that indexing it is simple to extract out the data.

#+BEGIN_SRC python :var data=supporting-information.org:so2-capacity-1
import numpy as np
data = np.array(data)
cycles = data[:, 0]
ads_cap = data[:, 1]
des_cap = data[:, 2]

import matplotlib.pyplot as plt
plt.plot(cycles, ads_cap, cycles, des_cap)
plt.legend(['Ads. capacity', 'Des. capacity'])
plt.xlabel('# Cycles')
plt.ylabel('Capacity (mol/kg)')
plt.savefig('images/si-image.png')
#+END_SRC

#+RESULTS:

[[./images/si-image.png]]

That is pretty easy. There are also Excel sheets embedded in that supporting information file, along with scripts that illustrate how to use the data in the Excel sheets for further analysis. How about that for data sharing!

* DONE Invisible text in emacs
  CLOSED: [2014-02-06 Thu 09:03]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/02/06 09:02:44
  :updated:  2014/02/06 09:03:02
  :END:

Emacs supports [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Invisible-Text.html][invisible text]]. In other words, you can use code to set properties on text in a buffer that make it visible, or invisible. You can use code to change the invisibility properties of text.

I have been exploring ways to conditionally navigate in org documents using links. These links may validate that some property has been set in a heading, for example. An alternative approach is to make regions visible, depending on some criteria. That is what we do today. You will probably want to see this  [[./images/invisible-text.swf][video]], since what happens in this post is dynamic, and you will not see visible and invisible text.

What I have below here are a set of headings with properties that indicate what "level" they are at: beginner, medium and advanced.
First, we mark each org subtree  with an overlay that has an 'invisible property that contains the "level". Then, we add the "level" to the list of symbols that marks invisible sections.  If you run this block, the headings all disappear.

#+BEGIN_SRC emacs-lisp :results value silent
(org-map-entries (lambda ()
		   (let ((level (org-entry-get (point) "level"))
			  (symbol-level))
		     (when level
		       (setq symbol-level (intern level))
		       (org-mark-subtree)
		       (overlay-put (make-overlay (point) (mark))
				    'invisible
				    symbol-level)
                       ;; make regions with symbol-level invisible
		       (add-to-invisibility-spec `(,symbol-level))))))
#+END_SRC

Now, we can selectively make them appear with these links.

[[elisp:(remove-from-invisibility-spec '(beginner))][show me beginner]]

[[elisp:(remove-from-invisibility-spec '(medium))][show me medium]]

[[elisp:(remove-from-invisibility-spec '(advanced))][show me advanced]]

I imagine this could be useful to show selective content based on user choices. I am not sure it is better than links to external files. I imagine you would have to open this org file by some elisp command that would run the block at the top to make everything invisible, and then show it to the user. You could definitely build in more complex code to determine if a user was allowed to open a section.

#+BEGIN_SRC emacs-lisp
(defun level2-p ()
  "return if user is ready for level 2 based on value of property named correct"
  (interactive)
  (save-excursion
    (org-open-link-from-string "[[#beginner]]")
    (let ((val (org-entry-get (point) "correct")))
      (if (and val (string= val "true"))
	  t
	nil))))
#+END_SRC

#+RESULTS:
: level2-p

Now, we can build this link: [[elisp:(when (level2-p) (remove-from-invisibility-spec '(medium)))]]

This will show the medium level, provided we have already opened the beginner level and set the property value correctly.

** subsection 1
   :PROPERTIES:
   :level:    beginner
   :CUSTOM_ID: beginner
   :correct:  true
   :END:
some text in 1

** subsection 2
   :PROPERTIES:
   :level:    medium
   :END:
more text in 2

** subsection 3
   :PROPERTIES:
   :level:    advanced
   :END:
last section 3

* DONE Add time to a deadline
  CLOSED: [2014-02-05 Wed 09:41]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/02/05 09:41:04
  :updated:  2014/02/05 09:41:04
  :END:
I have an application where an org-file is a template with some due dates in it. I would like to update the deadlines to make them all relative to today. In this post I explore a way to do that. The strategy is to find deadlines, parse the time out of the time stamp, add an appropriate amount of time, and replace the time stamp. For this exercise, we use this org-file, which has one DEADLINE of "2014-01-13 Mon", and I want to add 60 days to the time stamp.

Amazingly, emacs can parse time strings into a format that it can understand. I do not claim to understand what this function returns, but it is some representation of time that emacs understands.

#+BEGIN_SRC emacs-lisp :results value raw
(date-to-time "<2014-01-13 Mon>")
#+END_SRC

#+RESULTS:
(21203 11392)

Now, we can add time to that format. Let us say I want to add 60 days. In emacs, we add seconds to a time, so 60 days is 60 days * 24 hours * 60 minutes * 60 seconds, or in elisp: (* 60 24 60 60).
#+BEGIN_SRC emacs-lisp :results value raw
(let ((sixty-days (seconds-to-time (* 60 24 60 60))))
  (time-add (date-to-time "<2014-01-13 Mon>") sixty-days))
#+END_SRC

#+RESULTS:
(21282 18048)

That does not make too much sense, so we can use another function to format it like a new time stamp.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((sixty-days (seconds-to-time (* 60 24 60 60))))
  (format-time-string "<%Y-%m-%d %a>"
		      (time-add (date-to-time "<2014-01-13 Mon>") sixty-days)))
#+END_SRC

#+RESULTS:
<2014-03-13 Thu>

Beautiful. We just got a timestamp that is 60 days later than the original timestamp. Now we just search forward to find deadline, get the time stamp, add the time to it, and replace the line. I specifically want to change deadlines, so we will develop a regular expression for that. Here is a block that searches forward for a DEADLINE, parses it, adds 60 days to it, and replaces the deadline. The regular expression is limited to timestamps that look like <yyyy-mm-dd day>, i.e. no warnings or repeaters are found. In this post, there is subheading that looks like this initially:

#+BEGIN_EXAMPLE
** s1
    DEADLINE: <2014-01-02 Thu>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(progn
  (save-excursion
    ;; go to timestamp
    (re-search-forward "DEADLINE:\\s-*<\\(\\([0-9]\\{4\\}\\)-\\([0-9]\\{2\\}\\)-\\([0-9]\\{2\\}\\)\\s-\\(Mon\\|Tue\\|Wed\\|Thu\\|Fri\\|Sat\\|Sun\\)\\)>")
    (let ((ts (match-string 1)) ;; this is the timestamp
          (sixty-days (seconds-to-time (* 60 24 60 60)))
          (new-ts))
      (setq new-ts (format-time-string "    DEADLINE: <%Y-%m-%d %a>"
                                       (time-add (date-to-time ts) sixty-days)))
      ;; now we kill the old time stamp, and insert the new one
      (beginning-of-line)
      (kill-line)
      (insert new-ts))))
#+END_SRC

#+RESULTS:

After we run the code above, the deadline looks like this:
#+BEGIN_EXAMPLE
** s1
    DEADLINE: <2014-03-02 Sun>
#+END_EXAMPLE

We succeeded in moving it by 60 days. An interesting application of this would be to make all the deadlines in an org-file relative to some baseline date. For example, you have a series of deadlines for assignments throughout a semester, and it would be tedious to update these by hand. Suppose you could just establish a new beginning date, and make all deadlines relative to that date with a command. That seems useful.


** s1
    DEADLINE: <2014-03-02 Sun>



* DONE Separating code blocks from results in org-mode
  CLOSED: [2014-02-08 Sat 09:03]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/02/08 08:54:57
  :updated:  2014/02/08 09:15:39
  :END:
I often put my code blocks right where I need them in my org documents. It usually has a section explaining what I want to do, then the code block that implements the idea, following by the output. Sometimes the code blocks are long, however, and it might be desirable for that code to be in an appendix. [fn:4]

Org-mode enables this with #+CALL. For example, I have a function named =circle-area= in the appendix of this post that calculates the area of a circle given its radius. The function is "named" by a line like this:

#+BEGIN_EXAMPLE
#+name: function-name
#+END_EXAMPLE

I can use the function like this:

#+BEGIN_EXAMPLE
#+CALL: circle-area(1)
#+END_EXAMPLE

#+CALL: circle-area(1)

#+RESULTS:
: 3.14159265359

That is pretty nice. You can separate the code out from the main document. You still have to put the #+CALL: line in though. It may be appropriate to put a call inline with your text. If you add the following sentence, and put your cursor on the call_circle-area and press C-c C-c, the output is put in verbatim markers right after it.

#+BEGIN_EXAMPLE
The area of a circle with unit radius is call_circle-area(1).
#+END_EXAMPLE

The area of a circle with unit radius is call_circle-area(1) =3.14159265359=.

Here is another interesting way to do it. We can specify a named results block. Let us consider another function named =hello-block= that prints output. We specify a named results block like this:

#+BEGIN_EXAMPLE
#+RESULTS: function-name
#+END_EXAMPLE

Now, whenever you execute that block, the results will get put where this line is like this.

#+RESULTS: hello-block
: hello John

These could be useful approaches to making the "top" of your document cleaner, with less code in it. The code of course is still in the document, but at the end, in an appendix for example. This kind of separation might make it a little harder to find the code, and to reevaluate it,[fn:5] but it might improve the readability for others.




** Appendix of code

*** Area of a circle
#+name: circle-area
#+header: :var r=0
#+begin_src python :results value
import numpy as np
return np.pi * r**2
#+end_src


*** Hello function

#+name: hello-block
#+header: :var name="John"
#+BEGIN_SRC python  :results output
print 'hello ' + name
#+END_SRC


* DONE yasnippets for jasp, ase and python
  CLOSED: [2014-02-17 Mon 09:03]
  :PROPERTIES:
  :categories: jasp,ase,emacs
  :date:     2014/02/17 09:03:50
  :updated:  2014/02/17 09:03:50
  :END:

In using [[http://github.com/jkitchin/jasp for calculations, I find there are lots of small python phrases I use over and over. Today I will examine using [[http://capitaomorte.github.io/yasnippet/index.html][yasnippet]] to save time and keystrokes. yasnippet is a template expansion module, where you type a small set of characters, press =Tab=, and the
characters "expand" to the full text. It is pretty sophisticated, and allows you to define "tab-stops" which you interactively fill in, and tab between like filling in a form.

All the snippets are defined in the [[*Appendix][Appendix]].

** Tangle the snippets, and add them to yasnippet

Each snippet definition belongs in a file in a directory. The main directory is called "snippets". Since I anticipate using these snippets in org-mode, each snippet is defined in a directory within snippets called "org-mode". First, we make the directory here. I also want to use the snippets in python mode, so we also create a python-mode directory here. We do not have to duplicate the snippets. We can create a file called [[http://capitaomorte.github.io/yasnippet/snippet-organization.html][.yas-parents]], with one line in it containing "org-mode".

#+BEGIN_SRC sh
mkdir -p snippets/org-mode
mkdir -p snippets/python-mode
echo "org-mode" > snippets/python-mode/.yas-parents
#+END_SRC

#+RESULTS:

Each snippet is defined in a src block with  a =:tangle= header. So, we can extract them all in one command here.

#+BEGIN_SRC emacs-lisp
(org-babel-tangle)
#+END_SRC

#+RESULTS:
| snippets/org-mode/iase | snippets/org-mode/imp | snippets/org-mode/inp | snippets/org-mode/ij | snippets/org-mode/pl | snippets/org-mode/pyl | snippets/org-mode/pxl | snippets/org-mode/pp | snippets/org-mode/npa | snippets/org-mode/awt | snippets/org-mode/avw | snippets/org-mode/agf | snippets/org-mode/ape | snippets/org-mode/atms | snippets/org-mode/atm | snippets/org-mode/cga | snippets/org-mode/cc | snippets/org-mode/wjn | snippets/org-mode/wjl |

We also need to add our new directory to yasnippets. This is done by adding the directory to the =yas-snippet-dirs= variable. You could add this to your init.el file to permanently add these snippets.

#+BEGIN_SRC emacs-lisp
(add-to-list 'yas-snippet-dirs "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/snippets")
#+END_SRC
#+RESULTS:
| c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/snippets | ~/.emacs.d/snippets | c:/users/jkitchin/Dropbox/kitchingroup/jmax/elpa/yasnippet-20140106.1009/snippets |

Finally, we reload all the snippet definitions, so our new definitions are ready to use.
#+BEGIN_SRC emacs-lisp
(yas-reload-all)
#+END_SRC

#+RESULTS:
: [yas] Reloaded everything (snippets will load just-in-time)... (some errors, check *Messages*).

Alternatively, you might just load this directory.
#+BEGIN_SRC emacs-lisp
(yas-load-directory "./snippets")
#+END_SRC

#+RESULTS:

** Using the snippets
Each of these snippets is for a python phrase, but I usually write my python blocks in org-mode. You would use these by typing the shortcut name, and then pressing tab. Below I show what each shortcut expands to.

wjl \to =with jasp('') as calc:=

wjn \to =with jasp('',) as calc:=
    =calc.calculate(atoms)=

cc  \to =calc.calculate(atoms)=

cga \to =atoms = calc.get_atoms()=

atm \to =Atom('', )=

atms \to =atoms = Atoms([], cell=)=

ape \to =atoms.get_potential_energy()=

agf \to =atoms.get_forces()=

avw \to =from ase.visualize import view=
=view(atoms)=

awt \to =from ase.io import write=
=write('.png', atoms, show_unit_cell=2)=

npa \to =np.array()=

pp \to =plt.plot(, )=

pxl \to =plt.xlabel()=

pyl \to =plt.ylabel()=

pl \to =plt.legend()=

ij \to =from jasp import *=

inp \to =import numpy as np=

imp \to =import matplotlib.pyplot as plt=

iase \to =from ase import Atom, Atoms=

What other snippets would be handy?

** Appendix
*** jasp snippets
#+BEGIN_SRC snippet :tangle snippets/org-mode/wjl
# -*- mode: snippet -*-
# --
with jasp('$1') as calc:
    $0
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/wjn
# -*- mode: snippet -*-
# --
with jasp('$1',$0) as calc:
    calc.calculate(atoms)
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/cc
# -*- mode: snippet -*-
# --
calc.calculate(atoms)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/cga
# -*- mode: snippet -*-
# --
atoms = calc.get_atoms()
#+END_SRC

*** ase snippets

Template for an ase.Atom

#+BEGIN_SRC snippet :tangle snippets/org-mode/atm
# -*- mode: snippet -*-
# --
Atom('$1', $2)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/atms
# -*- mode: snippet -*-
# --
atoms = Atoms([$1], cell=$2)
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/ape
# -*- mode: snippet -*-
# --
atoms.get_potential_energy()
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/agf
# -*- mode: snippet -*-
# --
atoms.get_forces()
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/avw
# -*- mode: snippet -*-
# --
from ase.visualize import view
view(${1:atoms})
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/awt
# -*- mode: snippet -*-
# --
from ase.io import write
write('$1.png', ${2:atoms}, show_unit_cell=${3:2})
#+END_SRC

*** python snippets
#+BEGIN_SRC snippet :tangle snippets/org-mode/inp
# -*- mode: snippet -*-
# --
import numpy as np
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/imp
# -*- mode: snippet -*-
# --
import matplotlib.pyplot as plt
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/iase
# -*- mode: snippet -*-
# --
from ase import Atom, Atoms
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/npa
# -*- mode: snippet -*-
# --
np.array($0)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pp
# -*- mode: snippet -*-
# --
plt.plot($1, $2)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pxl
# -*- mode: snippet -*-
# --
plt.xlabel($1)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pyl
# -*- mode: snippet -*-
# --
plt.ylabel($1)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pl
# -*- mode: snippet -*-
# --
plt.legend($1)
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/ij
# -*- mode: snippet -*-
# --
from jasp import *
#+END_SRC
* DONE A dynamic snippet for a task due 7 days from now
  CLOSED: [2014-02-16 Sun 13:50]
  :PROPERTIES:
  :categories: emacs,org-mode
  :date:     2014/02/16 13:50:27
  :updated:  2014/02/16 15:52:44
  :END:

I have been playing with yasnippets. A pretty cool feature is that you can run elisp code in the template to generate text. Below, I define a snippet that will create a todo item due 7 days from the time you define it. This is an unconventional way to define a snippet, but I did not want to save it to a file just to try it out. So, I put it in a temporary buffer, and load it from there. When you run this block, it will note it is a new snippet, and ask if you want to save it. You can say no.

We will use the code we developed [[http://kitchingroup.cheme.cmu.edu/blog/2014/02/05/Add-time-to-a-deadline/][here]] to create a timestamp from the
current time plus seven days.

#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# name : todo-followup
# --

*************** TODO $1
${2:		 DEADLINE: `(let ((seven-days (seconds-to-time (* 7 24 60 60))))
  (format-time-string \"<%Y-%m-%d %a>\" (time-add (current-time) seven-days)))`}$0
*************** END
")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+RESULTS:


Now, you will have a new entry in the YASnippet menu that is called todo-followup. If you put the cursor on a blank line, and select that entry you get this below (after you fill in the text for the headline, of course!):

#+BEGIN_EXAMPLE
*************** TODO see how many times this was viewed
		DEADLINE: <2014-02-23 Sun>
*************** END
#+END_EXAMPLE



That is pretty nice, as it saves a lot of keystrokes for that
particular kind of task. Let us up the ante, and see if we can make it
interactive so you can enter the number of days from now the task is
due.

#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# name : todo-followup
# --

*************** TODO $1
${2:		 DEADLINE: `(let ((ndays (seconds-to-time (* (string-to-int (read-from-minibuffer \"Days until due: \")) 24 60 60))))
  (format-time-string \"<%Y-%m-%d %a>\" (time-add (current-time) ndays)))`}$0
*************** END
")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+RESULTS:

#+BEGIN_EXAMPLE
*************** TODO sweet!
		DEADLINE: <2014-02-26 Wed>
*************** END
#+END_EXAMPLE
Well, that made it just a bit sweeter! I was prompted for the "Days
until due:", entered 10 days, and a date 10 days from now was
automatically entered!


* DONE Interesting online python sites
  CLOSED: [2014-01-27 Mon 13:51]
  :PROPERTIES:
  :categories: python
  :date:     2013/02/28 18:58:21
  :updated:  2013/02/28 19:01:33
  :permalink: http://jkitchin.github.com/blog/2013-02-28-interesting-online-python-sites/index.html
  :END:
I have come across some very interesting online, /interactive/ python sites recently.

- http://interactivepython.org has some interactive books with embedded python interpreters in the exercises.

- sympy actually has an [[http://live.sympy.org/][online shell]]! The [[http://docs.sympy.org/0.7.2/index.html][documentation]] has live examples in a shell you can use that is integrated with Sphinx.

Here are a few others I came across:
- https://www.pythonanywhere.com/try-ipython/ Ipython in your browser!
- http://www.trypython.org/#
- http://www.pythontutor.com/
- http://py-ide-online.appspot.com/

* DONE An index function for strings in emacs-lisp
  CLOSED: [2013-12-22 Sun 12:05]
  :PROPERTIES:
  :categories: emacs-lisp
  :date:     2013/03/05 19:28:30
  :updated:  2013/03/05 19:28:31
  :END:

I could not find an index function for strings in emacs-lisp. The =position= function seems to work for numbers, but not strings. Here is a version that works on strings.
#+BEGIN_SRC emacs-lisp :results value verbatim
(defun index (item list)
  "return index of item in list or nil"
  (let ((counter 0)
        (found nil))
    (dolist (listelement list counter)
      (if (string= item listelement)
        (progn
          (setq found t)
          (return counter)) ; exit the loop
        ;; else increment counter
        (incf counter)))
    ;; if we found it return counter otherwise return nil
    (if found counter nil)))
#+END_SRC

#+RESULTS:
: index

Here are some example uses:

#+BEGIN_SRC emacs-lisp :results value
(index "test" '("a" "test" "y"))
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC emacs-lisp :results value
(index "z" '("a" "b" "z"))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC emacs-lisp :results value verbatim
(index "testy" '("a" "test" "y"))
#+END_SRC

#+RESULTS:
: nil

This raises an error because we use string=.

#+BEGIN_SRC emacs-lisp :results value verbatim
(index 1 '("a" "test" "y" 1))
#+END_SRC
* DONE Integrating the Fermi distribution to compute entropy
  CLOSED: [2013-12-22 Sun 12:04]
  :PROPERTIES:
  :categories: dft, integration, gotcha
  :date:     2013/03/06 09:39:42
  :updated:  2013/03/06 09:47:19
  :END:

The Fermi distribution is defined by $f(\epsilon) = \frac{1}{e^{(\epsilon - \mu)/(k T)} + 1}$. This function describes the occupation of energy levels at temperatures above absolute zero. We use this function to compute electronic entropy in a metal, which contains an integral of $\int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon$, where $n(\epsilon)$ is the electronic density of states. Here we plot the Fermi distribution function. It shows that well below the Fermi level the states are fully occupied, and well above the Fermi level, they are unoccupied. Near the Fermi level, the states go from occupied to unoccupied smoothly.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def f(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.linspace(-10, 10, 200)
plt.plot(espan, f(espan))
plt.ylim([-0.1, 1.1])
plt.savefig('images/fermi-entropy-integrand-1.png')
#+END_SRC

#+RESULTS:

[[./images/fermi-entropy-integrand-1.png]]

Let us consider a simple density of states function, just a parabola. This could represent a s-band for example. We will use this function to explore the integral.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def f(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

def dos(e):
    d = (np.ones(e.shape) - 0.03 * e**2)
    return d * (d > 0)
espan = np.linspace(-10, 10)

plt.plot(espan, dos(espan), label='Total dos')
plt.plot(espan, f(espan) * dos(espan), label='Occupied states')
plt.legend(loc='best')
plt.savefig('images/fermi-entropy-integrand-2.png')
#+END_SRC

#+RESULTS:

[[./images/fermi-entropy-integrand-2.png]]
Now, we consider the integral to compute the electronic entropy. The entropy is proportional to this integral.

\( \int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon \)

It looks straightforward to compute, but it turns out there is a wrinkle. Evaluating the integrand leads to =nan= elements because the ln(0) is -\infty.

#+BEGIN_SRC python
import numpy as np
mu = 0
k = 8.6e-5
T = 100

def fermi(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.array([-20, -10, -5, 0.0, 5, 10])
f = fermi(espan)

print f * np.log(f)
print (1 - f) * np.log(1 - f)
#+END_SRC

#+RESULTS:
: [  0.00000000e+000   0.00000000e+000   0.00000000e+000  -3.46573590e-001
:   -1.85216532e-250               nan]
: [        nan         nan         nan -0.34657359  0.          0.        ]

In this case, these =nan= elements should be equal to zero (x ln(x) goes to zero as x goes to zero). So, we can just ignore those elements in the integral. Here is how to do that.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def fermi(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

def dos(e):
    d = (np.ones(e.shape) - 0.03 * e**2)
    return d * (d > 0)

espan = np.linspace(-20, 10)
f = fermi(espan)
n = dos(espan)

g = n * (f * np.log(f) + (1 - f) * np.log(1 - f))

print np.trapz(espan, g) # nan because of the nan in the g vector
print g

plt.plot(espan, g)
plt.savefig('images/fermi-entropy-integrand-3.png')

# find the elements that are not nan
ind = np.logical_not(np.isnan(g))

# evaluate the integrand for only those points
print np.trapz(espan[ind], g[ind])
#+END_SRC

#+RESULTS:
#+begin_example
nan
[             nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
  -9.75109643e-14  -1.05987106e-10  -1.04640574e-07  -8.76265644e-05
  -4.92684641e-02  -2.91047740e-01  -7.75652579e-04  -1.00962241e-06
  -1.06972936e-09  -1.00527877e-12  -8.36436686e-16  -6.48930917e-19
  -4.37946336e-22  -2.23285389e-25  -1.88578082e-29   0.00000000e+00
   0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00
   0.00000000e+00   0.00000000e+00]
0.208886080897
#+end_example

[[./images/fermi-entropy-integrand-3.png]]

The integrand is pretty well behaved in the figure above. You do not see the full range of the x-axis, because the integrand evaluates to =nan= for very negative numbers. This causes the =trapz= function to return =nan= also. We can solve the problem by only integrating the parts that are not =nan=. We have to use numpy.logical_not to get an element-wise array of which elements are not =nan=. In this example, the integrand is not well sampled, so the area under that curve may not be very accurate.

* DONE Uncertainty in implicit functions
  CLOSED: [2013-12-22 Sun 12:04]
  :PROPERTIES:
  :categories: statistics
  :date:     2013/03/08 17:04:02
  :updated:  2013/03/14 15:34:19
  :END:
Suppose we have an equation $y = e^{a y}$ that we want to solve, where $a$ is a constant with some uncertainty. What is the uncertainty in the solution $y$?

Finding a solution is not difficult. The uncertainty in the solution, however, is not easy, since we do not have an explicit function to propagate errors through. Let us examine the solution first.
#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve

a = 0.20

def f(y):
    return y - np.exp(a * y)

sol, = fsolve(f, 1)
print sol
#+END_SRC

#+RESULTS:
: 1.2958555091

A way to estimate the uncertainty is by Monte Carlo simulation. We solve the equation many times, using values sampled from the uncertainty distribution. Here we assume that the $a$ parameter is normally distributed  with an average of 0.2 and a std deviation of 0.02. We solve the equation 10000 times for different values of $a$ sampled according to the normal distribution. That gives us a distribution of solutions that we can do statistical analysis of to get the average and std deviation.

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
N = 10000

A = np.random.normal(0.2, 0.02, size=N)

sol = np.zeros(A.shape)

for i, a in enumerate(A):
    s, = fsolve(lambda y:y - np.exp(a * y), 1)
    sol[i] = s

ybar = np.mean(sol)
s_y = np.std(sol)

print ybar, s_y, s_y / ybar

import matplotlib.pyplot as plt
count, bins, ignored = plt.hist(sol)
plt.savefig('images/implicit-uncertainty.png')
#+END_SRC

#+RESULTS:
: 1.29887470397 0.0465110111613 0.0358086973433

We get approximately the same answer, and you can see here the distribution of solution values is not quite normal. We compute the standard deviation anyway, and find the standard deviation is about 3.6%. It would be nice to have some analytical method to estimate this uncertainty. So far I have not figured that out.

This method could have relevance in estimating the uncertainty in the friction factor for turbulent flow ($Re > 2100$). In that case we have the implicit equation $\frac{1}{\sqrt{f_F}}=4.0 \log(Re \sqrt{f_F})-0.4$. Uncertainties in the Re number would lead to uncertainties in the friction factor. Whether those uncertainties are larger than the uncertainties from the original correlation would require some investigation.

* DONE Capturing stderr and exceptions from python in org-mode
  CLOSED: [2013-12-22 Sun 12:03]
  :PROPERTIES:
  :categories: org-mode,python
  :date:     2013/09/27 19:37:05
  :updated:  2013/09/27 19:47:53
  :END:
I have used org-mode extensively to create examples of using python using the code blocks. For example to illustrate the difference between integer and float division you can do this:

#+BEGIN_SRC python
print 1 / 3
print 1.0 / 3.0
#+END_SRC

#+RESULTS:
: 0
: 0.333333333333

There are some limitations to showing output though. For example, the code blocks do not capture anything from stderr.

#+BEGIN_SRC python
import sys

print >>sys.stderr, 'message to stderr'
#+END_SRC

#+RESULTS:

And exceptions result in no output whatsoever. That is not helpful if you are trying to teach about exceptions!

I discovered a way around this. The key is using a python sandbox that redirects stdout, stderr and that captures anything sent to those channels. You can also capture any exceptions, and redirect them to a variable. Finally, you can construct the output anyway you see fit.

Below is the code that runs python code in a sandbox, with redirected outputs. I defined a function that temporarily redirects the output to stdout and stderr, so they can be captured. I execute the code wrapped in a try/except block to capture any exceptions that occur. Finally, I construct a string formatted in a way that lets you know what was on stdout, stderr, and what was an exception.

#+BEGIN_SRC python :tangle sandbox.py
#!/usr/bin/env python
from cStringIO import StringIO
import os, sys

def Sandbox(code):
    '''Given code as a string, execute it in a sandboxed python environment

    return the output, stderr, and any exception code
    '''
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    redirected_output = sys.stdout = StringIO()
    redirected_error = sys.stderr = StringIO()

    ns_globals = {}
    ns_locals = {}
    out, err, exc = None, None, None

    try:
        exec(code, ns_globals, ns_locals)
    except:
        import traceback
        exc = traceback.format_exc()

    out = redirected_output.getvalue()
    err = redirected_error.getvalue()

    # reset outputs to the original values
    sys.stdout = old_stdout
    sys.stderr = old_stderr

    return out, err, exc


if __name__ == '__main__':
    content = sys.stdin.read()
    out, err, exc =  Sandbox(content)

    s = '''---stdout-----------------------------------------------------------
{0}
'''.format(out)

    if err:
        s += '''---stderr-----------------------------------------------------------
{0}
'''.format(err)

    if exc:
        s += '''---Exception--------------------------------------------------------
{0}
'''.format(exc)

    print s

#+END_SRC

To use this, we have to put this file (sandbox.py) in our PYTHONPATH. Then, we tell org-babel to run python using our new sandbox.py module. org-babel pipes the code in a src block to stdin of the python command, which will be intercepted by our sandbox module. If you put this in your init.el, or other customization location, then subsequent uses of python in org-mode will use your sandbox module. I usually only run this for a session as needed.

#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "python -m sandbox")
#+END_SRC

Now, when we use python, we can capture output to stderr!

#+BEGIN_SRC python
import sys

print >>sys.stderr, 'message to stderr'
#+END_SRC

#+RESULTS:
: ---stdout-----------------------------------------------------------
:
: ---stderr-----------------------------------------------------------
: message to stderr
:
:
And, we can capture exceptions!

#+BEGIN_SRC python
print 1 / 0
#+END_SRC

#+RESULTS:
#+begin_example
---stdout-----------------------------------------------------------

---Exception--------------------------------------------------------
Traceback (most recent call last):
  File "c:\Users\jkitchin\Dropbox\blogofile-jkitchin.github.com\_blog\sandbox.py", line 20, in Sandbox
    exec(code, ns_globals, ns_locals)
  File "<string>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero


#+end_example

There is a little obfuscation in the exception, since it technically occurs in the Sandbox, but this is better than getting no output whatsoever! I have not tested the sandbox.py code extensively, so I don't know if there will be things that do not work as expected. If you find any, please let me know!
* DONE Notice anything different
  CLOSED: [2013-12-22 Sun 12:03]
  :PROPERTIES:
  :date:     2013/09/29 11:07:00
  :updated:  2013/09/29 11:41:28
  :END:
Based on the last few posts on [[http://jkitchin.github.io/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][making links to external files work in the blog]], and [[http://jkitchin.github.io/blog/2013/09/28/Customizing-export-of-code-blocks-in-HTML/][customizing code block export in HTML]], I have rewritten [[https://github.com/jkitchin/jmax/blob/prelude/blogofile.el][blogofile.el]] to more cleanly support the use of images and data files in my blog posts. Now, I should be able to include a data file (like this [[../../pycse/data/antoine_data.dat][one]]) in a post and you should be able to click on the link to open it after I publish the post in the usual way by pressing F10. That should process the post, construct URLs for all the links, including images, copy the relevant files to the blog directory, and generate the HTML file for blogofile to build. This is a little more robust than it used to be, as all files are stored in a directory named based on the post title, so there is less concern of using duplicate filenames for images and datafiles.

Here is a gratuitous image, just to see if it works ;)

#+CAPTION: test image
[[./images/heat-transfer-roots-1.png]]

Hopefully, there is nothing different on the outside! URLs to images are now in a different place, but that should not be apparent unless you read source code. The real difference is that now there are working links to data files! And it is easier for me to write my posts including them, with simple publishing.
* DONE Enabling right-clicks in org-mode links
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/10/21 19:58:52
  :updated:  2013/10/21 20:45:37
  :END:
Out of the box you can click on org-mode links to make the do things. On my machine, all clicks are equal, left mouse, middle mouse, and right mouse all act as a "click". I was curious about whether I could get different behavior on a link with a left or right mouse click. It is easy enough to [[http://orgmode.org/manual/Adding-hyperlink-types.html][define a new link type]]. You define a function that is run when you click on the link.

To figure out what to do here, I looked into the events handling in emacs. According to this [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Click-Events.html][page]], there are click events. So, after we click on a link, there should be a click event which was the last input event. We can get that, figure out which button was pressed, and run code accordingly. We will make the code add some lines to the buffer after the link about what happened.

Here is my link definition.

#+BEGIN_SRC emacs-lisp
(setq counter 1)
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (link-string)
   (let ((button (car last-input-event)))
     (cond ((eq button 'mouse-1)
            (end-of-line)
            (insert (format "\nclick %s. mouse-1 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1)))
           ((eq button 'mouse-2)
            (end-of-line)
            (insert (format "\nclick %s. mouse-2 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1)))
           ((eq button 'mouse-3)
            (end-of-line)
            (insert (format "\nclick %s. mouse-3 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "<pre>%s:%s</pre>" keyword desc)))))
#+END_SRC


Here we make a link. When you click on it, it adds lines right after the link telling you what was clicked on. I left-clicked, middle-clicked and right-clicked. The right-clicked result is the first line.

test:which-button
click 3. mouse-3 pressed (mouse-3 (#<window 46 on blog.org> 56959 (57 . 456) -320964819 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))

click 2. mouse-2 pressed (mouse-2 (#<window 46 on blog.org> 56959 (57 . 456) -320965724 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))

click 1. mouse-2 pressed (mouse-2 (#<window 46 on blog.org> 56959 (57 . 456) -320966660 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))


Curiously, this only shows that mouse-2 (for left or middle mouse) or mouse-3 (for right click) was pressed, never mouse-1. I am not sure what causes that. If I try to capture an event it does show mouse-1 is active.

#+BEGIN_SRC emacs-lisp
(princ (read-event))
#+END_SRC

#+RESULTS:
: (down-mouse-1 (#<window 34 on blog.org> 56437 (253 . 308) -322917920 nil 56437 (31 . 19) nil (93 . 4) (8 . 16)))

Anyway, it looks conceivable that you could have different link actions occur for different mouse clicks. I could see using this in a citation link, where a left click might open the citation in my bibtex file, and right clicking would open a pdf of the citation if it existed.

I have not figured out how flexible this might be, for example could you use modifier keys with mouse clicks? This code suggests that it is possible in emacs, but so far none of these make it into the last-input-event in the org-link clicks.

#+BEGIN_SRC emacs-lisp
(princ (read-event))
#+END_SRC

#+RESULTS:
: (S-down-mouse-1 (#<window 34 on blog.org> 56725 (1 . 299) -322897656 nil 56725 (0 . 18) nil (1 . 11) (8 . 16)))

It might be difficult remembering all the modifiers and clicks, but it would be cool if it was possible!
* DONE Hatched symbols in matplotlib
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: plotting
  :date:     2013/10/26 14:35:19
  :updated:  2013/10/26 14:35:19
  :END:
I learned something new about matplotlib today: How to make hatched (patterned) symbols in a plot. Well, sort of. The scatter plot in matplotlib has a hatch keyword argument that specifies a pattern on the marker. Below, is an example that runs through a handful of hatch patterns, on randomly selected symbols.

Curiously, hatch is not a kwarg of the scatter function, but of [[http://matplotlib.org/api/collections_api.html#matplotlib.collections.Collection.set_hatch][collections]]. Anyway, let us see how to get the hatched symbols.

#+BEGIN_SRC python
import random
import numpy as np
import matplotlib.pyplot as plt

patterns = ('-', '+', 'x', '\\', '*', 'o', 'O', '.', '/')
markers = 'os<^>p*'
for pattern in patterns:
    plt.scatter(np.random.uniform(size=(3,1)), np.random.uniform(size=(3,1)), s=1000,
                marker=random.choice(markers),
                facecolor='white',
                hatch=3*pattern, label=pattern)

plt.legend(scatterpoints=1, loc='best')
plt.savefig('images/hatched-symbols.png')
#+END_SRC

#+RESULTS:

[[./images/hatched-symbols.png]]

There are some other interesting things you can do with [[http://matplotlib.org/examples/pylab_examples/filledmarker_demo.html][filled markers]], [[http://matplotlib.org/examples/pylab_examples/contourf_hatching.html][hatched contours]] and with [[http://matplotlib.org/examples/pylab_examples/hatch_demo.html][hatched bar graphs]]. Note this hatching is specific to plt.scatter. It does not work with plt.plot.

* DONE Automating Adobe Acrobat Pro with python
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: automation,pdf
  :date:     2013/11/23 10:34:47
  :updated:  2013/11/23 10:34:47
  :END:

I have a need to automate Adobe Pro for a couple of applications:

1. I could use Adobe Pro to automatically add rubric pages to assignments before grading them. The rubric has embedded javascript that stores the grade inside the pdf file.
2. I could use Adobe Pro to extract information, e.g. grades, stored in a set of PDF files for analysis.

I came across this [[http://win32com.goermezer.de/content/view/232/288/][script]] to automate Adobe Pro using python and OLE automation.  Two other useful references are:

1. http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/iac_api_reference.pdf
2. http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/iac_developer_guide.pdf

In this post, we look at some simple code to get data out of a pdf.  We start with just opening a PDF file.

#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('writing-exams-in-orgmode.pdf')

app = Dispatch("AcroExch.AVDoc")

app.Open(src, src)

app.Close(-1)  # do not save on close
#+END_SRC

#+RESULTS:

Opening and closing a file is not that useful.  Here, we can get some information out of the file. The pdf we looked at above has a custom property =PTEX.Fullbanner= from pdflatex. We can extract it like this.

#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('writing-exams-in-orgmode.pdf')

app = Dispatch("AcroExch.AVDoc")

app.Open(src, src)
pddoc = app.GetPDDoc()
print pddoc.GetInfo('PTEX.Fullbanner')

print pddoc.GetNumPages()
app.Close(-1)  # do not save on close
#+END_SRC

#+RESULTS:
: This is MiKTeX-pdfTeX 2.9.4535 (1.40.13)
: 5


Finally, let us try inserting pages. I have a [[../../CMU/classes/06-625/rubric/rubric.pdf][rubric file ]] that I want to insert at the end of the [[writing-exams-in-orgmode.pdf][pdf]] above. We will open both documents, insert the rubric, and save the result as a new file.


#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('../../CMU/classes/06-625/rubric/rubric.pdf')
src2 = os.path.abspath('writing-exams-in-orgmode.pdf')

# It seems I need two of these
avdoc1 = Dispatch("AcroExch.AVDoc")
avdoc2 = Dispatch("AcroExch.AVDoc")

# this is the rubric
avdoc1.Open(src, src)
pddoc1 = avdoc1.GetPDDoc()
N1 = pddoc1.GetNumPages()

# this is the other doc
avdoc2.Open(src2, src2)
pddoc2 = avdoc2.GetPDDoc()
N2 = pddoc2.GetNumPages()

# Insert rubric after last page of the other doc. pages start at 0
pddoc2.InsertPages(N2 - 1, pddoc1, 0, N1, 0)

# save as a new file. 1 means full save at absolute path provided.
pddoc2.Save(1, os.path.abspath('./woohoo.pdf'))

# close files.
avdoc1.Close(-1)
avdoc2.Close(-1)
#+END_SRC

#+RESULTS:

Here is our result: [[./woohoo.pdf]]. I went ahead and gave myself an A ;).

** Summary
It looks like I can replace the dependence of my box-course code on all the python-based pdf libraries (which are not fully functional, and do not work on all pdfs), and on pdftk, with this automation approach of Adobe Pro. It is unfortunate that it is not a free program, but i would expect it to work on all PDF files, and it provides features like combining PDFs with their javascript, that /no/ other PDF package has. I have tried other PDF programs to combine the rubric and assignment page, but they all lose the javascript. With this method, I could keep a set of enriched rubric files for different types of assignments, and add them to assignments as part of the assessment process.
* DONE Selectively exporting headlines in org-mode
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/12/08 16:35:35
  :updated:  2013/12/08 16:35:35
  :END:
I have on several occasions needed to selectively export only portions of an org document. For example, I may write a problem set or exam, and have some headlines that are the problems, and others that are the solutions. Or, I may have done some analysis in a headline, e.g. statistics of problem scores that I do not want in exported content, or I have a manuscript with a supporting information section that does not go in the exported manuscript, and the manuscript cannot go in the supporting information file.

org-mode supports [[http://www.gnu.org/software/emacs/manual/html_node/org/Selective-export.html][selective export]] through use of tags. However, this is inflexible if you want to export multiple different documents with different selective exports, unless you don't mind changing the settings, or commenting and uncommenting lines all the time.

Enter dynamic binding of variables in emacs-lisp. We can temporarily define variables, especially =org-export-select-tags= and =org-export-exclude-tags=, and write emacs-lisp code blocks to export the current document the way we want. First, let us create some headlines.

** problem 1                                                        :problem:
description of a hard problem
*** solution to problem 1                                          :solution:
it is an easy solution
** problem 2                                                        :problem:
what is the square root of 100?
*** solution to problem 2                                          :solution:
why it's 10 of course.

** Code to export                                                      :code:

*** Export just the problems
First, let us output this document with just the problems. The code block does that, just put your cursor in in block and press C-c C-c (in emacs of course).

#+BEGIN_SRC emacs-lisp
(let ((org-export-exclude-tags '("solution" "code"))
      (org-latex-default-packages-alist
       '(("" "lmodern" nil)
         ("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only nil)
      (ext-plist '()))
  (org-latex-export-to-pdf async subtreep visible-only body-only ext-plist))
(rename-file "blog.pdf" "blog-1.pdf")
#+END_SRC

#+RESULTS:

You get this: [[./blog-1.pdf]] which only has the problems in it.

*** Problems and solutions
Next, we consider the problems and the solutions. We cannot just get solutions in this document because solutions are nested in the problems.

#+BEGIN_SRC emacs-lisp
(let ((org-export-exclude-tags '("code"))
      (org-latex-default-packages-alist
       '(("" "lmodern" nil)
         ("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only nil)
      (ext-plist '()))
  (org-latex-export-to-pdf async subtreep visible-only body-only ext-plist))
(rename-file "blog.pdf" "blog-2.pdf" t)
#+END_SRC

#+RESULTS:

This document ([[./blog-2.pdf]]) now has problems and solutions. Note that neither of these documents has the section we labeled =:code:=.

** Summary
Tags are a nice way to label sections. In combination with dynamic binding, you can build code blocks that selectively export pieces of an org-file by temporarily defining the values of variables. In this example, there are four versions of this document: 1) the org-file that contains everything, 2) the html blog post, 3) a pdf with the problems, and 4) a pdf with problems and solutions. Good luck getting that out of a Word file ;)


#+LATEX_CLASS: revtex4-1
#+LATEX_CLASS_OPTIONS: [aps,prb,citeautoscript,preprint,citeautoscript,showkeys]
* DONE Finding the box root directory on a local machine
  CLOSED: [2013-12-22 Sun 11:38]
  :PROPERTIES:
  :categories: box
  :date:     2013/12/22 10:26:24
  :updated:  2013/12/22 10:26:24
  :END:
I am working to automate some aspects of box.com, specifically to create collaborations in folders and tasks on files on my local computer at the command-line. I use Box Sync to mirror folders and files on my local computer, and I would like to open a prompt in one of these folders and type something like:
#+BEGIN_EXAMPLE
box collaborate --role editor someone@gmail.com
#+END_EXAMPLE
to add that person as an editor to my box folder.

The challenge is that I need to know the =id= of that folder on box. Box stores the files on their server by id, not by name, and the root box folder has an id of =0=. On my local computer, the box root folder is where =Box Sync= puts my synchronized files. In my box_course python module I wrote a function that will return the =id= of an item in box given the /box path/ which is relative to the box root directory. For example, here we can get the =id= for a folder called group-course.

#+BEGIN_SRC python
from box_course import box

print box.get_item('/group-course')
#+END_SRC

#+RESULTS:
: {u'sequence_id': u'1', u'etag': u'1', u'type': u'folder', u'id': u'1328895168', u'name': u'group-course'}

On my local computer, group course is located at C:\Users\jkitchin\Box Sync\group-course, and C:\Users\jkitchin\Box Sync is like the box root directory. So, the challenge is, if I am on the local computer in some directory, how do I determine the box path to that directory?

What I worked out is to start in the current directory, and check directories above this for a file that indicates you are in the box root directory. With Box Sync 3, that file was "Box Sync ReadMe.pdf", but Box Sync 4 does not include that file anymore. I just put a folder of that name in the Box Sync 4 root directory [fn:1].

Here is a way to start in a box directory, and walk up the path to look for the file. We get the path, and then split each directory off the end, checking for the existence of the file, until the path is gone.
#+BEGIN_SRC python
import os
# change into a box directory
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync

That gets us the box root directory. Now, we need to strip this off of the current working directory. We also need to replace all the backslashes that Windows uses with forward slashes so that we can get the id.

#+BEGIN_SRC python
import os
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

cwd = os.getcwd()

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
print cwd
print cwd.replace(wd, '').replace('\\','/')
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync
: C:\Users\jkitchin\Box Sync\group-course
: /group-course

This seems to work pretty well, but on some Windows machines, the drive letter is lower case, and then this does not work. In that case, we use =os.path.normcase= to make everything consistent.

#+BEGIN_SRC python
import os
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

from box_course import box

cwd = os.getcwd()

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
print cwd
bpath = os.path.normcase(cwd).replace(os.path.normcase(wd), '').replace('\\','/')

print bpath
print box.get_item(bpath)
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync
: C:\Users\jkitchin\Box Sync\group-course
: /group-course
: {u'sequence_id': u'1', u'etag': u'1', u'type': u'folder', u'id': u'1328895168', u'name': u'group-course'}

This seems to work so far. Something similar this is probably done in git repositories, to find the .git file. This is also a useful way to find a config file higher up the path.

* DONE An improved index function for emacs-lisp
  CLOSED: [2013-12-22 Sun 12:01]
  :PROPERTIES:
  :date:     2013/12/22 12:01:48
  :updated:  2013/12/22 12:02:06
  :categories: emacs-lisp
  :END:
I previously worked out an [[http://kitchingroup.cheme.cmu.edu/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp/][index]] function for a list of strings in emacs-lisp, but at the end I showed it would not work for arbitrary elements of a list. Here is an exercise to improve on that. The goal is a function that looks like this:
#+BEGIN_EXAMPLE
(index 1 '("a" 2 1 "b"))
#+END_EXAMPLE
that would return 2 in this case. Last time I used string=, which is why I could not find a number in the list. This time, we will use =equal= (see http://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html) which compares components of objects for equality. That should let us find arbitrary objects in a list.

Here is our improved function:

#+BEGIN_SRC emacs-lisp
(defun index (object list)
  "return the index of object in list"
  (let ((counter 0)
        (found nil))
    (catch 'finished
      (dolist (listelement list counter)
        (if (equal object listelement)
            (progn
              (setq found t)
              (throw 'finished counter))
          ;; else increment counter
          (incf counter)))
    ;; if we found it return counter otherwise return nil
    (if found counter nil))))
#+END_SRC

#+RESULTS:

Now, let us test some examples:

#+BEGIN_SRC emacs-lisp :results value
(index 1 '("a" 2 1 "b"))
#+END_SRC

#+RESULTS:
: 2

No problem finding a number in a list.

#+BEGIN_SRC emacs-lisp :results value
(index "b" '("a" 2 1 "b"))
#+END_SRC

#+RESULTS:
: 3

How about something more complicated, like a list in a list?
#+BEGIN_SRC emacs-lisp :results value
(index '(1 2) '("a" 2 1 (1 2) "b"))
#+END_SRC

#+RESULTS:
: 3

That looks good.

#+BEGIN_SRC emacs-lisp
(princ (index '(1 2) '("a" 2 1 (2 (1 2)) "b")))
#+END_SRC

#+RESULTS:
: nil

Note, we do not find the nested object. That is ok, the location of that object would require two indices, which this function is not designed for.

Here we consider an object of an a-list
#+BEGIN_SRC emacs-lisp :results value
(index '("nut" . "acorn") '(("nut" . "acorn") ("fruit" . "apple")))
#+END_SRC

#+RESULTS:
: 0

I am not quite sure how you would use that, but it does illustrate the generality of the index function!

* DONE Using data in a table in another org-file
  CLOSED: [2013-12-22 Sun 13:42]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/12/22 13:42:20
  :updated:  2014/01/16 07:30:30
  :END:
I have found using tables in an org-file as data sources to code blocks very convenient for documenting work. A typical work flow might go like this:
1. Use a code block to generate some data in an org-table.
2. Use another code block to analyze the data.

For example, here is a code block that prints data in a table [fn:2]:
#+BEGIN_SRC python :results raw
import numpy as np

print '#+tblname: cos-data'
print '| x | cos(x)|'
print '|-'

for x in np.linspace(0, 2*np.pi, 10):
    print '|{0}|{1}|'.format(x, np.cos(x))
#+END_SRC

#+RESULTS:
#+tblname: cos-data
| x | cos(x)|
|-
|0.0|1.0|
|0.698131700798|0.766044443119|
|1.3962634016|0.173648177667|
|2.09439510239|-0.5|
|2.79252680319|-0.939692620786|
|3.49065850399|-0.939692620786|
|4.18879020479|-0.5|
|4.88692190558|0.173648177667|
|5.58505360638|0.766044443119|
|6.28318530718|1.0|

Now, we use that table in a code block to plot the data. We do this by using some header arguments to the code block:

#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=cos-data
#+END_EXAMPLE

Then we can use the =data= variable inside the code block like this:

#+BEGIN_SRC python :var data=cos-data
import numpy as np
import matplotlib.pyplot as plt

data = np.array(data) # data is a list coming in
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('cos(x)')
plt.savefig('images/cos-plot.png')
#+END_SRC

#+RESULTS:

[[./images/cos-plot.png]]

That is pretty awesome, but what if we have data in a table from another org-file? It turns out we can use it too. I have data for the sin(x) stored in a table called =sin-data= in [[./sin.org]], which I now want to use. We can access that table like this in a header arg:

#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=sin.org:sin-data
#+END_EXAMPLE

And now use the data variable just like before!

#+BEGIN_SRC python :var data=sin.org:sin-data
import numpy as np
import matplotlib.pyplot as plt

data = np.array(data) # data is a list coming in
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.savefig('images/sin-plot.png')
#+END_SRC

#+RESULTS:

[[./images/sin-plot.png]]

This is a powerful capability, as it allows you to pull data from other files into your current analysis. For example, the supporting information files from some of our recent publications have org-files embedded in them with data stored in org-tables. You could use that data in your own analysis without having to type it in yourself. The only thing you need to do is make sure each table in a document is uniquely named.

Special thanks to Eric Schulte for pointing out the syntax for using external tables!

* DONE Python as alternative to Matlab for engineering calculations
  CLOSED: [2013-12-30 Mon 16:05]
  :PROPERTIES:
  :categories: python
  :date:     2013/12/30 15:20:04
  :updated:  2013/12/30 21:15:44
  :END:
For the past year I have been seriously exploring whether Python could be used as a practical alternative to Matlab in engineering calculations, particularly in chemical engineering undergraduate and graduate courses. Matlab is very well suited for these calculations, and I have used it extensively in teaching in the past. For example, there is my Matlab blog (http://matlab.cheme.cmu.edu), and my cmu Matlab package that contains a very nice units package (https://github.com/jkitchin/matlab-cmu). Matlab is widely used and recognized as a standard software package in engineering. My university has a site license for Matlab, so it doesn't cost me or my students anything to use. Matlab is easy to install, and has almost everything we need out of the box. So why try using something else then? Here are the main reasons:

1. Not everyone has access to a "free" Matlab license, and Matlab may not be available to my students when they leave the University. Python offers a free, always available option to them.
2. There are several recent Python distributions that are easy to install, and contain almost everything we need for engineering calculations.
3. I have been increasingly integrating code into my lecture notes, and this is not easy with Matlab, but it is easy with Python.
4. I use Python exclusively in my research, and although Matlab and Python are similar, they are different enough that switching between them is bothersome to me. I do not like teaching students to use tools I do not regularly use, and I believe I can provide them with more value by teaching with tools I have a high level of proficiency in.

** The significance of an open-source alternative
Many people will be able to use Matlab or some other proprietary software that someone has paid for the license to use. Some people, however, will not have that option for a variety of reasons. Maybe the company they work for will not pay for the license, maybe they are unemployed, or entrepeneurs in a small startup that cannot afford it, maybe they are students at a University without a site license,... For these people Python is a viable option that is always available. That makes me happy.

** Easy to install Python distributions
An important development in using Python as an alternative to Matlab is the development of many "one-click" installers. Ten years ago it took me about 2 weeks to download and build a Python environment suitable for scientific and engineering calculations. That has kept me from trying to use Python in teaching in the past. Today, I can download a package and install one in about 10 minutes! More importantly, so can my students.

My favorite distribution is the Enthought Canopy distribution (https://www.enthought.com/products/canopy/). This distribution comes with all the essential python modules, and an integrated editor with IPython. It is available for Windows, Macs and Linux. They offer free academic licenses.

Another good alternative is the Anaconda distribution (https://store.continuum.io/cshop/anaconda/) by Continuum Analytics. It is also available for Windows, Macs and Linux. I have not used this one, but it looks like it would be very good. Anaconda comes with the Spyder editor. They offer free academic licenses.

Python(x,y) is available for Windows (http://code.google.com/p/pythonxy/) and comes with the Spyder editor.

WinPython (http://winpython.sourceforge.net/) is also available for Windows, and comes with the Spyder editor.

The point here is that there are many options available now that make installing a Python distribution as easy as installing packages like Matlab. Enthought Canopy also provides a "desktop environment" similar to Matlab with an editor, documentation browser, package manager and console that is pretty easy to use.

** Python + numpy/scipy/matplotlib does almost everything you need
Python by itself is not suitable for typical engineering calculations. You need the numerical, scientific and plotting libraries that provide that functionality. These are provided in numpy, scipy and matplotlib, which are included in the distributions described above.

Typical chemical engineering calculations involve one or more of the following kinds of math problems:

- [[http://docs.scipy.org/doc/numpy-dev/reference/routines.linalg.html][Linear algebra]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve][Root finding]] (nonlinear algebra)
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq][linear regression]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit][Nonlinear regression]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/tutorial/integrate.html][Integration and ordinary differential equations]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/tutorial/stats.html][statistics]]
- [[http://matplotlib.org/][plotting]]

All of these are doable out of the box with the Python distributions discussed above. You can find many examples of using these, and more on my PYCSE blog (http://kitchingroup.cheme.cmu.edu) and http://kitchingroup.cheme.cmu.edu/pycse/. In short, almost every example I put in the Matlab blog has been done in Python. The only ones I did not do yet are some of the interactive graphics with the steam tables. I have not had time to work those out in detail.

I have found it convenient to augment theses with a package I wrote called pycse (https://github.com/jkitchin/pycse).

- an ode integrator with events similar to the one in Matlab
- some numerical differentiation functions
- linear and nonlinear regression with confidence intervals
- some boundary value problem solvers
- a publish function to convert python scripts to PDF via LaTeX

This package is still a work in progress. Notably, there is not a really good units package in Python that works as well as my Matlab units package does. Two that come close are [[http://pythonhosted.org/quantities/][quantities]] and [[https://pint.readthedocs.org/en/latest/][pint]]. Both have some nuances that make them tricky for regular use, and both have some challenges in covering all the functions you might want to use them for.

** Python from the educator perspective
Make that my perspective. I have developed an approach to using code in my lectures where I use the code to reinforce the structure of the problems, and to analyze the solutions that result. Doing that means I need to have code to show students, and the output, and sometimes to run the code to illustrate something. I also like these examples integrated into my lecture notes, so they have the right context around them.

I have found that [[http://www.youtube.com/watch?v=1-dUkyn_fZA][Emacs+org-mode+python]] allows me to easily integrate notes, equations, images, code and output in one place, and then export it to a PDF which I can annotate in class. This ensures that the code and output stay synchronized, that the code is always right where it needs to be, in the right context, and that I can annotate actual code in class, and not pseudocode. This heavily influenced my decision to use Python because it leverages what I already know and want to do. In fact, using it makes me even better at what I already know and helps me learn more about it. That makes me happy!

Not everyone will be a content developer like this, but that is what I like to do. Python makes that process fun, and worth doing for me.

** Final thoughts
In my opinion Python is and is becoming a more viable alternative to other packages like Matlab for scientific and engineering calculations. I have used it exclusively for about a year solving all kinds of engineering problems that I used to solve in Matlab.

Python is different, for sure. The main differences in my opinion are:
 - Python is less consistent in syntax than Matlab. For example, there are two ODE solvers in scipy with incompatible syntax. That is a result of the fact that you install a Python distribution made of packages written by many different people with different needs.
 - There is duplicated functionality between numpy and scipy.
 - Some functionality in scipy is provided by external "scikits" (http://scikits.appspot.com/).
 - Support for boundary value problems and partial differential equations is not as good in Python as it is in Matlab [fn:3]. At the undergraduate level, this is not a big deal. It is not like the Matlab functions are that easy to use!
 - Data regression in Python is not as complete as in Matlab.
 - indexing in Python starts at 0, and uses [], whereas in Matlab it starts at 1 and uses ()
 - You have to import most functions into Python. In contrast, Matlab has them all in one big namespace.


It is certainly doable to use Python for many scientific and engineering calculations. This past Fall I took the plunge, and taught a whole core course in chemical reaction engineering using Python! It was a Master's level course with 59 graduate students in it. I have also taught a graduate elective course in Molecular Simulation using Python. I still have some polishing to do before I would teach this to undergraduates, but I think it is definitely worth trying!


* DONE Creating a transportable zip-archive of an org-file
  CLOSED: [2014-03-05 Wed 12:31]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/05 10:49:14
  :updated:  2014/03/05 12:31:34
  :END:

This post explores a method to save an org-buffer to a zip archive, with all the referencing files. The challenge is that you may want to share the org-file with someone, but the links break if you send them the file, and it is not that trivial to find all the links and change them, and to copy the files to a place where the new links work.

The idea is to export the buffer to an org-file and process all the links to copy the files to a new directory, and change the links to point to these new files. For example, [[./blog.pdf]] would be copied to the temporary directory, given a unique name, and then relinked. The text below includes some examples of the links that need to be modified.

A figure looks like:

[[./images/cos-plot.png]]

Alternatively, we might use a [[./images/eos.png][link]] to a file. We do not want to change urls, such as this one: http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/. As in that example, we will create a list of all the links in the buffer, but only modify the links that are files. We can parse the buffer and get the links like this.

#+BEGIN_SRC emacs-lisp :results output
(let ((parsetree (org-element-parse-buffer))
      (counter 0))
  (org-element-map parsetree 'link
    (lambda (link)
      (let ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
        (princ (format "%s %s: %s %s\n"
		       counter
		       (plist-get plist ':type)
		       (plist-get plist :path)
		       content))
        (setq counter (+ counter 1))))))
#+END_SRC
#+RESULTS:
: 0 file: ./blog.pdf nil
: 1 file: ./images/cos-plot.png nil
: 2 file: ./images/eos.png link
: 3 http: //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ nil

So, our overall strategy will be to create a new directory to store the new versions of the files in. Then, we will copy the files that links point to into that directory, and give them new unique names. We will rename the links to point to these new names. We do this because you may, for some reason have links to files with the same name but in different directories. We want to make sure we do not clobber the files by overwriting them. We use a simple method here, based on unique, temporary filenames. There are other ways to do it to, this way worked first. Finally, we will zip that new directory, and delete the new directory.


#+BEGIN_SRC emacs-lisp :results value raw
;; directory to save all exports in, using the current date
(setq org-archive (concat "org-archive-" (format-time-string "%Y-%m-%d" (current-time))))

;; delete directory and zip file if it exists
(when (file-exists-p (concat org-archive ".zip"))
    (delete-file (concat org-archive ".zip") t))

(when (file-exists-p org-archive)
    (delete-directory org-archive t))

;; make directory
(make-directory org-archive t)

;; get list of links, copy files and save names
(setq link-list (let ((parsetree (org-element-parse-buffer))
                     (counter 0))
                 (org-element-map parsetree 'link
                   (lambda (link)
                     (let* ((type (nth 0 link))
                            (plist (nth 1 link))
                            (content (nth 2 link))
                            (path (plist-get plist :path))
                            (type (plist-get plist ':type))
                            (fname (car (last (split-string path "/"))))
			    (temporary-file-directory org-archive)
			    (new-file)
                            )
                       (cond
                        ;; regular file with content
                        ((and (string= type "file")  content)
			 (setq new-file  (make-temp-file (file-name-sans-extension fname) nil
							 (concat "." (file-name-extension fname))))
			 (with-temp-file new-file
			   (insert-file-contents path))
			 (format "[[./%s][%s]] " (file-name-nondirectory new-file) content))
                        ;; regular file with no content
                        ((and (string= type "file"))
			 (setq new-file  (make-temp-file (file-name-sans-extension fname) nil
							 (concat "." (file-name-extension fname))))
			 (with-temp-file new-file
			   (insert-file-contents path))
			 (format "[[./%s]] " (file-name-nondirectory new-file)))
			(t nil)))))))

;; save current buffer name
(setq current-name (buffer-name))

;; create filter for links and export org buffer
(let ((counter 0))
  (defun ox-mrkup-filter-link (text back-end info)
    (let ((link (nth counter link-list)))
      (if (not (string= link "nil")) (setq output   (format "%s" link))
        (setq output (format "%s" text)))
      (setq counter (+ counter 1))
      output))

  (let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-org-export-as-org)))

(switch-to-buffer "*Org ORG Export*")
(write-file (expand-file-name current-name org-archive))
(shell-command (concat "zip -R " org-archive ".zip  *"))
(rename-file (concat org-archive ".zip") (concat "../"org-archive ".zip"))
(kill-buffer)

(switch-to-buffer current-name)
(delete-directory org-archive t)  ;; get rid of temp-dir
#+END_SRC



This example works fine! The result is here: [[./org-archive-2014-03-05.zip]] This code would ideally be put into a function, and cleaned up a little so there are not global variables being set here and there. A subsequent function might make it easy to attach this file to an email. That code might look something like this:

#+BEGIN_SRC emacs-lisp
(mail)
(mail-to)
(insert "jkitchin@andrew.cmu.edu")
(mml-attach-file "./org-archive-2014-03-05.zip")
#+END_SRC

* DONE Getting a list of figures in an org-buffer
  CLOSED: [2014-03-02 Sun 10:03]
  :PROPERTIES:
  :date:     2014/03/02 10:03:00
  :updated:  2014/03/03 14:50:40
  :categories: org-mode
  :END:

Similar to the previous [[http://kitchingroup.cheme.cmu.edu/blog/2014/03/01/Getting-a-list-of-tables-in-an-org-buffer/][example]] of getting a list of tables, here we examine getting a list of figures. Here are two figure links, one with a label, and one with a caption.

# figure with no caption
#+label: fig:cos
[[./images/cos-plot.png]]

#+caption: An equation of state. this is the caption of the figure.
[[./images/eos-uncertainty.png]]

#+attr_latex: :width 3in
#+caption: another figure
[[./images/implicit-uncertainty.png]]

We define a link that will parse the buffer, and create links in a new buffer to the figures. We define a figure as a  link with a :type of "file" that has a path that points to a file ending with png or pdf.  We will improve on the list of tables by making the buffer read-only, and making a local key binding to kill the buffer by pressing "q". Here is our attempted code.

#+BEGIN_SRC emacs-lisp
;; http://www.emacswiki.org/emacs/ElispCookbook#toc4
(defun string/ends-with (s ending)
  "return non-nil if string S ends with ENDING."
  (cond ((>= (length s) (length ending))
	 (let ((elength (length ending)))
	   (string= (substring s (- 0 elength)) ending)))
	(t nil)))

(org-add-link-type
 "list-of-figures"
 (lambda (link-string)
   (let* ((c-b (buffer-name))
          (counter 0)
          (list-of-figures
           (org-element-map (org-element-parse-buffer) 'link
             (lambda (link)
               "create a link for to the figure"
	       (when
		   (and (string= (org-element-property :type link) "file")
			(string-match-p
			 "[^.]*\\.\\(png\\|jpg\\)$"
			 (org-element-property :path link)))
		 (incf counter)

		 (let* ((start (org-element-property :begin link))
			(parent (car (cdr (org-element-property :parent link))))
			(caption (caaar (plist-get parent :caption)))
			(name (plist-get parent :name)))
		   (if caption
		       (format
			"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]] %s\n"
			c-b start counter (or name "") caption)
		     (format
		      "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]]\n"
		      c-b start counter (or name "")))))))))
	  (switch-to-buffer "*List of Figures*")
	  (org-mode)
	  (erase-buffer)
	  (insert (mapconcat 'identity list-of-figures ""))
	  (setq buffer-read-only t)
	  (use-local-map (copy-keymap org-mode-map))
	  (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))
   (lambda (keyword desc format)
     (cond
      ((eq format 'latex)
       (format "\\listoffigures")))))
#+END_SRC



This is a test to see if our function works for other image types.
[[./images/smiley.jpg]]

And a link to test it out:

[[list-of-figures:clickme][List of Figures]]

This works too. I am not sure I am getting the figure name and caption in a bulletproof way. They seem to be buried in the :parent of the element, which is a paragraph element. The caption seems to be buried in a few sets of parentheses, hence the use of =caaar= to get the caption out. I am not sure if the caption is always at that depth or not. As a proof of concept though, this is not too bad.

* DONE Getting a list of tables in an org-buffer
  CLOSED: [2014-03-01 Sat 18:12]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/01 18:12:15
  :updated:  2014/03/02 08:02:52
  :END:

In a large document it might be nice to quickly get a list of tables. Preferrably by clicking on a link that generates the list, and exports appropriately, e.g. =listoftables= for LaTeX. A link like this:

[[list-of-tables:clickme][List of Tables]]

Before getting to the code that does what we need, let us make some tables. We make three different kinds of tables for fun. A named table, an unnamed table, and a table with a caption.

#+tblname: first-table
| 1 | 2 |
| a | b |


# unnamed table
| t | y |
| 5 | 6 |


#+caption: column of numbers
#+tblname: tbl-with-caption
| 34 |
|  6 |
|  6 |


We would like a function that creates a buffer with a list of the tables, and links to them. We include the table name, and caption if there is one. We will create an org-buffer, and use org-links to the tables. Here is a link definition that will do that.

#+BEGIN_SRC emacs-lisp :results output raw
(org-add-link-type
 "list-of-tables"
 (lambda (link-string)
   (let* ((c-b (buffer-name))
	  (counter 0)
	  (list-of-tables
	   (org-element-map (org-element-parse-buffer 'element) 'table
	     (lambda (table)
	       "create a link for to the table"
	       (incf counter)
	       (let ((start (org-element-property :begin table))
                     (name  (org-element-property :name table))
		     (caption (caaar (org-element-property :caption table))))
		 (if caption
		     (format
		      "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]] %s\n"
		      c-b start counter (or name "") caption)
		   (format
		    "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]]\n"
		    c-b start counter (or name ""))))))))
     (switch-to-buffer "*List of Tables*")
     (org-mode)
     (erase-buffer)
     (insert (mapconcat 'identity list-of-tables ""))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\listoftables")))))
#+END_SRC

#+RESULTS:

A list of figures would only be a little trickier. You would map over the links, and find the file type links that have a select number of extensions, e.g. png, jpg, etc...


* DONE Using yasnippet to get completion in ref links
  CLOSED: [2014-03-08 Sat 07:55]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/08 07:55:54
  :updated:  2014/03/08 07:55:54
  :END:

This post illustrates an alternative approach to completion in creating ref links compared to the approach shown [[http://kitchingroup.cheme.cmu.edu/blog/2014/03/06/Using-completion-in-ref-links/][here]]. In this approach we use a dynamic yasnippet to do the completion. We start with similar code that I used before to get a list of labels from the buffer. I used a slightly different regexp to recognize links in this version.

label:code-example
#+BEGIN_SRC emacs-lisp
(defun get-labels ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "label:\\([a-zA-z0-9:-]*\\)" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
      matches)))
#+END_SRC

#+RESULTS:
: get-labels

Let us see that in action:

#+BEGIN_SRC emacs-lisp
(get-labels)
#+END_SRC

#+RESULTS:
| code-example | \\ | code:ref-snippet | load-snippets |

I think the =\\= link is an artifact of the regexp in my get-labels code, and it would not appear in other examples.

Now, we are going to create a yasnippet that uses the list returned from ~get-labels~ to provide your choices. See http://capitaomorte.github.io/yasnippet/snippet-development.html#sec-3-8 for some details. We will tangle this code block into a local snippets directory.

label:code:ref-snippet
#+BEGIN_SRC snippet :tangle snippets/org-mode/ref
# -*- mode: snippet -*-
# --
ref:${1:$$(yas-choose-value (get-labels))} $0
#+END_SRC

Now we load the snippets directory.

label:load-snippets
#+BEGIN_SRC emacs-lisp
(yas-load-directory "./snippets")
#+END_SRC

#+RESULTS:

Finally, we can type ref, press tab to complete it, and then select the label you want from a list. Here are some examples:

ref:code-example

ref:code:ref-snippet

That also works! I cannot decide if I like this better than the Emacs completion. yasnippet gives a popup menu, which is not as easy to navigate as the Emacs completion mechanism. It also requires a working yasnippet, which has not made it into my regular work flows too often. I think I like the Emacs completion better (which actually goes through Icicles since I have that installed). I like it better because I do not have to leave the keyboard or use the arrow buttons to choose a label. However, I do need to bind that function to some key to use it, or type in the command name. It turns out I do not use ref links too often, so it is not too burdensome.


* DONE Using completion in ref links
  CLOSED: [2014-03-06 Thu 19:11]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/06 19:11:07
  :updated:  2014/03/06 19:11:07
  :END:

I came across this interesting post on using completion in links: http://draketo.de/light/english/free-software/custom-link-completion-org-mode-25-lines-emacs. I like the idea, but the type-flow for is not how I usually insert links. For the method there to work, you have to enter a link with C-c C-l, partially enter the link type, press enter, and then partially enter the description, which can be completed with tab. That is a lot of typing to me, compared to what I usually do which is type the link in directly. That habit does not work too well in large documents, and always has the possibility of a typo in the link, which then does not work or export correctly.

Here I explore how to make a ref:label link using a function that provides all the options available as labels. The idea is to write a function that generates a list of labels in the buffer, which you can make a link to. Let us try an interactive function with a list of arguments. We are first going to generate a list of labels from the buffer. We use this code to get a list of labels in the buffer. You will get to choose which label you want a link to, and the function will insert it for you. Here it is:

label:code-example
#+BEGIN_SRC emacs-lisp
(defun get-labels ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "label:\\(.*\\)" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
      matches)))

(defun org-insert-ref-link (&optional arg)
  (interactive (list (completing-read "label: " (get-labels))))
  (insert (format "ref:%s" arg)))
#+END_SRC

#+RESULTS:
: org-insert-ref-link

So, here you run the command with M-x org-insert-ref-link, press tab, and select the label you want to use. A link like this gets inserted in your buffer ref:code-example. This is pretty nice. It should reduce the number of ref link mistakes, and make it easier to find the labels in the whole buffer.



* DONE Searching for directories by tags
  CLOSED: [2014-03-29 Sat 17:41]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/29 17:41:08
  :updated:  2014/03/30 12:02:43
  :END:

Today I explore searching for directories by using tags. We will create a TAGS table by first walking through the directories and tagging each directory with all of the relative path components. Then, we will use set algebra to identify specific directories.

First, let us make a directory setup to use. We will nest some calculations that might be typical. These will be nested directories that might contain planewave (pw) and k-points (kpts) convergence and equation of state (eos) directories, with the sets of calculations inside those. The idea then is that the directory components will form at least some of the tags.

#+BEGIN_SRC python
import os

os.mkdir('tags')

for cmpd in ['A', 'B', 'C', 'D']:
    for c in ['pw', 'kpts', 'eos']:
        os.makedirs(os.path.join('tags', cmpd, c))

for cmpd in ['A', 'B', 'C', 'D']:
    for run in [1, 2, 3, 4, 5]:
        os.makedirs(os.path.join('tags', cmpd, 'eos', str(run)))

for cmpd in ['A', 'B', 'C', 'D']:
    for run in [200, 250, 300, 350, 400]:
        os.makedirs(os.path.join('tags', cmpd, 'pw', str(run)))

for cmpd in ['A', 'B', 'C', 'D']:
    for run in ['2x2x2', '4x4x4', '8x8x8']:
        os.makedirs(os.path.join('tags', cmpd, 'kpts', str(run)))
#+END_SRC

#+RESULTS:

Let us just double check what this directory tree looks like for one compound A.
#+BEGIN_SRC sh
ls tags/A/*
#+END_SRC

#+RESULTS:
#+begin_example
tags/A/eos:
1
2
3
4
5

tags/A/kpts:
2x2x2
4x4x4
8x8x8

tags/A/pw:
200
250
300
350
400
#+end_example

Now, we will walk through the directories, and split the path components to create a TAGS structure. I will store these as sets within a dictionary. We will save the structure in a pickle file to reuse it later.

#+BEGIN_SRC python
import os
import pickle

TAGS = {}
TAGS['all'] = set()

for root, dirs, files in os.walk('tags'):
    base, tail = os.path.split(root)
    TAGS['all'].add(root)
    while base:
        if tail in TAGS:
            TAGS[tail].add(root)
        else:
            TAGS[tail] = set([root])
        base, tail = os.path.split(base)

with open('TAGS.pkl', 'w') as f:
    f.write(pickle.dumps(TAGS))

print TAGS.keys()
#+END_SRC

#+RESULTS:
: ['A', '1', 'all', 'B', '250', 'pw', '2x2x2', '300', 'C', '400', 'kpts', '8x8x8', 'eos', '3', '2', '5', '4', '350', '200', '4x4x4', 'D']

Now we have a lot of keys that tag each directory. Each tag is a set of directories, and we can do set algebra to get specific results. For example, we can find a result by appropriate differences, intersections and unions of the sets. An advantage of this approach is that order of the tags is not relevant (unlike the path, where each component must be in the right order).

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

print TAGS['A'].intersection(TAGS['pw']).intersection(TAGS['300'])
print TAGS['300'].intersection(TAGS['pw']).intersection(TAGS['A'])
#+END_SRC

#+RESULTS:
: set(['tags\\A\\pw\\300'])
: set(['tags\\A\\pw\\300'])

The syntax here is a tad heavy because of the chained dot notation operations. You can also use the logical operators like this:

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# 300 and pw and A
print TAGS['300'] & TAGS['pw'] & TAGS['A']
#+END_SRC

#+RESULTS:
: set(['tags\\A\\pw\\300'])


We can get a set of calculations, for example an equation of state like this:
#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# 300 and pw and A
print TAGS['A'] & TAGS['eos']
#+END_SRC

#+RESULTS:
: set(['tags\\A\\eos', 'tags\\A\\eos\\5', 'tags\\A\\eos\\4', 'tags\\A\\eos\\1', 'tags\\A\\eos\\3', 'tags\\A\\eos\\2'])

Now, let us construct some more complex queries. With sets we use intersections for =and= and we construct unions of queries that are like an or. We examine different notations to see which one is better.

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# find calculation 3 in eos for B and C
print (TAGS['3']
       .intersection(TAGS['eos'])
       .intersection(TAGS['B'])
       .union
       (TAGS['3']
        .intersection(TAGS['eos'])
        .intersection(TAGS['C'])))

# this notation makes more sense to me. ^ = or
print TAGS['3'] & TAGS['eos'] & (TAGS['B'] ^ TAGS['C'])
#+END_SRC

#+RESULTS:
: set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
: set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])

You can see the two approaches give the same results. The logical operator syntax is more concise and (I think) more readable. Let us consider a query with "not". We can use a difference operator for that. We subtract all the paths with tag "B" from the set containing "4x4x4", which will give us paths tagged with "4x4x4" but not "B".

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# find calculation 4x4x4 but not B
print (TAGS['4x4x4'].difference(TAGS['B']))

# this makes more sense 4x4x4 but not B,
# i.e. subtract paths tagged B from those tagged 4x4x4
print TAGS['4x4x4'] -  TAGS['B']
#+END_SRC

#+RESULTS:
: set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
: set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])


Note it is not so obvious how to get results not tagged with "A". We need to subtract the tagged calculations from some set.

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

print TAGS['all'] - TAGS['A']  # not A
#+END_SRC

#+RESULTS:
: set(['tags\\D\\kpts', 'tags\\D\\pw\\200', 'tags\\D\\pw\\350', 'tags\\D\\pw\\250', 'tags\\D\\kpts\\8x8x8', 'tags\\C\\eos', 'tags\\D\\eos\\2', 'tags\\D\\eos\\3', 'tags\\D\\eos\\4', 'tags\\D\\eos\\5', 'tags\\B\\kpts\\2x2x2', 'tags\\C\\kpts\\4x4x4', 'tags\\C\\eos\\3', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1', 'tags\\C\\kpts\\8x8x8', 'tags\\C\\eos\\5', 'tags\\C\\eos\\4', 'tags\\B\\kpts', 'tags\\C\\pw\\200', 'tags\\B\\eos\\2', 'tags\\B\\pw\\350', 'tags\\B\\eos\\1', 'tags\\B\\kpts\\8x8x8', 'tags\\C\\pw\\300', 'tags\\B\\eos\\4', 'tags\\B\\eos\\5', 'tags\\C\\kpts', 'tags\\D\\pw\\300', 'tags\\B\\kpts\\4x4x4', 'tags\\C\\kpts\\2x2x2', 'tags\\D\\kpts\\4x4x4', 'tags\\B\\pw\\250', 'tags', 'tags\\D\\pw\\400', 'tags\\D\\eos', 'tags\\C\\pw\\400', 'tags\\D\\kpts\\2x2x2', 'tags\\D\\pw', 'tags\\C\\pw\\250', 'tags\\C\\pw\\350', 'tags\\C\\pw', 'tags\\D\\eos\\1', 'tags\\B\\pw\\400', 'tags\\B\\pw', 'tags\\B\\eos', 'tags\\B\\pw\\300', 'tags\\B\\eos\\3', 'tags\\C', 'tags\\B', 'tags\\D', 'tags\\B\\pw\\200'])

We can also look at "or". This is done with the =union= function, which is the set of elements in either set. The logical operator is =|=.

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

print TAGS['1'].union(TAGS['2'])
print TAGS['1'] | TAGS['2']        # 1 or 2
#+END_SRC

#+RESULTS:
: set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
: set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])

There is an =xor= operator too. xor is not the same as or, it means =A xor B= means "A or B but not both". The =symmetric_difference= function gives this behavior. The logical operator is =^=.

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# I think this is like the xor, A or 2 but not both
print TAGS['A'].symmetric_difference(TAGS['2']), '\n'
print TAGS['A'] ^ TAGS['2']
#+END_SRC

#+RESULTS:
: set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200'])
:
: set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200'])



To summarize, this is one approach to using tags with the technical infrastructure of the set. The advantage is flexibility, that you do not need to know the full path to a result, provided you know the set of tags that refers to it. You can use the tags in any order.

There are many alternative approaches to implementing this idea. One could create a sqlite table and do SQL queries. You could also store lists in the dictionary, and use python code to find the matches. The syntax here is varied. Using the functional approach, the syntax gets heavy with all the dot notation. With the logical operators, the syntax is a little lighter.


* DONE Literate programming in python with org-mode and noweb
  CLOSED: [2014-03-27 Thu 10:47]
  :PROPERTIES:
  :categories: org-mode,python
  :date:     2014/03/27 10:46:55
  :updated:  2014/03/27 11:07:15
  :END:
This post examines a different approach to literate programming with org-mode that uses [[http://www.cs.tufts.edu/~nr/noweb/][noweb]]. I have adapted an example from http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html which has some pretty cool ideas in it.

The gist of using noweb is that in your source blocks you have labels like =<<imports>>=, that refer to other named code blocks that get substituted in place of the label. In the example below, we put labels for a code block of imports, for a function definition, a class definition, and a main function. This code block will get tangled to [[./main.py]]. The noweb expansion happens at export, so here is the literal code block:
#+BEGIN_EXAMPLE
#+BEGIN_SRC python :noweb yes :tangle main.py
<<imports>>

<<some-func>>

<<class-dfn>>

<<main-func>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC
#+END_EXAMPLE

You may want to just check out the org-mode source link at the bottom of the post to see all the details.

#+BEGIN_SRC python :noweb yes :tangle main.py
<<imports>>

<<some-func>>

<<class-dfn>>

<<main-func>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC

** imports
Now, we define a block that gives us the imports. We do not have to use any tangle headers here because noweb will put it in where it belongs.

#+NAME: imports
#+BEGIN_SRC python
import sys
import numpy as np
import matplotlib.pyplot as plt

from argparse import ArgumentParser
#+END_SRC

** utility function
Now we define a function we will want imported from the main file.

#+NAME: some-func
#+BEGIN_SRC python
def utility_func(arg=None):
    return 'you called a utility function with this arg: {0}'.format(arg)
#+END_SRC

** class definition
Finally, let us define a class. Note we use noweb here too, and we get the indentation correct!

#+NAME: class-dfn
#+BEGIN_SRC python :noweb yes
class HelloWorld(object):
    def __init__(self, who):
        self.who = who

    def __call__(self):
        return 'Hello {0}'.format(self.who)

    <<some-other-func>>
#+END_SRC

*** some class function
Now, let us make the some-other-func. This block is not indented, but with the noweb syntax above, it seems to get correctly indented. Amazing.

#+NAME: some-other-func
#+BEGIN_SRC python
def test(self):
    return True
#+END_SRC

** The main function

This is a typical function that could be used to make your module into a script, and is only run when the module is used as a script..

#+NAME: main-func
#+BEGIN_SRC python
def main():
    parser = ArgumentParser(description="Say hi")
    parser.add_argument("-w", "--who",
                        type=str,
                        default="world",
                        help="Who to say hello to")
    args = parser.parse_args()

    who = args.who

    greeter = HelloWorld(who)
    greeter()

    print 'test func = ', greeter.test()

    print utility_func()
    print utility_func(5)

    return 0
#+END_SRC

** Tangle and run the code

This link will extract the code to main.py: elisp:org-babel-tangle

We can run the code like this (linux):
#+NAME: bashrun-helloworld
#+BEGIN_SRC sh :results output
python main.py --w John 2>&1
true
#+END_SRC
#+RESULTS: bashrun-helloworld
: test func =  True
: you called a utility function with this arg: None
: you called a utility function with this arg: 5

or this (windows, which as no sh)

#+BEGIN_SRC python
from main import *

main()
#+END_SRC

#+RESULTS:
: test func =  True
: you called a utility function with this arg: None
: you called a utility function with this arg: 5

** Summary thoughts
The use of noweb syntax is pretty cool. I have not done anything serious with it, but it looks like you could pretty easily create a sophisticated python module this way that is documented in org-mode.
* DONE Deleting multiple elements of a list
  CLOSED: [2014-03-25 Tue 18:40]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/25 18:40:34
  :updated:  2014/03/25 18:40:34
  :END:

Today someone asked about deleting multiple elements from a list (actually it was about deleting multiple atoms from an ase.Atoms object, but some principles here apply. I will address that actual question later.).

Deleting multiple items from a list is not directly possible in one command in Python. There are a few approaches to accomplishing something like it. Which one is best depends on your objective.

One problem is when you delete an item, the indices of every item after it also changes. One strategy then is to delete the elements in descending order, i.e. delete the largest indices first. That way, you do not change the indices of the smaller indices, so you can still delete them. We can sort them in reverse order like this:

#+BEGIN_SRC python
a = [1, 2, 5, 6, 7]

ind2remove = [1, 3]

for i in sorted(ind2remove, reverse=True):
    del a[i]

print a
#+END_SRC

#+RESULTS:
: [1, 5, 7]

An alternative approach is to make a new list that only has the elements you want using list comprehension. For example:

#+BEGIN_SRC python
a = [1, 2, 5, 6, 7]

ind2remove = [1, 3]

a = [x for i,x in enumerate(a) if i not in ind2remove]

print a
#+END_SRC

#+RESULTS:
: [1, 5, 7]

With numpy arrays you can delete multiple elements like this:

#+BEGIN_SRC python
import numpy as np

a = np.array([1, 2, 5, 6, 7])

ind2remove = [1, 3]

print np.delete(a, ind2remove)
print a
#+END_SRC

#+RESULTS:
: [1 5 7]
: [1 2 5 6 7]

The delete command makes a new object; the original list is unchanged. Numpy arrays are technically immutable, so the only way to do this is to make a copy. Another way is to use a boolean mask that only selects the indices where the mask is True, and not where they are False.

#+BEGIN_SRC python
import numpy as np

a = np.array([1, 2, 5, 6, 7])

ind2remove = [1, 3]

mask = np.ones(len(a), dtype=bool)
mask[ind2remove] = False
print a[mask]
print a
#+END_SRC

#+RESULTS:
: [1 5 7]
: [1 2 5 6 7]

There might be other ways to do this too. These examples are nearly indistinguishable for small lists. For very large lists (I guess 1000's of elements), you may find one method more efficient than the others.

* DONE Make a list of org-files in all the subdirectories of the current working directory
  CLOSED: [2014-03-23 Sun 15:36]
  :PROPERTIES:
  :categories: org-mode,emacs,recursive
  :date:     2014/03/23 15:36:56
  :updated:  2014/03/23 15:36:56
  :END:

It would be helpful to get a listing of org-files in a directory tree in the form of clickable links. This would be useful, for example, to find all files associated with a project in a directory with a particular extension, or to do some action on all files that match a pattern. To do this, we will have to recursively walk through the directories and examine their contents.

Let us examine some of the commands we will need to use. One command is to get the contents of a directory. We will explore the contents of a directory called =literate= in my computer.

#+BEGIN_SRC emacs-lisp
;; list contents of the directory
(let ((abspath nil)
      (match nil)
      (nosort t))
  (directory-files "literate" abspath match nosort))
#+END_SRC

#+RESULTS:
| makefile-main | Makefile | main.o | main.f90 | main | literate.org | hello.f90 | circle.o | circle.mod | circle.f90 | circle-area.png | archive | a.out | .. | . |

Note the presence of =.= and =..=. Those stand for current directory and one directory up. We should remove those from the list. We can do that like this.

#+BEGIN_SRC emacs-lisp
;; remove . and ..
(let ((abspath nil)
      (match nil)
      (nosort t))
  (remove "."
	  (remove ".."
		  (directory-files "literate" abspath match nosort))))
#+END_SRC

#+RESULTS:
| makefile-main | Makefile | main.o | main.f90 | main | literate.org | hello.f90 | circle.o | circle.mod | circle.f90 | circle-area.png | archive | a.out |

Next, we need to know if a given entry in the directory files is a file or a directory. Emacs-lisp has a few functions for that. We use absolute filenames here since the paths are relative to the  "molecules" directory. Note we could use absolute paths in directory-files, but that makes it hard to remove "." and "..".

#+BEGIN_SRC emacs-lisp :results output
;; print types of files in the directory
(let ((root "literate")
      (abspath nil)
      (match nil)
      (nosort t))
  (mapcar (lambda (x)
	    (cond
	     ((file-directory-p (expand-file-name x root))
	      (print (format "%s is a directory" x)))
	     ((file-regular-p (expand-file-name x root))
	      (print (format "%s is a regular file" x)))))
	  (remove "."
		  (remove ".."
			  (directory-files root abspath match nosort)))))
#+END_SRC

#+RESULTS:
#+begin_example

"makefile-main is a regular file"

"Makefile is a regular file"

"main.o is a regular file"

"main.f90 is a regular file"

"main is a regular file"

"literate.org is a regular file"

"hello.f90 is a regular file"

"circle.o is a regular file"

"circle.mod is a regular file"

"circle.f90 is a regular file"

"circle-area.png is a regular file"

"archive is a directory"

"a.out is a regular file"
#+end_example

Now, we are at the crux of this problem. We can differentiate between files and directories. For each directory in this directory, we need to recurse into it, and list the contents. There is some code at http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html which does this, but I found that I had to modify the code to not list directories, and here I want to show a simpler recursive code.

#+BEGIN_SRC emacs-lisp
(defun os-walk (root)
  "recursively walks through directories getting list of absolute paths of files"
  (let ((files '()) ; empty list to store results
	(current-list (directory-files root t)))
    ;;process current-list
    (while current-list
      (let ((fn (car current-list))) ; get next entry
	(cond
	 ;; regular files
	 ((file-regular-p fn)
	  (add-to-list 'files fn))
	 ;; directories
	 ((and
	   (file-directory-p fn)
	   ;; ignore . and ..
	   (not (string-equal ".." (substring fn -2)))
	   (not (string-equal "." (substring fn -1))))
	  ;; we have to recurse into this directory
	  (setq files (append files (os-walk fn))))
	)
      ;; cut list down by an element
      (setq current-list (cdr current-list)))
      )
    files))

(os-walk "literate")
#+END_SRC

#+RESULTS:
| c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/makefile-main | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/main.o | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/main.f90 | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/main | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/literate.org | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/hello.f90 | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle.o | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle.mod | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle.f90 | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle-area.png | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/a.out | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/Makefile | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/archive/empty-text-file.txt |

Nice, that gives us a recursive listing of all the files in this directory tree. Let us take this a step further, and apply a function to that list to filter out a list of the org files. We will also create org-links out of these files.

#+BEGIN_SRC emacs-lisp :results output org raw
(defun os-walk (root)
  (let ((files '()) ;empty list to store results
	(current-list (directory-files root t)))
    ;;process current-list
    (while current-list
      (let ((fn (car current-list))) ; get next entry
	(cond
	 ;; regular files
	 ((file-regular-p fn)
	  (add-to-list 'files fn))
	 ;; directories
	 ((and
	   (file-directory-p fn)
	   ;; ignore . and ..
	   (not (string-equal ".." (substring fn -2)))
	   (not (string-equal "." (substring fn -1))))
	  ;; we have to recurse into this directory
	  (setq files (append files (os-walk fn))))
	)
      ;; cut list down by an element
      (setq current-list (cdr current-list)))
      )
    files))

(require 'cl)

(mapcar
 (lambda (x) (princ (format "[[%s][%s]]\n" x (file-relative-name x "."))))
 (remove-if-not
  (lambda (x) (string= (file-name-extension x) "org"))
  (os-walk "literate")))
#+END_SRC

#+RESULTS:
[[c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/literate.org][literate/literate.org]]


That is certainly functional. It might be nice to format the links a bit nicer to show their structure in a table of contents way, or to sort them in a nice order if there were many of these files.




* DONE Finding VASP calculations in a directory tree
  CLOSED: [2014-03-20 Thu 20:09]
  :PROPERTIES:
  :categories: python,vasp
  :date:     2014/03/20 20:09:26
  :updated:  2014/03/20 20:09:26
  :END:

The goal in this post is to work out a way to find all the directories in some root directory that contain VASP calculations. This is a precursor to doing something with those directories, e.g. creating a summary file, adding entries to a database, doing some analysis, etc... For fun, we will just calculate the total elapsed time in the calculations.

What is challenging about this problem is that the calculations are often nested in a variety of different subdirectories, and we do not always know the structure. We need to recursively descend into those directories to check if they contain VASP calculations.

We will use a function that returns True or False to tell us if a particular directory is a VASP calculation or not. We can tell that because a completed VASP calculation has specific files in it, and specific content in those files. Notably, there is an OUTCAR file that contains the text "General timing and accounting informations for this job:" near the end of the file.

We will also use [[http://docs.python.org/2/library/os.html#os.walk][os.walk]] as the way to recursively descend into the root directory.

#+BEGIN_SRC python
import os
from jasp import *

def vasp_p(directory):
    'returns True if a finished OUTCAR file exists in the current directory, else False'
    outcar = os.path.join(directory, 'OUTCAR')
    if os.path.exists(outcar):
        with open(outcar, 'r') as f:
            contents = f.read()
            if 'General timing and accounting informations for this job:' in contents:
                return True
    return False


total_time = 0

for root, dirs, files in os.walk('/home-research/jkitchin/research/rutile-atat'):
    for d in dirs:
        # compute absolute path to each directory in the current root
        absd = os.path.join(root, d)
        if vasp_p(absd):
            # we found a vasp directory, so we can do something in it.
            # here we get the elapsed time from the calculation
            with jasp(absd) as calc:
                total_time += calc.get_elapsed_time()

print 'Total computational time on this project is {0:1.0f} minutes.'.format(total_time / 60)
#+END_SRC

#+RESULTS:
: Total computational time on this project is 231 minutes.




* DONE Using tags searches on objects in python
  CLOSED: [2014-03-24 Mon 21:52]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/24 21:52:13
  :updated:  2014/03/24 21:52:13
  :END:

I am exploring the possibility of using tags on python objects in conjunction with searches to find sets of objects. Here I want to explore some syntax and methods for doing that.

In org-mode there is a syntax like '+boss+urgent-project1' for =and= and =not= operators and 'A|B' for =or= operators. I think we need [[http://pyparsing.wikispaces.com/Examples][pyparsing]] to untangle this kind of syntax. See http://pyparsing.wikispaces.com/file/view/simpleBool.py for an example. Another alternative might be the natural language toolkit ([[http://www.nltk.org/][nltk]]). Before we dig into those, let us see some python ways of doing the logic.

Below we define some lists containing tags (strings). We

#+BEGIN_SRC python
a = ['A', 'B', 'C']

b = ['A', 'B']

c = ['A', 'C']

d = [ 'B', 'C']

all_lists = [a, b, c, d]

# get functions with tags A and B
print 'A and B ',[x for x in all_lists if ('A' in x) & ('B' in x)]

# A not B
print 'A not B ',[x for x in all_lists if ('A' in x) & ('B' not in x)]

# B or C
print 'B or C ', [x for x in all_lists if ('B' in x) | ('C' in x)]

# B or C but not both
print 'B xor C ',[x for x in all_lists if ('B' in x) ^ ('C' in x)]
#+END_SRC

#+RESULTS:
: A and B  [['A', 'B', 'C'], ['A', 'B']]
: A not B  [['A', 'C']]
: B or C  [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['B', 'C']]
: B xor C  [['A', 'B'], ['A', 'C']]

Those are not too bad. Somehow I would have to get pyparsing to generate that syntax. That will take a lot of studying. There are some other ways to do this too. Let us try that out with itertools.

#+BEGIN_SRC python
a = ['A', 'B', 'C']

b = ['A', 'B']

c = ['A', 'C']

d = [ 'B', 'C']

all_lists = [a, b, c, d]

import itertools as it

# ifilter returns an iterator
print 'A and B ', list(it.ifilter(lambda x: ('A' in x) & ('B' in x), all_lists))

#+END_SRC

#+RESULTS:
: A and B  [['A', 'B', 'C'], ['A', 'B']]

I do not like this syntax better. The iterator is lazy, so we have to wrap it in a list to get the results.  Eventually, I want to do something like these:

#+BEGIN_EXAMPLE
filter('A and B', all_lists)
A or B
A xor B
not A and B
not(A and B)
#+END_EXAMPLE

I think that calls for pyparsing.  I think the syntax above is better (more readable) than this:

#+BEGIN_EXAMPLE
filter('A & B', all_lists)
A | B
A ^ B
~A & B
~(A & B)
#+END_EXAMPLE

It is not that obvious though how to get from that syntax to the code I illustrated above though.

* DONE Scheduling tasks on a rotating semester basis
  CLOSED: [2014-04-03 Thu 19:29]
  :PROPERTIES:
  :categories: python
  :date:     2014/04/03 19:29:34
  :updated:  2014/04/03 19:29:35
  :END:

Let us say we have a list of tasks labeled task a through k. We want to schedule these tasks on a rotating basis, so that some tasks are done in even years and some tasks are done in odd years. Within those years, some tasks are done in the Fall, and some are done in the spring. This post explores how to code those tasks so we can figure out which tasks should be done in some part of some year.

We break the problem down like this. A year is an even year if =mod(year,2)=0=, and it is odd if =mod(year,2)=1=. So for a year, we have a bit of information. Now, since there are two times of the year we will do the tasks, we can assign this as another bit, e.g. =FALL=0=, and =SPRING=1=. Now, we have the following possibilities:

| year | time period | binary code | decimal number |
|------+-------------+-------------+----------------|
| 2013 | Fall        |          10 |              2 |
| 2014 | Spring      |          01 |              1 |
| 2014 | Fall        |          00 |              0 |
| 2015 | Spring      |          11 |              3 |

And then the cycle will repeat. So, if we code each task with an integer of 0, 1, 2 or 3, we can say in a given year and time period whether a task should be completed. If =2 * mod(year, 2) + period_code= is equal to the code on the task, then it should be executed.

Now, we need to start the task sequence. Let us say we start in the Fall of 2013. That is an odd year, so =year % 2 = 1=, and we use a tag  of =0= to represent the Fall semester, giving an overall binary code of =10= which is equal to 2, so all tasks labeled 2 should be executed.

We will assign the codes to each task by enumerating a string of letters, and giving the task a code of mod(letter index, 4). That will loop through the tasks assigning codes of 0, 1, 2 or 3 to each task.

So to schedule these we will loop through a list of years, calculate the code for each year and time perid, and then filter the list of tasks with that code.

#+BEGIN_SRC python
tasks = [(letter, i % 4) for i,letter in enumerate('abcdefghijk')]

print 'tasks = ',tasks

SEMESTERS = (('FALL',0), ('SPRING',1))

for year in [2013, 2014, 2015, 2016, 2017, 2018]:
    for semester,i in SEMESTERS:
        N = 2 * (year % 2) + i
        print '{0} {1:8s}: {2}'.format(year, semester,
                                    [x[0] for x in
                                     filter(lambda x: x[1]==N,
                                            tasks)])
#+END_SRC

#+RESULTS:
#+begin_example
tasks =  [('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 0), ('f', 1), ('g', 2), ('h', 3), ('i', 0), ('j', 1), ('k', 2)]
2013 FALL    : ['c', 'g', 'k']
2013 SPRING  : ['d', 'h']
2014 FALL    : ['a', 'e', 'i']
2014 SPRING  : ['b', 'f', 'j']
2015 FALL    : ['c', 'g', 'k']
2015 SPRING  : ['d', 'h']
2016 FALL    : ['a', 'e', 'i']
2016 SPRING  : ['b', 'f', 'j']
2017 FALL    : ['c', 'g', 'k']
2017 SPRING  : ['d', 'h']
2018 FALL    : ['a', 'e', 'i']
2018 SPRING  : ['b', 'f', 'j']
#+end_example

This leads to each task being completed every other year. We could also write a function and filter by list comprehension.

#+BEGIN_SRC python
tasks = [(letter, i % 4) for i,letter in enumerate('abcdefghijk')]

FALL = 0
SPRING = 1

def execute_p(year, semester, task):
    'year is an integer, semester is 0 for fall, 1 for spring, task is a tuple of (label,code)'
    N = 2 * (year % 2) + semester
    return task[1] == N

YEAR, SEMESTER = 2018, FALL
print '{0} {1:8s}: {2}'.format(YEAR,
                               'FALL' if SEMESTER==0 else 'SPRING',
                               [task[0]  for task in tasks
                                if execute_p(2018, FALL, task)])
#+END_SRC

#+RESULTS:
: 2018 FALL    : ['a', 'e', 'i']

Now, at any point in the future you can tell what tasks should be done!

* DONE Using pyparsing for search  queries with tags
  CLOSED: [2014-03-31 Mon 13:21]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/31 13:21:16
  :updated:  2014/03/31 13:21:16
  :END:

A few times I  have wanted  to use  a more natural search string like "A and pw and 350 and not  kpt". The trouble  is figuring out how to parse that string and turn it  into search code. There  may  be nested logic,  e.g. "(A xor B)  and  (pw and (200 or 300))". This means we have  to recursively parse  the sstring. Rather  than invent this from  scratch, we  use pyparsing which is designed for that. There is   some code in "Getting started with pyparsing" that provides an example on parsing search strings. I want to see how I can turn the parsed output into search code. Here, we parse the search string and generate something that looks like lisp code.

** Parsing simple string and generating lisp

We define  a  hiearchy of classes that codifythe operators, and which print representations of the logic. The grammar we implement is basically words or  strings separatedd by logic operators.

#+BEGIN_SRC python
from pyparsing import *

class UnaryOperation(object):
    'takes one operand,e.g. not'
    def __init__(self, tokens):
        self.op, self.operands = tokens[0]

class BinaryOperation(object):
    'takes two or more operands, e.g. and, or'
    def __init__(self, tokens):
        self.op = tokens[0][1]
        self.operands = tokens[0][0::2]

class SearchAnd(BinaryOperation):
    def __repr__(self):
        return '(AND {0})'.format(' '.join(str(oper) for oper in self.operands))

class SearchOr(BinaryOperation):
    def __repr__(self):
        return '(OR {0})'.format(' '.join(str(oper) for oper in self.operands))

class SearchNot(UnaryOperation):
    def __repr__(self):
        return '(NOT {0})'.format(self.operands)

class SearchTerm(object):
    'represents a termthat is being searched. here just a word'
    def __init__(self, tokens):
        self.term = tokens[0]

    def __repr__(self):
        return self.term

# the grammar
and_ = CaselessLiteral("and")
or_ = CaselessLiteral("or")
not_ = CaselessLiteral("not")

searchTerm = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

searchExpr = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])


print searchExpr.parseString('not kpt')[0]
print searchExpr.parseString('not (kpt and eos)')[0]
print searchExpr.parseString('wood and blue or red')[0]
print searchExpr.parseString('wood and blue and heavy or red')[0]
#+END_SRC

#+RESULTS:
: (NOT kpt)
: (NOT (AND kpt eos))
: (OR (AND wood blue) red)
: (OR (AND wood blue heavy) red)

That works pretty well, and does not seem overly complicated to me. There is a lot of class definition, but that would presumably get buried in a module as a one time investment, and some function interface would look like this: =search('wood and blue or red')=.

Now, let us try python notation.

** Parsing a search string to generate python set notations
I will use a similar idea as I used before with TAGS. We will use set operations with the binary logical operators to do the actual searching. Finally, we wrap the code in a little function to search a dictionary we previously made.

#+BEGIN_SRC python
from pyparsing import *

class UnaryOperation(object):
    def __init__(self, tokens):
        self.op, self.operands = tokens[0]

class BinaryOperation(object):
    def __init__(self, tokens):
        self.op = tokens[0][1]
        self.operands = tokens[0][0::2]

class SearchAnd(BinaryOperation):
    def __repr__(self):
        return '(' + ' & '.join(['{}'.format(oper) for oper in self.operands]) + ')'

class SearchOr(BinaryOperation):
    def __repr__(self):
        return '(' + ' | '.join(['{}'.format(oper) for oper in self.operands]) +')'

class SearchXor(BinaryOperation):
    def __repr__(self):
        return '(' + ' ^ '.join(['{}'.format(oper) for oper in self.operands]) + ')'

class SearchNot(UnaryOperation):
    def __repr__(self):
        return 'TAGS[\'all\'] - {}'.format(self.operands)

class SearchTerm(object):
    def __init__(self, tokens):
        self.term = tokens[0]

    def __repr__(self):
        'instead of just the  term, we represent it as TAGS[term]'
        return 'TAGS[\'{0}\']'.format(self.term)

# the grammar
and_ = CaselessLiteral("and")
or_ = CaselessLiteral("or")
xor_ = CaselessLiteral("xor")
not_ = CaselessLiteral("not")

searchTerm = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

searchExpr = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (xor_, 2, opAssoc.LEFT, SearchXor),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])

print searchExpr.parseString('not kpt')[0]
print searchExpr.parseString('not (kpt and eos)')[0]
print searchExpr.parseString('kpt or not eos)')[0]
print searchExpr.parseString('wood and blue or red')[0]
print searchExpr.parseString('wood and blue xor red')[0]

# check it out on tags.
def search_tags(srch):
    'function to  search the TAGS  file'
    import pickle

    with open('TAGS.pkl', 'r') as f:
        TAGS = pickle.loads(f.read())

    s = searchExpr.parseString(srch)[0]
    return eval(str(s))
print search_tags('pw and A and not 300')
#+END_SRC

#+RESULTS:
: TAGS['all'] - TAGS['kpt']
: TAGS['all'] - (TAGS['kpt'] & TAGS['eos'])
: (TAGS['kpt'] | TAGS['all'] - TAGS['eos'])
: ((TAGS['wood'] & TAGS['blue']) | TAGS['red'])
: ((TAGS['wood'] & TAGS['blue']) ^ TAGS['red'])
: set(['tags\\A\\pw\\350', 'tags\\A\\pw', 'tags\\A\\pw\\200', 'tags\\A\\pw\\400', 'tags\\A\\pw\\250'])

That is pretty nice. It looks like a nice syntax for queries. One day I will try incorporating this into a database application.


* DONE Popup tips on bibtex links in org-mode
  CLOSED: [2014-04-12 Sat 14:15]
  :PROPERTIES:
  :date:     2014/04/12 14:15:45
  :updated:  2014/04/12 14:15:45
  :END:

I want to explore using popup tips to display richer information about org-mode links. The idea is to have something like a tooltip that displays the bibtex entry when you hover over it, or click on it.

https://github.com/auto-complete/popup-el/blob/master/popup.el

Here is a canonical example of a popup.

#+BEGIN_SRC emacs-lisp
(popup-tip "Hello, World!")
#+END_SRC

#+RESULTS:
: t

[[./images/hello-world-popup.png]]

All I need to do is figure out a simple way to get the bibtex entry as a string, and pop it up when a link is clicked on.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (link-string)
   (popup-tip link-string))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "<pre>%s:%s</pre>" keyword desc)))))
#+END_SRC
#+RESULTS:
| lambda | (link-string)         | (popup-tip link-string)                                                  |
| lambda | (keyword desc format) | (cond ((eq format (quote html)) (format <pre>%s:%s</pre> keyword desc))) |

Now we give it a try.   test:show-me-the-popup

[[./images/test-link-popup.png]]

That looks good.

Ok, the penultimate step will be to lookup a bibtex entry, and show the entry in a popup. We will hardcode the path to the bibtex file.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (bibtex-key)
   (let ((entry (with-temp-buffer
		  (insert-file-contents "~/Dropbox/bibliography/references.bib")
		  (goto-char (point-min))
		  (re-search-forward bibtex-key)
		  (bibtex-narrow-to-entry)
		  (buffer-string))))
     (popup-tip entry))))
#+END_SRC

#+RESULTS:
| lambda | (bibtex-key) | (let ((cb (current-buffer)) (entry (with-temp-buffer (insert-file-contents ~/Dropbox/bibliography/references.bib) (goto-char (point-min)) (re-search-forward bibtex-key) (bibtex-narrow-to-entry) (buffer-string)))) (popup-tip entry)) |


test:mehta-2014-ident-poten

And here is what appears for me:
[[./images/bibtex-popup-entry.png]]

The final step is to connect this to an [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Idle-Timers.html][idle timer]]. We want a popup to occur when our mouse is idle. I am setting this up to run one time, after 5 seconds of idleness.

#+BEGIN_SRC emacs-lisp
(run-with-idle-timer 5 nil (lambda () (popup-tip "You are being idle")))
#+END_SRC
#+RESULTS:
: [nil 0 5 0 nil (lambda nil (popup-tip "You are being idle")) nil idle 0]

[[./images/idle-timer-popup.png]]

So, we need to setup an idle timer that runs on some interval. When the cursor is on the right kind of link, we want to get a popup. I adapted the following code from http://www.emacswiki.org/emacs/IdleTimers.

#+BEGIN_SRC emacs-lisp
;; variable for the timer object
(defvar idle-timer-bibtex-timer nil)

;; callback function
(defun idle-timer-bibtex-callback ()
  "displays a popup of the bibtex entry in a test link"
  (interactive)
  (let ((object (org-element-context)))
    (when (and (equal (org-element-type object) 'link)
               (equal (org-element-property :type object) "test"))
      (let* ((bibtex-key (org-element-property :path object))
	     (entry (with-temp-buffer
		      (insert-file-contents "~/Dropbox/bibliography/references.bib")
		      (goto-char (point-min))
		      (re-search-forward bibtex-key)
		      (bibtex-narrow-to-entry)
		      (buffer-string))))
	(popup-tip entry)))))

;; start functions
(defun idle-timer-bibtex-start ()
  (interactive)
  (when (timerp idle-timer-bibtex-timer)
    (cancel-timer idle-timer-bibtex-timer))
  (setq idle-timer-bibtex-timer
          (run-with-timer 1 1 #'idle-timer-bibtex-callback)))

;; stop function
(defun idle-timer-bibtex-stop ()
  (interactive)
  (when (timerp idle-timer-bibtex-timer)
    (cancel-timer idle-timer-bibtex-timer))
  (setq idle-timer-bibtex-timer nil))

(idle-timer-bibtex-start)
#+END_SRC
#+RESULTS:
: idle-timer-bibtex-stop


test:kitchin-2008-alloy

Now, whenever the cursor is on the link, and there is an idle of about a sec, I get a popup window of the bibtex entry. It looks like this:
too
[[./images/bibtex-popup2.png]]

There are still some limitations to this code. It does not handle multiple citations in a link (like the cite links I normally use do). That will take a little work to fixup. I cannot figure out how to get mouse-over tooltips; this only works when the cursor is on the link.  I do not know what the optimal timer setting is. This one runs every second. I do not see any issues in performance with that. Another issue might be making the timer a file local variable. It would be nice if the timer quit running when the file was closed. I do not know how easy that would be to implement, or if there should be one timer running for org-mode. Finally, this code is hard-coded to use my reference file. For a real module, we would probably provide some customization to choose other bibtex files. Overall though, this might be a handy way to quickly peruse the citations in an org-file.


[[./O_sv]]
* DONE Finding missing citation entries in an org-file
  CLOSED: [2014-04-29 Tue 10:37]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/04/29 10:37:51
  :updated:  2014/05/21 11:00:19
  :END:

Today we consider how to find citations in a document that have no corresponding entries in a bibtex file. There are a couple of pieces to this which we work out in stages below. First, we specify the bibtex file using a bibliography link defined in jorg-bib.el.


bibliography:bib1.bib,bib2.bib

jorg-bib provides a function that gives us the relevant bibliography files found in this file.

#+BEGIN_SRC emacs-lisp
(cite-find-bibliography)
#+END_SRC

#+RESULTS:
| bib1.bib | bib2.bib |

We can get a list of keys in these files

#+BEGIN_SRC emacs-lisp
(let ((bibtex-files (cite-find-bibliography)))
(bibtex-global-key-alist))
#+END_SRC

#+RESULTS:
| (adams-1993-orien-imagin . t) | (aarik-1997-effec-tio2 . t) | (aruga-1985-struc-iron . t) |


Now, here are some citations that we want to include in this document.

cite:aruga-1985-struc-iron,aarik-1997-effec-tio2

Here is a citation that is not in the bibtex file cite:kitchin-2016-nobel-lecture


To find out if any of these are missing, we need a list of the citation keys in this document. We first get all the content from the cite links.  We parse the buffer, and for each cite link, we get the path of the link, which contains our keys.

#+BEGIN_SRC emacs-lisp
(let ((parsetree (org-element-parse-buffer)))
  (org-element-map parsetree 'link
    (lambda (link)
      (let ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (plist-get plist ':path))))))
#+END_SRC
#+RESULTS:
| aruga-1985-struc-iron,aarik-1997-effec-tio2 | kitchin-2016-nobel-lecture |

That is almost what we need, but we need to separate the keys that are joined by commas. That function already exists in jorg-bib as cite-split-keys. We need to make a slight variation to get a list of all the entries, since the cite-split-keys returns a list of entries for each link. Here is on approach to that. b

#+BEGIN_SRC emacs-lisp
(let ((parsetree (org-element-parse-buffer))
      (results '()))
  (org-element-map parsetree 'link
    (lambda (link)
      (let ((plist (nth 1 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (setq results (append results (cite-split-keys (plist-get plist ':path))))))))
results)
#+END_SRC

#+RESULTS:
| aruga-1985-struc-iron | aarik-1997-effec-tio2 | kitchin-2016-nobel-lecture |

Ok, now we just need to check each entry of that list against the list of entries in the bibtex files, and highlight any that are not good. We use an index function below to tell us if an element is in a list. This index function works for strings. We use the strange remove-if-not function, which requires something like triple negative logic to get the list of keys that are not in the bibtex files.

#+BEGIN_SRC emacs-lisp :results output
(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (parsetree (org-element-parse-buffer))
       (cited-keys))
  (org-element-map parsetree 'link
    (lambda (link)
      (let ((plist (nth 1 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (setq cited-keys (append cited-keys (cite-split-keys (plist-get plist ':path))))))))

(princ (remove-if-not (lambda (arg) (not (index arg bibtex-keys))) cited-keys))
)
#+END_SRC

#+RESULTS:
: (kitchin-2016-nobel-lecture)


The only improvement from here would be if this generated a temporary buffer with clickable links to find that bad entry! Let us take a different approach here, and print this to a temporary buffer of clickable links.

#+BEGIN_SRC emacs-lisp :results value raw
(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (bad-citations '()))

  (org-element-map (org-element-parse-buffer) 'link
    (lambda (link)
      (let ((plist (nth 1 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (dolist (key (cite-split-keys (plist-get plist ':path)) )
	    (when (not (index key bibtex-keys))
	      (setq bad-citations (append bad-citations
			    `(,(format "%s [[elisp:(progn (find-file \"%s\")(goto-char %s))][not found here]]\n"
		      key (buffer-file-name)(plist-get plist ':begin)))))
			    ))))))

(mapconcat 'identity bad-citations ""))
#+END_SRC

#+RESULTS:
kitchin-2016-nobel-lecture [[elisp:(progn (find-file "/home-research/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org")(goto-char 1052))][not found here]]

That is likely to come in handy. I have put a variation of this code in jorb-bib, in the function called jorg-bib-find-bad-citations.

* DONE A popup menu for citation links in org-mode
  CLOSED: [2014-04-28 Mon 10:13]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/04/28 10:13:17
  :updated:  2014/04/28 10:13:17
  :END:

I have been exploring ways to get more information out of links in org-mode. I have considered [[http://kitchingroup.cheme.cmu.edu/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode/][popups]], and [[http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/][right-clicking]]. Here I show how to get a popup menu on a citation link. The idea is that clicking or opening the ditation link should give you a menu. The menu should give you some context, e.g. if the bibtex key even exists. If it does, you should be able to get a quick view of the citation in the minibuffer. You should be able to open the entry in the bibtex file from the menu. If you have a pdf of the reference, you should have an option to open it. You should be able to open the url associated with the entry from the menu too.

Here is the function. We use https://github.com/auto-complete/popup-el, and some code from https://github.com/jkitchin/jmax/blob/master/jorg-bib.el.

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "cite"
 ;; this function is run when you click on the link
 (lambda (link-string)
   (let* ((menu-choice)
         ;; this is in jorg-bib.el
         (results (get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat jorg-bib-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))
     (setq menu-choice
	   (popup-menu*
	    (list (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       "Simple citation"
				     "No key found")  :value "cite")
		  (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       (format "Open %s in %s" key bibfile)
				     "No key found") :value "bib")
		  (popup-make-item
		   ;; check if pdf exists.jorg-bib-pdf-directory is a user defined directory.
                   ;; pdfs are stored by bibtex key in that directory
		   (if (file-exists-p pdf-file)
		       (format "Open PDF for %s" key)
		     "No pdf found") :value "pdf")
		  (popup-make-item "Open URL" :value "web")
		  (popup-make-item "Open Notes" :value "notes")
		  )))

     (cond
      ;; goto entry in bibfile
      ((string= menu-choice "bib")
       (find-file bibfile)
       (bibtex-search-entry key))

      ;; goto entry and try opening the url
      ((string= menu-choice "web")
       (let ((cb (current-buffer)))
	 (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (bibtex-url))
	 (switch-to-buffer cb)))

      ;; goto entry and open notes, create notes entry if there is none
      ((string= menu-choice "notes")
       (find-file bibfile)
       (bibtex-search-entry key)
       (jorg-bib-open-bibtex-notes))

     ;; open the pdf file if it exists
     ((string= menu-choice "pdf")
      (when (file-exists-p pdf-file)
	  (org-open-file pdf-file)))

     ;; print citation to minibuffer
     ((string= menu-choice "cite")
      (let ((cb (current-buffer)))
	(message "%s" (save-excursion (find-file bibfile)
				      (bibtex-search-entry key)
				      (jorg-bib-citation)))
	(switch-to-buffer cb))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))
#+END_SRC


cite:daza-2014-carbon-dioxid,mehta-2014-ident-poten,test,ahuja-2001-high-ruo2


bibliography:../../bibliography/references.bib,bib.bib



Here you can see an example of a menu where I have the PDF:

[[./images/cite-menu-1.png]]

Here is an example menu of a key with no entry:
[[./images/cite-menu-2.png]]

And, and entry with no PDF:
[[./images/cite-menu-3.png]]

Here is the simple citation:

[[./images/cite-menu-4.png]]

And a reference from the other bibliography:

[[./images/cite-menu-5.png]]

Not bad! I will probably replace the cite link in jorg-bib with something like this.






* DONE A better insert citation function for org-mode
  CLOSED: [2014-04-27 Sun 14:40]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/04/27 14:40:45
  :updated:  2014/04/27 14:40:45
  :END:

I have setup a reftex citation format that inserts a cite link using reftex like this.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l"))))))
#+END_SRC

I mostly like this, but it does not let me add citations to an existing citation; doing that leads to the insertion of an additional cite within the citation, which is an error. One way to make this simple is to add another cite format which simple returns the selected keys. You would use this with the cursor at the end of the link, and it will just append the results.

#+BEGIN_SRC emacs-lisp
(add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))
#+END_SRC

That actually works nicely. I would like a better approach though, that involves less keywork. Ideally, a single function that does what I want, which is when on a link, append to it, and otherwise insert a new citation link. Today I will develop a function that fixes that problem.

#+BEGIN_SRC emacs-lisp
(defun insert-cite-link ()
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))
    (if (and (equal (org-element-type object) 'link)
               (equal (org-element-property :type object) "cite"))
	(progn
	  (goto-char link-string-end)
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))
      (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))
      )))
#+END_SRC

That function is it! Org-mode just got a lot better. That function only puts a cite link in, but since that is all I use 99.99+% of the time, it works fine for me!


* DONE Autogenerating functions in emacs-lisp
  CLOSED: [2014-05-12 Mon 18:05]
  :PROPERTIES:
  :categories: emacs, emacs-lisp
  :date:     2014/05/12 18:05:45
  :updated:  2014/05/12 18:05:54
  :END:

I have a need to generate a lot of similar functions, and I do not want to cut and paste the code. I want to generate the functions with code. This seems to be what macros are for in emacs lisp.

As a prototype example, we will make functions that raise a number to a power. We want functions like power-3 and power-4 that raise numbers to the third and fourth powers. We will define functions like this for the numbers 0-9.

Here we define the macro. i do not want to get into the nitty gritty details of macro definitions here.

#+BEGIN_SRC emacs-lisp
(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(make-power-n 4)

(power-4 4)
#+END_SRC

#+RESULTS:
: 256

Now we use the macro and mapcar on it onto a list of numbers. We have to eval the macro in the mapcar lambda function.

#+BEGIN_SRC emacs-lisp
(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(mapcar (lambda (x) (eval `(make-power-n ,x))) '(0 1 2 3 4 5 6 7 8 9))

;; example of a few functions
(list (power-0 3) (power-1 3) (power-2 3))
#+END_SRC

#+RESULTS:
| 1 | 3 | 9 |


It works! We created 10 functions in a little bit of code.



* DONE Sorting citation links by year
  CLOSED: [2014-05-21 Wed 09:57]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/05/21 09:57:48
  :updated:  2014/05/21 09:57:48
  :END:

When there are several citations grouped together, I like them sorted by year. For example, I do not like this cite:liu-2014-spect-studies,mcalpin-2010-epr-eviden,kanan-2009-cobal,lutterman-2009-self-healin,kanan-2008-in-situ. I prefer cite:kanan-2008-in-situ,kanan-2009-cobal,lutterman-2009-self-healin,mcalpin-2010-epr-eviden,liu-2014-spect-studies. It is just a preference, but it seems appropriate to cite things in chronological order.

It is actually a little tedious to sort this by hand though. Hence, today we examine some tools to automate the sorting. The idea is to make a function that will get the keys, sort them by year, and then replace the link with the sorted text.

Let us try some sorting. We will construct a set of cons cells with a year and key, sort that list by year, and then concatenate the keys. Here is an example of the sorting. The years will come as strings from the bibtex file.

#+BEGIN_SRC emacs-lisp
(setq data '(("2014" . "key1") ("2012" . "key2")("2016" . "key3")))
(setq data
	(cl-sort data (lambda (x y) (< (string-to-int (car x)) (string-to-int (car y))))))
(mapconcat (lambda (x) (cdr x)) data ",")
#+END_SRC

#+RESULTS:
: key2,key1,key3

That is easy enough. Now, a function to get the year, and then the function to sort a link.

#+BEGIN_SRC emacs-lisp
(defun org-ref-get-citation-year (key)
  "get the year of an entry with key"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file key))
	 (bibfile (cdr results))
	 (cb (current-buffer)))
    (message "---------%s %s" key bibfile)
    (set-buffer (find-file-noselect bibfile))
    (bibtex-search-entry key nil 0)
    (prog1 (reftex-get-bib-field "year" (bibtex-parse-entry t))
      (set-buffer cb))))

(defun org-ref-sort-citation-link ()
 "replace link at point with sorted link by year"
 (interactive)
 (let* ((object (org-element-context))
        (type (org-element-property :type object))
	(begin (org-element-property :begin object))
	(end (org-element-property :end object))
	(link-string (org-element-property :path object))
	keys years data)
  (setq keys (org-ref-split-and-strip-string link-string))
  (setq years (mapcar 'org-ref-get-citation-year keys))
  (setq data (mapcar* (lambda (a b) `(,a . ,b)) years keys))
  (setq data (cl-sort data (lambda (x y) (< (string-to-int (car x)) (string-to-int (car y))))))
  ;; now get the keys separated by commas
  (setq keys (mapconcat (lambda (x) (cdr x)) data ","))
  ;; and replace the link with the sorted keys
  (cl--set-buffer-substring begin end (concat type ":" keys))
))

#+END_SRC

Now, you put your cursor on a link, run M-x org-ref-sort-citation-link, and the magic happens  cite:kanan-2008-in-situ,kanan-2009-cobal,lutterman-2009-self-healin,mcalpin-2010-epr-eviden,liu-2014-spect-studies! It would also be nice to have some arrow commands so you could do something like manually reorder them with S-right arrow or something like in the calendar, but that will be another day. It looks like there are hooks for org-shiftright-hook and org-shiftleft-hook that might be able to make this happen.

* DONE org-shift hooks for ordering citations
  CLOSED: [2014-05-21 Wed 11:11]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/05/21 11:11:56
  :updated:  2014/05/21 11:37:40
  :END:
I wrote a function that sorts citations by year, but there might be a reason to order them some other way. Here we develop a method to use shift-arrow keys to do the ordering. We will need to write a function that gets the citations in a link, gets the key under point, and then swap with neighboring keys depending on the arrow pressed. It is trivial to get the key under point (org-ref-get-bibtex-key-under-cursor), and we saw before it is easy to get the keys in a link. Let us examine swapping elements of a list here. This is an old algorithm, we store the first value, replace it with the second value, and then set the second value.

#+BEGIN_SRC emacs-lisp
(defun org-ref-swap-keys (i j keys)
 "swap the keys in a list with index i and j"
 (let ((tempi (nth i keys)))
   (setf (nth i keys) (nth j keys))
   (setf (nth j keys) tempi))
  keys)

(org-ref-swap-keys 2 3 '(1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 2 | 4 | 3 |

So, we need to get the keys in the link at point, the key at point, the index of the key at point, and then we can swap them, and reconstruct the link. Here is the function that does this, and that adds the hooks.

#+BEGIN_SRC emacs-lisp
(defun org-ref-swap-citation-link (direction)
 "move citation at point in direction +1 is to the right, -1 to the left"
 (interactive)
 (let* ((object (org-element-context))
        (type (org-element-property :type object))
	(begin (org-element-property :begin object))
	(end (org-element-property :end object))
	(link-string (org-element-property :path object))
        (key (org-ref-get-bibtex-key-under-cursor))
	(keys (org-ref-split-and-strip-string link-string))
        (i (index key keys)) point) ;; defined in org-ref
   (if (> direction 0) ;; shift right
     (org-ref-swap-keys i (+ i 1) keys)
     (org-ref-swap-keys i (- i 1) keys))
  (setq keys (mapconcat 'identity keys ","))
  ;; and replace the link with the sorted keys
  (cl--set-buffer-substring begin end (concat type ":" keys))
  ;; now go forward to key so we can move with the key
  (re-search-forward key)
  (goto-char (match-beginning 0))))

(add-hook 'org-shiftright-hook (lambda () (org-ref-swap-citation-link 1)))
(add-hook 'org-shiftleft-hook (lambda () (org-ref-swap-citation-link -1)))
#+END_SRC

#+RESULTS:
| lambda | nil | (org-ref-swap-citation-link -1) |

cite:kanan-2008-in-situ,kanan-2009-cobal,lutterman-2009-self-healin,mcalpin-2010-epr-eviden,liu-2014-spect-studies!

That is it! Wow, not hard at all. Check out this video of the code in action: http://screencast.com/t/YmgA0fnZ1Ogl


* DONE Using org-files like el-files
  CLOSED: [2014-06-24 Tue 21:32]
  :PROPERTIES:
  :categories: emacs,org-mode
  :date:     2014/06/24 21:32:58
  :updated:  2014/06/24 21:34:15
  :END:
I wrote some emacs-lisp code in org-mode, and load them with org-babel-load-file. I thought it would be nice if there was load path for org-files, similar to the one for lisp files. Here I document what it might look like.

We need a load path to search for the org-file.
#+BEGIN_SRC emacs-lisp
(setq org-load-path '("~/Dropbox/kitchingroup/jmax/"))
#+END_SRC

#+RESULTS:
| ~/Dropbox/kitchingroup/jmax/ |

Next, we need the function to do the loading. We need to find the org-file, and then load it.



#+BEGIN_SRC emacs-lisp
(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (org-babel-load-file path)))


(org-require 'org-ref)
#+END_SRC

#+RESULTS:
: Loaded ~/Dropbox/kitchingroup/jmax/org-ref.el

That looks pretty simple. You do need write access to the location where the org-file is though. Let us look at a version that copies the file to a temporary directory. For some reason, I am not able to use org-babel-load-file with this. But, it does look like I can tangle the file, and assuming (big assumption) that the file tangles to a regularly named .el file, this seems to work too.

#+BEGIN_SRC emacs-lisp
(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
        (el-file (concat (symbol-name orgfile) ".el"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (copy-file path temporary-file-directory t)

  (org-babel-tangle-file (concat temporary-file-directory (file-name-nondirectory path)))
  (load-file (concat temporary-file-directory el-file))
))

(org-require 'org-ref)
#+END_SRC

#+RESULTS:
: t

This actually seems pretty reasonable. I have not thought about complications but for simple cases, e.g. single org-file, it looks ok.


* DONE Better integration of org-mode and email
  CLOSED: [2014-06-08 Sun 20:57]
  :PROPERTIES:
  :categories: email,org-mode
  :date:     2014/06/08 20:57:53
  :updated:  2014/06/08 20:57:53
  :END:
I like to email org-mode headings and content to people. It would be nice to have some records of when a heading was sent, and to whom. We store this information in a heading. It is pretty easy to write a simple function that emails a selected region.

#+BEGIN_SRC emacs-lisp
(defun email-region (start end)
  "Send region as the body of an email."
  (interactive "r")
  (let ((content (buffer-substring start end)))
    (compose-mail)
    (message-goto-body)
    (insert content)
    (message-goto-to)))
#+END_SRC

that function is not glamorous, and you still have to fill in the email fields, and unless you use gnus and org-contacts, the only record keeping is through the email provider.

What I would like is to send a whole heading in an email. The headline should be the subject, and if there are TO, CC or BCC properties, those should be used. If there is /no TO/, then I want to grab the TO from the email after you enter it and store it as a property. You should be able to set OTHER-HEADERS as a property (this is just for fun. There is no practical reason for this yet). After you send the email, it should record in the heading when it was sent.

It turned out that is a relatively tall order. While it is easy to setup the email if you have everything in place, it is tricky to get the information on TO and the time sent /after/ the email is sent. Past lispers had a lot of ideas to make this possible, and a day of digging got me to the answer. You can specify some "action" functions that get called at various times, e.g. after sending, and a return action when the compose window is done. Unfortunately, I could not figure out any way to do things except to communicate through some global variables.

So here is the code that lets me send org-headings, with the TO, CC, BCC properties, and that records when I sent the email after it is sent.

#+BEGIN_SRC emacs-lisp
(defvar *email-heading-point* nil
  "global variable to store point in for returning")

(defvar *email-to-addresses* nil
  "global variable to store to address in email")

(defun email-heading-return ()
  "after returning from compose do this"
  (switch-to-buffer (marker-buffer  *email-heading-point*))
  (goto-char (marker-position  *email-heading-point*))
  (setq *email-heading-point* nil)
  (org-set-property "SENT-ON" (current-time-string))
  ;; reset this incase you added new ones
  (org-set-property "TO" *email-to-addresses*)
  )

(defun email-send-action ()
  "send action for compose-mail"
  (setq *email-to-addresses* (mail-fetch-field "To")))

(defun email-heading ()
  "Send the current org-mode heading as the body of an email, with headline as the subject.

use these properties
TO
OTHER-HEADERS is an alist specifying additional
header fields.  Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

save when it was sent as s SENT property. this is overwritten on
subsequent sends. could save them all in a logbook?
"
  (interactive)
  ; store location.
  (setq *email-heading-point* (set-marker (make-marker) (point)))
  (org-mark-subtree)
  (let ((content (buffer-substring (point) (mark)))
	(TO (org-entry-get (point) "TO" t))
	(CC (org-entry-get (point) "CC" t))
	(BCC (org-entry-get (point) "BCC" t))
	(SUBJECT (nth 4 (org-heading-components)))
	(OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
	(continue nil)
	(switch-function nil)
	(yank-action nil)
	(send-actions '((email-send-action . nil)))
	(return-action '(email-heading-return)))

    (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
    (message-goto-body)
    (insert content)
    (when CC
      (message-goto-cc)
      (insert CC))
    (when BCC
      (message-goto-bcc)
      (insert BCC))
    (if TO
	(message-goto-body)
      (message-goto-to))
    ))
#+END_SRC

This works pretty well for me. Since I normally use this to send tasks to people, it keeps the task organized where I want it, and I can embed an org-id in the email so if the person replies to it telling me the task is done, I can easily navigate to the task to mark it off. Pretty handy.

* DONE Finding emails from tags from org-contacts database
  CLOSED: [2014-06-05 Thu 14:42]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/06/05 14:42:21
  :updated:  2014/06/05 14:42:21
  :END:

Org-mode has a contacts manager called org-contacts. If you set it up, you can use it to insert email addresses using a tag in message-mode. Out of the box though, it only works on one tag. You cannot do something like +group-phd to get entries tagged group but not tagged phd. Here we develop a function to do that for us.

We could use the org-files and map the headings to do this, but org-contacts has already done this and has a database we can use instead. We get the database from org-contacts-filter. Here is the first entry.

#+BEGIN_SRC emacs-lisp :results raw
(car (org-contacts-filter))
#+END_SRC

#+RESULTS:
(Chris Jones #<marker at 1 in contacts.org> ((FILE . c:/Users/jkitchin/Dropbox/org-mode/contacts.org) (TAGS . :co2:) (ALLTAGS . :co2:) (BLOCKED . ) (COMPANY . Georgia Tech, Chemical Engineering) (EMAIL . Christopher.Jones@chbe.gatech.edu) (CATEGORY . contacts)))

It looks like we have (name marker (cons cells)) for each entry. We can get the tags associated with that entry like this.

We can get the tags for an entry with this code:
#+BEGIN_SRC emacs-lisp
(let ((entry (car (org-contacts-filter))))
  (cdr (assoc "TAGS" (nth 2 entry))))
#+END_SRC

#+RESULTS:
: :co2:

We will use some code for org tags. Notably, from a tags expression, we can automatically generate code that tells us if we have a match. Here we generate the code to test for a match on "+co2-group".

#+BEGIN_SRC emacs-lisp :results raw
(let ((todo-only nil))
  (cdr (org-make-tags-matcher "+co2-group")))
#+END_SRC

#+RESULTS:
(and (progn (setq org-cached-props nil) (and (not (member group tags-list)) (member co2 tags-list))) t)

Note we will have to bind tags-list before we eval this.

So to use it, we need to split the tags from an org-contacts entry into a list of strings. It appears each entry just has the tag string, so we split the substring (skipping first and last characters) by ":" to get the list. We do that here, and test if a list of tags containing "co2" is matched by the expression "co2-junior".

#+BEGIN_SRC emacs-lisp
(let* ((tags-list (split-string (substring ":co2:" 1 -1) ":"))
       (todo-only nil))
  (eval (cdr (org-make-tags-matcher "co2-junior"))))
#+END_SRC

#+RESULTS:
: t

It is. So, now we just need to loop through the database, and collect entries that match.

#+BEGIN_SRC emacs-lisp
(defun insert-emails-from-tags (tag-expression)
  "insert emails from org-contacts that match the tags expression. For example:
group-phd will match entries tagged with group but not with phd."
  (interactive "sTags: ")
  (insert
   (mapconcat 'identity
	      (loop for contact in (org-contacts-filter)
		    for contact-name = (car contact)
		    for email = (org-contacts-strip-link (car (org-contacts-split-property
							       (or
								(cdr (assoc-string org-contacts-email-property
										   (caddr contact)))
								""))))
		    for tags = (cdr (assoc "TAGS" (nth 2 contact)))
		    for tags-list = (if tags
					(split-string (substring (cdr (assoc "TAGS" (nth 2 contact))) 1 -1) ":")
				      '())
		    if (let ((todo-only nil))
			 (eval (cdr (org-make-tags-matcher tag-expression))))

		    collect (org-contacts-format-email contact-name email))
	      ",")))
#+END_SRC

This is not quite completion in message-mode, but it is good enough. You put your cursor in the To field, and run that command, enter the tag expression, and you will get your emails!

* DONE Automatic downloading of a pdf from a journal site
  CLOSED: [2014-05-23 Fri 11:44]
  :PROPERTIES:
  :categories: bibtex,emacs
  :date:     2014/05/23 11:44:11
  :updated:  2014/05/23 11:44:11
  :END:
Many bibliography software packages can automatically download a pdf for you. In this post, we explore how that can be done from emacs. The principle idea is that the pdf is obtained from a url, and that you can calculate the url by some method. Then you can download the file.

For example, consider this article in Phys. Rev. Lett. http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105. There is a link to get the pdf for this article at http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105. It is not difficult to construct that url; you just replace =/abstract/= with =/pdf/=.

The trick is how to get the first url. We have previously seen that we can construct a bibtex entry from a doi. In fact, we can use the doi to get the url above. If you visit https://doi.org/10.1103/PhysRevLett.99.016105, you will be redirected to the url. It so happens that you can use code to get the redirected url. In emacs-lisp it is a little convoluted; you have to use url-retrieve, and provide a callback that sets the redirect. Here is an example. It appears you need to run this block twice to get the right variable setting. That seems like some kind of error in what I have set up, but I cannot figure out why.

#+BEGIN_SRC emacs-lisp :results output
(defvar *doi-utils-redirect*)

(defun callback (&optional status)
 (when status ;  is nil if there none
   (setq *doi-utils-redirect* (plist-get status :redirect))))

(url-retrieve
  "https://doi.org/10.1103/PhysRevLett.99.016105"
  'callback)

(print *doi-utils-redirect*)
#+END_SRC

#+RESULTS:
:
: "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105"

From there, creating the pdf url is as simple as

#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "prl/abstract" "prl/pdf" "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105")
#+END_SRC

#+RESULTS:
: http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105

And finally we download the file with

#+BEGIN_SRC emacs-lisp
(url-copy-file "http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105" "PhysRevLett.99.016105.pdf" nil)
#+END_SRC

#+RESULTS:
: t

So that is the gist of automating pdf downloads. You do these steps:
1. Get the DOI
2. Get the url that the DOI redirects to
3. Calculate the link to the pdf
4. Download the pdf

Each publisher does something a little bit different, so you have to work this out for each one. I have worked alot of them out at https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el. That file is a work in progress, but it is a project I intend to use on a regular basis.

* DONE Converting a doi to a bibtex entry
  CLOSED: [2014-05-22 Thu 16:22]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/05/22 16:22:31
  :updated:  2014/05/22 16:22:31
  :END:
Many citation management packages allow you to download a bibliography entry from a doi. I want to be able to do that in emacs. I found this [[http://homepages.see.leeds.ac.uk/~eeaol/notes/2013/02/doi-metadata/][page]] that shows it is possible to get metadata about a doi with an http request, and from that data, we can create a bibtex entry. So, here is the basic code for getting metadata about a doi. We specify that we want json code, and then use [[http://edward.oconnor.cx/2006/03/json.el][json.el]] to view the results.

We temporarily set a few url-* variables with affect the url-retrieve results. And we rely on url-http-end-of-headers which tells us the end of the headers that get returned, so we can use the remaining text as the data.

#+BEGIN_SRC emacs-lisp :results raw
(require 'json)

(let ((url-request-method "GET")
      (url-mime-accept-string "application/citeproc+json")
      (json-object-type 'plist)
      (results))
  (setq results
	(with-current-buffer (url-retrieve-synchronously "https://doi.org/10.1016/S0022-0248(97)00279-0")
	  (json-read-from-string (buffer-substring url-http-end-of-headers (point-max))))))
#+END_SRC

#+RESULTS:
(:volume 181 :indexed (:timestamp 1389218884442 :date-parts [[2014 1 8]]) :publisher Elsevier BV :source CrossRef :URL https://doi.org/10.1016/S0022-0248(97)00279-0 :ISSN [0022-0248] :DOI 10.1016/s0022-0248(97)00279-0 :type journal-article :title Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process :issue 3 :deposited (:timestamp 1386028800000 :date-parts [[2013 12 3]]) :page 259-264 :reference-count nil :container-title Journal of Crystal Growth :author [(:given Jaan :family Aarik) (:given Aleks :family Aidla) (:given Väino :family Sammelselg) (:given Teet :family Uustare)] :prefix http://id.crossref.org/prefix/10.1016 :score 1.0 :issued (:date-parts [[1997 11]]) :subject [Condensed Matter Physics Inorganic Chemistry Materials Chemistry] :subtitle [])

That data is now sufficient for us to consider constructing a bibtex entry. For an article, a prototypical entry looks like:

#+BEGIN_EXAMPLE
@Article{,
  author =	 {},
  title =	 {},
  journal =	 {},
  year =	 {},
  OPTkey =	 {},
  OPTvolume =	 {},
  OPTnumber =	 {},
  OPTpages =	 {},
  OPTmonth =	 {},
  OPTnote =	 {},
  OPTannote =	 {}
}
#+END_EXAMPLE

Let us create a function that takes a doi and constructs a bibtex entry. I do not use all the metadata, so I just store the json data in the annote field. Maybe I should use another field for that, but annote seems ok since I do not use if for anything. I am going to use a template expansion function I developed earlier to make the bibtex entry template easier to write and read. Here is the code.

#+BEGIN_SRC emacs-lisp
(require 'json)

(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
                            (lambda (arg)
                              (let ((sexp (substring arg 2 -1)))
                                (format "%s" (eval (read sexp))))) s))

(defun doi-to-bibtex-article (doi)
 "insert a bibtex entry for doi at point"
 (interactive "sDOI: ")
 (let ((url-request-method "GET")
       (url-mime-accept-string "application/citeproc+json")
       (json-object-type 'plist)
       type
       results
       author
       title
       journal
       year
       volume
       number
       pages
       month
       url json-data)

   (setq results
	 (with-current-buffer
	     (url-retrieve-synchronously
	      (concat "https://doi.org/" doi))
	 (json-read-from-string (buffer-substring url-http-end-of-headers (point-max))))
         type (plist-get results :type)
	 author (mapconcat (lambda (x) (concat (plist-get x :given) " " (plist-get x :family)))
		     (plist-get results :author) " and ")
	 title (plist-get results :title)
	 journal (plist-get results :container-title)
	 volume (plist-get results :volume)
	 issue (plist-get results :issue)
	 year (elt (elt (plist-get (plist-get results :issued) :date-parts) 0) 0)
	 month (elt (elt (plist-get (plist-get results :issued) :date-parts) 0) 1)
	 pages (plist-get results :page)
	 doi (plist-get results :DOI)
	 url (plist-get results :URL)
	 json-data (format "%s" results))

   (when (string= type "journal-article")

     (expand-template "@article{,
  author =	 {%{author}},
  title =	 {%{title}},
  journal =	 {%{journal}},
  year =	 {%{year}},
  volume =	 {%{volume}},
  number =	 {%{issue}},
  pages =	 {%{pages}},
  doi =          {%{doi}},
  url =          {%{url}},
  month =	 {%{month}},
  json =	 {%{json-data}}
}"))))

(doi-to-bibtex-article "10.1016/s0022-0248(97)00279-0")
#+END_SRC

#+RESULTS:
#+begin_example
@article{,
  author =	 {Jaan Aarik and Aleks Aidla and Väino Sammelselg and Teet Uustare},
  title =	 {Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process},
  journal =	 {Journal of Crystal Growth},
  year =	 {1997},
  volume =	 {181},
  number =	 {3},
  pages =	 {259-264},
  doi =          {10.1016/s0022-0248(97)00279-0},
  url =          {https://doi.org/10.1016/s0022-0248(97)00279-0},
  month =	 {11},
  json =	 {(:volume 181 :indexed (:timestamp 1389218884442 :date-parts [[2014 1 8]]) :publisher Elsevier BV :source CrossRef :URL https://doi.org/10.1016/s0022-0248(97)00279-0 :ISSN [0022-0248] :DOI 10.1016/s0022-0248(97)00279-0 :type journal-article :title Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process :issue 3 :deposited (:timestamp 1386028800000 :date-parts [[2013 12 3]]) :page 259-264 :reference-count nil :container-title Journal of Crystal Growth :author [(:given Jaan :family Aarik) (:given Aleks :family Aidla) (:given Väino :family Sammelselg) (:given Teet :family Uustare)] :prefix http://id.crossref.org/prefix/10.1016 :score 1.0 :issued (:date-parts [[1997 11]]) :subject [Condensed Matter Physics Inorganic Chemistry Materials Chemistry] :subtitle [])}
}
#+end_example

That looks excellent. Note there are some non-ascii characters in it, which would have to be fixed. Let us try it on an ASAP article.

#+BEGIN_SRC emacs-lisp
(doi-to-bibtex-article "10.1021/ie403744u")
#+END_SRC

#+RESULTS:
#+begin_example
@article{,
  author =	 {José A. Delgado and V. I. Águeda and M. A. Uguina and J. L. Sotelo and P. Brea and Carlos A. Grande},
  title =	 { Adsorption and Diffusion of H 2 , CO, CH 4 , and CO 2 in BPL Activated Carbon and 13X Zeolite: Evaluation of Performance in Pressure Swing Adsorption Hydrogen Purification by Simulation },
  journal =	 {Industrial & Engineering Chemistry Research},
  year =	 {2014},
  volume =	 {nil},
  number =	 {nil},
  pages =	 {140117091024005},
  doi =          {10.1021/ie403744u},
  url =          {https://doi.org/10.1021/ie403744u},
  month =	 {1},
  json =	 {(:indexed (:timestamp 1392935578089 :date-parts [[2014 2 20]]) :publisher American Chemical Society (ACS) :source CrossRef :URL https://doi.org/10.1021/ie403744u :ISSN [0888-5885 1520-5045] :DOI 10.1021/ie403744u :type journal-article :title  Adsorption and Diffusion of H 2 , CO, CH 4 , and CO 2 in BPL Activated Carbon and 13X Zeolite: Evaluation of Performance in Pressure Swing Adsorption Hydrogen Purification by Simulation  :deposited (:timestamp 1389916800000 :date-parts [[2014 1 17]]) :page 140117091024005 :reference-count nil :container-title Industrial & Engineering Chemistry Research :author [(:given José A. :family Delgado) (:given V. I. :family Águeda) (:given M. A. :family Uguina) (:given J. L. :family Sotelo) (:given P. :family Brea) (:given Carlos A. :family Grande)] :prefix http://id.crossref.org/prefix/10.1021 :score 1.0 :issued (:date-parts [[2014 1 17]]) :subject [Chemistry(all) Industrial and Manufacturing Engineering Chemical Engineering(all)] :subtitle [])}
}
#+end_example

You see that nil is put in for missing entries. That is probably ok. There is an & in the journal that needs to be cleaned up, but that is easily done with org-ref-clean-bibtex-entry. In summary, this looks like a very convenient way to get bibtex entries inside emacs. I should probably have the function insert that string to a buffer at point, but that is not difficult to do.


* DONE Another parsing of links for citations with pre and post text.
  CLOSED: [2014-06-26 Thu 20:16]
  :PROPERTIES:
  :categories: emacs,org-mode,org-ref
  :date:     2014/06/26 20:16:43
  :updated:  2014/06/26 20:16:43
  :END:

Some LaTeX citations look like \cite[pretext][post text]{key}. Here I explore parsing a link like [[cite:(pre text)(post text)key]]. Note you cannot use [] inside the link, as it breaks the link syntax. Also, these links must be wrapped in =[[]]= because of the parentheses and spaces in the parentheses. This is a very different approach than used [[http://kitchingroup.cheme.cmu.edu/blog/2014/05/19/Exporting-citations-with-biblatex/][here]] which used the description of the link to define the pre and post text. The disadvantage of that approach is that the key is hidden, whereas in this approach it is not; you can see the key and pre/post text.

The basic strategy will be to use a regexp to parse the link path. The regexp below is pretty hairy, but basically it looks for optional text in () and uses numbered groups to store what is found. Then, we use what we found to construct the LaTeX syntax. We redefine the function in org-ref that gets the key for clicking, and we redefine the cite format function. The result is that we retain the click functionality that shows us what the key refers to.

#+BEGIN_SRC emacs-lisp
(defun org-ref-parse-key (s)
  "return pretext, posttext and bibtex key from a string like \"(pre text)(post text)bibtexkey\""
  (string-match "\\(?1:(\\(?2:[^)]*\\))\\)?\\(?3:(\\(?4:[^]]*\\))\\)?\\(?5:.*\\)" s)
  ;; return pretext postext key
  (list (match-string 2 s) (match-string 4 s) (match-string 5 s)))

(defun org-ref-get-bibtex-key-and-file (&optional key)
  "returns the bibtex key and file that it is in. If no key is provided, get one under point"
 (interactive)
 (let ((org-ref-bibliography-files (org-ref-find-bibliography))
       (file))
   (unless key
     ;; get the key
     (setq key (nth 2 (org-ref-parse-key (org-ref-get-bibtex-key-under-cursor)))))
   (setq file     (catch 'result
		    (loop for file in org-ref-bibliography-files do
			  (if (org-ref-key-in-file-p key (file-truename file))
			      (throw 'result file)))))
   (cons key file)))

(defun org-ref-format-cite (keyword desc format)
   (cond
    ((eq format 'latex)
     (let* ((results (org-ref-parse-key keyword))
	    (pretext (nth 0 results))
	    (posttext (nth 1 results))
	    (key (nth 2 results)))
       (concat "\\cite"
	       (when pretext (format "[%s]" pretext))
	       (when posttext (format "[%s]" posttext))
	       (format "{%s}" key))))))
#+END_SRC

#+RESULTS:
: org-ref-format-cite

#+BEGIN_SRC emacs-lisp
(org-ref-format-cite "(pre text)(post text)key" nil 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text][post text]{key}

#+BEGIN_SRC emacs-lisp
(org-ref-format-cite "(pre text)key" nil 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text]{key}

#+BEGIN_SRC emacs-lisp
(org-ref-format-cite "key" nil 'latex)
#+END_SRC

#+RESULTS:
: \cite{key}

It looks like they all work! Let us test the links: cite:mehta-2014-ident-poten, [[cite:(pre text)mehta-2014-ident-poten]] and [[cite:(pre text)(post text)biskup-2014-insul-ferrom-films]]. a multiple citation cite:mehta-2014-ident-poten,thompson-2014-co2-react,calle-vallejo-2013-number.

This seems to work from an export point of view. You can not mix multiple citations with this syntax, and I did not define the html export above. Otherwise, it looks like this might be a reasonable addition to org-ref.


* DONE Org-mode is awesome
  CLOSED: [2014-07-12 Sat 16:12]
  :PROPERTIES:
  :categories: org
  :date:     2014/07/12 16:12:48
  :updated:  2014/07/14 16:31:42
  :END:

I made a video on Youtube (https://www.youtube.com/watch?v=fgizHHd7nOo) demonstrating how we use Emacs and org-mode. The source for that file can be found [[file:why-org-mode.org][here]].

There are some other good org-mode videos out there. Here are few:

- [[https://www.youtube.com/watch?v%3DoJTwQvgfgMM][Emacs Org-mode - a system for note-taking and project planning]] (Carsten Dominik)
- [[https://www.youtube.com/watch?v%3D6W82EdwQhxU][Hack Emacs - An Overview of Org Mode]]
- [[https://www.youtube.com/watch?v%3DnsGYet02bEk][Hack Emacs - Org Mode In Depth: Managing Structure]]
- [[http:www.youtube.com/watch?v%3D1-dUkyn_fZA][Emacs + org-mode + python in reproducible research; SciPy 2013 Presentation]]
- [[http:www.youtube.com/watch?v%3DJyvpSVl4_dg][Using org-ref]]
- [[http://vimeo.com/99167082][Emacs Org-mode Bibtex Screencast]]

* DONE Jump to most recent timestamp in an org document
  CLOSED: [2014-08-14 Thu 11:45]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/14 11:45:42
  :updated:  2014/08/14 11:45:42
  :END:
Timestamps serve many purposes in an org document: deadlines, scheduled time, record of time, etc... Depending on the document, you may have organized a set of tasks logically, but you are completing them in some other order. Here, we examine how to jump to the most recent timestamp.

Here is an example of an inactive (will not cause an agenda entry) timestamp [2014-08-07 Thu] and an active timestamp <2014-08-13 Wed>. You can also have times in the timestamps, e.g. <2014-08-14 Thu 13:00> or <2014-08-14 Thu 14:00>. There may be a timestamp that is in the future [2014-08-15 Fri].

We may have some headlines with a due date.

** Headline with duedate
   DEADLINE: <2014-08-17 Sun>

** Analyzing the timestamps in this file
We can get a sorted list of the time-stamps like this.

#+BEGIN_SRC emacs-lisp
(sort (org-element-map (org-element-parse-buffer) 'timestamp
	(lambda (timestamp)
	  (org-element-property :raw-value timestamp))) 'org-time>)
#+END_SRC

#+RESULTS:
| [2014-08-15 Fri] | <2014-08-14 Thu 14:00> | <2014-08-14 Thu 13:00> | <2014-08-13 Wed> | [2014-08-07 Thu] |

Interestingly, the deadline timestamp does not appear in this list! I am not sure why it doesn't show up.

Unfortunately, having those time stamps in this buffer will complicate further analysis, because org-mode will parse them too. What we need to do next is figure out a way to sort with the positions, so we can jump to it.

Side bar: How to sort a cons list based on the first element of each cons cell? Here are two examples.

#+BEGIN_SRC emacs-lisp :results raw
(cl-sort '((3 . "a") (2 . "b") (1 . "c")) '> :key 'car)
#+END_SRC

#+RESULTS:
((3 . a) (2 . b) (1 . c))


#+BEGIN_SRC emacs-lisp :results raw
(sort '((3 . "a") (2 . "b") (1 . "c"))
      (lambda (a b)
	(> (car a) (car b))))
#+END_SRC

#+RESULTS:
((3 . a) (2 . b) (1 . c))


So, we just build up a sorted cons-list of timestamps and their beginning characters, then pop the top entry off and jump to it. Here is the code. Running this jumps directly to the most recent (which could be in the future) timestamp.

#+BEGIN_SRC emacs-lisp :results raw
(let ((timestamps (cl-sort
		   (org-element-map (org-element-parse-buffer) 'timestamp
		     (lambda (timestamp)
		       `(,(org-element-property :raw-value timestamp) . ,(org-element-property :begin timestamp))))
		   'org-time> :key 'car)))
  (goto-char
   (cdr
    (pop timestamps))))
#+END_SRC

There are some limitations here:
1. Only free timestamps are shown, timestamps associated with deadlines and scheduling do not appear to be considered here. You would need to map over the headlines and check for deadlines to get these I think.
2. The code block above finds the timestamp with the highest time value, which may be in the future. It is an interesting exercise to think about how to find the most recent timestamp that is not in the future.
* DONE What we are using org-mode for
  CLOSED: [2014-08-08 Fri 14:00]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/08 13:59:59
  :updated:  2014/08/08 13:59:59
  :END:
About four years ago I picked up Emacs again, because of org-mode. It started as an experiment to see if org-mode might be a solution to managing my growing list of obligations. Since then I have learned alot about org-mode. I was feeling reflective today, so here I describe a few of the things we are doing with it now, besides just organizing my obligations! I have found org-mode useful for many other things.

** This blog
Every entry of this blog is written in org-mode and exported to an HTML file (https://github.com/jkitchin/jmax/blob/master/user/blogofile.el) that is compiled by blogofile (http://www.blogofile.com/). Thanks to some emacs-lisp code, each post has the raw org-file linked to it so you can see exactly how the page was made.

** Writing large technical documents/books
I used org-mode to write my book on modeling materials properties using density functional theory (http://kitchingroup.cheme.cmu.edu/dft-book). This book has over 100 Python code examples that are integrated with the narrative text, including equations, figures and references.

I also used org-mode to write "Python computations in Science and Engineering" (http://kitchingroup.cheme.cmu.edu/pycse), which shows that Python can be used extensively for solving scientific and engineering problems.

These "books" are not published in any traditional way; their value is in the org-format where the code is executable.

** Writing scientific publications

The following papers from our group were written in org-mode. The supporting information files all contain embedded org-files with all of the code used to generate figures and analysis, as well as the data to make the papers reproducible and reusable. These papers include both experimental and computational work.

1. Spencer D. Miller, Vladimir V. Pushkarev, Andrew J. Gellman and John R. Kitchin, Simulating Temperature Programmed Desorption of Oxygen on Pt(111) Using DFT Derived Coverage Dependent Desorption Barriers, Topics In Catalysis, 57(1), 106-117 (2013). http://link.springer.com/article/10.1007%2Fs11244-013-0166-3

2. Alex Hallenbeck and John R. Kitchin, Effects of O_2 and SO_2 on the Capture Capacity of a Primary-Amine Based Polymeric CO2 Sorbent, I&ECR, 52 (31), 10788-10794 (2013). https://doi.org/10.1021/ie400582a.

3. Mehta, Prateek; Salvador, Paul; Kitchin, John, Identifying Potential BO_2 Oxide Polymorphs for Epitaxial Growth Candidates", ACS Applied Materials and Interfaces, 6(5), 3630-3639 (2014). http://pubs.acs.org/doi/full/10.1021/am4059149.

4. Zhongnan Xu and John R Kitchin, Relating the Electronic Structure and Reactivity of the 3d Transition Metal Monoxide Surfaces, Catalysis Communications, 52, 60-64 (2014),        https://doi.org/10.1016/j.catcom.2013.10.028.

We have several more papers in progress that are being written in org-mode. We just export the LaTeX manuscript (https://github.com/jkitchin/jmax/blob/master/ox-manuscript.el) and submit it. My students now use org-mode to produce reports for their PhD qualifying exams, MS project reports, and other internal reports I ask them to write. I have used it for writing internal memos and reports for the Department. I occasionally use it to write technical emails.

** Writing software

I have used org-mode in three serious software development efforts. So far, all of them have been in emacs-lisp.

1. org-ref is an extension of org-mode that provides deeply integrated citation and referencing in org-mode documents using bibtex as the reference database. The software is written in emacs-lisp, in an org-file, and the source code is tangled out of it. See https://github.com/jkitchin/jmax/blob/master/org/org-ref.org. The code is about 1700 lines long.

2. doi-utils is a smaller package that allows you to download bibtex entries and pdfs from a DOI. See https://github.com/jkitchin/jmax/blob/master/org/doi-utils.org

3. org-show is an emacs-lisp package for using org-files to give presentations. See  https://github.com/jkitchin/jmax/blob/master/org/org-show.org.

This literate programming approach to writing software is interesting. You can document via narrative text what the software does, and how it works, sometimes as you write the code. I have not used org-mode to write a large Python project yet. I am considering it.

** Giving presentations

For some examples of using org-show, see:
  a. Org-mode is awesome  https://www.youtube.com/watch?v=fgizHHd7nOo
  b. Using org-ref https://www.youtube.com/watch?v=JyvpSVl4_dg
  c. The org-show show https://www.youtube.com/watch?v=JZ8RK-R9O_g
  d. Scipy 2014: Python in teaching https://www.youtube.com/watch?v=IsSMs-4GlT8
  e. Scipy 2013: reproducible research talk in Beamer generated from org-mode  https://www.youtube.com/watch?v=1-dUkyn_fZA

Presenting from org-mode takes some adjustment, but it really lets you strip something down to what is important, with few distractions!

** Teaching classes

The book on dft that I wrote has been used in a graduate course several times. The last time I taught it we actually used the org-file directly in class during lecture, and I had students turn in their assignments with org-mode. That was done on a computer cluster I administer, so everyone had the emacs/org-mode setup I created.

This fall I am teaching a graduate MS course in chemical reaction engineering. It will be taught from org-mode. All the notes are in org-mode, all the assignments are in org-mode. Emacs will communicate with a git-server I run that will provide authenticated delivery of course materials and assignments. Grading is all done through org-mode, with the grades stored directly in the assignment files. The source code behind this effort is located for now at https://github.com/jkitchin/jmax/tree/master/techela. There is no course website; students will run M-x techela, select their course, and the syllabus.org file will be updated and shown, with org-links to get assignments, open lecture notes, etc... The students will do all this on their own laptop, with a preinstalled version of https://github.com/jkitchin/jmax, Enthought Canopy Python, git, ssh and TeXLive.

I am needless to say, very excited to try it!

** Managing obligations
And of course, I still use org-mode to manage my daily job responsibilities as a professor:
1. Running a research group of ~10 PhD and MS students, managing grants, paper deadlines,... I share org-files with my students through Dropbox to keep some activities coordinated.
2. Teaching classes
3. Department, college, university committee duties
4. Preparing for professional meetings
5. Conference organization
6. Keeping track of personal things
7. etc...

I just counted the lines of the files in my org-agenda:

#+BEGIN_SRC sh
wc -l ~/Dropbox/org-mode/*.org
#+END_SRC

#+RESULTS:
#+begin_example
    346 /c/Users/jkitchin/Dropbox/org-mode/abet.org
     28 /c/Users/jkitchin/Dropbox/org-mode/advising.org
    854 /c/Users/jkitchin/Dropbox/org-mode/cheme-undergrad-committee.org
    745 /c/Users/jkitchin/Dropbox/org-mode/committees.org
  11187 /c/Users/jkitchin/Dropbox/org-mode/contacts.org
    451 /c/Users/jkitchin/Dropbox/org-mode/department.org
      2 /c/Users/jkitchin/Dropbox/org-mode/email+gnus.org
     91 /c/Users/jkitchin/Dropbox/org-mode/email.org
    611 /c/Users/jkitchin/Dropbox/org-mode/gilgamesh.org
     91 /c/Users/jkitchin/Dropbox/org-mode/gnus.org
      6 /c/Users/jkitchin/Dropbox/org-mode/group.org
    749 /c/Users/jkitchin/Dropbox/org-mode/journal.org
    274 /c/Users/jkitchin/Dropbox/org-mode/lab.org
    352 /c/Users/jkitchin/Dropbox/org-mode/manuscripts.org
    117 /c/Users/jkitchin/Dropbox/org-mode/master.org
   1239 /c/Users/jkitchin/Dropbox/org-mode/meetings.org
    513 /c/Users/jkitchin/Dropbox/org-mode/notes.org
    118 /c/Users/jkitchin/Dropbox/org-mode/org-course.org
    182 /c/Users/jkitchin/Dropbox/org-mode/personal.org
    485 /c/Users/jkitchin/Dropbox/org-mode/prj-doe-early-career.org
    109 /c/Users/jkitchin/Dropbox/org-mode/prj-exxon.org
     25 /c/Users/jkitchin/Dropbox/org-mode/prj-gcep-project.org
     15 /c/Users/jkitchin/Dropbox/org-mode/prj-simonseed.org
     83 /c/Users/jkitchin/Dropbox/org-mode/prj-task-191.org
      8 /c/Users/jkitchin/Dropbox/org-mode/prj-task-203.org
    349 /c/Users/jkitchin/Dropbox/org-mode/prj-task-97-mat.org
    238 /c/Users/jkitchin/Dropbox/org-mode/proposals.org
    378 /c/Users/jkitchin/Dropbox/org-mode/research.org
      7 /c/Users/jkitchin/Dropbox/org-mode/researcher-ids.org
    110 /c/Users/jkitchin/Dropbox/org-mode/reviews.org
    619 /c/Users/jkitchin/Dropbox/org-mode/software.org
    629 /c/Users/jkitchin/Dropbox/org-mode/tasks.org
      2 /c/Users/jkitchin/Dropbox/org-mode/taxes.org
  21013 total
#+end_example

hmm... that contacts file is big. My agenda might speed up if I move it out. It is not so slow that it bothers me though. That happens when you dump gmail contacts to org-contacts. That is even after cleaning up all the obviously bad entries!

** Summary
There is hardly an area in my work not touched by org-mode these days!


* DONE Using Pymacs to integrate Python into Emacs
  CLOSED: [2014-10-19 Sun 09:33]
  :PROPERTIES:
  :categories: python,emacs
  :date:     2014/10/19 09:33:08
  :updated:  2014/10/19 09:33:08
  :END:
 [[https://github.com/pinard/Pymacs][Pymacs]] is a project that aims to integrate Python into Emacs, and vice versa. In this post, I am going to examine the Python into Emacs integration. I cloned the git repository, ran make install, and setup my init.el file like this, as suggested in the manual.

#+BEGIN_EXAMPLE
(add-to-list 'load-path (expand-file-name "Pymacs" starter-kit-dir))
(require 'pymacs)
(autoload 'pymacs-apply "pymacs")
(autoload 'pymacs-call "pymacs")
(autoload 'pymacs-eval "pymacs" nil t)
(autoload 'pymacs-exec "pymacs" nil t)
(autoload 'pymacs-load "pymacs" nil t)
(autoload 'pymacs-autoload "pymacs")
#+END_EXAMPLE

Pymacs provides some mapping of Python modules to emacs-lisp functions. You load modules in emacs-lisp, and then a dash-mangled version of the Python functions are available, /in emacs lisp/. Here is an example. We will load numpy, and find the maximum element of an array. For comparison, here is the Python script.

#+BEGIN_SRC python
import numpy as np
print np.max(np.array([[1, 1], [2, 4]]))
#+END_SRC

#+RESULTS:
: 4

Now, the corresponding emacs version using Pymacs.

#+BEGIN_SRC emacs-lisp
(pymacs-load "numpy" "np-")
(np-max (np-array '((1 1) (2 4))))
#+END_SRC

#+RESULTS:
: 4

Neat! The dot notation is basically replaced with dash notation, and we use a lisp list as the argument instead of an array. Otherwise, this looks almost identical. Now, let us consider something more complicated, and get the determinant of the array. We add a PREFIX to the load statement for numpy.linalg similar to what we would do in Python:

#+BEGIN_SRC python
import numpy as np
import numpy.linalg as la
print la.det(np.array([[1, 1], [2, 4]]))
#+END_SRC

#+RESULTS:
: 2.0

And in emacs-lisp:

#+BEGIN_SRC emacs-lisp
(pymacs-load "numpy" "np-")
(pymacs-load "numpy.linalg" "la-")
(la-det (np-array '((1 1) (2 4))))
#+END_SRC

#+RESULTS:
: 2.0

We can call functions from matplotlib to make a figure. For example:

#+BEGIN_SRC emacs-lisp
(pymacs-load "matplotlib.pyplot" "plt-")
(let* ((x  '(1 2 3 4))
       (y  (mapcar (lambda (z) (* z z)) x)))
  (plt-plot x y)
  (plt-xlabel "x values")
  (plt-ylabel "x$^2$")
  (plt-savefig "plt-pymacs.png"))
#+END_SRC

#+RESULTS:


[[./plt-pymacs.png]]

This was a little subtle. It was necessary to save the lists as variables, and use the variables in the plot command.

I am not sure what this offers over just having a Python block present in org-mode though. Maybe it is more useful in emacs-lisp libraries where you want to bring in some numerical analysis. Or if you have some custom library of Python you would like to use in elisp. Here is a highly contrived example. Suppose we have a Python module with this special function that converts an argument to "J":

#+BEGIN_SRC python :tangle my_python.py
def special_func(x):
    return "J"
#+END_SRC

In Python, we might use it like this:

#+BEGIN_SRC python
import my_python as mp
print [mp.special_func(x) for x in [1, 2, 3]]
#+END_SRC

#+RESULTS:
: ['J', 'J', 'J']

We can import the module, and use the function in emacs-lisp too. The underscore in the function name is turned into a dash, which is a little confusing, but it works otherwise.

#+BEGIN_SRC emacs-lisp
(pymacs-load "my_python" "mp-")
(mapcar 'mp-special-func '(1 2 3))
#+END_SRC

#+RESULTS:
| J | J | J |


It does not seem possible to do everything though. For example, It is not clear how to pass functions through either side. For example, this does not work for fsolve, although it seems like it should.

#+BEGIN_SRC emacs-lisp
(pymacs-load "scipy.optimize" "so-")

(defun objective (x)
  (- x 5))

(so-fsolve 'objective 3)
#+END_SRC

I get an error like this:
#+BEGIN_EXAMPLE
Pymacs loading scipy.optimize...done
pymacs-report-error: Python: Emacs: "(wrong-type-argument number-or-marker-p (pymacs-python . 47))"
#+END_EXAMPLE

The Python equivalent is here:
#+BEGIN_SRC python
from scipy.optimize import fsolve
def objective(x):
    return x - 5

print fsolve(objective, 3)
#+END_SRC

#+RESULTS:
: [ 5.]

There is an open question on StackOverflow [[http://stackoverflow.com/questions/25471580/can-you-use-a-function-as-an-argument-to-a-python-function-in-pymacs][here]] on this issue. Overall, I find the project very interesting. It would be awesome if you could extend emacs more easily in other languages, especially scripting languages such as Python that have numerical and plotting capabilities. Right now, this is possible in limited ways. For example, Xah Lee describes an [[http://ergoemacs.org/emacs/elisp_perl_wrapper.html][approach]] where an arbitrary script can take data on stdin, process it, and output the results to stdout. Emacs can capture this and use it to modify the buffer. This uses the =shell-command= features in Emacs. These scripts could be written in Python, Perl, Ruby, etc... This seems like a simpler and more flexible approach, except that it requires creating the shell commands and putting them on the executable path (as opposed to having Python modules on a PYTHONPATH). These lack the deep integration of documentation you get with emacs-lisp and Python functions.


#+BEGIN_SRC emacs-lisp
(pymacs-eval "lambda x:x-5")
#+END_SRC

#+RESULTS:
| lambda | (&rest arguments) | (pymacs-apply (quote (pymacs-python . 1922)) arguments) |

#+BEGIN_SRC emacs-lisp
(pymacs-exec "import scipy.optimize as so")

(defun objective (x)
  (- x 5))

(pymacs-call "so.fsolve" 'objective 3)
#+END_SRC
* DONE Storing solutions to homework problems in an org-file with encrypted headlines
  CLOSED: [2014-08-19 Tue 09:30]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/19 09:30:27
  :updated:  2014/08/19 09:30:27
  :END:
I have been creating homework problems in org-files, which I distribute to students. A recurring dilemma I have had is where do you put the solution? If you put it in a separate file, there is not an elegant way to keep them connected, so if you end up changing the problem, it is easy to forget to update the solution.

Recently I learned about org-crypt. This allows you to encrypt the content of a heading. All you have to do is tag a heading with :crypt:, and when you save the file it will encrypt the contents of the heading. In this example, we try that out. We will use symmetric encryption, which just uses a password. Here is the setup for your init.el file.

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;;  set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

#+RESULTS:

Now, for the question. What is the Answer to the Ultimate Question of Life, The Universe, and Everything?


The solution is encrypted below. Note, all you have to do is tag the headline with crypt, and when you save the file, you will be prompted for a passphrase and to confirm the passphrase (I used the passphrase 1234). To decrypt the solution, run elisp:org-decrypt-entries. You may get a warning that autosave can cause leakage, and a request to disable it for this buffer. You can do that. Then, You will be prompted for a passphrase for symmetric encryption. Enter 1234, and you should be rewarded with the solution!

This could be a good way to keep solutions and problems together, as long as you can remember the passphrase! The passphrase would obviously have to be different for each problem (or one passphrase would open all solutions), and unguessable for this to be useful. Once again, Emacs can help you out. We just need to remember one secret passphrase, and then compute a cryptographic hash that we could use for the encrypting passphrase. We could then just concatenate our secret key onto some unchanging property of the problem that will not change, and generate a secret password. Like this for example.

#+BEGIN_SRC emacs-lisp
(let ((my-secret-key "1234"))
  (format "This problem passphrase is %s." (secure-hash 'md5 (concat my-secret-key (org-get-heading t t)))))
#+END_SRC

#+RESULTS:
: This problem passphrase is 68ea5a0eefc31d34ee5d562891e4dcb7.

For this to work, you must keep your secret key absolutely secret, or someone could generate the passwords for each assignment. Also, you must make sure the property of the problem you use never changes, or you will not be able to generate a usable passphrase again! The property could be a filename, or problem label. All that really matters is that it not change, since the solution is stored in encrypted form. It might make sense to write the problem passphrase to a file, as long as the file is not accessible to students, and it is somehow always kept up to date.

Some other notes:
1. org-mode seems to save the passphrase somewhere, so when you save the file after decrypting it, the headline is automatically reencrypted with the same password.
2. If you remove the crypt tag, the file is saved in plain text
3. This seems to rely on GnuPG being installed on your computer.

** Solution							      :crypt:
-----BEGIN PGP MESSAGE-----
Version: GnuPG v1

jA0EAwMC+AOmtRnbOY1gyZddPkzbHlSfApI4u29D3n05rwScSnx2jlmT8dPP6xES
DWGfnByJhtHC/IhbmmECPH4F88lT8RsY8Ng6RmZjGsUJDXZzLBv3CITAgwx4sXz0
hq0dv4HvlW4OUNBoM6HzflMhJO/YlYHf00H94nzZ9T++mW+foHLMSiJ3XdglWMIA
EwIz2uBmwEnsOLQ4M5W3lTBmet9iVKsT
=Zo7c
-----END PGP MESSAGE-----


* DONE Find the most recent timestamp that is not in the future
  CLOSED: [2014-08-17 Sun 09:42]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/17 09:42:44
  :updated:  2014/08/17 09:42:44
  :END:
In a previous post, we looked at a way to jump to a timestamp ([[http://kitchingroup.cheme.cmu.edu/blog/2014/08/14/Jump-to-most-recent-timestamp-in-an-org-document][post]]). A limitation of that post was that our definition of "most recent" included timestamps in the future. Here we further constrain the definition to mean the most recent that is not in the future.

We will do that by getting the list of timestamps, then filtering out future ones.

Here is a list of time-stamps
1. [2014-08-17 Sun]
2. <2014-08-17 Sun 08:23>
3. <2014-08-17 Sun 09:23>
4. [2014-08-18 Mon]
5. [2014-08-17 Sun 13:00]
6. [2014-08-16 Sat 13:00]

Here is the code that filters out future timestamps. As I write this it is <2014-08-17 Sun 08:31>.

#+BEGIN_SRC emacs-lisp :results raw
(let ((now (with-temp-buffer
             ;; sachac suggested this way to get a timestamp of "now"
	     (org-insert-time-stamp (org-read-date t t ".") t)
	     (buffer-string))))
  (remove-if (lambda (entry) (org-time> (car entry) now))
	     (cl-sort
	      (org-element-map (org-element-parse-buffer) 'timestamp
		(lambda (timestamp)
		  (cons (org-element-property :raw-value timestamp) (org-element-property :begin timestamp))))
	      'org-time> :key 'car)))
#+END_SRC

#+RESULTS:
((<2014-08-17 Sun 08:31> . 811) (<2014-08-17 Sun 08:23> . 613) ([2014-08-17 Sun] . 593) ([2014-08-16 Sat 13:00] . 712))


You can see that only past timestamps show up in the list, and they are sorted with the most recent timestamp. The =remove-if= function is in 'cl, which is loaded in my init files. You may have to require that if you don't load it in your init files.

* DONE Colorized text in Emacs
  CLOSED: [2014-09-14 Sun 14:23]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/09/14 14:23:05
  :updated:  2014/09/14 14:33:32
  :END:

As I continue investigating Emacs + org-mode as a platform for creating applications, it has come up a few times that it would be useful to display colored text. For example, in a summary report of a git repo, you might want to see some information in red, e.g. if you have uncommitted changes, and some information in green, e.g. the repo is clean and consistent with a remote.

We can set colors on a string in Emacs like this:

#+BEGIN_SRC emacs-lisp
(propertize "Red Text" 'font-lock-face '(:foreground "red"))
#+END_SRC

The only tricky part is that we need to insert the text into a font-locked buffer to see it. That is also a tad tricky to illustrate in a code block, so here is a way to try it:

#+BEGIN_SRC emacs-lisp
(re-search-forward "-> ")
(insert
  (propertize "Red Text" 'font-lock-face '(:foreground "red")))
#+END_SRC

#+RESULTS:

-> Red Text

The red text does not show in the HTML post, so this is a screenshot of what it looks like in my buffer:

[[./images/red-text.png]]

Now, here is how we might use this in a summary report. Say we have a git repo, and we want to know various facts about it. We can get information about tracked/ untracked and modified files like this:

#+BEGIN_SRC sh
git status --porcelain
#+END_SRC
#+RESULTS:
:  M _blog/blog.html
:  M _blog/blog.org
: A  _blog/images/red-text.png

This shows we have two tracked, but modified files, and on added but not committed file. We can use this code to show if we have any untracked files.

#+BEGIN_SRC emacs-lisp
(let ((n 0) s)
  (dolist (line (split-string
		 (shell-command-to-string "git status --porcelain")
		 "\n"))
    (when (string-match "^\\?\\?" line)
      (setq n (+ 1 n))))
  (if (> n 0)
      (setq s (propertize (format "%s untracked files" n)
			  'font-lock-face '(:foreground "red")))
    (setq s (propertize "No untracked files"
			'font-lock-face '(:foreground "forest green"))))
  (re-search-forward "->")
  (insert s))
#+END_SRC

#+RESULTS:

->No untracked files

In HTML (i.e. the blog post) you cannot really see the green text, so here is a screenshot illustrating it.
[[./images/git-untracked-files.png]]

Similarly, we can check for modified files. We add a wrinkle and add a tooltip like text that shows the output of the git command.

#+BEGIN_SRC emacs-lisp
(let ((n 0)
      (output (shell-command-to-string "git status --porcelain"))
      s)
  (dolist (line (split-string
		 output
		 "\n"))
    (when (string-match "^ M" line)
      (setq n (+ 1 n))))
  (if (> n 0)
      (setq s (propertize (format "%s modified files" n)
                          'help-echo output
			  'font-lock-face '(:foreground "red")))
    (setq s (propertize "No modified files"
			'font-lock-face '(:foreground "forest green"))))
  (re-search-forward "-> ")
  (insert s))
#+END_SRC

#+RESULTS:

-> 2 modified files

That looks like this in emacs:

 [[./images/git-modified.png]]


That is the main idea in this post. You can create strings with properties, and use code to determine what they e.g. what color the text is, etc... There are lots of properties listed at http://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html that might be helpful in an application. Here are some previous posts that examined similar ideas.

- Read-only text http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/

- Tool tips: http://kitchingroup.cheme.cmu.edu/blog/2013/04/12/Tool-tips-on-text-in-Emacs/

- Invisible text (this is not exactly a property, but it is similar)
http://kitchingroup.cheme.cmu.edu/blog/2014/02/06/Invisible-text-in-emacs/
* DONE Make some org-sections read-only
  CLOSED: [2014-09-13 Sat 13:50]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2014/09/13 13:50:49
  :updated:  2014/09/13 13:50:49
  :END:
There are times where I want an org-file to be /partly/ read-only. For example, there might be instructions that should not be modified. In this post we consider how to implement that. For now, we only want an org-section to be read-only, and we will designate those sections by a tag read_only. Then, the idea is that a hook function would be run when the org-file is loaded, and mark regions of text as read-only before the user can do anything.

In Emacs, you can mark a section of text, and set it to have a property of read-only. So, we can just map over the entries, and any heading that is tagged as read_only can be made read-only!

Here we set the first few characters of this buffer to be read-only.
#+BEGIN_SRC emacs-lisp
(add-text-properties 1 8 '(read-only t))
#+END_SRC

#+RESULTS:

Emacs is semi-serious about what read-only means. You cannot even change properties of read-only text, unless you set inhibit-read-only as a variable.

#+BEGIN_SRC emacs-lisp
(let ((inhibit-read-only t))
 (remove-text-properties 1 8 '(read-only t)))
#+END_SRC

#+RESULTS:
: t

Now, we can map over the entries in this buffer, and set any heading tagged read_only to actually be that way like this.

#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda ()
		   (let* ((element (org-element-at-point))
			  (begin (org-element-property :begin element))
			  (end (org-element-property :end element)))
		     (add-text-properties begin end '(read-only t))))
		 "read_only")
#+END_SRC

#+RESULTS:
| t |

To get this to work when org-mode is turned on, we just wrap it in a function, add the function to a hook, and a function to undo the read-only behavior. I found that if I use the end reported by org-element-at-point, it includes the first character of the next section, we take one away from the end to avoid that.

#+BEGIN_SRC emacs-lisp
(defun org-mark-readonly ()
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((element (org-element-at-point))
	    (begin (org-element-property :begin element))
	    (end (org-element-property :end element)))
       (add-text-properties begin (- end 1) '(read-only t
                                              font-lock-face '(:background "yellow")))))
   "read_only")
 (message "Made readonly!"))


(defun org-remove-readonly ()
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((element (org-element-at-point))
	    (begin (org-element-property :begin element))
	    (end (org-element-property :end element))
	    (inhibit-read-only t))
	 (remove-text-properties begin (- end 1) '(read-only t font-lock-face '(:background "yellow")))))
     "read_only"))

(add-hook 'org-mode-hook 'org-mark-readonly)
#+END_SRC

#+RESULTS:
| org-mark-readonly | #[nil \300\301\302\303\304$\207 [org-add-hook before-save-hook org-encrypt-entries nil t] 5] | org-mode-reftex-setup | org-clock-load | #[nil \305\306\n>\203 \307\n\310\311#\210\307\312\313#\210\307\314\315#\210\306\n>\203, \307\n\316\317#\210\307\n\320\321#\210\322\n>\203> \307\323\324#\210\307\325\324#\210\326\n>\203P \307\n\327\317#\210\307\n\330\321#\210\331\n>\203_ \332\311\n\333BC\334#\210\335\n>\203k \332\311\336\334#\210\337\n>\203w \332\311\340\334#\210\341\342\343\344\311$\210\345\342\311"\210\342\207 [org-mouse-context-menu-function org-mouse-features org-mouse-map org-mode-map org-outline-regexp org-mouse-context-menu context-menu org-defkey [mouse-3] nil [mouse-3] org-mouse-show-context-menu [down-mouse-1] org-mouse-down-mouse [C-drag-mouse-1] org-mouse-move-tree [C-down-mouse-1] org-mouse-move-tree-start yank-link [S-mouse-2] org-mouse-yank-link [drag-mouse-3] move-tree [drag-mouse-3] [down-mouse-3] activate-stars font-lock-add-keywords (0 (` (face org-link mouse-face highlight keymap (, org-mouse-map))) (quote prepend)) t activate-bullets ((^[ \n]*\([-+*]\ | [0-9]+[.)]\) + (1 (` (face org-link keymap (, org-mouse-map) mouse-face highlight)) (quote prepend)))) activate-checkboxes ((^[ \n]*\([-+*]\ | [0-9]+[.)]\) +\(\[[ X]\]\) (2 (` (face bold keymap (, org-mouse-map) mouse-face highlight)) t))) ad-add-advice org-open-at-point (org-mouse-open-at-point nil t (advice lambda nil (let ((context (org-context))) (cond ((assq :headline-stars context) (org-cycle)) ((assq :checkbox context) (org-toggle-checkbox)) ((assq :item-bullet context) (let ((org-cycle-include-plain-lists t)) (org-cycle))) ((org-footnote-at-reference-p) nil) (t ad-do-it))))) around ad-activate] 5] | #[nil \300\301\302\303\304$\207 [org-add-hook change-major-mode-hook org-show-block-all append local] 5] | #[nil \300\301\302\303\304$\207 [org-add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | turn-on-flyspell |
#+TBLFM:

That seem to be all there is. After executing the code above, when I open this file, the next section is read-only! I can use the other function to remove that if I need to edit it. Score one for Emacs + org-mode!

** Read-only section						  :read_only:

This text is so important, it should be read-only.

** Editable section

You can do what you want here. Like add text.


* DONE Randomize a list in Emacs
  CLOSED: [2014-09-06 Sat 10:08]
  :PROPERTIES:
  :categories: emacs_lisp
  :date:     2014/09/06 10:08:04
  :updated:  2014/09/06 15:11:50
  :END:

I have an application where I have a list of userids, and I want to randomize the order of the list. Today, I explore some ways to do that. The first idea is to simply mimic the algorithm in Python's random.shuffle algorithm.

#+BEGIN_SRC python
    def shuffle(self, x, random=None):
        """x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.

        """

        if random is None:
            random = self.random
        _int = int
        for i in reversed(xrange(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = _int(random() * (i+1))
            x[i], x[j] = x[j], x[i]
#+END_SRC

It looks like we loop through the elements, and swap them at random.

We have a similar feature for xrange in emacs-lisp:

#+BEGIN_SRC emacs-lisp
(number-sequence 1 5)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

Note that number-sequence includes the last value, unlike xrange. And for reverse:

#+BEGIN_SRC emacs-lisp
(reverse (number-sequence 1 5))
#+END_SRC

#+RESULTS:
| 5 | 4 | 3 | 2 | 1 |

Of course, we can select random numbers:
#+BEGIN_SRC emacs-lisp
(random 5) ; random between 0 and 5
#+END_SRC

#+RESULTS:
: 4

Last, we need to work out how to swap to elements. It looks like this will swap elements 2 and 3. We store element 3 temporarily, set 3 to 2, and then set 2 to the temporarily stored value of 3.
#+BEGIN_SRC emacs-lisp
(let* ((L '(1 2 3 4))
       (tmp (nth 3 L)))
  (setf (nth 3 L) (nth 2 L))
  (setf (nth 2 L) tmp)
L)
#+END_SRC

#+RESULTS:
| 1 | 2 | 4 | 3 |

So, now we can shuffle our list.

#+BEGIN_SRC emacs-lisp
(setq userids '(user1 user2 user3 user4 user5 user6))

(defun swap (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (nth el1 LIST)))
    (setf (nth el1 LIST) (nth el2 LIST))
    (setf (nth el2 LIST) tmp)))

;; now run the loop
(loop for i in (reverse (number-sequence 1 (1- (length userids))))
      do (let ((j (random (+ i 1))))
	   (swap userids i j)))

userids
#+END_SRC

#+RESULTS:
| user4 | user6 | user3 | user2 | user1 | user5 |

The order has certainly changed. It is a little difficult to tell how randomized it actually is, but what is important for my application is that the order is different each time I use it. It looks like this will accomplish that objective. I think this basically implements the algorithm in the Python random.shuffle code. That code does something a little differently. It generates a random float between 0-1, multiplies it by i + 1, and converts the result to an integer. We directly get an integer in the range of 0 to i + 1. I think the result is practically the same.

Finally, let us wrap the whole thing up in a nice neat function for future use. We will use elt instead of nth so it works for arrays too.

#+BEGIN_SRC emacs-lisp
(defun swap (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))


(defun shuffle (LIST)
  "Shuffle the elements in LIST.
shuffling is done in place."
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
	do (let ((j (random (+ i 1))))
	     (swap LIST i j)))
  LIST)
#+END_SRC

#+RESULTS:
: shuffle

Example usage for a list:
#+BEGIN_SRC emacs-lisp
(shuffle '(user1 user2 user3 user4 user5 user6))
#+END_SRC

#+RESULTS:
| user4 | user2 | user3 | user5 | user6 | user1 |

And for a vector:
#+BEGIN_SRC emacs-lisp
(shuffle [user1 user2 user3 user4 user5 user6])
#+END_SRC

#+RESULTS:
: [user3 user2 user6 user4 user5 user1]

** Addendum
Artur at http://endlessparentheses.com suggested one can use psetf to swap values. Thanks for the tip, I was not aware of that cool function. It evaluates the values first, then sets them, so there is no need for a temporary storage of a value! Here is an example usage. We could rewrite our swap function like this if we wanted.

#+BEGIN_SRC emacs-lisp
(let ((LIST '(1 2 3 4 5)))
  (psetf (elt LIST 2) (elt LIST 1)
	 (elt LIST 1) (elt LIST 2))
LIST)
#+END_SRC

#+RESULTS:
| 1 | 3 | 2 | 4 | 5 |


* DONE Using Mac gestures in Emacs
  CLOSED: [2014-08-31 Sun 10:20]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/08/31 10:20:46
  :updated:  2014/08/31 10:20:46
  :END:

I recently got a MacBook Air, and I have been exploring what you can do with it and Emacs. The Mac trackpad has some interesting gestures that are useful in Emacs. For example, you can scroll the buffer by moving two fingers up or down the trackpad. Or tap the trackpad with two fingers to get the equivalent of a right click. I was curious what other gestures could be used effectively in Emacs. Emacs does not capture all of the trackpad gestures, but it does capture the two finger swipe left and right as a triple-wheel-left or right key. We can use that to switch buffers. Normally one uses C-x leftarrow or right arrow to do that, but with the trackpack we can use a gesture!

The gesture triggers a triple-wheel key, which we can bind to an function. This code does that.

#+BEGIN_SRC emacs-lisp
(global-set-key [triple-wheel-left] 'previous-buffer)
(global-set-key [triple-wheel-right] 'next-buffer)
#+END_SRC
#+RESULTS:
: next-buffer

This scrolls through buffers blazingly fast! Almost unusably fast. If you move very slow, you can get some control and switch one buffer at a time. Interestingly, I see these messages while gesturing slowly:

#+BEGIN_EXAMPLE
<wheel-left> is undefined
<double-wheel-left> is undefined
<wheel-right> is undefined
<double-wheel-right> is undefined
<wheel-right> is undefined [2 times]
<double-wheel-right> is undefined
#+END_EXAMPLE

We need a custom function that has some kind of delay to slow down the buffer switching. Here is an idea. We will store a value in a global variable, and only switch buffers when it is true. After we switch the buffer we set the variable to nil, and activate a timer to reset the variable to t after a short delay. say one second. Here it is.

#+BEGIN_SRC emacs-lisp
(defvar *my-previous-buffer* t
  "can we switch?")

(defun my-previous-buffer ()
  (interactive)
  (message "custom prev: *my-previous-buffer*=%s" *my-previous-buffer*)
  (when *my-previous-buffer*
    (previous-buffer)
    (setq *my-previous-buffer* nil)
    (run-at-time "1 sec" nil (lambda ()
			       (setq *my-previous-buffer* t)))))

(defvar *my-next-buffer* t
  "can we switch?")

(defun my-next-buffer ()
  (interactive)
  (message "custom prev: *my-next-buffer*=%s" *my-next-buffer*)
  (when *my-next-buffer*
    (next-buffer)
    (setq *my-next-buffer* nil)
    (run-at-time "1 sec" nil (lambda ()
			       (setq *my-next-buffer* t)))))

(global-set-key [triple-wheel-right] 'my-previous-buffer)
(global-set-key [triple-wheel-left] 'my-next-buffer)
#+END_SRC

#+RESULTS:
: my-next-buffer

Note I reversed the left/right order. It seems that swiping left triggers the triple-wheel-right key. Go figure. Anyway, this makes the gesture actually usable, as it only changes one buffer at a time, with a short delay before you can change the buffer again. It is not a groundbreaking addition to Emacs, but it satisfied a curiousity itch for the day for me.


* DONE Editing org-mode python source blocks in an external editor (Canopy)
  CLOSED: [2014-09-28 Sun 14:41]
  :PROPERTIES:
  :categories: orgmode,python
  :date:     2014/09/28 14:41:49
  :updated:  2014/09/28 14:41:49
  :END:
Continuing on the [[http://kitchingroup.cheme.cmu.edu/blog/2014/09/27/Improved-debugging-of-Python-code-blocks-in-org-mode/][last post]] about leveraging org-mode and python syntax checkers, here we consider using (heresy alert...) an external editor for Python src blocks in org-mode. Why would we consider such insanity? Because, for beginners, environments such as Canopy are (IMHO) easier to use, and better than anything I have used in Emacs. And, I still want the framework of org-mode for content, just a better Python code writing environment.

This problem has some interesting challenges. I would like a command that opens a code block with its contents in the Canopy editor, or that creates a code block if needed. We need to figure out that context based on the cursor position. We will use the same temporary file strategy as used before, so Canopy has something to read and save to. We need to wait for Canopy to finish, which will be tricky because it returns as soon as you run it. Finally, I want the code block to run after it is put back in the org-file, so that the results are captured.

This code block implements the idea, and the comments in the code explain what each section is doing.

#+BEGIN_SRC emacs-lisp
(defun edit-in-canopy ()
  (interactive)
  (let* ((eop (org-element-at-point))
	 ;; use current directory for temp file so relative paths work
	 (temporary-file-directory ".")
	 (tempfile))

    ;; create a tempfile.
    (setq tempfile (make-temp-file "canopy" nil ".py"))

    ;; figure out what to do
    (when
	;; in an existing source block. we want to edit it.
	(and (eq 'src-block (car eop))
	     (string= "python" (org-element-property :language eop)))

      ;; put code into tempfile
      (with-temp-file tempfile
        (insert (org-element-property :value eop))))

    ;; open tempfile in canopy
    (shell-command (concat "canopy " tempfile))
    (sleep-for 2) ;; startup time. canopy is slow to showup in
		  ;; ps. This gives it some time to do that. Canopy
		  ;; returns right away, so we sleep while there is
		  ;; evidence that it is open. We get that evidence
		  ;; from ps by searching for canopy.app.main, which
		  ;; seems to exist in the output while Canopy is
		  ;; open.
    (while
	(string-match "canopy\.app\.main"
		      (shell-command-to-string "ps aux"))
      ;; pause a while, then check again.
      (sleep-for 1))

    ;; Canopy has closed, so we get the new script contents
    (let ((new-contents (with-temp-buffer
			  (insert-file-contents tempfile)
			  (buffer-string))))
      (cond
       ;; replace existing code block contents
       ((and (eq 'src-block (car eop))
	     (string= "python" (org-element-property :language eop)))
	(goto-char (org-element-property :begin eop))
	(search-forward (org-element-property :value eop))
	(replace-match (concat new-contents "\n")))
       ;; create new code block
       (t
	(insert
	 (format "\n#+BEGIN_SRC python
%s
,#+END_SRC
" new-contents))
	;; go into new block so we can run it.
	(previous-line 2))))

    ;; delete the tempfile so they do not accumulate
    (delete-file tempfile)
    ;; and run the new block to get the results
    (org-babel-execute-src-block)))
#+END_SRC

#+RESULTS:
: edit-in-canopy

That seems to work. It is difficult to tell from this post the function works as advertised. You can see it in action here: http://www.youtube.com/watch?v=-noKrT1dfFE.


#+BEGIN_SRC python
from scipy.integrate import odeint


def dydx(y, x):
    k = 1
    return -k * y

print odeint(dydx, 1, [0, 1])

import numpy as np
print np.exp(-1)
#+END_SRC

#+RESULTS:
: [[ 1.        ]
:  [ 0.36787947]]
: 0.367879441171



We created this code block externally.

#+BEGIN_SRC python
print 'hello'
#+END_SRC

#+RESULTS:
: hello


** Summary thoughts
Opening Canopy is a little slow (and that is coming from someone who opens Emacs ;). But, once it is open it is pretty nice for writing code, with the interactive Ipython console, and integrated help. Yes, it is probably possible to get Emacs to do that too, and maybe it will do that one day. Canopy does it today.

Unfortunately, this code will not work on Windows, most likely, since it relies on the ps program. There does seem to be a tasklist function in Windows that is similar, but it seems that Canopy runs as pythonw in that function, which is not very specific.
* DONE Improved debugging of Python code blocks in org-mode
  CLOSED: [2014-09-27 Sat 15:27]
  :PROPERTIES:
  :categories: orgmode,python
  :date:     2014/09/27 15:27:40
  :updated:  2014/09/27 15:27:40
  :END:
Writing and running code blocks in org-mode is awesome, when it works. I find as the code blocks get past a certain size though, it can be tedious to debug, especially for new users. Since I am teaching 59 students to use Python in org-mode, I see this issue a lot! They lack experience to avoid many simple errors, and to find and fix them. Even in my hands, I do not always want to be switching to Python mode to run and debug blocks.

org-mode src-blocks offer a unique challenge for the usual tools like pylint and pychecker, because the code does not exist in a file. In this post, I will explore developing some functions that do syntax checking on a src block. We will use a simple method which will write the block to a temporary file, and to the checking on that block. Then, we will create temporary buffers with the output.

Here is the first idea. We create a temp file in the working directory, write the code to it, and run pychecker, pyflakes and pep8 on the file.

#+BEGIN_SRC emacs-lisp
(defun org-pychecker ()
  "Run pychecker on a source block"
  (interactive)
  (let ((eop (org-element-at-point))
	(temporary-file-directory ".")
	(tempfile))
    (when (and (eq 'src-block (car eop))
	       (string= "python" (org-element-property :language eop)))
      (setq tempfile (make-temp-file "pychecker" nil ".py"))
      ;; create code file
      (with-temp-file tempfile
	(insert (org-element-property :value eop)))
      (switch-to-buffer "*pychecker*")
      (erase-buffer)
      (insert "pychecker\n=================\n")
      (insert
       (shell-command-to-string (format "pychecker %s" (file-name-nondirectory tempfile))))
      (insert "\npyflakes\n=================\n")
      (insert
       (shell-command-to-string (format "pyflakes %s" (file-name-nondirectory tempfile))))
      (insert "\npep8\n=================\n")
      (insert
       (shell-command-to-string (format "pep8 %s" (file-name-nondirectory tempfile))))
      (delete-file tempfile))))
#+END_SRC

Here is a sample code block with some errors in it.
#+BEGIN_SRC python
a = 5  # a variable we do not use


def f(x, y):  # unused argument
    return x - b # undefined variable

print 6 * c
#+END_SRC

#+RESULTS:

On the code block above, that function leads to this output.

#+BEGIN_EXAMPLE
pychecker
=================
Processing module pychecker63858xo0 (pychecker63858xo0.py)...
  Caught exception importing module pychecker63858xo0:
    File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/pychecker/pcmodules.py", line 540, in setupMainCode()
      module = imp.load_module(self.moduleName, handle, filename, smt)
    File "pychecker63858xo0.py", line 7, in <module>()
      print 6 * c
  NameError: name 'c' is not defined

Warnings...

pychecker63858xo0:1: NOT PROCESSED UNABLE TO IMPORT

pyflakes
=================
pychecker63858xo0.py:5: undefined name 'b'
pychecker63858xo0.py:7: undefined name 'c'

pep8
=================
pychecker63858xo0.py:5:17: E261 at least two spaces before inline comment

#+END_EXAMPLE

That is pretty helpful, but it gives us line numbers we cannot directly access in our code block. We can open the code block in Python mode, and then navigate to them, but that is likely to make the buffer with this information disappear. It would be better if we could just click on a link and go to the right place. Let us explore what we need for that.

We need to parse the output to get the line numbers, and then we can construct org-links to those places in the src block. pyflakes, pep8 and pylint look like the easiest to get. A way to get to the line would be a lisp function that moves to the beginning of the code block, and then moves forward n lines. We will use a regular expression on each line of the output of pyflakes and pep8 to get the line number. We will construct an org-link to go to the source block at the line.

In this long code block, we create a function that will run pyflakes, pep8 and pylint, and create a new buffer with links to the issues it finds. Finally, we apply this as advice on executing org-babel-execute:python so it only runs when we execute a python block in org-mode. This is a long block, because I have made it pretty feature complete.

#+BEGIN_SRC emacs-lisp
(defun org-py-check ()
  "Run python check programs on a source block.
Opens a buffer with links to what is found."
  (interactive)
  (let ((eop (org-element-at-point))
	(temporary-file-directory ".")
        (cb (current-buffer))
	(n) ; for line number
	(content) ; error on line
	(pb "*org pycheck*")
	(pyflakes-status nil)
	(link)
	(tempfile))

    (unless (executable-find "pyflakes")
      (error "pyflakes is not installed."))

    (unless (executable-find "pep8")
      (error "pep8 not installed"))

    (unless (executable-find "pylint")
      (error "pylint not installed"))

    ;; rm buffer if it exists
    (when (get-buffer pb) (kill-buffer pb))

    ;; only run if in a python code-block
    (when (and (eq 'src-block (car eop))
	       (string= "python" (org-element-property :language eop)))

      ;; tempfile for the code
      (setq tempfile (make-temp-file "pychecker" nil ".py"))
      ;; create code file
      (with-temp-file tempfile
	(insert (org-element-property :value eop)))

      (let ((status (shell-command
		     (format "pyflakes %s" (file-name-nondirectory tempfile))))
	    (output (delete "" (split-string
				(with-current-buffer "*Shell Command Output*"
				  (buffer-string)) "\n"))))
	(setq pyflakes-status status)
	(kill-buffer "*Shell Command Output*")
	(when output
	  (set-buffer (get-buffer-create pb))
	  (insert (format "\n* pyflakes output (status=%s)
pyflakes checks your code for errors. You should probably fix all of these.

" status))
	  (dolist (line output)
	    ;; get the line number
	    (if
		(string-match (format "^%s:\\([0-9]*\\):\\(.*\\)"
				      (file-name-nondirectory tempfile))
			      line)
		(progn
		  (setq n (match-string 1 line))
		  (setq content (match-string 2 line))
		  (setq link (format "[[elisp:(progn (switch-to-buffer-other-window \"%s\")(goto-char %s)(forward-line %s))][%s]]\n"
				     cb
				     (org-element-property :begin eop)
				     n
				     (format "Line %s: %s" n content))))
	      ;; no match, just insert line
	      (setq link (concat line "\n")))
	    (insert link))))

      (let ((status (shell-command
		     (format "pep8 %s" (file-name-nondirectory tempfile))))
	    (output (delete "" (split-string
				(with-current-buffer "*Shell Command Output*"
				  (buffer-string)) "\n"))))
	(kill-buffer "*Shell Command Output*")
	(when output
	  (set-buffer (get-buffer-create pb))
	  (insert (format "\n\n* pep8 output (status = %s)\n" status))
	  (insert "pep8 is the [[http://legacy.python.org/dev/peps/pep-0008][officially recommended style]] for writing Python code. Fixing these will usually make your code more readable and beautiful. Your code will probably run if you do not fix them, but, it will be ugly.

")
	  (dolist (line output)
	    ;; get the line number
	    (if
		(string-match (format "^%s:\\([0-9]*\\):\\(.*\\)"
				      (file-name-nondirectory tempfile))
			      line)
		(progn
		  (setq n (match-string 1 line))
		  (setq content (match-string 2 line))
		  (setq link (format "[[elisp:(progn (switch-to-buffer-other-window \"%s\")(goto-char %s)(forward-line %s))][%s]]\n"
				     cb
				     (org-element-property :begin eop)
				     n
				     (format "Line %s: %s" n content))))
	      ;; no match, just insert line
	      (setq link (concat line "\n")))
	    (insert link))))

      ;; pylint
      (let ((status (shell-command
		     (format "pylint -r no %s" (file-name-nondirectory tempfile))))
	    (output (delete "" (split-string
				(with-current-buffer "*Shell Command Output*"
				  (buffer-string)) "\n"))))
	(kill-buffer "*Shell Command Output*")
	(when output
	  (set-buffer (get-buffer-create pb))
	  (insert (format "\n\n* pylint (status = %s)\n" status))
	  (insert "pylint checks your code for errors, style and convention. It is complementary to pyflakes and pep8, and usually more detailed.

")

	  (dolist (line output)
	    ;; pylint gives a line and column number
	    (if
		(string-match "[A-Z]:\\s-+\\([0-9]*\\),\\s-*\\([0-9]*\\):\\(.*\\)"
			      line)
		(let ((line-number (match-string 1 line))
		      (column-number (match-string 2 line))
		      (content (match-string 3 line)))

		  (setq link (format "[[elisp:(progn (switch-to-buffer-other-window \"%s\")(goto-char %s)(forward-line %s)(forward-line 0)(forward-char %s))][%s]]\n"
				     cb
				     (org-element-property :begin eop)
				     line-number
				     column-number
				     line)))
	      ;; no match, just insert line
	      (setq link (concat line "\n")))
	    (insert link))))

      (when (get-buffer pb)
	(switch-to-buffer-other-window pb)
	(goto-char (point-min))
	(insert "Press q to close the window\n")
	(org-mode)
	(org-cycle '(64))
	;; make read-only and press q to quit
	(setq buffer-read-only t)
	(use-local-map (copy-keymap org-mode-map))
	(local-set-key "q" #'(lambda () (interactive) (kill-buffer))))

      (unless (= 0 pyflakes-status)
	(forward-line 4)
	(error "pyflakes exited non-zero. please fix errors"))
      ;; final cleanup and delete file
      (delete-file tempfile)
      (switch-to-buffer-other-window cb))))


(defadvice org-babel-execute:python (before pychecker)
  (org-py-check))

(ad-activate 'org-babel-execute:python)
#+END_SRC

#+RESULTS:
: org-babel-execute:python

Now, when I try to run this code block, which has some errors in it:

#+BEGIN_SRC python
a = 5  # a variable we do not use


def f(x, y):  # unused argument
    return x - b # undefined

print 6 * c
#+END_SRC

#+RESULTS:

I get a new buffer with approximately these contents:

#+BEGIN_SRC org
Press q to close the window

,* pyflakes output (status=1)
pyflakes checks your code for errors. You should probably fix all of these.

[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 5))][Line 5:  undefined name 'b']]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 7))][Line 7:  undefined name 'c']]


,* pep8 output (status = 1)
pep8 is the [[http://legacy.python.org/dev/peps/pep-0008][officially recommended style]] for writing Python code. Fixing these will usually make your code more readable and beautiful. Your code will probably run if you do not fix them, but, it will be ugly.

[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 5))][Line 5: 17: E261 at least two spaces before inline comment]]


,* pylint (status = 22)pylint checks your code for errors, style and convention. It is complementary to pyflakes and pep8, and usually more detailed.

No config file found, using default configuration
,************* Module pychecker68224dkX
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 1)(forward-line 0)(forward-char 0))][C:  1, 0: Invalid module name "pychecker68224dkX" (invalid-name)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 1)(forward-line 0)(forward-char 0))][C:  1, 0: Missing module docstring (missing-docstring)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 1)(forward-line 0)(forward-char 0))][C:  1, 0: Invalid constant name "a" (invalid-name)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 4)(forward-line 0)(forward-char 0))][C:  4, 0: Invalid function name "f" (invalid-name)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 4)(forward-line 0)(forward-char 0))][C:  4, 0: Invalid argument name "x" (invalid-name)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 4)(forward-line 0)(forward-char 0))][C:  4, 0: Invalid argument name "y" (invalid-name)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 4)(forward-line 0)(forward-char 0))][C:  4, 0: Missing function docstring (missing-docstring)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 5)(forward-line 0)(forward-char 15))][E:  5,15: Undefined variable 'b' (undefined-variable)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 4)(forward-line 0)(forward-char 9))][W:  4, 9: Unused argument 'y' (unused-argument)]]
[[elisp:(progn (switch-to-buffer-other-window "blog.org")(goto-char 9180)(forward-line 7)(forward-line 0)(forward-char 10))][E:  7,10: Undefined variable 'c' (undefined-variable)]]

#+END_SRC

Each of those links takes me to either the line, or the position of the error (in the case of pylint)! I have not tested this on more than a handful of code blocks, but it has worked pretty nicely on them so far!

Of course, you must have pyflakes, pep8 and pylint installed. But those are all easily installed with pip as far as I can tell.



* DONE Generating an atomic stoichiometric matrix
  CLOSED: [2014-09-23 Tue 14:25]
  :PROPERTIES:
  :categories: python,thermodynamics
  :date:     2014/09/23 14:25:36
  :updated:  2014/09/23 14:25:36
  :END:

In computing thermodynamic properties with specqies, it is sometimes required to get a matrix that specifies number of each type of atom in each species. For example, we can create this by hand as follows:

|   | H2O | CO2 | H2 | CO |
| H | 2   | 0   | 2  | 0  |
| C | 0   | 1   | 0  | 1  |
| O | 1   | 2   | 0  | 1  |

Here we aim to generate this table from code. Why? 1. We can readily add species to it if we do it right. 2. We are less likely to make mistakes in generation of the table, and if we do, it will be faster to regenerate the table.

We will start with a list of strings that represent the chemical formula of each species. We will need to parse the strings to find the elements, and number of them. We will use a fairly naive regular expression to parse a chemical formula. Basically, we match a capital letter + an optional lowercase letter, followed by an optional number. Here is a fictitous example to illustrate. Note, this will not work with formulas that have parentheses, or charges.

#+BEGIN_SRC python
import re
m = re.findall('([A-Z][a-z]?)(\d?)' , 'ArC2H6Cu56Pd47Co')
print m
#+END_SRC

#+RESULTS:
: [('Ar', ''), ('C', '2'), ('H', '6'), ('Cu', '5'), ('Pd', '4'), ('Co', '')]

Now, we need to loop over the species, and collect all the elements in them. We will just make a list of all of the elments, and then get the set.

#+BEGIN_SRC python
import re

# save for future use
cf = re.compile('([A-Z][a-z]?)(\d?)')

species = ['H2O', 'CO2', 'H2', 'CO2']

all_elements = []

for s in species:
    for el, count in re.findall(cf, s):
        all_elements += [el]

print set(all_elements)
#+END_SRC

#+RESULTS:
: set(['H', 'C', 'O'])

Finally, we can create the table. We need to loop through each element, and then through each species


#+BEGIN_SRC python :results value
import re

# save for future use
cf = re.compile('([A-Z][a-z]?)(\d?)')

species = ['H2O', 'CO2', 'H2', 'CO2']

all_elements = []

for s in species:
    for el, count in re.findall(cf, s):
        all_elements += [el]

atoms = set(all_elements)

# we put a placeholder in the first row
counts = [[""] + species]
for e in atoms:
    # store the element in the first column
    count = [e]
    for s in species:
        d = dict(re.findall(cf, s))
        n = d.get(e, 0)
        if n == '': n = 1
        count += [int(n)]
    counts += [count]

# this directly returns the array to org-mode
return counts
#+END_SRC

#+RESULTS:
|   | H2O | CO2 | H2 | CO2 |
| H |   2 |   0 |  2 |   0 |
| C |   0 |   1 |  0 |   1 |
| O |   1 |   2 |  0 |   2 |

For this simple example it seems like a lot of code. If there were 200 species though, it would be the same code! Only the list of species would be longer. It might be possible to avoid the two sets of looping, if you could represent the stoichiometric matrix as a sparse matrix, i.e. only store non-zero elements. The final comment I have is related to the parsing of the chemical formulas. Here we can only parse simple formulas. To do better than this would require a pretty sophisticated parser, probably built on the grammar of chemical formulas. The example [[http://www.onlamp.com/pub/a/python/2006/01/26/pyparsing.html?page=3][here]] implements the code above using pyparsing, and could probably be extended to include more complex formulas such as (CH3)3CH.


* DONE Showing what data went into a code block on export
  CLOSED: [2014-09-22 Mon 12:25]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/09/22 12:25:29
  :updated:  2014/09/22 12:33:51
  :END:
Sometimes I define variables in the header of a code block and then use the code to analyze the data. In org-mode this is super, and you can read the file and easily see what is going on.

When you export the file, however, the information is lost, and in the exported result you cannot see what data went into a code block, or figure out where it is from.

Today we examine how to get that information into exported code. First, we setup a simple example that will do what need.

#+tblname: tbl-data
| x | y |
|---+---|
| 1 | 1 |
| 2 | 4 |
| 3 | 9 |

Now a code block that has a defined variable in the header that uses data from the table defined above.

#+name: print-table
#+BEGIN_SRC python :var data=tbl-data :results value
return data
#+END_SRC

#+RESULTS: print-table
| 1 | 1 |
| 2 | 4 |
| 3 | 9 |

During export, org-mode does some interesting things to the document, including removing the headers from the code blocks, which makes it impossible to access them inside the export. The headers are apparently removed during org-babel-exp-process-buffer. It does not appear possible to advise this function because it processes the whole buffer at once, and we need to save data for each code block.

So, we will have to preprocess the buffer to get the parameters on each block, and then put the parameters in the export afterwards. For this, we can use a filter. We will preprocess the buffer to get names of tables, and parameters of src-blocks. (I suppose we could put this preprocessing in the advice function, but I tend to avoid advice when possible).

Here is how we can get a list of the table-names indicating their name or that they are results (results are enclosed in ()).

#+BEGIN_SRC emacs-lisp
(org-element-map (org-element-parse-buffer) 'table
  (lambda (element)
    (or (org-element-property :name element) (org-element-property :results element))))
#+END_SRC

#+RESULTS:
| tbl-data | (print-table) | () | () |

Similarly, here is the list of parameters for each block.

#+BEGIN_SRC emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element)
    (org-element-property :parameters element)))
#+END_SRC

#+RESULTS:
| :var data=tbl-data :results value |

Now, we combine them with filters to modify the output. First, we preprocess to get each list, and then in the filter, we will pop off each value and insert the data. We will also get the language for each code block, and add that in the export. We use a filter because we are not modified the transcoded text, simply adding some new text in front of it.

#+BEGIN_SRC emacs-lisp
(defun ox-mrkup-filter-table (text back-end info)
  (let ((tblname (pop tblnames)))
    (message "tblname is \"%s\"" tblname)
    ; pop does not remove nil from the list, so we do it here.
    (when (null tblname) (setq tblnames (cdr tblnames)))
    (cond
     ((listp tblname)  ; from results
      (concat (format "<br>Results: %s" (car tblname)) text))
     ((null tblname)   ; no name
      text)
     (t ; everything else
      (concat (format "<br>Table name: %s" tblname) text)))))

(defun ox-mrkup-filter-src-block (text back-end info)
  (let ((params (pop src-params))
	(lang (pop src-langs)))
    (when (null params) (setq src-params (cdr src-params)))
    (if params
	(concat (format "<pre>Language = %s\nParameters = %s</pre>" lang params) text)
      text)))

;; preprocess to get table names, src parameters and languages.
(let ((tblnames (org-element-map (org-element-parse-buffer) 'table
		  (lambda (element)
		    (or (org-element-property :name element)
			(org-element-property :results element)))))

      (src-params (org-element-map (org-element-parse-buffer) 'src-block
		    (lambda (element)
		      (org-element-property :parameters element))))

      (src-langs (org-element-map (org-element-parse-buffer) 'src-block
		    (lambda (element)
		      (org-element-property :language element))))

      ;; register the filters
      (org-export-filter-table-functions '(ox-mrkup-filter-table))
      (org-export-filter-src-block-functions '(ox-mrkup-filter-src-block)))

  ;; and export the result
  (browse-url (org-export-to-file 'html "custom-src-table-export-3.html")))
#+END_SRC

#+RESULTS:
: #<process open custom-src-table-export-3.html>


Here is the resulting html file: [[./custom-src-table-export-3.html]] which shows the new export behavior. It might not be too difficult to make links between the parameters and the tables, but it would require parsing the :parameters string. For now, this makes it easy enough to read in HTML where the data is coming from (assuming fluency in org-mode header arguments!).

Special thanks to Aaron Ecay, and Charles Berry on the org-mode mailing list for pointing me towards a solution.

* DONE Getting information about named tables in exported org-files
  CLOSED: [2014-09-21 Sun 14:34]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/09/21 14:34:50
  :updated:  2014/09/21 14:34:50
  :END:
I have found that the names of tables typically get lost when you export an org-file to another format like html or pdf. Since we may use named tables as data sources, it can become unclear in the exported file what has happened, or which table data came from. In this post, we examine how to include the name of a table in exported html. Here are two named tables =tbl-1= and =tbl-2= that will form the beginning of our effort.

#+tblname: tbl-1
| x | y |
|---+---|
| 1 | 2 |
| 2 | 3 |

Another table, so we have something to work with later.

#+name: tbl-2
| a |
|---|
| 5 |
| 3 |


Org-buffers get parsed into nested lists, with properties usually in plists. It will be convenient to get a list of the keys for an element, so we can tell what information we have on each element. Some code for this can be found here: http://www.emacswiki.org/emacs/mon-plist-utils.el. Rather than use that recursive approach, here we just loop through the plist and accumulate the keys.

#+name: elisp-keys
#+BEGIN_SRC emacs-lisp
(defun plist-get-keys (plist)
  (interactive)
  (let ((keys))
    (while (car plist)
      (add-to-list 'keys (car plist) t)
      (setq plist (cddr plist)))
    keys))

; example of use
(plist-get-keys '(:a 1 :b 3 :parent '(another plist)))
#+END_SRC

#+RESULTS: elisp-keys
| :a | :b | :parent |


Now, when we parse a buffer for elements, we get a nested lisp data structure, and the best I can tell is we need the cadr of that list to get to the relevant plist of properties. So, here, we map over the tables, and see what properties are available.


#+BEGIN_SRC emacs-lisp
(org-element-map
    (org-element-parse-buffer) 'table
  (lambda (element)  (plist-get-keys (cadr element))))
#+END_SRC

#+RESULTS:
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :name    | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :name    | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :results | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :caption | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :name    | :caption | :parent |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :results | :parent  |         |

Depending on when you run the codeblock above (i.e. I ran it at different stages of development of this document, so some tables after this point are shown), you see different results; some of the tables are RESULTS from code blocks with no names, and two tables have a caption.

Let us now map over the tables and see if they have names. We add an unnamed table, and a named table, both with captions.

#+Caption: an unnamed table of category counts.
| category | count |
|----------+-------|
| emacs    | 4     |
| orgmode  | 3     |

#+name: python-table
#+Caption: an named table of category counts on python.
| category | count |
|----------+-------|
| Python   |     4 |
| pep8     |     3 |

Here we get the names of the tables. Only three tables have names, and several are unnamed.

#+BEGIN_SRC emacs-lisp
(org-element-map
    (org-element-parse-buffer) 'table
  (lambda (element)  (plist-get (cadr element) :name)))
#+END_SRC
#+RESULTS:
| tbl-1 | tbl-2 | python-table |


If you think that is a little awkward, I agree. Here is probably a better way to get that information using features in org-mode..

#+BEGIN_SRC emacs-lisp
(org-element-map
    (org-element-parse-buffer) 'table
  (lambda (element)  (org-element-property :name element)))
#+END_SRC
#+RESULTS:
| tbl-1 | tbl-2 | python-table |


I had thought we could use a [[http://orgmode.org/manual/Advanced-configuration.html][filter]] to add the name to each table. The issue with filtering is that we get the transcoded text directly, and no practical way to get back to the element it came from (at least none I could find). I have previously used filters (e.g. for [[http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][changing links on export]]) for something like this, but it involved parsing the document once, then exporting, and iterating through the results to change the output. I want to do something different here, and fix the issue on the export.

That requires us to derive a new backend for export, with our new function for formatting. This will give us access to the actual table element, and we can use the original transcoding function to get most of the table, and our own code to modify that before it is exported.

Basically, we just want to add an HTML anchor to the table with some text to indicate the table name. With the anchor we can then link to it elsewhere like this:

#+BEGIN_HTML
 <a href="#tbl-2"> See tbl-2</a>
#+END_HTML

We just define a function that satisfies the transcoding function signature (element contents info), and if our element has a :name property, we will prepend it onto the usual table output for html. We will go ahead and code in some conditional code for different backends, although for now only handle the html backend.

#+BEGIN_SRC emacs-lisp
(defun my-table-format (table contents info)
  (let ((tblname (org-element-property :name table)))
    (cond
     ((eq (elt (plist-get info :back-end) 2) 'html)
      (concat
       (when tblname
	 (format "<br>TBLNAME: <a name=\"%s\"></a>%s<br>" tblname tblname))
       (org-html-table table contents info))))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((table . my-table-format)))


(browse-url (org-export-to-file 'my-html "custom-src-table-export.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-src-table-export.html>

That seems to do it. You may need to see [[./custom-src-table-export.html]] to see the newly annotated tables, since they probably do not show up in the blog post.


* DONE A git status Emacs modeline
  CLOSED: [2014-09-19 Fri 09:36]
  :PROPERTIES:
  :categories: emacs,git
  :date:     2014/09/19 09:36:21
  :updated:  2014/09/19 09:36:21
  :END:
I am using git more and more in Emacs, and I would like a way to know the status of the git repo I am working in by looking at the modeline. I know about [[https://github.com/magit/magit][magit]], and other git modes, but none of them provide something as easy as useful as say [[https://github.com/magicmonty/bash-git-prompt][bash-git-prompt]] in the bash shell, which is to say I do not want to run a command to see the status (I might as well be in the shell then). Part of this need comes from a project with hundreds of git repos in it, and I want convenient status when I open any one of them.

Here, I want to emulate the bash-git-prompt feature in the Emacs modeline where it will show you when you are in a git repo, and then some basic information like what branch you are on, the number of untracked, modified files, and the commit status with respect to a remote. First, we only want this when we are in a git repo. We can check for that like this. The command in this block returns a string that starts with fatal when not in a git repo.

#+BEGIN_SRC emacs-lisp
(not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir")))
#+END_SRC

#+RESULTS:
: t

Let us wrap that in a nice function so we can use it later..
#+BEGIN_SRC emacs-lisp
(defun in-git-p ()
  (not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir"))))

(in-git-p)
#+END_SRC

#+RESULTS:
: t

Next, we would like to know how many untracked, modified and other (e.g. unmerged, deleted, etc...) files we have. We can get this from  =git status --porcelain=. I am going to set these to be red if they are not zero, so they stand out, and be green otherwise. We will also store a list of each file type so we can make a tooltip on the counter to see what is there.

#+BEGIN_SRC emacs-lisp
(defun git-parse-status ()
  (interactive)
  (let ((U 0)   ; untracked files
	(M 0)   ; modified files
	(O 0)   ; other files
	(U-files "")
	(M-files "")
	(O-files ""))
    (dolist (line (split-string
		   (shell-command-to-string "git status --porcelain")
		   "\n"))
      (cond

       ;; ignore empty line at end
       ((string= "" line) nil)

       ((string-match "^\\?\\?" line)
	(setq U (+ 1 U))
	(setq U-files (concat U-files "\n" line)))

       ((string-match "^ M" line)
	(setq M (+ 1 M))
	(setq M-files (concat M-files "\n" line))
	)

       (t
        (message "detected other in %s" line)
	(setq O (+ 1 O))
	(setq O-files (concat O-files "\n" line)))))

    ;; construct propertized string
    (concat
     "("
     (propertize
      (format "M:%d" M)
      'face (list ':foreground (if (> M 0)
				   "red"
				 "forest green"))
      'help-echo M-files)
     "|"
     (propertize
      (format "U:%d" U)
      'face (list ':foreground (if (> U 0)
				   "red"
				 "forest green"))
      'help-echo U-files)
     "|"
     (propertize
      (format "O:%d" O)
      'face (list ':foreground (if (> O 0)
				   "red"
				 "forest green"))
      'help-echo O-files)
      ") ")))

(git-parse-status)
#+END_SRC

#+RESULTS:
: (M:1|U:2|O:0)

Finally, let us get the branch we are on, and the commits with respect to a remote. We can do that like this. We use some unicode characters to indicate what direction things go, e.g. an up arrow to indicate you need to push, and a down arrow to indicate you should pull.

#+BEGIN_SRC emacs-lisp
(defun git-remote-status ()
  (interactive)
  (let* (;; get the branch we are on.
	 (branch (s-trim
		  (shell-command-to-string
		   "git rev-parse --abbrev-ref HEAD")))
	 ;; get the remote the branch points to.
	 (remote (s-trim
		  (shell-command-to-string
		   (format "git config branch.%s.remote" branch))))
         (remote-branch (s-trim
			 (shell-command-to-string
			  "git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)")))
	 (commits (split-string
		   (s-trim
		    (shell-command-to-string
		     (format
		      "git rev-list --count --left-right HEAD...%s"
		      remote-branch)))))
	 (local (nth 0 commits))
	 (remotes (nth 1 commits)))
    (concat
     "["
     (propertize
      (format "%s" branch)
      'face (list :foreground "magenta"))
     "|"
     (format "↑%s|↓%s" local remotes)
     "]")))

(git-remote-status)
#+END_SRC

#+RESULTS:
: [source|↑0|↓0]

Now, we can finally put this together in a little minor mode. We add an element to the mode-line-format variable that evaluates those functions. When we turn off the minor mode, we remove the element from the modeline.

#+BEGIN_SRC emacs-lisp
(define-minor-mode git-mode
  "minor mode to put git repo status in modeline"
  nil nil nil
  (let ((git-modeline '(:eval (if (not (in-git-p))
				  ""
				(concat
				 (git-remote-status)
				 (git-parse-status))))))
    (if git-mode
	;; put in modeline
	(push git-modeline mode-line-format)
      ;; remove from modeline
      (setq mode-line-format
	    (-remove (lambda (x)
		       (equal x git-modeline))
		     mode-line-format)))))
#+END_SRC

#+RESULTS:

This leads to a modeline that looks like this (when my mouse is hovered over the M):

[[./images/git-modeline.png]]

This seems to have some performance issue, since pretty much everytime I type a key, it updates the modeline, and runs git. That is too often. Let us redefine the mode here so we have a minimum time between updates, say 15 seconds. We will store the last time updated, and the last value of the mode-line. Then each time the modeline updates, if the time since the last update is greater than our interval, then we will run the git commands. Otherwise, we just use the old modeline value.

#+BEGIN_SRC emacs-lisp
(defvar git-modeline-last-update (float-time) "Last time we updated")
(defvar git-modeline-update-interval 15 "Minimum time between update in seconds")
(defvar git-modeline "" "Last value of the modeline")

(define-minor-mode git-mode
  "minor mode to put git repo status in modeline"
  nil nil nil
  (let ((git-modeline '(:eval (if
				  (> (- (float-time) git-modeline-last-update)
				     git-modeline-update-interval)
				  ;; we are updating
				  (setq git-modeline
					(if (not (in-git-p))
					    ""
					  (setq  git-modeline-last-update (float-time))
					  (concat
					   (git-remote-status)
					   (git-parse-status))))

			      ;; use last value of the modeline
			      git-modeline))))
    (if git-mode
	;; put in modeline
	(push git-modeline mode-line-format)
      ;; remove from modeline
      (setq mode-line-format
	    (-remove (lambda (x)
		       (equal x git-modeline))
		     mode-line-format)))))
#+END_SRC

#+RESULTS:

That does it I think. I don't have any performance issues here now. I have not tested this super thoroughly on many git repos, but it seems to be pretty consistent and correct so far. The remote status code is where there is the most probability for issues. I still do not know that part of git very well.  I wonder if there is a more elegant solution than this, perhaps an idle timer. I notice a little lag in updating the data when I switch to another git repo. That might be a little confusing one day.


Otherwise, this seems like a pretty nice solution so far. There are still some things that would be nice to see on here. For example, a pop-up menu on the modeline to switch branches, push or pull, and with actions for the files, e.g. add/commit, etc... Those do not seem to hard to

* DONE Sentence casing your bibtex entry journal titles
  CLOSED: [2014-10-14 Tue 08:48]
  :PROPERTIES:
  :categories: bib
  :date:     2014/10/14 08:48:19
  :updated:  2014/10/14 08:48:19
  :END:

I previously talked about [[http://kitchingroup.cheme.cmu.edu/blog/2014/10/12/Title-casing-bibtex-entry-journal-titles/][title-casing]] the titles of journal articles in bibtex entries. Here we describe an alternative transformation: sentence-casing. In sentence case the first word is capitalized, and all others (except proper nouns). We also should capitalize the first word of any subtitles, which we take to be the first word after a :. That is usually correct. We should also ignore any LaTeX commands, or protected words in the title.

#+BEGIN_SRC emacs-lisp
(defun jmax-sentence-case-article (&optional key start end)
  "Convert a bibtex entry article title to sentence-case. The
arguments are optional, and are only there so you can use this
function with `bibtex-map-entries' to change all the title
entries in articles."
  (interactive)
  (bibtex-beginning-of-entry)

  (let* ((title (bibtex-autokey-get-field "title"))
	 (words (split-string title))
	 (start 0))
    (when
	(string= "article" (downcase (cdr (assoc "=type=" (bibtex-parse-entry)))))
      (setq words (mapcar
		   (lambda (word)
		     (if
			 ;; match words containing {} or \ which are probably
			 ;; LaTeX or protected words
			 (string-match "\\$\\|{\\|}\\|\\\\" word)
			 word
		       (s-downcase word)))
		   words))

      ;; capitalize first word
      (setf (car words) (s-capitalize (car words)))

      ;; join the words
      (setq title (mapconcat 'identity words " "))

      ;; capitalize a word after a :, eg. a subtitle, and protect it
      (while
	  (string-match "[a-z]:\\s-+\\([A-Z]\\)" title start)
	(let ((char (substring title (match-beginning 1) (match-end 1))))
	  (setf (substring title (match-beginning 1) (match-end 1))
		(format "%s" (upcase char)))
	  (setq start (match-end 1))))

      ;; this is defined in doi-utils
      (bibtex-set-field
       "title" title)

      ;; clean and refill entry so it looks nice
      (bibtex-clean-entry)
      (bibtex-fill-entry))))
#+END_SRC

#+RESULTS:
: jmax-sentence-case-article

Now, we can easily convert this entry in title-case:
#+BEGIN_SRC bibtex
@article{arroyave-2005-ab-ni,
  author =	 {R. Arroyave and D. Shin and Z.-K. Liu},
  title =	 {Ab Initio Thermodynamic Properties of Stoichiometric
                  Phases in the {Ni-Al} System},
  journal =	 {Acta Materialia },
  volume =	 53,
  number =	 6,
  pages =	 {1809 - 1819},
  year =	 2005,
  doi =		 {10.1016/j.actamat.2004.12.030},
  url =
                  {http://www.sciencedirect.com/science/article/pii/S1359645404007669},
  issn =	 {1359-6454},
  keywords =	 {Ab initio},
}
#+END_SRC

To this in sentence case:
#+BEGIN_SRC bibtex
@article{arroyave-2005-ab-ni,
  author =	 {R. Arroyave and D. Shin and Z.-K. Liu},
  title =	 {Ab initio thermodynamic properties of stoichiometric
                  phases in the {Ni-Al} system},
  journal =	 {Acta Materialia },
  volume =	 53,
  number =	 6,
  pages =	 {1809 - 1819},
  year =	 2005,
  doi =		 {10.1016/j.actamat.2004.12.030},
  url =
                  {http://www.sciencedirect.com/science/article/pii/S1359645404007669},
  issn =	 {1359-6454},
  keywords =	 {Ab initio},
}
#+END_SRC

The function is written so you can use it with bibtex-map-entries to change all the titles in one shot like this:

#+BEGIN_SRC bibtex
% (bibtex-map-entries 'jmax-sentence-case-article)
#+END_SRC

The function is /not/ perfect. For example in this next entry, the chemical symbols Mn, Fe, Co, Ni, are incorrectly lower-cased.

#+BEGIN_SRC bibtex
@article{arroyo-2010-first-princ,
  author =	 {Arroyo y de Dompablo, M. E. and Lee, Yueh-Lin and
                  Morgan, D.},
  title =	 {First principles investigation of oxygen vacancies
                  in columbite \ce{MNb_2O_6} ({M = Mn, Fe, Co, Ni,
                  Cu})},
  journal =	 {Chemistry of Materials},
  volume =	 22,
  number =	 3,
  pages =	 {906-913},
  year =	 2010,
  doi =		 {10.1021/cm901723j},
  url =		 {http://pubs.acs.org/doi/abs/10.1021/cm901723j},
  eprint =	 {http://pubs.acs.org/doi/pdf/10.1021/cm901723j},
}
#+END_SRC

Here is the result of sentence casing:
#+BEGIN_SRC bibtex
@article{arroyo-2010-first-princ,
  author =	 {Arroyo y de Dompablo, M. E. and Lee, Yueh-Lin and
                  Morgan, D.},
  title =	 {First principles investigation of oxygen vacancies
                  in columbite \ce{MNb_2O_6} ({M = mn, fe, co, ni,
                  Cu})},
  journal =	 {Chemistry of Materials},
  volume =	 22,
  number =	 3,
  pages =	 {906-913},
  year =	 2010,
  doi =		 {10.1021/cm901723j},
  url =		 {http://pubs.acs.org/doi/abs/10.1021/cm901723j},
  eprint =	 {http://pubs.acs.org/doi/pdf/10.1021/cm901723j},
}
#+END_SRC

The Cu is not lower-cased because it has a } attached to it after the title is split into words. The original entry is not properly formatted, in my opinion. I was lazy in wrapping the whole string in braces, {M = Mn, Fe, Co, Ni, Cu}, to protect the capitalization of the elements in bibtex. The correct way to do this is the more verbose: {M} = {M}n, {F}e, {C}o, {N}i, {C}u, where each letter is individually protected.

Still, the function can save a lot of keystrokes. You should still inspect the final results, to catch any unusual modifications. You do have your bibtex file under version control right?

This function can also be found at https://github.com/jkitchin/jmax/blob/master/jmax-bibtex.el.


* DONE Navigating your bibtex file
  CLOSED: [2014-10-13 Mon 10:22]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/10/13 10:22:27
  :updated:  2014/10/13 10:22:27
  :END:

You may be able to tell I am spending some time cleaning up bibtex files these days. One of the things I need to do is navigate around a bibtex file easily. There are some built-in navigation keys within an entry.

| navigation         | key strokes |
|--------------------+-------------|
| next field         | C-j         |
| end of field       | TAB         |
| beginning of entry | C-M-a       |
| end of entry       | C-M-e       |

I am not aware of an easy way to navigate to the next or previous entry though. I would like something simple to do that. There is a regexp defined in bibtex "bibtex-entry-head", to search for the next or previous entry.

#+BEGIN_SRC emacs-lisp
bibtex-entry-head
#+END_SRC

#+RESULTS:
: ^[	]*\(@[		]*\(?:\(?:Article\|Book\(?:let\)?\|In\(?:Book\|Collection\|Proceedings\)\|M\(?:a\(?:nual\|stersThesis\)\|isc\)\|P\(?:\(?:hdThesi\|roceeding\)s\)\|TechReport\|Unpublished\)\)\)[	]*[({][
: ]*\([][[:alnum:].:;?!`'/*@+|()<>&_^$-]+\)

Here are two functions that do it. This was a little more subtle than I anticipated.  The subtlety comes about if you are at the beginning of the entry, we need to move the cursor by a character, and then search forward because of the way re-search-forward works. I also wrote in an option for a prefix argument, so you can go forward or backward several entries.

#+BEGIN_SRC emacs-lisp
(defun bibtex-next-entry (&optional n)
  "Jump to the beginning of the next bibtex entry. N is a prefix
argument. If it is numeric, jump that many entries
forward. Negative numbers do nothing."
  (interactive "P")
  ;; Note if we start at the beginning of an entry, nothing
  ;; happens. We need to move forward a char, and call again.
  (when (= (point) (save-excursion
		     (bibtex-beginning-of-entry)))
    (forward-char)
    (bibtex-next-entry))

  ;; search forward for an entry
  (when
      (re-search-forward bibtex-entry-head nil t (and (numberp n) n))
    ;; go to beginning of the entry
    (bibtex-beginning-of-entry)))


(defun bibtex-previous-entry (&optional n)
  "Jump to beginning of the previous bibtex entry. N is a prefix
argument. If it is numeric, jump that many entries back."
  (interactive "P")
  (bibtex-beginning-of-entry)
 (when
     (re-search-backward bibtex-entry-head nil t (and (numberp n) n))
   (bibtex-beginning-of-entry)))
#+END_SRC

#+RESULTS:
: bibtex-previous-entry

That is pretty simple. Let us go ahead and bind these to M-n, and M-p, but only in bibtex-mode. Thanks to [[http://ergoemacs.org/emacs/emacs_set_keys_for_major_mode.html][Xah Lee]] for this idea.

#+BEGIN_SRC emacs-lisp
(defun jmax-bibtex-mode-keys ()
  "Modify keymaps used by `bibtex-mode'."
  (local-set-key (kbd "M-n") 'bibtex-next-entry)
  (local-set-key (kbd "M-p") 'bibtex-previous-entry))

;; add to bibtex-mode-hook
(add-hook 'bibtex-mode-hook 'jmax-bibtex-mode-keys)
#+END_SRC

#+RESULTS:
| jmax-bibtex-mode-keys |

Now, C-n moves forward an entry, C-u 2 C-n moves you two entries, etc... and C-p moves you back an entry, while C-u 2 C-p moves you back two entries.

Finally, I sometimes want to jump to a field in an entry. Basically, I want a completion enabled function that lists the fields in the current entry, and then jumps to the selected field. Yes, you could simply do an incremental search forward or backward that is about as simple. But, then I would not get to remind myself how to do a completion command ;)

#+BEGIN_SRC emacs-lisp
(defun jmax-bibtex-get-fields ()
  "Get a list of fields in a bibtex entry."
  (bibtex-beginning-of-entry)
  (remove "=type="
	  (remove "=key="
		  (mapcar 'car (bibtex-parse-entry)))))

(defun jmax-bibtex-jump-to-field (field)
  "Jump to FIELD in the current bibtex entry"
  (interactive
   (list
    (ido-completing-read "Field: " (jmax-bibtex-get-fields))))
  (save-restriction
    (bibtex-narrow-to-entry)
    (bibtex-beginning-of-entry)
    (when
	;; fields start with spaces, a field name, possibly more
	;; spaces, then =
	(re-search-forward (format "^\\s-*%s\\s-*=" field) nil t))))
#+END_SRC

#+RESULTS:
: jmax-bibtex-jump-to-field

These functions live in https://github.com/jkitchin/jmax/blob/master/jmax-bibtex.el, which is the version we use on a regular basis.


* DONE Title casing bibtex entry journal titles
  CLOSED: [2014-10-12 Sun 09:23]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/10/12 09:23:17
  :updated:  2014/10/12 09:23:17
  :END:

I mostly love bibtex. You keep bibliographic entries in a central file, and you can cite them in your writing. Bibtex takes care of /most/ of the formatting for you, but not always all of it. Lately, we have been writing some manuscripts for submission to ACS journals. They want the titles of journal articles included in the bibliography, preferrably in title-case, or in sentence case, but all the same format either way. Unfortunately, the achemso.bst bibtex format does not make this happen. You have to title-case or sentence case the titles themselves in your bibtex file. Well, at least we can get Emacs to do the heavy lifting on that for us.

First, the manual approach. Open your bibtex file, navigate to a title field, put your cursor on the first letter of the title, and press M-c until you get to the end of the title. That runs (capitalize-word). For a few titles, you might just do this. It does not take long.

For a lot of entries though, you might prefer some code to do it. Here we consider how to convert all article titles to Title case. The current code can be found at https://github.com/jkitchin/jmax/blob/master/jmax-bibtex.el.

First, we need to decide on some rules. We will capitalize every word in a title except for words like a, an, the, ... unless they start the title. We do not want to change words with $, {} in them, or \, because these are either protected or LaTeX commands and we probably do not want to change them. The gist of our idea is to get the title, split it into words, capitalize each word that needs to be,  join the words together, and then set the entry title to the new capitalized title.

We use functions from [[https://github.com/magnars/s.el][s.el]], and [[https://github.com/jkitchin/jmax/blob/master/org/doi-utils.org][doi-utils.org]] here.

#+BEGIN_SRC emacs-lisp
(defvar jmax-lower-case-words
  '("a" "an" "on" "and" "for"
    "the" "of" "in")
  "List of words to keep lowercase")

(defun jmax-title-case-article (&optional key start end)
  "Convert a bibtex entry article title to title-case. The
arguments are optional, and are only there so you can use this
function with `bibtex-map-entries' to change all the title
entries in articles."
  (interactive)
  (bibtex-beginning-of-entry)

  (let* ((title (bibtex-autokey-get-field "title"))
	 (words (split-string title))
	 (lower-case-words '("a" "an" "on" "and" "for"
			     "the" "of" "in")))
    (when
	(string= "article" (downcase (cdr (assoc "=type=" (bibtex-parse-entry)))))
      (setq words (mapcar
		   (lambda (word)
		     (if (or
			  ;; match words containing {} or \ which are probably
			  ;; LaTeX or protected words
			  (string-match "\\$\\|{\\|}\\|\\\\" word)
			  ;; these words should not be capitalized, unless they
			  ;; are the first word
			  (-contains? lower-case-words (s-downcase word)))
			 word
		       (s-capitalize word)))
		   words))

      ;; Check if first word should be capitalized
      (when (-contains? jmax-lower-case-words (car words))
	(setf (car words) (s-capitalize (car words))))

      ;; this is defined in doi-utils
      (bibtex-set-field
       "title"
       (mapconcat 'identity words " "))
      (bibtex-fill-entry))))
#+END_SRC

#+RESULTS:
: jmax-title-case-article


Now, a single command converts this:

#+BEGIN_SRC bibtex
@article{campbell-2013-enthal-entrop,
  author =	 {Charles T. Campbell and Jason R. V. Sellers},
  title =	 {Enthalpies and entropies of adsorption on
                  well-defined oxide surfaces: experimental
                  measurements},
  journal =	 CR,
  volume =	 113,
  number =	 6,
  pages =	 {4106-4135},
  year =	 2013,
  doi =		 {10.1021/cr300329s},
  url =		 {https://doi.org/10.1021/cr300329s},
  month =	 6,
}
#+END_SRC

to this:

#+BEGIN_SRC bibtex
@article{campbell-2013-enthal-entrop,
  author =	 {Charles T. Campbell and Jason R. V. Sellers},
  title =	 {Enthalpies and Entropies of Adsorption on
                  Well-defined Oxide Surfaces: Experimental
                  Measurements},
  journal =	 CR,
  volume =	 113,
  number =	 6,
  pages =	 {4106-4135},
  year =	 2013,
  doi =		 {10.1021/cr300329s},
  url =		 {https://doi.org/10.1021/cr300329s},
  month =	 6,
}
#+END_SRC

We wrote the title case function so we can use it with bibtex-map-entries. That means we can fix every entry in a file by putting a comment at the top like this:

#+BEGIN_SRC bibtex
% (bibtex-map-entries 'jmax-title-case-article)  <- put cursor here. C-x C-e
#+END_SRC

The function is not perfect, and does not include every word that should not be capitalized. You will still want to review your entries, but hopefully this saves some typing in the end.
* DONE Abbreviated journal names in bibtex
  CLOSED: [2014-10-11 Sat 17:32]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/10/11 17:31:59
  :updated:  2014/10/11 17:31:59
  :END:

Some journals require abbreviated journal names in the bibliography, and some require full names. Unfortunately, it is not possible to have both in your bibtex file. Or is it...

It is possible to define a [[http://www.bibtex.org/Format/][@string]] that is replaced in your bibtex file. If we have the definition of the @string in a separate file, we can specify its definition there, e.g. as an abbreviation, or as the full name. To make this useful, we need a simple way to add new journals, and to generate the definitions.

First, you can find accepted journal name abbreviations here: http://cassi.cas.org/search.jsp.

We are going to define a variable to hold the string definition, journal full name and an abbreviation. You can find our production version of what follows here: https://github.com/jkitchin/jmax/blob/master/jmax-bibtex.el

#+BEGIN_SRC emacs-lisp
(defvar jmax-bibtex-abbreviations
  '(("ACAT" "ACS Catalysis" "ACS Catal.")
    ("AM" "Acta Materialia" "Acta Mater.")
    ("AMM" "Acta Metallurgica et Materialia" "Acta Metall. Mater.")
    ("AMiner" "American Mineralogist" "Am. Mineral.")
    ("AngC" "Angewandte Chemie-International Edition" "Angew. Chem. Int. Edit.")
    ("APLM" "APL Materials" "APL Mat.")
    ("ACBE" "Applied Catalysis B: Environmental" "Appl. Catal. B-Environ.")
    ("APL" "Applied Physics Letters" "Appl. Phys. Lett.")
    ("ASS" "Applied Surface Science" "Appl. Surf. Sci.")
    ("CL" "Catalysis Letters" "Catal. Lett.")
    ("CT" "Catalysis Today" "Catal. Today")
    ("CPL" "Chemical Physics Letters" "Chem. Phys. Lett")
    ("CR" "Chemical Reviews" "Chem. Rev.")
    ("CSR" "Chemical Society Reviews" "Chem. Soc. Rev.")
    ("CSR" "Chemical Society Reviews" "Chem. Soc. Rev.")
    ("CM" "Chemistry of Materials" "Chem. Mater.")
    ("CSA" "Colloids and Surfaces, A: Physicochemical and Engineering Aspects" "Colloids Surf., A")
    ("CPMS" "Computational Materials Science" "Comp. Mater. Sci.")
    ("CPC" "Computer Physics Communications" "Comput. Phys. Commun.")
    ("CGD" "Crystal Growth \\& Design" "Cryst. Growth Des.")
    ("CEC" "CrystEngComm" "CrystEngComm")
    ("ECST" "ECS Transactions" "ECS Trans.")
    ("EES" "Energy \\& Environmental Science" "Energy Environ. Sci.")
    ("HPR" "High Pressure Research" "High Pressure Res.")
    ("IC" "Inorganic Chemistry" "Inorg. Chem.")
    ("IECR" "Industrial \\& Engineering Chemistry Research" "Ind. Eng. Chem. Res.")
    ("JJAP" "Japanese Journal of Applied Physics" "Jpn. J. Appl. Phys.")
    ("JMatR" "Journal of  Materials Research" "J. Mater. Res.")
    ("JALC" "Journal of Alloys and Compounds" "J. Alloy Compd.")
    ("JAC" "Journal of Applied Crystallography" "J. Appl. Crystallogr.")
    ("JAP" "Journal of Applied Physics" "J. Appl. Phys.")
    ("JC" "Journal of Catalysis" "J. Catal.")
    ("JCP" "Journal of Chemical Physics" "J. Chem. Phys.")
    ("JCG" "Journal of Crystal Growth" "J. Crys. Growth")
    ("JMC" "Journal of Materials Chemistry" "J. Mater. Chem.")
    ("JMC" "Journal of Materials Chemistry" "J. Mater. Chem.")
    ("JMSL" "Journal of Materials Science Letters" "J. Mater. Sci. Lett.")
    ("JMS" "Journal of Membrane Science" "J. Memb. Sci.")
    ("JPE" "Journal of Phase Equilibria" "J. Phase Equilib.")
    ("JPCS" "Journal of Physics and Chemistry of Solids" "J. Phys. Chem. Solids")
    ("JPCM" "Journal of Physics: Condensed Matter" "J. Phys.: Condens. Matter")
    ("JSSC" "Journal of Solid State Chemistry" "J. Solid State Chem.")
    ("JACerS" "Journal of the American Ceramic Society" "J. Am. Ceram. Soc.")
    ("JACS" "Journal of the American Chemical Society" "J. Am. Chem. Soc.")
    ("JES" "Journal of The Electrochemical Society" "J. Electrochem. Soc.")
    ("JES" "Journal of The Electrochemical Society" "J. Electrochem. Soc.")
    ("JMS" "Journal of Membrane Science" "J. Memb. Sci.")
    ("JVST" "Journal of Vacuum Science \\& Technology A" "J. Vac. Sci. Technol. A")
    ("ML" "Materials Letters" "Mater. Lett.")
    ("MSE-BS" "Materials Science and Engineering B" "Mat. Sci. Eng. B-Solid")
    ("MOLSIM" "Molecular Simulation" "Mol. Sim.")
    ("Nature" "Nature" "Nature")
    ("NM" "Nature Materials" "Nat. Mater.")
    ("PML" "Philosophical Magazine Letters" "Phil. Mag. Lett.")
    ("PMA" "Philosophical Magazine A" "Phil. Mag. A")
    ("PA" "Physica A: Statistical Mechanics and its Applications" "Physica A")
    ("PB" "Physica B-Condensed Matter" "Physica B")
    ("PCCP" "Physical Chemistry Chemical Physics" "Phys. Chem. Chem. Phys.")
    ("PSSB" "physica status solidi (b)" "Phys. Status Solidi B")
    ("PRA" "Physical Review A" "Phys. Rev. A")
    ("PRB" "Physical Review B" "Phys. Rev. B")
    ("PRL" "Physical Review Letters" "Phys. Rev. Lett.")
    ("PCM" "Physics and Chemistry of Minerals" "Phys. Chem. Miner.")
    ("PSurfSci" "Progress in Surface Science" "Prog. Surf. Sci.")
    ("Science" "Science" "Science")
    ("SABC" "Sensors and Actuators B: Chemical" "Sensor. Actuat. B-Chem.")
    ("SS" "Surface Science" "Surf. Sci.")
    ("EPJB" "The European Physical Journal B" "Eur. Phys. J. B")
    ("JPC" "The Journal of Physical Chemistry" "J. Phys. Chem.")
    ("JPCB" "The Journal of Physical Chemistry  B" "J. Phys. Chem. B")
    ("JPCC" "The Journal of Physical Chemistry C" "J. Phys. Chem. C")
    ("JCP" "The Journal of Chemical Physics" "J. Chem. Phys.")
    ("TSF" "Thin Solid Films" "Thin Solid Films")
    ("TC" "Topics in Catalysis" "Top. Catal.")
    ("WR" "Water Research" "Water Res."))
  "List of (string journal-full-name journal-abbreviation)")
#+END_SRC

#+RESULTS:
: bibtex-abbreviations

This data structure will serve a few purposes.

1. We will generate the bib files that define the @string definitions
2. We will use it to modify bibtex files to use those strings.

First, here are some simple functions to generate the @string definitions.

#+BEGIN_SRC emacs-lisp
(defun jmax-bibtex-generate-longtitles ()
  (interactive)
  (with-temp-file "longtitles.bib"
    (dolist (row bibtex-abbreviations)
      (insert (format "@string{%s=\"%s\"}\n"
		      (nth 0 row)
		      (nth 1 row))))))

(defun jmax-bibtex-generate-shorttitles ()
  (interactive)
  (with-temp-file "shorttitles.bib"
    (dolist (row bibtex-abbreviations)
      (insert (format "@string{%s=\"%s\"}\n"
		      (nth 0 row)
		      (nth 2 row))))))
#+END_SRC

#+RESULTS:
: jmax-bibtex-generate-shorttitles

#+BEGIN_SRC emacs-lisp
(jmax-bibtex-generate-longtitles)
(jmax-bibtex-generate-shorttitles)
#+END_SRC

#+RESULTS:

Here are the results of running that code: file:shorttitles.bib and file:longtitles.bib. This is the first step. We have the @strings defined. Now, we need to convert the names in a bibtex entry to use our string. We want to replace full names and abbreviated names with the @string.

#+BEGIN_SRC emacs-lisp
(defun jmax-stringify-journal-name (&optional key start end)
  "replace journal name with a string. The strings are defined in `bibtex-abbreviations'."
  (interactive)
  (bibtex-beginning-of-entry)
  (when
      (string= "article"
	       (downcase
		(cdr (assoc "=type=" (bibtex-parse-entry)))))
    (let* ((full-names (mapcar
			(lambda (row)
			  (cons  (nth 1 row) (nth 0 row)))
			bibtex-abbreviations))
	   (abbrev-names (mapcar
			  (lambda (row)
			    (cons  (nth 2 row) (nth 0 row)))
			  bibtex-abbreviations))
	   (journal (s-trim (bibtex-autokey-get-field "journal")))
	   (bstring (or
		     (cdr (assoc journal full-names))
		     (cdr (assoc journal abbrev-names)))))
      (when bstring
	(bibtex-set-field "journal" bstring t)
        (bibtex-fill-entry)))))
#+END_SRC

#+RESULTS:
: jmax-stringify-journal-name

Now, with a single command, we can convert this:

#+BEGIN_SRC bibtex
@article{lizzit-2001-surfac-ru,
  author =	 {S. Lizzit and A. Baraldi and A. Groso and K. Reuter
                  and M. Ganduglia-Pirovano and C. Stampfl and
                  M. Scheffler and M. Stichler and C. Keller and
                  W. Wurth and D. Menzel},
  title =	 {Surface Core-level Shifts of Clean and
                  Oxygen-covered {R}u(0001)},
  journal =	 {Physical Review B,
  volume =	 63,
  number =	 20,
  pages =	 {nil},
  year =	 2001,
  doi =		 {10.1103/physrevb.63.205419},
  url =		 {https://doi.org/10.1103/PhysRevB.63.205419},
  month =	 5,
}
#+END_SRC

into this:

#+BEGIN_SRC bibtex
@article{lizzit-2001-surfac-ru,
  author =	 {S. Lizzit and A. Baraldi and A. Groso and K. Reuter
                  and M. Ganduglia-Pirovano and C. Stampfl and
                  M. Scheffler and M. Stichler and C. Keller and
                  W. Wurth and D. Menzel},
  title =	 {Surface Core-level Shifts of Clean and
                  Oxygen-covered {R}u(0001)},
  journal =	 PRB,
  volume =	 63,
  number =	 20,
  pages =	 {nil},
  year =	 2001,
  doi =		 {10.1103/physrevb.63.205419},
  url =		 {https://doi.org/10.1103/PhysRevB.63.205419},
  month =	 5,
}
#+END_SRC

If you have a lot of entries you want to modify, you can use bibtex-map-entries like this. Basically, put the elisp form in a comment, and then execute the elisp form

#+BEGIN_SRC bibtex
%% (bibtex-map-entries 'jmax-stringify-journal-name)  <- put cursor here. C-x C-e
#+END_SRC

This saves some effort. Over time, I will keep adding entries to the abbreviation table. As long as a standard journal name or abbreviation is in your bibtex file, this approach should work pretty well. After you replace the journal names with @string entries, you have to generate the string file, either shorttitles.bib or longtitles.bib, and in your LaTeX file, change your bibliography line to:

#+BEGIN_SRC latex
\bibliography{shorttitles,references}
#+END_SRC

The order is important. The @string definitions are in shorttitles.bib, and your bibtex entries in references.bib.

* DONE Generate emacs-lisp documentation
  CLOSED: [2014-10-17 Fri 14:39]
  :PROPERTIES:
  :categories: emacs_lisp
  :date:     2014/10/17 14:39:49
  :updated:  2014/10/17 14:39:49
  :END:

Emacs has some pretty amazing features to get help on a function (describe-function), to navigate quickly to functions in an elisp file (speedbar and imenu). Other languages have tools for generating documentation for all the functions in a file, e.g. epydoc, javadoc, Doxygen,... I have not found an equivalent to this in emacs-lisp. Here, we explore some options to get something similar to this. Our goal will be to take an emacs-lisp file, and generate an org-file of documentation, and then convert that to PDF for reading.

Say we have a function, jmax-bibtex-next-entry, and we want some information about it. Here are three functions that give us the argument list, documentation string, and function definition.

#+BEGIN_SRC emacs-lisp
(help-function-arglist 'jmax-bibtex-next-entry)
#+END_SRC

#+RESULTS:
| &optional | n |

#+BEGIN_SRC emacs-lisp
(documentation 'jmax-bibtex-next-entry)
#+END_SRC

#+RESULTS:
: Jump to the beginning of the next bibtex entry. N is a prefix
: argument. If it is numeric, jump that many entries
: forward. Negative numbers do nothing.

#+BEGIN_SRC emacs-lisp
(symbol-function 'jmax-bibtex-next-entry)
#+END_SRC

#+RESULTS:
| lambda | (&optional n) | Jump to the beginning of the next bibtex entry. N is a prefix\nargument. If it is numeric, jump that many entries\nforward. Negative numbers do nothing. | (interactive P) | (if (= (point) (save-excursion (bibtex-beginning-of-entry))) (progn (forward-char) (bibtex-next-entry))) | (if (re-search-forward bibtex-entry-head nil t (and (numberp n) n)) (progn (bibtex-beginning-of-entry))) |

That will not always be the code we wrote, but it is functionally similar.

So we could create an org-entry like this:

#+BEGIN_SRC emacs-lisp :results org
(defun fun2org (function-symbol)
  (let ((args (help-function-arglist function-symbol))
	(doc  (documentation function-symbol))
	(code (symbol-function function-symbol)))
    (format "** %s %s
%s

,#+BEGIN_SRC emacs-lisp
%S
,#+END_SRC
" function-symbol args doc code)))

(fun2org 'jmax-bibtex-next-entry)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
,** jmax-bibtex-next-entry (&optional n)
Jump to the beginning of the next bibtex entry. N is a prefix
argument. If it is numeric, jump that many entries
forward. Negative numbers do nothing.

,#+BEGIN_SRC emacs-lisp
(lambda (&optional n) "Jump to the beginning of the next bibtex entry. N is a prefix
argument. If it is numeric, jump that many entries
forward. Negative numbers do nothing." (interactive "P") (if (= (point) (save-excursion (bibtex-beginning-of-entry))) (progn (forward-char) (bibtex-next-entry))) (if (re-search-forward bibtex-entry-head nil t (and (numberp n) n)) (progn (bibtex-beginning-of-entry))))
,#+END_SRC
#+END_SRC

The code is not that beautifully indented, but it is optional.

For variables, there are similar functions to get their documentation:

#+BEGIN_SRC emacs-lisp
(documentation-property 'jmax-bibtex-journal-abbreviations 'variable-documentation)
#+END_SRC

#+RESULTS:
: List of (string journal-full-name journal-abbreviation). Find abbreviations at http://cassi.cas.org/search.jsp.

The problem still is, you have to know the variable and function names in advance. I want to take a file, and generate this for each function, and variable.

I posted a question on [[http://stackoverflow.com/questions/26330363/how-do-i-get-a-list-of-functions-defined-in-an-emacs-lisp-file/26360946?iemail=1&noredirect=1#26360946][StackOverflow]] on how to get the functions defined in a file. The most feasible suggestion was to use the variable load-history, which contains a history of the variables and functions loaded, and the files they are in.

Here is an example of getting the entries associated with jmax-bibtex.el

#+BEGIN_SRC emacs-lisp :results code
(cdr (assoc "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el" load-history ))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(jmax-bibtex-journal-abbreviations
 (defun . jmax-bibtex-generate-longtitles)
 (defun . jmax-bibtex-generate-shorttitles)
 (defun . jmax-stringify-journal-name)
 (defun . jmax-set-journal-string)
 jmax-nonascii-latex-replacements
 (defun . jmax-replace-nonascii)
 jmax-lower-case-words
 (defun . jmax-title-case-article)
 (defun . jmax-sentence-case-article)
 (defun . jmax-bibtex-next-entry)
 (defun . jmax-bibtex-previous-entry)
 (defun . jmax-bibtex-mode-keys)
 (provide . jmax-bibtex))
#+END_SRC

Each element in this case is either a variable, defun or provide. Here, we can use this to print some information about the variables defined in this file. I think it is sufficient to check if the element in the list is a symbol, because all the other elements are cons elements. I suppose there are other possibilities, including defcustom, defgroup, defalias, defsubst, and maybe others.

#+BEGIN_SRC emacs-lisp :results output
(dolist (element (cdr
		  (assoc
		   "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"
		   load-history )))
  (when (symbolp element)
    (princ
    (format "%s
Documentation: %s

" element (documentation-property element 'variable-documentation)))))
#+END_SRC

#+RESULTS:
: jmax-bibtex-journal-abbreviations
: Documentation: List of (string journal-full-name journal-abbreviation). Find abbreviations at http://cassi.cas.org/search.jsp.
:
: jmax-nonascii-latex-replacements
: Documentation: Cons list of non-ascii characters and their LaTeX representations
:
: jmax-lower-case-words
: Documentation: List of words to keep lowercase
:

We can handle functions by checking if an element is a cons cell with a first element of defun.

#+BEGIN_SRC emacs-lisp :results output
(dolist (element (cdr
		  (assoc
		   "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"
		   load-history )))
  (when (and (consp element)
	     (eq (car element) 'defun))
    (princ (format "%s is a function\n" (cdr element))))))
#+END_SRC

#+RESULTS:
#+begin_example
jmax-bibtex-generate-longtitles is a function
jmax-bibtex-generate-shorttitles is a function
jmax-stringify-journal-name is a function
jmax-set-journal-string is a function
jmax-replace-nonascii is a function
jmax-title-case-article is a function
jmax-sentence-case-article is a function
jmax-bibtex-next-entry is a function
jmax-bibtex-previous-entry is a function
jmax-bibtex-mode-keys is a function
#+end_example


So, we have the important pieces to mash up what I am looking for. Let us refine the goal. I want to create a PDF documentation of what is in an elisp file with a section on variables, and a section on functions.

#+BEGIN_SRC emacs-lisp :results output
(let* ((elements (cdr
		  (assoc
		   "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"
		   load-history)))
       (vars (-filter 'symbolp elements))
       (funcons (-filter (lambda (x)
			   (and (consp x)
				(eq 'defun (car x))))
			 elements))
       (funcs (mapcar 'cdr funcons)))
  (switch-to-buffer "*org-doc*")
  (erase-buffer)
  (insert (format "#+TITLE: Documentation for %s
#+OPTIONS: toc:nil
\\maketitle
\\tableofcontents
" "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"))
  (insert "* Variables\n")
  (dolist (var (sort vars 'string-lessp))
    (insert (format "** %s
Documentation: %s\n\n" var  (documentation-property var 'variable-documentation))))

  (insert "* Functions\n\n")
  (dolist (funcs (sort funcs 'string-lessp))
    (insert (format "** %s %s
Documentation: %s

Code:
,#+BEGIN_SRC emacs-lisp
%S
,#+END_SRC
"
		    funcs
		    (or (help-function-arglist funcs) "")
		    (documentation funcs)
		    (symbol-function funcs))))

  (org-mode)
  (write-file "jmax-bibtex-doc.org")
  (org-export-to-file 'latex "jmax-bibtex-doc.tex")
  (org-latex-compile "jmax-bibtex-doc.tex")
  (kill-buffer "*org-doc*")
  (kill-buffer "jmax-bibtex-doc.org"))
#+END_SRC

#+RESULTS:

Here is the resulting pdf: file:jmax-bibtex-doc.pdf. It is not too bad. The code is not beautiful, and it would take some work to get that looking nice. It might be nice to find all instances of '` and replace them with links to variable names, but I leave that for another day. There is also no information about the header comments, but I leave this for another day to.

* DONE words - some interesting utilities for text in emacs
  CLOSED: [2014-11-03 Mon 11:31]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/11/03 11:31:45
  :updated:  2014/11/04 09:20:15
  :END:
Recently I [[http://kitchingroup.cheme.cmu.edu/blog/2014/11/02/A-generalized-org-link-with-an-extendable-menu-of-actions/][posted]] about an org-link with a menu. Here I extend the idea to a command that will do approximately the same thing. The idea is a command called words that will be run interactively. It will grab the word at point, or operate on a selected region, and then offer a menu to lookup the definition, find it in a thesaurus, google it, etc... We structure the code so you can add functions to it later, without directly modifying this code. The only limitation of this code is that the functions must have a signature with no arguments. That does not seem terribly limiting, as we can check for a region, and use it if we want (see the words-google function).

#+BEGIN_SRC emacs-lisp
(defun words-dictionary ()
  (interactive)
  (browse-url
   (format
    "http://dictionary.reference.com/browse/%s?s=t"
    (thing-at-point 'word))))

(defun words-thesaurus ()
  (interactive)
  (browse-url
   (format
    "http://www.thesaurus.com/browse/%s"
    (thing-at-point 'word))))

(defun words-google ()
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s"
    (if (region-active-p)
	(url-hexify-string (buffer-substring (region-beginning)
					     (region-end)))
      (thing-at-point 'word)))))


(defvar words-funcs '()
 "functions to run in `words'. Each entry is a list of (key menu-name function).")

(setq words-funcs
  '(("d" "ictionary" words-dictionary)
    ("t" "hesaurus" words-thesaurus)
    ("g" "oogle" words-google)))


(defun words ()
  (interactive)
   (message
   (concat
    (mapconcat
     (lambda (tup)
       (concat "[" (elt tup 0) "]"
	       (elt tup 1) " "))
     words-funcs "") ": "))
   (let ((input (read-char-exclusive)))
     (funcall
      (elt
       (assoc
	(char-to-string input) words-funcs)
       2))))
#+END_SRC

#+RESULTS:
: words

This works nicely. Now, let us add a new function that looks up the word or selection on twitter. We just define a new function, and add the menu selection to the words-func variable.

#+BEGIN_SRC emacs-lisp
(defun words-twitter ()
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s"
    (if (region-active-p)
	(url-hexify-string (buffer-substring (region-beginning)
					     (region-end)))
      (thing-at-point 'word)))))

(add-to-list 'words-funcs
  '("w" "twitter" words-twitter)
  t) ; append

#+END_SRC

#+RESULTS:
| d | ictionary | words-dictionary |
| t | hesaurus  | words-thesaurus  |
| g | oogle     | words-google     |
| w | twitter   | words-twitter    |

Finally, the most complicated idea: spelling and grammar. I know there is flyspell, and such, but they are build on an ancient dictionary. Here, for fun, we explore a web api. This next function is not a trivial one, and I will not explain it here beyond saying it sends a selection of text to a url, gets an xml response back, and that response is parsed and printed to a buffer by this function. The main point is to illustrate we can do interesting things with a selection of text!

#+BEGIN_SRC emacs-lisp
(defun words-atd ()
  "Send paragraph at point to After the deadline for spell and grammar checking."
  (interactive)

  (let* ((url-request-method "POST")
	 (url-request-data (format
			    "key=some-random-text-&data=%s"
			    (url-hexify-string
			     (thing-at-point 'paragraph))))
	 (xml  (with-current-buffer
		   (url-retrieve-synchronously
		    "http://service.afterthedeadline.com/checkDocument")
		 (xml-parse-region url-http-end-of-headers (point-max))))
	 (results (car xml))
	 (errors (xml-get-children results 'error)))

    (switch-to-buffer-other-frame "*ATD*")
    (erase-buffer)
    (dolist (err errors)
      (let* ((children (xml-node-children err))
	     ;; for some reason I could not get the string out, and had to do this.
	     (s (car (last (nth 1 children))))
	     ;; the last/car stuff doesn't seem right. there is probably
	     ;; a more idiomatic way to get this
	     (desc (last (car (xml-get-children children 'description))))
	     (type (last (car (xml-get-children children 'type))))
	     (suggestions (xml-get-children children 'suggestions))
	     (options (xml-get-children (xml-node-name suggestions) 'option))
	     (opt-string  (mapconcat
			   (lambda (el)
			     (when (listp el)
			       (car (last el))))
			   options
			   " ")))

	(insert (format "** %s ** %s
Description: %s
Suggestions: %s

" s type desc opt-string))))))

(add-to-list 'words-funcs
  '("s" "spell/grammar" words-atd)
  t) ; append
#+END_SRC

#+RESULTS:
: words-atd

My final words menu looks like:
#+attr_html: :width 400
[[./images/final-menu.png]]

If I have the cursor in the previous paragraph, run the words command and select "s" I get a buffer with these contents:

#+BEGIN_EXAMPLE
** flyspell ** (spelling)
Description: (Spelling)
Suggestions: flywheel flyball

** are build on ** (grammar)
Description: (Auxiliary Verb Agreement)
Suggestions: are built on

** api ** (spelling)
Description: (Spelling)
Suggestions: app ape apt ai ami

** url ** (spelling)
Description: (Spelling)
Suggestions: urn ure curl hurl burl

** xml ** (spelling)
Description: (Spelling)
Suggestions: xl ml

** selection ** (suggestion)
Description: (Complex Expression)
Suggestions: choice

** an xml ** (grammar)
Description: (Wrong article)
Suggestions: a xml

** a selection of ** (grammar)
Description: (Hidden Verbs)
Suggestions:

** is parsed ** (grammar)
Description: (Passive voice)
Suggestions:

** selection ** (suggestion)
Description: (Complex Expression)
Suggestions: choice

** a selection of ** (grammar)
Description: (Hidden Verbs)
Suggestions:
#+END_EXAMPLE

It might be nice to link back to those words, so you could click on them and fix them, but that is a beyond today's goal. In summary, today we looked at a framework to create a user-modifiable menu of commands that are launched from a single command. Here we called the command words, and then built up some different things we might want to do with the word or selection at point. While you can of course just remember the individual commands, remembering one command and then being prompted might have some advantages.
* DONE A generalized org-link with an extendable menu of actions
  CLOSED: [2014-11-02 Sun 19:33]
  :PROPERTIES:
  :categories: org
  :date:     2014/11/02 19:33:14
  :updated:  2014/11/02 19:33:14
  :END:
In org-ref the cite links are actually a menu of options. Here I want to explore generalizing the concept, and enable users to add new menu items. When you click on a cite link, it calls a function that constructs the menu as a string. Then, we read something from the minibuffer to say what should be done. We could store these things in variables, so that a user could add their own things. We need a list of characters, menu strings, and functions to run when to create the menu. Here we put together a little example code that shows the idea.

#+BEGIN_SRC emacs-lisp :results silent
(defun option-a (link)
  (message "You picked option A for %s" link))

(defun option-b (link)
  (message "You picked option B for %s" link))

(defvar menu-funcs
 '(("a" "Option 1" option-a)
   ("b" "Option 2" option-b)))

(defun menu-click (path)
  "display menu of actions for the link"
  (message
   (concat
    (mapconcat
     (lambda (tup)
       (concat "[" (elt tup 0) "]"
	       (elt tup 1) " "))
     menu-funcs "") ": "))
  (setq input (read-char-exclusive))
  (funcall
   (elt
    (assoc
     (char-to-string input) menu-funcs)
    2)
   path))

(org-add-link-type
 "menu"
 'menu-click)
#+END_SRC

menu:element  Clicking on that link in Emacs gives me the desired menu!

#+attr_html: :width 200
[[./images/menu.png]]

and

#+attr_html: :width 200
[[./images/menu-response.png]]

Now, we test adding a new function.

#+BEGIN_SRC emacs-lisp
(defun option-c (link)
  (message "You picked option C for %s" link))

(add-to-list 'menu-funcs
 '("c" "Option C" option-c))
#+END_SRC

#+RESULTS:
| c | Option C | option-c |
| a | Option 1 | option-a |
| b | Option 2 | option-b |

Well, that worked fine! You might want to append to the list instead of put it at the beginning, but that is really your choice.

#+BEGIN_SRC emacs-lisp
(defun option-4 (link)
  (message "You picked option 4 for %s" link))

(add-to-list 'menu-funcs
 '("4" "Option 4" option-4) t)
#+END_SRC

#+RESULTS:
| c | Option C | option-c |
| a | Option 1 | option-a |
| b | Option 2 | option-b |
| 4 | Option 4 | option-4 |

I think this example more or less shows the basic idea here. These external functions may do a variety of things, like look up something on google, or some other web service, search for something on your hard drive, etc... For example in org-ref, clicking on a cite link gives you options to open the bibtex file, a pdf, a url or notes. This would allow you to open other things too, if you felt like it. For better or worse, you can modify the behavior of the link after it is defined.

* DONE Annotating matplotlib figures
  CLOSED: [2014-11-01 Sat 10:35]
  :PROPERTIES:
  :categories: python matplotlib
  :date:     2014/11/01 10:35:15
  :updated:  2014/11/01 10:35:15
  :END:


There is a nice picture of an ethanolamine molecule [[http://en.wikipedia.org/wiki/Ethanolamine][here]]. The first thing we consider is embedding this figure in a matplotlib figure. It is a little tricky because we have to create a special axes to put the image in. The axes are created in a fractional coordinate systems that is defined by [left, bottom, width, height]. Placing the figure where you want it is an iterative process that involves changing those values to get the image where you want.

So, note that (0, 0) is the bottome left corner of the figure, and (1, 1) is the upper right corner. So, to make an axes for the main figure that takes up 75% of the width and 80% of the height, and starts 20% from the left, 15% from the bottom, we use [0.2, 0.15, 0.75, 0.8]. That covers most of the space, and leaves room for labels.

The axes for the image is about the same, but it is a little trickier to figure out the width and height. In this example these arguments appear to just rescale the image.

Here is some code that puts the image near the upper left-corner of the plot.

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from scipy.misc import imread
import numpy as np

im = imread('images/Ethanolamine-2D-skeletal-B.png')

fig = plt.figure(figsize=(3, 4))
#                    left bottom width height
f_ax = fig.add_axes([0.2, 0.15, 0.75, 0.8], zorder=1)

# plot some function
f_ax.plot(np.arange(10), 4 * np.arange(10))
plt.xlabel('some xlabel')
plt.ylabel('Y')

# axes for the image
i_ax = fig.add_axes([0.22, 0.8, 0.3, 0.1],
                    frameon=False, xticks=[], yticks=[],
                    zorder=2)

# add the image. zorder>1 makes sure it is on top
i_ax.imshow(im)

# print dir(i_ax)

plt.savefig('images/fig-in-plot-2.png', dpi=300)
#+END_SRC
#+RESULTS:


#+attr_html: :width 300
#+caption: A matplotlib figure with an embedded images.
[[./images/fig-in-plot-2.png]]


There it is.

* DONE A hint system for problems in org-mode
  CLOSED: [2014-11-09 Sun 09:55]
  :PROPERTIES:
  :categories: org
  :date:     2014/11/09 09:55:17
  :updated:  2014/11/09 09:55:17
  :END:
I use org-mode to write problems for classes that I teach. Sometimes it is helpful to be able to provide hints about aspects of the problem. I have used drawers for that before. Here I will look at another approach. The idea is to store a unique id (org-id) in the problem headline. We will make hints somewhere else, and each hint will store the id they refer to in some property. We will run a command in the problem that finds the hints, and offers a menu you can select from.

In the next sections, we define a [[id:EE9523FF-C4FF-45D9-BABA-8832A6E48C3B][Problem statement]], a section with [[*Hints][hints]] in it, and finally [[*The hint code][code]] that defines a hint function.

** Problem statement
   :PROPERTIES:
   :ID:       EE9523FF-C4FF-45D9-BABA-8832A6E48C3B
   :END:

What is the seventh number in the Fibonacci series?

** Hints
Hints will be stored in headings somewhere. Here we put them in this file, but they could be stored in another file too. We give each hint a HINT property, with the problem id as the value. Here are three hints. In real example, the hints would not be this easy to find in the document. You might store them somewhere else, in another file for example.

*** What is the Fibonacci series?
    :PROPERTIES:
    :HINT:     EE9523FF-C4FF-45D9-BABA-8832A6E48C3B
    :END:
The $i^{th} number in the Fibonacci series is equal to the sum of the previous two numbers in the series.


*** What does the series start with?
    :PROPERTIES:
    :HINT:     EE9523FF-C4FF-45D9-BABA-8832A6E48C3B
    :END:

The Fibonacci series starts with 1.

*** Example of the series.
    :PROPERTIES:
    :HINT:     EE9523FF-C4FF-45D9-BABA-8832A6E48C3B
    :END:
The Fibonacci series goes as 1, 1, 2, 3, 5, 8, ...


** The hint code
We want to get the id from the problem the point is in, and then find hints for the problem. Then, we construct a menu and prompt the user to select a hint. I use a number to select the hint because it was easier to generate the menu that way. I like characters better, because you just have to press a key. With numbers you type the number and press enter. We open a new buffer with the contents of the hint in it. You can close the buffer by pressing q.

#+BEGIN_SRC emacs-lisp
(defun hint ()
  "Present a menu of hints for the problem at point"
  (interactive)
  (let ((id (org-entry-get (point) "ID"))
	(entries '())
	(menu "")
	choice)

    (unless id
      (error "No problem ID found"))

    (org-map-entries
     (lambda ()
       (save-restriction
	 (org-narrow-to-subtree)
	 (add-to-list 'entries
		      (cons
		       (elt (org-heading-components) 4)
		       (buffer-string))
		      t)))
     (format "HINT=\"%s\"" id))

    ;; generate menu string
    (dolist (i (number-sequence 1 (length entries)))
      (setq menu (concat menu (format "[%s] %s\n" (- i 1)
				      (car (elt entries (- i 1)))))))

    (setq choice (elt entries (read-number (concat menu "Your choice: ") 0)))
    ;; this feels a little clunky. Maybe I could just save a marker to
    ;; the headline, and open it in a narrowed indirect buffer.
    (when choice
      (switch-to-buffer "*hint*")
      (erase-buffer)
      (insert (cdr choice))

      (org-mode)
      (show-subtree)
      (setq buffer-read-only t)
      (use-local-map (copy-keymap org-mode-map))
      (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))
      )))
#+END_SRC
#+RESULTS:
: hint

** Summary
This seems like an interesting way to provide hints, or related information in org-mode.  You could also consider using tags, or more sophisticated code  to determine what else is relevant. For example, you might keep track of some performance metric, and use some heuristic algorithm that ranks the related information. Or perhaps fuzzy text searching, or combinations of criteria. If the number of hits got large, then the menu approach here might not be the best one. Then, something like the occur interface might be more suitable.
* DONE A context-sensitive file link menu in org-mode
  CLOSED: [2014-11-08 Sat 10:26]
  :PROPERTIES:
  :categories: org
  :date:     2014/11/08 10:24:14
  :updated:  2014/11/08 10:26:22
  :END:
I am still interested in various ways to get more functionality of org-links. For example, we looked at:
1. [[http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/][enabling right clicks]] on links
2. [[http://kitchingroup.cheme.cmu.edu/blog/2014/11/02/A-generalized-org-link-with-an-extendable-menu-of-actions/][new links with menus]]

When you click on a link, the function org-open-at-point runs, which is a /large/ function that does a lot of things. One of them is to check if the link is defined in org-link-protocols, and to run the function definition there if it is. Here is a list of links defined for me. I defined a lot of these in org-ref, and my own init files, so you may not see these on your system.

#+BEGIN_SRC emacs-lisp
(mapcar 'car org-link-protocols)
#+END_SRC

#+RESULTS:
| google | ResearcherID | orcid | message | mac-outlook | skim | addressbook | x-together-item | rmail | mhe | irc | info | gnus | docview | bibtex | bbdb | ans | exercise | solution | assignment | doi | bibentry | Autocites | autocites | supercites | Textcites | textcites | Smartcites | smartcites | footcitetexts | footcites | Parencites | parencites | Cites | cites | fnotecite | Pnotecite | pnotecite | Notecite | notecite | footfullcite | fullcite | citeurl | citedate* | citedate | citetitle* | citetitle | Citeauthor* | Autocite* | autocite* | Autocite | autocite | supercite | parencite* | cite* | Smartcite | smartcite | Textcite | textcite | footcitetext | footcite | Parencite | parencite | Cite | Citeauthor | Citealp | Citealt | Citep | Citet | citeyear* | citeyear | citeauthor* | citeauthor | citetext | citenum | citealp* | citealp | citealt* | citealt | citep* | citep | citet* | citet | nocite | cite | eqref | nameref | pageref | ref | label | list-of-tables | list-of-figures | addbibresource | bibliographystyle | printbibliography | nobibliography | bibliography | pydoc | index | attachfile | msx | id | file+emacs | file+sys |

Interestingly, file links are not defined in org-link-protocols, they are handled separately. I would like to change the behavior of file+emacs links. Instead of just opening the file, I want a menu to give me the option to create the file if it does not exist, and to open it in emacs, or with a system program if the file does exist. Let us see what this link does.

#+BEGIN_SRC emacs-lisp
(assoc "file+emacs" org-link-protocols)
#+END_SRC

#+RESULTS:
| file+emacs | org-open-file-with-emacs | nil |

When you click on the link, it runs org-open-file-with-emacs, and there is no formatting function defined.

So, let us define a list of functions that could make a menu. A new variation we use in this post is that each element of the list will be a (key menu-name action-func visible-p) list. visible-p will be a function that determines if the function is listed in the menu. That way, our menu will be context specific.

We want an option to create a file if it does not exist, and if it does exist, a choice to open in emacs, or a system program. So the idea here is to create the menu in a variable (so it easy to add to later), then when you click on the link it will run a menu function that  filters the functions to run, and then prompt you for a selection.

#+BEGIN_SRC emacs-lisp
(defvar file+emacs-menu '()
  "list of menu entries. (key name action visible).
key is a character to select.
name is what shows in the menu as [key]name
action is a function that takes a path
visible is a function that determines if the entry is in the menu.")

(setq file+emacs-menu
      '(("c" "reate"
	 find-file ; action function
	 (lambda (x) (not (file-exists-p x)))) ; visible-p
	("o" "pen"
	 org-open-file-with-emacs
	 (lambda (x) (file-exists-p x)))
	("e" "xternal open"
	 (lambda (x) (org-open-file path '(16)))
	 (lambda (x) (file-exists-p x)))))


(defun file+emacs-menu (path)
  "menu command for file+emacs links"
  (interactive)
  (let* ((filtered-menu-list (-filter
			      (lambda (x) (funcall (car (last x)) path))
			      file+emacs-menu))
	 (menu-string (concat
		       (mapconcat
			(lambda (tup)
			  (concat "[" (elt tup 0) "]"
				  (elt tup 1) " "))
			filtered-menu-list
			"") ": "))
	 (input (read-char-exclusive menu-string nil 1))
	 (selected-func (and
			 input
			 (elt
			  (assoc
			   (char-to-string input) filtered-menu-list)
			  2))))
    (when selected-func
      (funcall selected-func path))))
#+END_SRC

#+RESULTS:
: file+emacs-menu

Now we need to change the link definition in org-link-protocols. setf comes to the rescue. We just get the whole entry, and then setf the second position in it like this.

#+BEGIN_SRC emacs-lisp
(setf (elt (assoc "file+emacs" org-link-protocols) 1)
  'file+emacs-menu)
#+END_SRC

#+RESULTS:
: file+emacs-menu

Here we just confirm we set it.

#+BEGIN_SRC emacs-lisp
(assoc "file+emacs" org-link-protocols)
#+END_SRC

#+RESULTS:
| file+emacs | file+emacs-menu | nil |

Now, when we click on these links, we get our context specific menu. When

This file exists: file+emacs:ase-db.org  so we see this menu:
#+attr_html: :width 200
[[./images/open-menu.png]]

This file does not exist: file+emacs:test.noext
So we see:
#+attr_html: :width 200
[[./images/create-menu.png]]

For these, we can select to open them in a pdf reader or MS Word from our new menu.
file+emacs:attaching-code-blocks-to-a-pdf.pdf

file+emacs:org-to-word.docx

I admit this example was a little contrived. You can do most of these things with prefix commands, or more specific commands in emacs. But, I rarely remember those. I would have preferred to use the file link in this example, but it is not defined in org-link-protocols, so this style of modification would not work, and I did not want to add it to org-link-protocols just to show how to change it this way.

This general approach would be very useful for links where there may be multiple contexts or actions that make sense. For file links, you may want do different things if the file already exists, or if it does not exist. As another example, my [[https://github.com/jkitchin/jmax/blob/master/org/doi-utils.org#a-new-doi-link-for-org-mode][doi link]] gives me a menu to:
1. open in https://doi.org
2. open the doi in Web of Science
3. find citing articles in Web of Science
4. search the doi in Google Scholar
5. open the doi in CrossRef
6. open the doi in Pubmed
7. find the doi in my bibtex file
8. get a bibtex entry for the doi

I get all that from a click! org-ref offers similar functionality for cite links, where you might want to do different things from a click:
1. See preview of the citation
2. open the bibtex entry
3. open the pdf if you have it
4. open the url for the entry
5. any of the things I listed for the doi example above.

I am sure there are many other things that might be useful to do!




* DONE Accessing web of science entry, citing and related articles from a doi in emacs
  CLOSED: [2014-11-04 Tue 21:18]
  :PROPERTIES:
  :categories: emacs,orgmode,org-ref
  :date:     2014/11/04 21:18:10
  :updated:  2014/11/05 10:55:03
  :END:

I have been investigating how to more deeply integrate online resources, scientific bibliographies and writing in Emacs. One feature I have been wanting is integration with [[http://apps.webofknowledge.com/UA_GeneralSearch_input.do?product=UA&search_mode=GeneralSearch&SID=4DwqzHSXl8YdqGjGQ2z&preferencesSaved=][Web Of Science]], especially to find citing and related articles from a DOI. This service is not free, but is available at many places where science is done. I came across this API http://wokinfo.com/media/pdf/OpenURL-guide.pdf to make links to the things I am interested in here. Based on that document, here are three links based on a doi:10.1021/jp047349j that take you to different Web Of Science (WOS) pages.


1. go to article in WOS: http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j
2. citing articles: http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info%3Adoi%2F10.1021/jp047349j&svc_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Asch_svc&svc.citing=yes
3. related articles: http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info%3Adoi%2F10.1021/jp047349j&svc_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Asch_svc&svc.related=yes

These are pretty easy to construct, so we can write functions that will create them and open the url in our browser. There are some other options that could be considered, but since we usually have a doi, it seems like the best way to go for creating the links. Here are the functions.

#+BEGIN_SRC emacs-lisp
(defun doi-utils-wos (doi)
  "Open Web of Science entry for DOI"
  (interactive "sDOI: ")
  (browse-url
   (format
    "http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/%s" doi)))

(defun doi-utils-wos-citing (doi)
  "Open Web of Science citing articles entry. May be empty if none are found"
  (interactive "sDOI: ")
  (browse-url
   (concat
    "http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info%3Adoi%2F"
    doi
    "&svc_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Asch_svc&svc.citing=yes")))

(defun doi-utils-wos-related (doi)
  "Open Web of Science related articles page."
  (interactive "sDOI: ")
  (browse-url
   (concat "http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info%3Adoi%2F"
	   doi
	   "&svc_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Asch_svc&svc.related=yes")))
#+END_SRC

#+RESULTS:
: doi-utils-wos-related

These are exciting because they could be integrated into org-ref or doi-utils to make citations in an org-document even more functional! There are some other interesting things [[http://bibwild.wordpress.com/2009/04/13/cited-by-from-isi-and-scopus-in-the-link-resolver/][here]] about Scopus and issues with ISI that I note for reference to future me.

Some of these are now included in [[https://github.com/jkitchin/jmax/blob/master/jmax-bibtex.el][jmax-bibtex.el]] and [[https://github.com/jkitchin/jmax/blob/master/org/doi-utils.org][doi-utils.org]].


* DONE Machine-gradable quizzes in emacs+org-modex
  CLOSED: [2014-11-23 Sun 16:49]
  :PROPERTIES:
  :categories: org,emacs,education
  :date:     2014/11/23 16:49:52
  :updated:  2014/11/23 16:49:52
  :END:

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/01/Interactive-quizzes-with-feedback-in-org-mode/][post]], we considered interactive quizzes in emacs and org-mode. Here we consider a variation of that idea with the aim of creating a machine-gradable quiz, i.e. a modern version of a scantron.

The idea is simple, we will let each question be represented by an org headline, and the choices will be clickable links that store the answer as a property in the headline. Each headline will have a unique id. The grading key will contain these ids and the correct answer, and a function will determine if the right answer was selected for each question.

Here is a simple link that will store the value of the link as a property. Note that the path must be at least two characters long to be recognized as a link, unless you wrap the link in double brackets. We will have the link insert a comment to indicate to the user what they chose. We do that because the PROPERTIES drawer is usually hidden, and it is not obvious it was changed.

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "mc"
 (lambda (link)
   (save-restriction
     (org-narrow-to-subtree)
     (goto-char (point-max))
     (insert (concat
	      (unless (bolp) "\n")
	      (format "# you chose %s" link))))

   (org-entry-put (point) "ANSWER" link)))
#+END_SRC

Next, we add a subheading with some questions to test the link.
** Some questions
*** question 1
    :PROPERTIES:
    :ID:       19C7BA30-A761-4C94-9F3B-E6010E263949
    :ANSWER:   c
    :END:
What is 2 + 2?

[[mc:a]] 1

[[mc:b]] 2

[[mc:c]] 4

# you chose a
# you chose c
*** question 2
    :PROPERTIES:
    :ID:       38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9
    :ANSWER:   a
    :END:
What is 2 - 2?

[[mc:a]] 0

[[mc:b]] 2

[[mc:c]] 4
# you chose c
# you chose a
** Grading

We will store an alist of id and answer for each problem. To grade, we simple map over the alist, go to the section with the id, and compare the answers. When the answer is correct, we save a point, and when not, no point. We can use the org-mode machinery to jump to the problems and get the stored answer. We put some feedback at the end of the file to see what was right, and what was wrong.

#+BEGIN_SRC emacs-lisp
(let* ((key '(("19C7BA30-A761-4C94-9F3B-E6010E263949" . "c")
	      ("38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9" . "a")))
       (MAX (length key))
       (points 0)
       (answer))

  (dolist (tup key)
    (save-excursion
      (org-open-link-from-string
       (format "id:%s" (car tup)))
      (setq answer (org-entry-get (point) "ANSWER"))
      (if (string= answer (cdr tup))
	  (progn
	    (setq points (+ 1 points))
	    (goto-char (point-max))
	    (insert (format "# id:%s: %s correct\n" (car tup) answer)))
        (goto-char (point-max))
	(insert (format "# id:%s: %s wrong (%s is correct)\n"
			(car tup)
			answer
			(cdr tup))))))
  (goto-char (point-max))
  (insert (format
	   "#+GRADE: %s" (/ (float points) (float MAX)))))
#+END_SRC

That works pretty well. I need to think about how to codify the key, since this would usually be stored in some file. We would also need to wrap the code block in a function that we could call easily. The org-id key is easy, but not very readable. It would make it easy to keep a database of these problems though.
# id:19C7BA30-A761-4C94-9F3B-E6010E263949: a wrong (c is correct)
# id:38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9: a correct
#+GRADE: 0.5

Just for completeness, I want to save the key to a file, and use it. We simply write the alist in a file. Here are the contents, which are tangled to key.el. One alternative might be to have a solution copy of the quiz which has the answers in it, and we read the answers from the file.

#+BEGIN_SRC emacs-lisp :tangle key.el
(("19C7BA30-A761-4C94-9F3B-E6010E263949" . "c")
 ("38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9" . "a"))
#+END_SRC

Now, we read it in like this. The rest of the code is basically the same.

#+BEGIN_SRC emacs-lisp
(let* ((key (with-temp-buffer
              (insert-file-contents "key.el")
	      (read (current-buffer))))
       (MAX (length key))
       (points 0)
       (answer))

  (dolist (tup key)
    (save-excursion
      (org-open-link-from-string
       (format "id:%s" (car tup)))
      (setq answer (org-entry-get (point) "ANSWER"))
      (if (string= answer (cdr tup))
	  (progn
	    (setq points (+ 1 points))
	    (goto-char (point-max))
	    (insert (format "# id:%s: %s correct\n" (car tup) answer)))
        (goto-char (point-max))
	(insert (format "# id:%s: %s wrong (%s is correct)\n"
			(car tup)
			answer
			(cdr tup))))))
  (goto-char (point-max))
  (insert (format
	   "#+GRADE: %s" (/ (float points) (float MAX)))))
#+END_SRC

# id:19C7BA30-A761-4C94-9F3B-E6010E263949: a wrong (c is correct)
# id:38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9: a correct
#+GRADE: 0.5

It is probably much easier to have a solution version of the quiz, and generate the key from it. For example, we can collect the ID and ANSWER from the problems in this file like this.

#+BEGIN_SRC emacs-lisp :results code
(let ((key '()))
  (org-map-entries
   (lambda ()
     (let ((id) (ans))
       (when (and
	      (setq id (org-entry-get (point) "ID"))
	      (setq ans (org-entry-get (point) "ANSWER")))
	 (add-to-list 'key (cons id ans))))))
key)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9" . "a")
 ("19C7BA30-A761-4C94-9F3B-E6010E263949" . "c"))
#+END_SRC

So, if we had a master solution file, we could read the key from there. That is the way to do this.

* DONE A helm interface to ps
  CLOSED: [2014-11-22 Sat 12:57]
  :PROPERTIES:
  :categories: helm emacs
  :date:     2014/11/22 12:57:42
  :updated:  2014/11/22 15:00:25
  :END:
Occassionally, I need to find the PID of a process to kill it or do something else. Usually I do the old-school unix thing  of piping the output of one command (ps) to another command (grep) to filter out interesting lines. Then, I can do something with that output.

#+BEGIN_SRC sh
ps aux | grep emacs
#+END_SRC

#+RESULTS:

Today, I will explore using helm in emacs to do something like that. The idea is to create a helm command that uses the output of ps as candidates, and then you select the process you want through the helm interface, and then select an action.

It is easy enough to get the output of the ps command in emacs like this. Here, we just get the first three results, and specify the output we want.

#+BEGIN_SRC emacs-lisp :results code
(let ((results (split-string
		(shell-command-to-string
		 "ps x -o ruser,pid,command") "\n")))
  (loop for i from 1 to 3
	collect (elt results i)))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("jkitchin   139 /sbin/launchd" "jkitchin   151 /usr/libexec/UserEventAgent (Aqua)" "jkitchin   152 /usr/sbin/distnoted agent")
#+END_SRC

These will be the candidates for the helm command. We will create a few actions. One will provide details about the pid, and one could in principle kill the pid or send some signal to it. We will just have these actions create message boxes for us to see helm in action. We will make the kill function interactive, so it allows an arbitrary signal to be sent. The other actions are placeholders for future actions, and so we can show off some shortcuts in helm later.

For the candidates, we will construct a list of cons cells where the car is a line from ps, and that is what will show in the helm selection interface, and the cdr will be the pid which we get by parsing the line to get the second element. When you select an entry in helm, the cdr of that entry (if it exists) is passed to the action function selected.

#+BEGIN_SRC emacs-lisp :results silent
(defun ps-candidates ()
  "return a list of cons cells (line . pid) for the output of ps"
  (loop for line in
	;; skip the first line which is a header
	(cdr (split-string
	      (shell-command-to-string
	       "ps ax -o ruser,pid,command") "\n"))
	collect
	(cons
	 line
	 (elt (split-string line) 1))))

(defun ps-details (pid)
  "give details of PID."
  (message-box "%s" (shell-command-to-string (format "ps ux %s" pid))))

(defun ps-kill (pid)
  "Message box instead of killing PID."
  (let ((SIG (read-string "Kill with signal: ")))
    (message-box "Killing pid %s with signal %s" pid SIG)))

(defun ps-hello (pid)
  (message-box "Silly 3rd action for %s" pid))

(defun ps-bye (pid)
  (message-box "Silly 4th action for %s" pid))

(defun ps-byebye (pid)
  (message-box "Silly 5th action for %s" pid))

;; the source variable for helm
(setq helm-source-ps '((name . "ps output")
		       ;; these are the entries you can select
		       (candidates . ps-candidates)
		       ;; these are the actions available for the
		       ;; selected entry. each function gets the cdr
		       ;; of the entry selected.
		       (action . (("details" . ps-details)
				  ("kill" . ps-kill)
				  ("hello" . ps-hello)
				  ("bye" . ps-bye)
				  ("byb-bye" . ps-byebye)))))

;; now we run the helm command
(helm :sources '(helm-source-ps))
#+END_SRC


You can navigate the helm interface with the arrows, or C-n (next/down) C-p (previous/up), or by typing in the pattern you want to match. There are only two actions here. The first one is the default action, which you can run by pressing tab or enter. The subtle difference between them is that tab leaves the helm window open, while enter runs the default action and closes the helm window. You can get it back with C-c h r (or M-x helm-resume).

To get the kill function, you can press C-z to get the action menu, and then press enter. Helm provides a shortcut for this. C-e selects the second action, so when you remember what the second action is and you want it, you can skip the C-z activity. You can access the third action with C-j. There is a command like helm-select-4th-action, but it is not bound to a key, so we have to make one like this.

#+BEGIN_SRC emacs-lisp :results silent
(define-key helm-map (kbd "C-k") 'helm-select-4th-action)
#+END_SRC

You can also define a 5th action like this. It does not seem possible to define an arbitrary nth action, because you cannot get an input for n while helm uses the minibuffer.

#+BEGIN_SRC emacs-lisp :results silent
(defun 5th-action ()
 (interactive)
 (let ((n 5))
   ;; actions start at 0, so the 5th action is actually indexed at 4
   (helm-select-nth-action (- n 1))))

(define-key helm-map (kbd "C-l") '5th-action)
#+END_SRC

That is the proof of concept in using a helm interface to interact with unix commands. There are other actions you might choose, like renice, or maybe it is possible to suspend a job by pid. The real application for this I had in mind was interaction with the Torque queue system, where you might want to modify, kill jobs in the queue system this way. I could also see applications in user management, where you have some well defined functions to run, e.g. checking quotas, changing passwords, etc... Clearly the utility of this approach rests heavily on there being a set of actions you do regularly enough to justify coding them into functions, and often enough you would remember to use your helm command! It is an interesting approach as an alternative to writing shell scripts to do this though.

This post might make more sense if you watch this video of the helm interface in action: http://www.youtube.com/watch?v=3FImB6OwHI0
* DONE The loop macro in emacs lisp
  CLOSED: [2014-11-20 Thu 09:50]
  :PROPERTIES:
  :categories: emacs_lisp
  :date:     2014/11/20 09:50:00
  :updated:  2014/11/20 09:50:00
  :END:
I was reading [[http://landoflisp.com][The Land Of Lisp]] chapter on the loop macro in Common Lisp. I am not too familiar with it, or the implementation in emacs-lisp, so in this post we explore what it can do. Here I will explore some uses of the loop macro to do things I used to do in Python all the time.

Here is a simple example to generate a list of numbers with the loop macro..

#+BEGIN_SRC emacs-lisp
(loop for i
      below 5
      collect i)
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 |

Evidently, i starts at 0, and increments by one. We can specify a different value like this. Here we use the =to= token, which also includes the last value.

#+BEGIN_SRC emacs-lisp
(loop for i from 2 to 10
  collect i)
#+END_SRC

#+RESULTS:
| 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

IF you want to go backwards:
#+BEGIN_SRC emacs-lisp
(loop for i downfrom 10 to 2 collect i)
#+END_SRC

#+RESULTS:
| 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 |

And if you want an (de)increment different than one, use the =by= token.
#+BEGIN_SRC emacs-lisp
(loop for i downfrom 10 to 2 by 3 collect i)
#+END_SRC

#+RESULTS:
| 10 | 7 | 4 |

We can use this to iterate over a list too. Let us collect the square of each element in a simple list. This is similar to the mapcar function.

#+BEGIN_SRC emacs-lisp
(loop for i in '(1 2 3 4)
  collect (* i i))
#+END_SRC

#+RESULTS:
| 1 | 4 | 9 | 16 |

You can combine the ideas to get something similar to the enumerate function in python.
#+BEGIN_SRC emacs-lisp :results code
(loop for i
      from 0
      for month
      in '(january february march april may june july august september
		   october november december)
      collect (cons i month))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((0 . january)
 (1 . february)
 (2 . march)
 (3 . april)
 (4 . may)
 (5 . june)
 (6 . july)
 (7 . august)
 (8 . september)
 (9 . october)
 (10 . november)
 (11 . december))
#+END_SRC

The loop stops because we run out of months to iterate over.  Here is a variation like the zip function in python.

#+BEGIN_SRC emacs-lisp
(loop for element1 in '(a b c d)
      for element2 in '(1 2 3 4)
      collect (list element1 element2))
#+END_SRC

#+RESULTS:
| a | 1 |
| b | 2 |
| c | 3 |
| d | 4 |

We can sum in the loop:
#+BEGIN_SRC emacs-lisp
(loop for i in '(100 200 300) sum i)
#+END_SRC

#+RESULTS:
: 600

We can conditionally sum things in the loop, e.g. sum only the odd numbers.
#+BEGIN_SRC emacs-lisp
(loop for i in '(1 2 3 4 5)
  when (oddp i)
  sum i)
#+END_SRC

#+RESULTS:
: 9

We can find the minima and maxima in a list
#+BEGIN_SRC emacs-lisp
(loop for i in '(-1 0 1)
  minimize i)
#+END_SRC

#+RESULTS:
: -1

#+BEGIN_SRC emacs-lisp
(loop for i in '(-1 0 1)
  maximize i)
#+END_SRC

#+RESULTS:
: 1

You may want to do some action in the loop. Say we want to print even numbers from a list.

#+BEGIN_SRC emacs-lisp :results output
(loop for i in '(1 2 3 4)
      when (evenp i)
      do (print i))
#+END_SRC

#+RESULTS:
:
: 2
:
: 4

There are some ways to break out of a loop using =return= like this.

#+BEGIN_SRC emacs-lisp :results output
(loop for i upto 10
      when (= i 3)
      return 'done
      do (print i))
#+END_SRC

#+RESULTS:
:
: 0
:
: 1
:
: 2

Alternatively, you can use while/until.

#+BEGIN_SRC emacs-lisp :results output
(loop for i downfrom 10
      do (print i)
      until (= i 6))
#+END_SRC

#+RESULTS:
#+begin_example

10

9

8

7

6
#+end_example

Or the while variation:

#+BEGIN_SRC emacs-lisp :results output
(loop for i downfrom 10
      do (print i)
      while (> i 6))
#+END_SRC

#+RESULTS:
#+begin_example

10

9

8

7

6
#+end_example

** Summary
This is not everything the loop macro can do! Here is what the help for that function says.

#+BEGIN_EXAMPLE
loop is an alias for `cl-loop' in `cl.el'.

(loop CLAUSE...)

The Common Lisp `loop' macro.
Valid clauses include:
  For clauses:
    for VAR from/upfrom/downfrom EXPR1 to/upto/downto/above/below EXPR2 by EXPR3
    for VAR = EXPR1 then EXPR2
    for VAR in/on/in-ref LIST by FUNC
    for VAR across/across-ref ARRAY
    for VAR being:
      the elements of/of-ref SEQUENCE [using (index VAR2)]
      the symbols [of OBARRAY]
      the hash-keys/hash-values of HASH-TABLE [using (hash-values/hash-keys V2)]
      the key-codes/key-bindings/key-seqs of KEYMAP [using (key-bindings VAR2)]
      the overlays/intervals [of BUFFER] [from POS1] [to POS2]
      the frames/buffers
      the windows [of FRAME]
  Iteration clauses:
    repeat INTEGER
    while/until/always/never/thereis CONDITION
  Accumulation clauses:
    collect/append/nconc/concat/vconcat/count/sum/maximize/minimize FORM
      [into VAR]
  Miscellaneous clauses:
    with VAR = INIT
    if/when/unless COND CLAUSE [and CLAUSE]... else CLAUSE [and CLAUSE...]
    named NAME
    initially/finally [do] EXPRS...
    do EXPRS...
    [finally] return EXPR

For more details, see Info node `(cl)Loop Facility'.
#+END_EXAMPLE

It is obviously quite powerful, although the syntax seems quite different than the usual lisp code I have been writing. It is not clear when this is superior to something like mapcar/mapconcat, or the dolist/dotimes functions.


* DONE Selective auto-capitalization in org-buffers
  CLOSED: [2014-12-03 Wed 12:20]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2014/12/03 12:20:24
  :updated:  2014/12/03 12:20:24
  :END:

I have been using auto-capitalize.el for a short time to automatically capitalize the beginning of sentences. I mostly like what it does, but in org-mode I tend to write short code blocks while still in org-mode, and it is pretty irritating for auto-capitalize to "fix" the capitalization of your code. Of course, I can type C-c ' to edit the block in its native mode, but I do not always want to do that.

Below, I illustrate an approach to turn off auto-capitalize-mode when the cursor is inside a code-block. Basically, we write a function that checks if you are in a src-block, and if auto-capitalize is on, turn it off. If you are not in the code-block, we turn auto-capitalize on if it is not on. Then we hook the function into post-command-hook, which will run it after every emacs command, including cursor movements.

Here is that code:
#+BEGIN_SRC emacs-lisp
(defun dwiw-auto-capitalize ()
  (if (org-in-block-p '("src"))
      (when auto-capitalize
	(auto-capitalize-mode -1))
    (unless auto-capitalize
      (auto-capitalize-mode 1))))

(add-hook 'post-command-hook 'dwiw-auto-capitalize)
#+END_SRC

#+RESULTS:
| dwiw-auto-capitalize |

It works! Now the minor mode turns on and off depending on where the cursor is in my org document.



* DONE A database of quiz questions to generate quizzes and solutions
  CLOSED: [2014-11-28 Fri 14:41]
  :PROPERTIES:
  :categories: education
  :date:     2014/11/28 14:41:45
  :updated:  2014/11/28 14:41:45
  :END:
In this [[http://kitchingroup.cheme.cmu.edu/blog/2014/11/23/Machine-gradable-quizzes-in-emacs+org-modex/][post]] I talked about a machine gradable quiz. One issue I have been trying to resolve is how to keep questions and solutions together. Currently, I have them separated, and that occasionally leads to them not being synchronized. One tricky part is if they are together, how do you create the quiz without answers in them? The answer is you have to "export" the quiz and selected problems, with selective content, and you want the elements of the question exported in some format, e.g. html or LaTeX.

I am going to explore representing a question as some data structure, not in org-mode for now. Then, we will use emacs-lisp to format the question the way we want it. The data we need about a question include the type of question, a unique id, the question, the choices, and the answer. For the choices, we might want some descriptive text for the solution. Here is one example of how we could represent a question as a struct in emacs-lisp. I do not claim here that this is the best or most complete way to represent it; it is simply a way that we could do it so we can discuss it later.

#+BEGIN_SRC emacs-lisp
(defstruct question type id question choices)
#+END_SRC

#+RESULTS:
: question

The defstruct macro creates a constructor function "make-question" for us, and we create questions like this:

#+BEGIN_SRC emacs-lisp
(setq q1 (make-question
	  :type 'multiple-choice
	  :id "id:1"
	  :question "What is 2 + 2?"
	  :choices '(('choice 0 "Not correct")
		     ('choice 2 "Not correct")
		     ('choice 4 nil 'answer)
		     ('choice "None of the above" "Not correct"))))
#+END_SRC

#+RESULTS:
: [cl-struct-question multiple-choice "id:1" "What is 2 + 2?" (((quote choice) 0 "Not correct") ((quote choice) 2 "Not correct") ((quote choice) 4 nil (quote answer)) ((quote choice) "None of the above" "Not correct"))]

The defstruct macro also creates accessor functions to get the information stored in the question. These go by "question-SLOTNAME" and they make it pretty easy to get the data. We can convert this structure to an org-mode formatted question by using a formatted string, substituting values from the question object where we want them. I will make the headline contain the question, create some properties, and then make an org-link for each choice. The mc link is something I defined in the previous post.

#+BEGIN_SRC emacs-lisp
(format "** %s
  :PROPERTIES:
  :ID: %s
  :END:
%s" (question-question q1)
(question-id q1)
(mapconcat 'identity (loop for i to (length (question-choices q1))
			   for choice in (question-choices q1)
			   collect
			   (format "[[mc:%s]] %s" i (elt choice 1)))
	   "\n"))
#+END_SRC

#+RESULTS:
: ** What is 2 + 2?
:   :PROPERTIES:
:   :ID: id:1
:   :END:
: [[mc:0]] 0
: [[mc:1]] 2
: [[mc:2]] 4
: [[mc:3]] None of the above

To generate a quiz, we would just need to loop over several questions and insert the strings into a buffer then save it to a file.

To generate the key, we use pretty similar code, and additionally find the choice that is the answer, and print any hints with the choices.
#+BEGIN_SRC emacs-lisp :results value org
(format "** %s
  :PROPERTIES:
  :ID: %s
  :CORRECT-ANSWER: %s
  :END:
%s" (question-question q1)
    (question-id q1)
    ;; here we loop through the choices looking for the answer
    (loop for choice in (question-choices q1)
	  until (-contains? choice '(quote answer))
	  finally return (elt choice 1))
    (mapconcat 'identity (loop for i to (length (question-choices q1))
			       for choice in (question-choices q1)
			       collect
			       (format "[[mc:%s]] %s
%s" i (elt choice 1) (or (elt choice 2) "")))
	       "\n"))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
,** What is 2 + 2?
  :PROPERTIES:
  :ID: id:1
  :CORRECT-ANSWER: 4
  :END:
[[mc:0]] 0
Not correct
[[mc:1]] 2
Not correct
[[mc:2]] 4

[[mc:3]] None of the above
Not correct
#+END_SRC

It is a similar process to convert to LaTeX or HTML as well, just different syntax in the format statement.

The next question is how to make authoring the questions pretty easy, i.e. with a minimal amount of syntax that represents the question data and is easy to transform. The lisp data structure is not too bad, but might be less familiar to many. Next we consider how to represent this question in org-mode. For example the question would be in a headline, and the ID and answer stored as properties. The choices might be stored as sub-headings that are tagged as choices. Then, constructing the question would entail going to the question headline, getting the information you want, and formatting it like I did above. The next section represents a question in org-mode. I think it actually takes more typing to do this, but some of it reuses some org-machinery I am familiar with. In any case, it is possible to store all the same kind of information using combinations of tags and properties. The next section is the question (only really visible in org-mode, not in the html post), and the section after that is how to use it.

** What is 2 + 2?		 :multiple_choice:
  :PROPERTIES:
  :CORRECT-ANSWER: 4
  :ID:       99D480BD-9651-4987-9646-4BE90BA6CAEC
  :END:

*** 0					  :choice:
Not correct, This is the answer to 2 - 2.

*** 2					  :choice:
Not correct

*** 4				   :choice:answer:
Correct.

*** None of the above			  :choice:
This is not correct

** Working with the org representation of a question
Now, we use the org-machinery to work with the question and represent it in different formats. Here we just get the choices for a question with a specific id. We jump to the question, find headings tagged choice, and collect them.

#+BEGIN_SRC emacs-lisp
(save-excursion
  (org-open-link-from-string "id:99D480BD-9651-4987-9646-4BE90BA6CAEC")
  (save-restriction
    (org-narrow-to-subtree)
    (let ((choices '()))
      (org-map-entries
       (lambda ()
	 (add-to-list
	  'choices
	  (org-heading-components)
	  t))
       "choice")
      choices)))
#+END_SRC
#+RESULTS:
| 3 | 3 | nil | nil |                 0 | :choice: |
| 3 | 3 | nil | nil |                 2 | :choice: |
| 3 | 3 | nil | nil |                 4 | :choice: |
| 3 | 3 | nil | nil | None of the above | :choice: |

You could use the headline for each choice to construct a question. For example, here we output some HTML to represent checkboxes in an HTML form.

#+BEGIN_SRC emacs-lisp :results html
(save-excursion
  (org-open-link-from-string "id:99D480BD-9651-4987-9646-4BE90BA6CAEC")
  (let ((all-choices
	 (save-restriction
	   (org-narrow-to-subtree)
	   (let ((choices '()))
	     (org-map-entries
	      (lambda ()
		(add-to-list
		 'choices
		 (elt (org-heading-components) 4)
		 t))
	      "choice")
	     choices)))
	(question (elt (org-heading-components) 4))
	)
    (concat
     "<html><body>\n"
     "<h1>" question "</h1>\n"
     "<form action = \"\">"
     (mapconcat
      'identity
      (loop for choice in all-choices
	    collect
	    (format "  <input type=\"checkbox\" name=\"choice\" value=\"%s\">%s<br>"
		    choice choice))
      "\n")
     "\n</form>\n"
     "</body></html>")))
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<html><body>
<h1>What is 2 + 2?</h1>
<form action = "">  <input type="checkbox" name="choice" value="0">0<br>
  <input type="checkbox" name="choice" value="2">2<br>
  <input type="checkbox" name="choice" value="4">4<br>
  <input type="checkbox" name="choice" value="None of the above">None of the above<br>
</form>
</body></html>
#+END_HTML

There is no action button to submit this answer, but you could add one if wanted. Clearly, you will have custom functions to export each format you want, with the information you want in it. The code for the org-mode representation is a little more verbose than the lisp data representation, but they accomplish basically the same thing. One thing that would be necessary to do is create some functions that take a list of question IDs and generate the quiz and solution in a buffer, and a helm interface for question selection would be pretty sweet.

I can see adding several other pieces of information about a problem, including categories or keywords, level of difficulty, how many points the problem is worth, last time it was assigned, relationship to course learning objectives, maybe information about who authored the problem, and a source if that is appropriate. These would allow you to consider machine grading, or correlating performance between problems, assessing how a class is doing on a problem, etc... Lots of potential here.



* DONE A new mode for Python documentation
  CLOSED: [2014-12-20 Sat 15:02]
  :PROPERTIES:
  :date:     2014/12/20 15:02:05
  :updated:  2014/12/22 10:12:20
  :categories: emacs,python
  :END:

[2014-12-22 Mon] update: See this in action at http://www.youtube.com/watch?v=G_r7wTcVK54, and see the latest source at https://github.com/jkitchin/jmax/blob/master/pydoc.el.

The emacs-lisp documentation in Emacs is inspiring. It is interlinked, you can click on links to open source files, other commands, etc... Python documentation is not that nice. It should be.

I wrote a little pydoc function:

#+BEGIN_SRC emacs-lisp
(defun pydoc (name)
  "Display pydoc information for NAME in a buffer named *pydoc*."
  (interactive "sName of function or module: ")
  (switch-to-buffer-other-window "*pydoc*")
  (erase-buffer)
  (insert (shell-command-to-string (format "python -m pydoc %s" name)))
  (goto-char (point-min)))
#+END_SRC

which at least accesses python documentation in emacs. It looks like this:

[[./images/pydoc-jasp.png]]

But, this lacks functionality. I want there to be useful links in this, so I can click on the filename to open the source, or click on the packages to get their documentation. Below, we walk through a few functions that will operate on the buffer and put text properties on different pieces.


First, let us make the source file clickable so it opens the source.

#+BEGIN_SRC emacs-lisp
(defun pydoc-make-file-link ()
  "Find FILE in a pydoc buffer and make it a clickable link"
  (goto-char (point-min))
  (when (re-search-forward "^FILE
    \\(.*\\)$" nil t)

    (let ((map (make-sparse-keymap))
	  (start (match-beginning 1))
	  (end (match-end 1))
	  (source-file (match-string 1)))

      ;; set file to be clickable to open the source
      (define-key map [mouse-1]
	`(lambda ()
	  (interactive)
	  (find-file ,source-file)))

      (set-text-properties
       start end
       `(local-map, map
		   font-lock-face (:foreground "blue"  :underline t)
		   mouse-face highlight
		   help-echo "mouse-1: click to open")))))
#+END_SRC

#+RESULTS:
: pydoc-make-file-link

Next, sometimes there are URLs in the python documentation. These should all open up in a browser when you click on them. Here we propertize anything we recognize as a URL to make it open when clicked on.

#+BEGIN_SRC emacs-lisp
(defun pydoc-make-url-links ()
  (goto-char (point-min))
  (while (re-search-forward "\\(http\\(s\\)?://.*$\\)" nil t)
    (let ((map (make-sparse-keymap))
	  (start (match-beginning 1))
	  (end (match-end 1)))

      (define-key map [mouse-1]
	`(lambda ()
	  (interactive)
	  (browse-url ,(buffer-substring start end))))

      (set-text-properties
       start end
       `(local-map ,map
		   font-lock-face (:foreground "blue"  :underline t)
		   mouse-face highlight
		   help-echo (format "mouse-1: click to open"))))))
#+END_SRC

When we get documentation for a package, we should make each entry of the package clickable, so we can get to the documentation for that package easily. We store the name of the current package so we can construct the path to the subpackage.

#+BEGIN_SRC emacs-lisp
(defun pydoc-get-name ()
  "get NAME and store locally"
  (make-variable-buffer-local 'pydoc-name)
  (goto-char (point-min))
  (when (re-search-forward "^NAME
\\s-*\\([^-][a-zA-Z]*\\)" nil t)
    (setq pydoc-name (match-string 1))))


(defun pydoc-make-package-links ()
  "make links in PACKAGE CONTENTS"
  (goto-char (point-min))
  (when (re-search-forward "^PACKAGE CONTENTS" nil t)
    (forward-line)

    (while (string-match
	    "^    \\([a-zA-Z0-9_]*\\)[ ]?\\((package)\\)?"
	    (buffer-substring
	     (line-beginning-position)
	     (line-end-position)))

      (let ((map (make-sparse-keymap))
	    (start (match-beginning 1))
	    (end (match-end 1))
	    (package (concat
		      pydoc-name "."
		      (match-string 1
				    (buffer-substring
				     (line-beginning-position)
				     (line-end-position))))))

	(define-key map [mouse-1]
	  `(lambda ()
	    (interactive)
	    (pydoc ,package)))

	(set-text-properties
	 (+ (line-beginning-position) start)
	 (+ (line-beginning-position) end)
	 `(local-map, map
		      font-lock-face (:foreground "blue"  :underline t)
		      mouse-face highlight
		      help-echo (format "mouse-1: click to open %s" ,package))))
      (forward-line))))
#+END_SRC

Next, we put some eye candy on function names and arguments. This won't do anything functionally, but it breaks up the monotony of all black text.

#+BEGIN_SRC emacs-lisp
(defun pydoc-colorize-functions ()
  "Change color of function names and args."
  (goto-char (point-min))
  (when (re-search-forward "^Functions" nil t)
    (while (re-search-forward "    \\([a-zA-z0-9-]+\\)(\\([^)]*\\))" nil t)
      (set-text-properties
       (match-beginning 1)
       (match-end 1)
       '(font-lock-face (:foreground "brown")))

      (set-text-properties
       (match-beginning 2)
       (match-end 2)
       '(font-lock-face (:foreground "red"))))))
#+END_SRC

I have gotten used to the [back] link in emacs-lisp documentation, so we try to emulate it here.

#+BEGIN_SRC emacs-lisp
(defun pydoc-insert-back-link ()
  "Insert link to previous buffer"
  (goto-char (point-max))
  (insert "
[back]")
  (let ((map (make-sparse-keymap)))

    ;; set file to be clickable to open the source
    (define-key map [mouse-1]
      (lambda ()
	(interactive)
        (pydoc *pydoc-last*)))

      (set-text-properties
       (line-beginning-position)
       (line-end-position)
       `(local-map, map
		    font-lock-face (:foreground "blue"  :underline t)
		    mouse-face highlight
		    help-echo "mouse-1: click to return"))))
#+END_SRC

#+RESULTS:
: pydoc-insert-back-link

Ok, finally we remake the pydoc function.
#+BEGIN_SRC emacs-lisp
(defvar *pydoc-current* nil
 "Stores current pydoc command")

(defvar *pydoc-last* nil
 "Stores the last pydoc command")

(defun pydoc (name)
  "Display pydoc information for NAME in a buffer named *pydoc*."
  (interactive "sName of function or module: ")

  (switch-to-buffer-other-window "*pydoc*")
  (setq buffer-read-only nil)
  (erase-buffer)
  (insert (shell-command-to-string (format "python -m pydoc %s" name)))
  (goto-char (point-min))

  ;; save
  (when *pydoc-current*
      (setq *pydoc-last* *pydoc-current*))
  (setq *pydoc-current* name)


  (save-excursion
    (pydoc-get-name)
    (pydoc-make-url-links)
    (pydoc-make-file-link)
    (pydoc-make-package-links)
    (pydoc-colorize-functions)
    (pydoc-insert-back-link))

  ;; make read-only and press q to quit
  (setq buffer-read-only t)
  (use-local-map (copy-keymap org-mode-map))
  (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))

  (font-lock-mode))
#+END_SRC

#+RESULTS:
: pydoc

Now, we get a much more functional pydoc:

#+CAPTION: Annotated screenshot
[[./images/pydoc-enhanced-jasp.png]]

and with the colorized function names:

[[./images/pydoc-potcar.png]]

Admittedly, there seems to be a lot of boilerplate code for propertizing the strings, but it doesn't seem too bad. I will probably use this documentation tool this spring, so maybe I will think of new functionality to add to pydoc. Any ideas?


<<<<<<< HEAD
=======
* DONE 2014 Kitchin Research Group in a nutshell
  CLOSED: [2015-01-18 Sun 10:59]
  :PROPERTIES:
  :EXPORT_FILE_NAME: my-pdf
  :END:

** Graduated students
Steve Illes, Wenqin You, Meiheng Lu, and Nitish Govindarajan finished their MS degrees! Congratulations!

** Publications
It looks like six publications this year. We have six out for review right now, so next year looks like a good one!

Matthew T. Curnan and John R. Kitchin, Effects of Concentration, Crystal Structure, Magnetism, and Electronic Structure Method on First-Principles Oxygen Vacancy Formation Energy Trends in Perovskites, J. Phys. Chem. C., https://doi.org/10.1021/jp507957n.

Zhongnan Xu and John R. Kitchin, Probing the Coverage Dependence of Site and Adsorbate Configurational Correlations on (111) Surfaces of Late Transition Metals, J. Phys. Chem. C., https://doi.org/10.1021/jp508805h.

Ethan L. Demeter , Shayna L. Hilburg , Newell R. Washburn , Terrence J. Collins , and John R. Kitchin, Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator,  Journal of the American Chemical Society, 136(15) 5603-5606 (2014). https://doi.org/10.1021/ja5015986

Robert L. Thompson, Wei Shi, Erik Albenze, Victor A. Kusuma, David Hopkinson, Krishnan Damodaran,  Anita S. Lee, John R. Kitchin, David R. Luebke and Hunaid Nulwala, Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids, RSC Advances, 4 (25), 12748-12755 (2014). https://doi.org/10.1039/C3RA47097K.

Mehta, Prateek; Salvador, Paul; Kitchin, John, Identifying Potential BO2 Oxide Polymorphs for Epitaxial Growth Candidates", ACS Applied Materials and Interfaces, 6(5), 3630-3639 (2014). http://pubs.acs.org/doi/full/10.1021/am4059149.

Zhongnan Xu and John R Kitchin, Relating the Electronic Structure and Reactivity of the 3d Transition Metal Monoxide Surfaces, Catalysis Communications, 52, 60-64 (2014),        https://doi.org/10.1016/j.catcom.2013.10.028.

** Presentations
John Kitchin, Jacob Boes, Gamze Gumuslu, James Miller, Andrew Gellman, "Bulk Composition Dependent H2 Dissociative Adsorption Energies on CuxPd1-x Alloy Surfaces", U. Missouri, Department of Chemical Engineering, September 2014.

John Kitchin, "The next evolution in water oxidation", Department of Materials Science, Duke University, March 2014.

John Kitchin, Jacob Boes, Gamze Gumuslu, James Miller, Andrew Gellman, "Bulk Composition Dependent H2 Dissociative Adsorption Energies on CuxPd1-x Alloy Surfaces" Department of Energy - Basic Energy Science - Catalysis Program meeting, July 2014.

Jacob R. Boes and John R. Kitchin, Estimating Bulk Composition Dependent H2 Dissociative Adsorption Energies on CuxPd1-x Alloy (111) Surfaces, AICHE Atlanta, Nov 2014.

Zhongnan Xu and John R. Kitchin, Coverage-Dependent Site and Adsorbate Configurational Correlations on (111) Surfaces of Late Transition Metals, AICHE Atlanta, Nov 2014.

Matthew Curnan and John R. Kitchin, Prediction of Phase Stability and Transition Pressures in BO2 (B = Ti, V, Ru, Ir) Polymorphs Using DFT+U and Self-Consistent Linear Response Theory, AICHE Atlanta, Nov 2014.

John Kitchin, A success story in using Python in a graduate chemical engineering course, SciPy 2014, June 2014.  https://www.youtube.com/watch?v=IsSMs-4GlT8

** Recognitions
Professor Kitchin awarded the Philip L. Dowd Fellowship Award [[http://kitchingroup.cheme.cmu.edu/blog/2014/02/28/Professor-Kitchin-awarded-the-Philip-L-Dowd-Fellowship-Award/][(link)]].

Mehak Chawla was awarded a Prengle Fellowship ([[http://kitchingroup.cheme.cmu.edu/blog/2014/03/24/Mehak-Chawla-selected-as-the-H-William-and-Ruth-Hamilton-Prengle-Fellow-of-Chemical-Enginering-for-2013-2014/][link]]).

>>>>>>> 58fcf16ce35ec448ba7eff47aaa1bdae28defaf7

* DONE org-mode + Python + git in a graduate engineering course
  CLOSED: [2014-12-18 Thu 21:10]
  :PROPERTIES:
  :categories: orgmode,education
  :date:     2014/12/18 21:10:30
  :updated:  2014/12/19 11:19:51
  :END:

The Fall 2014 semester is over! I thought I would summarize here what we did. I taught a Master's course in Chemical Reaction Engineering for the second time. This time we had 58 students from around the world. What is remarkable about this course is that this time it was taught completely from Emacs. Every lecture was given from Emacs, every assignment completed in Emacs, turned in from Emacs, graded in Emacs, returned in Emacs.

Students came to class, opened Emacs, and ran a command that downloaded the latest syllabus and opened it. They opened the day's lecture notes from a link in the syllabus. I lectured from the notes in Emacs, editing them on the screen live, running Python code to illustrate engineering concepts. Students did exercises in class in Emacs, and ran an Emacs command to "turn it in" which pushed their work to a git server. Later, I ran an Emacs command to collect and grade the work, then return it. Students could run a menu command in Emacs to see their grade report.

Techela provided a menu of commands to turn in assignments, check grade reports, send me feedback, open the syllabus, etc... The notes were written in org-mode, and we used org-latex-fragments to see the equations. We used code-blocks to show Python examples of problem solving, every day in class.  It was awesome!

The way this worked is that most of my students got laptops as part of the MS program they enrolled in. I had my [[http://github.com/jkitchin/jmax][jmax]] repo installed on those computers, along with git, TexLive and Canopy Python. jmax provided a starter-kit for emacs that gave it the functionality I use on a regular basis. In jmax, I created a package of code I call techela, which interfaces Emacs with git, and which provides commands to download and turn in assignments, and to control permissions on each repo. This enabled me to change repos to read-only after they were due, and to grant read access when I wanted students to see them. About 15% of the class had their own computer, and we had to help them get this software installed. This got done in the first week of class, thanks to the help of my teaching assistants.

I ran a [[http://gitolite.com/gitolite/index.html][gitolite]] server that served the course materials, and a repo for each assignment for each student. When students first ran techela, it created a set of ssh keys which were used to authenticate each student in the gitolite server. Techela automates creation of the repos, and the permissions on each repo. Grading of assignments was done in Emacs. Every assignment turned in was an org-file, and we stored grades in the assignments as file tags.  Techela constructed a dynamic gradebook on demand, among other things.

Org-mode played a central role in the success of this course! It enabled the distribution of the notes in a readable, functional form. The programmable aspects of org-mode made it possible to create custom links for machine-gradable multiple choice questions, assignments, and solutions. It made it possible to use the assignments as a data storage source for grades, and later to pull the grades out for analysis.

Overall, the experience was just awesome. Techela has a few edges that need smoothed out, but I look forward to using it again this spring, this time on a course on Molecular Simulation!



* DONE Redirecting stderr in org-mode shell blocks
  CLOSED: [2015-01-04 Sun 08:59]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/01/04 08:59:04
  :updated:  2015/01/11 11:39:47
  :END:
Org-mode shell source blocks do not capture stderr. For example, in this block, with the default setup:

#+BEGIN_SRC sh :results output
echo "testing stdout" >&1
echo "testing stderr" >&2
#+END_SRC

#+RESULTS:
: testing stdout

You can see the second line is not in the output.

If you run this command, you get an *Org-Babel Error Output* buffer saying it is an illegal option.

#+BEGIN_SRC sh
date -g
#+END_SRC

#+RESULTS:

It would be nice to just capture that error, and show it.

We solved this problem in [[http://kitchingroup.cheme.cmu.edu/blog/2014/12/21/Capturing-stderr-from-Python-in-org-mode-take-2/][Python]] by redirecting stderr at runtime. It is not that simple in shell blocks, but we can do a similar thing. The code block is executed (I think) by saving the block to a temporary file, and then running org-babel-sh-command on the file. That magic happens inside the command shell-command-on-region. We just need to make that command redirect stderr. Here is a new shell command that does this. This next block can be tangled out to an executable command. This script takes one argument, which I believe is a filename (the temporary file containing the source block region).

#+BEGIN_SRC sh :tangle sh_stderr.sh :tangle-mode (identity #o755)
#!/bin/bash
{
bash $1
} 2>&1
#+END_SRC

#+RESULTS:

Now, we set org-babel-sh-command to our new shell command.

#+BEGIN_SRC emacs-lisp
(setq org-babel-sh-command "./sh_stderr.sh")
#+END_SRC

#+RESULTS:
: ./sh_stderr.sh

Now, it appears we get what we want:

#+BEGIN_SRC sh :results output
echo "testing stdout" >&1
echo "testing stderr" >&2
#+END_SRC
#+RESULTS:
: testing stdout
: testing stderr

And, with the bad option to date, we get:

#+BEGIN_SRC sh
date -g
echo
#+END_SRC
#+RESULTS:
: date: illegal option -- g
: usage: date [-jnu] [-d dst] [-r seconds] [-t west] [-v[+|-]val[ymwdHMS]] ...
:             [-f fmt date | [[[mm]dd]HH]MM[[cc]yy][.ss]] [+format]
:

Not bad! I have not tested this very thoroughly, i.e. beyond these little examples, but it seems like it could work.

Achim Gratz suggested this simpler approach that does not involve any external scripts. The : at the end is important!

#+BEGIN_SRC sh :results output
exec 2>&1
echo "testing stdout" >&1
echo "testing stderr" >&2
date -g
:
#+END_SRC
#+RESULTS:
: testing stdout
: testing stderr
: date: illegal option -- g
: usage: date [-jnu] [-d dst] [-r seconds] [-t west] [-v[+|-]val[ymwdHMS]] ...
:             [-f fmt date | [[[mm]dd]HH]MM[[cc]yy][.ss]] [+format]

* DONE 2014 Kitchin Research Group in a nutshell
  CLOSED: [2015-01-07 Wed 16:56]
  :PROPERTIES:
  :categories: news
  :date:     2015/01/07 16:56:39
  :updated:  2015/01/16 08:42:14
  :END:

It was a good year for the Kitchin Research Group. Here are a few of our main accomplishments for the year.

** Student accomplishments
Students are the backbone of our group. Steve Illes, Wenqin You, Meiheng Lu, and Nitish Govindarajan finished their MS degrees! Congratulations!

Mehak Chawla and John Michael both passed their PhD qualifying exams. Congratulations!

Prateek Mehta joined Bill Schneider's group at Notre Dame for his PhD!

Four new M.S. students have joined our group: Hari Thirumalai, Venkatesh Naik, Zhaofeng Chen, and Siddharth Deshpande. Welcome!

** Publications
It looks like seven publications this year. We have 5 out for review right now, so next year looks like a good one! Almost all of these were written in org-mode, with amazing, reproducible supporting information documents. Many thanks to my students, and co-authors.

Jacob Boes, Gamze Gumuslu, James Miller, Andrew Gellman, John Kitchin, Estimating bulk composition dependent H_{2} adsorption energies on Cu_{x}Pd_{1-x} alloy (111) surfaces, accepted in ACS Catalysis (Dec. 2014) https://doi.org/10.1021/cs501585k.

Matthew T. Curnan and John R. Kitchin, Effects of Concentration, Crystal Structure, Magnetism, and Electronic Structure Method on First-Principles Oxygen Vacancy Formation Energy Trends in Perovskites, J. Phys. Chem. C., https://doi.org/10.1021/jp507957n.

Zhongnan Xu and John R. Kitchin, Probing the Coverage Dependence of Site and Adsorbate Configurational Correlations on (111) Surfaces of Late Transition Metals, J. Phys. Chem. C., https://doi.org/10.1021/jp508805h.

Ethan L. Demeter , Shayna L. Hilburg , Newell R. Washburn , Terrence J. Collins , and John R. Kitchin, Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator,  Journal of the American Chemical Society, 136(15) 5603-5606 (2014). https://doi.org/10.1021/ja5015986

Robert L. Thompson, Wei Shi, Erik Albenze, Victor A. Kusuma, David Hopkinson, Krishnan Damodaran,  Anita S. Lee, John R. Kitchin, David R. Luebke and Hunaid Nulwala, Probing the effect of electron donation on CO_{2} absorbing 1,2,3-triazolide ionic liquids, RSC Advances, 4 (25), 12748-12755 (2014). https://doi.org/10.1039/C3RA47097K.

Mehta, Prateek; Salvador, Paul; Kitchin, John, Identifying Potential BO_{2} Oxide Polymorphs for Epitaxial Growth Candidates", ACS Applied Materials and Interfaces, 6(5), 3630-3639 (2014). http://pubs.acs.org/doi/full/10.1021/am4059149.

Zhongnan Xu and John R Kitchin, Relating the Electronic Structure and Reactivity of the 3d Transition Metal Monoxide Surfaces, Catalysis Communications, 52, 60-64 (2014), https://doi.org/10.1016/j.catcom.2013.10.028.

Our citations continue to grow:

[[./images/2014-citations.png]]

** Presentations
We did not travel as much this year as we have in the past. Here is where we did go.

John Kitchin, "The next evolution in water oxidation", Department of Materials Science, Duke University, March 2014.

John Kitchin, A success story in using Python in a graduate chemical engineering course, SciPy 2014, June 2014.  https://www.youtube.com/watch?v=IsSMs-4GlT8

John Kitchin, Jacob Boes, Gamze Gumuslu, James Miller, Andrew Gellman, "Bulk Composition Dependent H_{2} Dissociative Adsorption Energies on Cu_{x}Pd_{1-x} Alloy Surfaces" Department of Energy - Basic Energy Science - Catalysis Program meeting, July 2014.

John Kitchin, Jacob Boes, Gamze Gumuslu, James Miller, Andrew Gellman, "Bulk Composition Dependent H_{2} Dissociative Adsorption Energies on Cu_{x}Pd_{1-x} Alloy Surfaces", U. Missouri, Department of Chemical Engineering, September 2014.

Wenqin You, Hari C. Mantripragada, Edward S. Rubin and John Kitchin, Post-combustion CO_{2} Capture Using Metal Organic Frameworks-Thermodynamic Analysis, Pittsburgh Coal Conference, October 2014.

Jacob R. Boes and John R. Kitchin, Estimating Bulk Composition Dependent H2 Dissociative Adsorption Energies on CuxPd1-x Alloy (111) Surfaces, AICHE Atlanta, Nov 2014.

Zhongnan Xu and John R. Kitchin, Coverage-Dependent Site and Adsorbate Configurational Correlations on (111) Surfaces of Late Transition Metals, AICHE Atlanta, Nov 2014.

Matthew Curnan and John R. Kitchin, Prediction of Phase Stability and Transition Pressures in BO_{2} (B = Ti, V, Ru, Ir) Polymorphs Using DFT+U and Self-Consistent Linear Response Theory, AICHE Atlanta, Nov 2014.

** Teaching
This year I taught a core course in reaction engineering /from Emacs/ with Python and Emacs! I now teach two classes from Emacs: a graduate elective in molecular simulation (which I am teaching again this year), and a core MS course in reaction engineering.

** Recognitions
Professor Kitchin was awarded the Philip L. Dowd Fellowship Award in recognition of his work in integrating org-mode into education [[http://kitchingroup.cheme.cmu.edu/blog/2014/02/28/Professor-Kitchin-awarded-the-Philip-L-Dowd-Fellowship-Award/][(link)]].

Mehak Chawla was awarded a Prengle Fellowship ([[http://kitchingroup.cheme.cmu.edu/blog/2014/03/24/Mehak-Chawla-selected-as-the-H-William-and-Ruth-Hamilton-Prengle-Fellow-of-Chemical-Enginering-for-2013-2014/][link]]).

Jacob Boes was awarded a Bertucci fellowship!

** Software development
   The most significant developments from our group this year were [[http://github.com/jkitchin/jmax][jmax]], an emacs starter-kit I developed, and [[http://github.com/jkitchin/org-ref][org-ref]], a bibliography/citation tool for scientific publications in org-mode. It is amazing. These can be found at http://github.com/jkitchin/jmax and http://github.com/jkitchin/org-ref.

Python Computations in science and engineering reached a higher level of maturity: http://github.com/jkitchin/pycse. We used this in my reaction engineering course quite a bit.

Zhongnan put his ase interface to Quantum Espresso here: https://github.com/zhongnanxu/espresso

** Social media
It looks like we had about 117 blog entries in 2014. The Kitchin Group blog has been growing in popularity:

[[./images/kg-blog-sessions.png]]

** What's next in 2015?
We will continue developing jmax into the finest scientific publishing tool there ever was.

We will write a lot of papers with jmax. I predict we write more than ten papers next year. That will be a group record.

More good things to come! Stay tuned!

* DONE Building atomic clusters in ase
  CLOSED: [2014-12-22 Mon 08:55]
  :PROPERTIES:
  :categories: ase,python
  :date:     2014/12/22 08:55:38
  :updated:  2014/12/22 08:55:38
  :END:

I was perusing the [[https://wiki.fysik.dtu.dk/ase/epydoc/][ase]] codebase, and came across the [[https://wiki.fysik.dtu.dk/ase/epydoc/ase.cluster-module.html][cluster module]]. This does not seem to be documented in the main docs, so here are some examples of using it. The module provides some functions to make atomic clusters for simulations.

Below I show some typical usage. First, we look at an icosahedron with three shells.

#+BEGIN_SRC python
from ase.cluster.icosahedron import Icosahedron
from ase.io import write
from ase.visualize import view

atoms = Icosahedron('Au', noshells=3)
print atoms
view(atoms)
write('images/Au-icosahedron-3.png', atoms)
#+END_SRC

#+RESULTS:
: Atoms(symbols='Au55', positions=..., tags=..., cell=[9.816495585723144, 9.816495585723144, 9.816495585723144], pbc=[False, False, False])

#+attr_org: :width 200
[[./images/Au-icosahedron-3.png]]

Even with only three shells, there are already 55 atoms in this cluster!


How about a decahedron? There are more parameters to set here. I am not sure what the depth of the Marks re-entrance is.

#+BEGIN_SRC python
from ase.cluster.decahedron import Decahedron
from ase.io import write

atoms = Decahedron('Pt',
                   p=5,  # natoms on 100 face normal to 5-fold axis
                   q=2,  # natoms 0n 100 parallel to 5-fold axis
                   r=0)  # depth of the Marks re-entrance?

print('#atoms = {}'.format(len(atoms)))

write('images/decahedron.png', atoms)
#+END_SRC

#+RESULTS:
: #atoms = 156
:
:

#+attr_org: :width 300
[[./images/decahedron.png]]

You can see the 5-fold symmetry here. We can make octahedra too. Here, the length is the number of atoms on the edge.

#+BEGIN_SRC python
from ase.cluster.octahedron import Octahedron
from ase.io import write

atoms = Octahedron('Cu', length=5)
print atoms
write('images/octahedron.png', atoms)
#+END_SRC

#+RESULTS:
: Cluster(symbols='Cu85', positions=..., cell=[14.44, 14.44, 14.44], pbc=[False, False, False])
:
:

#+attr_org: :width 300
[[./images/octahedron.png]]

Finally, we can make particles based on a Wulff construction! We provide a list of surfaces, and their surface energies, with an approximate size we want, the structure to make the particle in, and what to do if there is not an exact number of atoms matching our size. We choose to round below here, so that the particle is not bigger than our size. In this example I totally made up the surface energies, with (100) as the lowest, so the particle comes out looking like a cube.

#+BEGIN_SRC python
from ase.cluster.wulff import wulff_construction
from ase.io import write

atoms = wulff_construction('Pd',
                           surfaces=[(1, 0, 0),
                                     (1, 1, 1),
                                     (1, 1, 0)],
                           energies=[0.1, 0.5, 0.15],
                           size=100,
                           structure='fcc',
                           rounding='below')

print atoms
write('images/wulff.png', atoms)
#+END_SRC
#+RESULTS:
: Cluster(symbols='Pd63', positions=..., cell=[7.779999999999999, 7.779999999999999, 7.779999999999999], pbc=[False, False, False])
:
:

#+attr_org: :width 300
[[./images/wulff.png]]

This is one handy module, if you need to make clusters for some kind of simulation!
* DONE Capturing stderr from Python in org-mode - take 2
  CLOSED: [2014-12-21 Sun 11:46]
  :PROPERTIES:
  :categories: emacs,python,orgmode
  :date:     2014/12/21 11:46:11
  :updated:  2014/12/21 11:46:11
  :END:
In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2013/09/27/Capturing-stderr-and-exceptions-from-python-in-org-mode/][post]] I wrote about a sandbox module to help capture stderr in Python code blocks in org-mode. That module worked, but ran as a script.

stderr is not captured in the output of a code block in org-mode. For example:

#+BEGIN_SRC python
import sys
print >>sys.stdout, "message on stdout"
print >>sys.stderr, "testing stderr"
#+END_SRC

#+RESULTS:
: message on stdout

The messages to stderr just disappears. Not good for code like this:

#+BEGIN_SRC python
from scipy.integrate import odeint

def ode(y, x):
    return -k * x

xspan = [0, 1]
y0 = 1

sol = odeint(ode, y0, xspan)
print sol
#+END_SRC

#+RESULTS:
: [[ 1.]
:  [ 1.]]

There is an error in that code, k is not defined. If you run that as a script, you get this output:
#+BEGIN_EXAMPLE
>>> Traceback (most recent call last):
  File "/var/folders/5q/lllv2yf95hg_n6h6kjttbmdw0000gn/T//python-69413hLF.py", line 4, in ode
    return -k * x
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "/var/folders/5q/lllv2yf95hg_n6h6kjttbmdw0000gn/T//python-69413hLF.py", line 4, in ode
    return -k * x
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "/var/folders/5q/lllv2yf95hg_n6h6kjttbmdw0000gn/T//python-69413hLF.py", line 4, in ode
    return -k * x
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "/var/folders/5q/lllv2yf95hg_n6h6kjttbmdw0000gn/T//python-69413hLF.py", line 4, in ode
    return -k * x
NameError: global name 'k' is not defined
#+END_EXAMPLE

But, that is evidently going to stderr, and not getting captured in org-mode. Boo. A silent error that returns a value! This behavior of odeint may be [[https://github.com/scipy/scipy/pull/4052][fixed]] in scipy 0.15, but it is a general deficiency of org-mode babel code blocks. So, today I am looking back into a way to fix it. We try something as mundane as just redefining stderr in Python at runtime.

#+BEGIN_SRC python
import sys
sys.stderr = sys.stdout

print >>sys.stdout, "message on stdout"
print >>sys.stderr, "testing stderr"
#+END_SRC

#+RESULTS:
: message on stdout
: testing stderr

That works fine. Let us test it with the other block.

#+BEGIN_SRC python
import sys
sys.stderr = sys.stdout

from scipy.integrate import odeint

def ode(y, x):
    return -k * x

xspan = [0, 1]
y0 = 1

sol = odeint(ode, y0, xspan)
print sol
#+END_SRC

#+RESULTS:
#+begin_example
Traceback (most recent call last):
  File "<stdin>", line 6, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 6, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 6, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 6, in ode
NameError: global name 'k' is not defined
[[ 1.]
 [ 1.]]
#+end_example

Sweet, we get the errors. We still get the returned value, but it is immediately obvious something is wrong. I have wrapped that little tidbit into a Python module in [[https://github.com/jkitchin/pycse/blob/master/pycse/orgmode.py][pycse.orgmode]], which you can import to get the same effect.

#+BEGIN_SRC python
import pycse.orgmode

from scipy.integrate import odeint

def ode(y, x):
    return -k * x

xspan = [0, 1]
y0 = 1

sol = odeint(ode, y0, xspan)
print sol
#+END_SRC

#+RESULTS:
#+begin_example
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined

[[ 1.]
 [ 1.]]

#+end_example

Finally, you can avoid the import by setting your org-babel Python command like this:

#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "python -i -c \"import pycse.orgmode\"")
#+END_SRC

#+RESULTS:
: python -i -c "import pycse.orgmode"

Now, we run our faulty block again:
#+BEGIN_SRC python
from scipy.integrate import odeint

def ode(y, x):
    return -k * x

xspan = [0, 1]
y0 = 1

sol = odeint(ode, y0, xspan)
print sol
#+END_SRC

#+RESULTS:
#+begin_example
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined
Traceback (most recent call last):
  File "<stdin>", line 2, in ode
NameError: global name 'k' is not defined

[[ 1.]
 [ 1.]]

#+end_example

Excellent. The stderr is captured.

And we get basically the same output as before for regular code blocks. There is an extra line before and after the output for some reason. I can live with that!

#+BEGIN_SRC python
print 6 + 7
#+END_SRC

#+RESULTS:
:
: 13
:

* DONE Equation of a plane through three points
  CLOSED: [2015-01-18 Sun 10:48]
  :PROPERTIES:
  :categories: python
  :date:     2015/01/18 10:48:21
  :updated:  2015/01/18 10:48:21
  :END:

We are given three points, and we seek the equation of the plane that goes through them. The method is straight forward. A plane is defined by the equation:

\(a x + b y + c z = d\)

and we just need the coefficients. The $a, b, c$ coefficients are obtained from a vector normal to the plane, and $d$ is calculated separately. We get the normal vector from the cross-product of two vectors connecting the points, and we get $d$ from the dot product of the normal vector with any one of the point position vectors.

Finally, given the equation, we want to generate a mesh that samples the plane, and plot the mesh and original points to verify the plane goes through the points. Here is the implementation.

#+BEGIN_SRC python
import numpy as np

p1 = np.array([1, 2, 3])
p2 = np.array([4, 6, 9])
p3 = np.array([12, 11, 9])

# These two vectors are in the plane
v1 = p3 - p1
v2 = p2 - p1

# the cross product is a vector normal to the plane
cp = np.cross(v1, v2)
a, b, c = cp

# This evaluates a * x3 + b * y3 + c * z3 which equals d
d = np.dot(cp, p3)

print('The equation is {0}x + {1}y + {2}z = {3}'.format(a, b, c, d))

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

x = np.linspace(-2, 14, 5)
y = np.linspace(-2, 14, 5)
X, Y = np.meshgrid(x, y)

Z = (d - a * X - b * Y) / c

# plot the mesh. Each array is 2D, so we flatten them to 1D arrays
ax.plot(X.flatten(),
        Y.flatten(),
        Z.flatten(), 'bo ')

# plot the original points. We use zip to get 1D lists of x, y and z
# coordinates.
ax.plot(*zip(p1, p2, p3), color='r', linestyle=' ', marker='o')

# adjust the view so we can see the point/plane alignment
ax.view_init(0, 22)
plt.tight_layout()
plt.savefig('images/plane.png')
plt.show()
#+END_SRC

#+RESULTS:
: The equation is 30x + -48y + 17z = -15

#+caption: Original points are in red, and the mesh is in blue.
[[./images/plane.png]]
It looks like the blue points form a plane that contains the red points.

* DONE Anatomy of a helm source
  CLOSED: [2015-01-24 Sat 11:15]
  :PROPERTIES:
  :categories: emacs,helm
  :date:     2015/01/24 11:15:56
  :updated:  2015/01/24 12:09:58
  :POST_FILENAME: ~/blogofile-jkitchin.github.com/_posts/2015-01-24-Anatomy-of-a-helm-source.html
  :PERMALINK: http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/index.html
  :END:

I have been integrating [[https://github.com/emacs-helm/helm][helm]] into my emacs work flows almost anywhere I need to make interactive selections and do something with them. In this post, I will go through the simplest helm examples I can think of that get you to writing your own example.

To run a helm selection process you basically just call a function that calls this minimal function:

#+BEGIN_SRC emacs-lisp
(helm :sources '(some-helm-source))
#+END_SRC

In that code, the symbol some-helm-source will provide the input for the helm buffer. Let us look at the simplest example here. Each source should have a name, a list of candidates, and an action that works on the selected candidate. We construct a source as a list of cons cells. Here, we make a source with the name "HELM at the Emacs", a static list of candidates, which are simply a list of numbers, and a single action that will operate on the selected candidate.

If you run this block, you will get a helm buffer, you can select an entry, press enter, and you should see a message box pop up telling you what entry you selected. I like to separate the source definition from the helm call like this, but only for readability.

#+BEGIN_SRC emacs-lisp
(setq some-helm-source
      '((name . "HELM at the Emacs")
	(candidates . (1 2 3 4))
	(action . (lambda (candidate)
		    (message-box "%s" candidate)))))

(helm :sources '(some-helm-source))
#+END_SRC

#+RESULTS:
: 3


Not bad, but what if we want some dynamic candidates? The usual way we will do that is to define a function that calculates the candidates for us. Let us work out an example that just shows us random numbers between 0 and 10 to select from. In a real example, you would use this function to generate a list of candidates like bibtex keys, email-addresses, etc...

#+BEGIN_SRC emacs-lisp
(defun random-candidates ()
  "Return a list of 4 random numbers from 0 to 10"
  (loop for i below 4 collect (random 10)))

(setq some-helm-source
      '((name . "HELM at the Emacs")
	(candidates . random-candidates)
	(action . (lambda (candidate)
		    (message "%s" candidate)))))

(helm :sources '(some-helm-source))
#+END_SRC


So far, we have looked at the simplest list of candidates: a simple list. It may be that this is not the most convenient way to see the candidates. We might like to have one set of candidates that we use for searching, but another set of equivalent candidates used for the action. For example, we might want a list of names for selecting, but then have the action work on the corresponding email address. Let us consider a case where we have a list of cons cells of names and email addresses.

We use the `, way to create the source variable to make sure our list of candidates is constructed. Then, in our function we take the selection and get the corresponding entry in the data a-list.

#+BEGIN_SRC emacs-lisp
(setq data '(("John" . "john@email.com")
	     ("Jim" . "jim@email.com")
	     ("Jane" . "jane@email.com")
	     ("Jill" . "jill@email.com")))

(setq some-helm-source
      `((name . "HELM at the Emacs")
	(candidates . ,(mapcar 'car data))
	(action . (lambda (candidate)
		    (message "%s" (cdr (assoc candidate data)))))))

(helm :sources '(some-helm-source))
#+END_SRC

#+RESULTS:
: jim@email.com

That is not too bad, and might be a general way to get to the data you want. But, helm can integrate this directly by using the a-list /directly/ as the list of candidates. Helm will show you the car of each cell, but return the cdr of the selected entry.

Let us try this to make a function that will give us a helm buffer to select some names from, and then insert a comma separated list of emails from our selection at the point. We make our action function just return the list of marked candidates. Then we create a function that calls helm, and inserts a concatenated string.

#+BEGIN_SRC emacs-lisp
(setq data '(("John" . "john@email.com")
	     ("Jim" . "jim@email.com")
	     ("Jane" . "jane@email.com")
	     ("Jill" . "jill@email.com")))

(setq some-helm-source
      `((name . "HELM at the Emacs")
	(candidates . ,data)
	(action . (lambda (candidate)
		    (helm-marked-candidates)))))

(defun helm-select-and-insert-emails ()
  (interactive)
  (insert
   (mapconcat 'identity
	      (helm :sources '(some-helm-source))
	      ",")))
#+END_SRC
#+RESULTS:
: helm-select-and-insert-emails


Here is what I get when I run the command, select John and Jill, and press enter: john@email.com,jill@email.com

That is it for this post. We looked at:

1. the simplest kind of helm interface with a fixed set of candidates
2. A simple dynamic set of candidates
3. A simple fixed set of candidates from a list of cons cells.

This barely scratches the surface of helm, but is already enough to do some useful things.

* DONE More adventures in helm - more than one action
  CLOSED: [2015-01-30 Fri 08:00]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/01/30 08:00:16
  :updated:  2015/01/30 08:00:16
  :END:
We continue our [[http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/][exploration of helm]] and now consider how to have more than one action for a selection. When you press enter, helm runs the default action defined, but you can define more than one action, and choose which one to run. How do you know if there are multiple actions? Press C-z in helm and you will get a new helm buffer showing the actions. The first action is the default, and you can select the the actions with function keys, e.g. f1 is the first action, f2 is the second action, or you can select the action and press enter.

The main difference in setting up multiple actions is that instead of a single function for action in the source definition, we provide a list of cons cells for the action element of the helm source. Each action cons cell should have a descriptive string as the car that identifies the action. This will be shown in the helm buffer. The cdr should be the function to run on the candidate. The function will be called with the selection, so the function must take one argument.

Here is an example where we have two actions. The default action will just show us the email address of the selected candidates in a message box. It will show as a list. The second action opens an email window and inserts the selected candidates in the To: field as a comma separated list. I use helm-selected-candidates in these functions instead of the just the current selected candidate so we can have multiple selections. I define the first function as a lambda function, and the second one as a defun to illustrate how to use both approaches. You can have as many actions as you want, so you could consider functions that open notes about the person, or open your contacts to look up a phone number, or functions with template emails you send often, etc...

Now, you have these options to run those actions.

1. Make a selection and press enter. That runs the first (and default) action to show you a message box.
2. Make a selection and press C-z to see what actions are available. Select the action you want, and press enter.
3. Make a selection and press F1 to run the default action, or F2 to run the second action.

Here is our code.
#+BEGIN_SRC emacs-lisp
(setq data '(("John" . "john@email.com")
	     ("Jim" . "jim@email.com")
	     ("Jane" . "jane@email.com")
	     ("Jill" . "jill@email.com")))


(defun open-email (candidates)
  "Compose an email to the candidates. Fill in the addresses and
move point to the subject."
  (compose-mail)
  (message-goto-to)
  (insert
   (mapconcat
    'identity
    (helm-marked-candidates)
    ","))
  (message-goto-subject))

(setq some-helm-source
      `((name . "HELM at the Emacs")
	(candidates . ,data)
	(action . (("show email address" . (lambda (candidate)
					     (message-box
					      "selected: %s"
					      (helm-marked-candidates))))
		   ("send email" . open-email)))))

(helm :sources '(some-helm-source))
#+END_SRC

#+RESULTS:
: t

Now, you can define multiple actions for your selection in helm!

* DONE Handling multiple selections in helm
  CLOSED: [2015-02-01 Sun 08:51]
  :PROPERTIES:
  :categories: emacs,helm
  :ORDERED:  t
  :date:     2015/02/01 08:51:26
  :updated:  2015/02/01 08:51:26
  :END:
The basic usage pattern of helm is you run a command which opens a buffer of choices. You enter some text in the minibuffer which eliminates choices that do not match what you type in. You can select multiple choices by using C-spc, or M-a to mark them all. When you press enter, the current selection is sent to the default action defined. The action is a function that does something, usually on the selected item(s). Here, we explore writing the action function to do what we want. The reason this is somewhat tricky is that when you mark an item in helm, the "cursor" moves to the next item, which means when you press enter it may be possible that the current highlighted item is not part of the items you have marked. If your action will perform a delete action, for example, you may have wanted to delete the marked items, and /not/ the current selection! So, what we need is a way to get what we want.

An action function in helm should normally take one argument, which is going to be the currently selected item from helm. However, we can use two different functions to access either the selected item (helm-get-selection) or the marked items (helm-marked-candidates). So, we can write our function to do "do what we mean". Note, even if you do not mark any candidates,  (helm-marked-candidates) will return a list that has the current selection in it. So we can write our action function to act on this list so it works on what is marked or what is selected if nothing is marked. That is probably "what we mean".

Here is one way to work on a selection or marked list of selections. We define an action function that takes an arg, but inside we operate on each element of the marked candidates.

#+BEGIN_SRC emacs-lisp
(defun some-action (candidate)
  (loop for cand in (helm-marked-candidates)
	do
	(message-box "working on %s" cand)))

(helm :sources '(((name . "HELM")
		  (candidates . (1 2 3 4))
		  (action . (("open" . some-action))))))
#+END_SRC


Here is an alternative approach. Here we define the action function to work on one candidate. That might be helpful for testing, for example. Then, we use mapc to apply the function to each marked candidate.

#+BEGIN_SRC emacs-lisp
(defun some-action (candidate)
  (message-box "single working on %s" candidate))

(helm :sources '(((name . "HELM")
		  (candidates . (1 2 3 4))
		  (action . (("open" . (lambda (candidate)
					 (mapc
					  'some-action
					  (helm-marked-candidates)))))))))
#+END_SRC

A little more verbose method might be like this. Here we just pull out the lambda function to another function, to make the helm source definition a little shorter. I cannot tell if this is easier to follow, it is just another option.

#+BEGIN_SRC emacs-lisp
(defun some-action (candidate)
  (message-box "single2 working on %s" candidate))

(defun some-actions (candidate)
  (mapc 'some-action (helm-marked-candidates)))

(helm :sources '(((name . "HELM")
		  (candidates . (1 2 3 4))
		  (action . some-actions))))
#+END_SRC


So there you have it. You can select multiple things in helm, and then operate on them with your action function!

* DONE helm actions when there is no match
  CLOSED: [2015-02-02 Mon 16:31]
  :PROPERTIES:
  :date:     2015/02/02 16:31:07
  :updated:  2015/02/02 16:31:07
  :END:

Sometimes you run out of matches in a helm selection buffer, and all that is left is the pattern you have typed in. It turns out you can perform some action on that pattern! Why would you do that? Suppose you are searching your bibliography, and you do not find what you are looking for. Then, you may want to send the pattern to Google, or some other search engine to see what comes up.

The key to handling this situation is to use /two/ sources in your helm session. One that works on the candidates and deals with actions on them, and one that has no candidates, and works on the pattern. The variable helm-pattern contains what you typed in. We call the second source the Fallback option. The second source has no candidates, and we use (dummy) in place of the candidates.

It easy to add two sources. Here we define the sources as variables, and use the variables in the :sources list to the helm command.

#+BEGIN_SRC emacs-lisp
(defun some-action (arg)
  (message-box "%s\n%s"
    (helm-get-selection)
    (helm-marked-candidates)))

(defun default-action (candidate)
  (browse-url
   (format
    "http://www.google.com/search?q=%s" (url-hexify-string helm-pattern))))

(defvar source1 '((name . "HELM")
		  (candidates . (1 2 3 4))
		  (action . (("open" . some-action)))))

(defvar fallback-source '((name . "fallback")
			  (dummy)
			  (action . (("Google" . default-action)))))

(helm :sources '(source1 fallback-source))
#+END_SRC

#+RESULTS:
: #<process open http://www.google.com/search?q=addtion%20pul>

When you run this, if you run out of search candidates, all that will be left is the fallback option, and when you press enter, it will launch a browser pointing to the google search for your pattern.

* DONE helm and prefix functions
  CLOSED: [2015-02-03 Tue 11:12]
  :PROPERTIES:
  :categories: emacs,helm
  :date:     2015/02/03 11:12:53
  :updated:  2015/02/03 11:12:53
  :END:
Helm modifies how you use [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Prefix-Command-Arguments.html][prefix arguments]] in Emacs. A prefix argument is when you type C-u before a command to modify its behavior. There are a few variations of prefix arguments. Basically, pressing C-u once sets a prefix variable to '(4), pressing twice sets it to '(16). Alternatively, C-u 7 sets the prefix to 7. In regular emacs commands, you type the prefix keys before the command. In helm, you type the after you enter the helm selection buffer, and before you press enter or select your action. In helm, you access the prefix arg in the variable helm-current-prefix-arg. Let us look at how you might use it.

We make an action function that does something conditionally depending on the prefix arg. Yes, you could write several functions to accomplish that too, but maybe there is just a little difference that you can use the prefix arg to handle. What you cannot remember 4 prefix options? You do write good doc strings on your functions right ;) If not, you probably ought to write four functions with meaningful names, and meaningful helm descriptions!

#+BEGIN_SRC emacs-lisp
(defun action (candidate)
  "Our action function.
with no prefix message no prefix arg
with one prefix arg message C-u
with two prefix args message C-u C-u
with a numeric prefix arg, message the number."
  (interactive "p")
  (cond
   ((eq nil helm-current-prefix-arg)
    (message-box "no prefix arg"))
   ((equal helm-current-prefix-arg '(4))
    (message-box "C-u"))
   ((equal helm-current-prefix-arg '(16))
    (message-box "C-u C-u"))
   (t
    (message-box (format "C-u %s" helm-current-prefix-arg)))))

(setq some-helm-source
      '((name . "HELM at the Emacs")
	(candidates . (1 2 3 4))
	(action . action)))

(helm :sources '(some-helm-source))
#+END_SRC

#+RESULTS:
: C-u (64)


* DONE New org-mode link to Web of Science
  CLOSED: [2015-01-28 Wed 13:55]
  :PROPERTIES:
  :date:     2015/01/28 13:55:54
  :updated:  2015/01/28 13:55:54
  :END:
For ages I have been trying to figure out how to make a link to open a search in Web of Science. Today, thanks to help from our library, I finally figured it out!

It turns out you can embed a search widget to Web of Science in a web page. See http://wokinfo.com/webtools/searchbox/. Here is an example.


#+BEGIN_HTML
<form method="get" action="http://gateway.webofknowledge.com/gateway/Gateway.cgi" target="_blank">
<table style="background-color:#FFF; border:1px solid #999; width:354px;" cellspacing="0" cellpadding="6" border="0">
<tr>
<td><p><img border="0" src="http://wokinfo.com/img/webtools/woknameplate_flat2.png" width="311" height="36" alt="Web of Science"></p>
<p><strong><font face="Verdana, Geneva, sans-serif"><font size="2" color="#808080">Search Web of Science&#8482;</font></font></strong><br>
<input type="hidden" name="GWVersion" value="2">
<input type="hidden" name="SrcApp" value="WEB">
<input type="hidden" name="SrcAuth" value="HSB">
<input type="hidden" name="DestApp" value="UA">
<input type="hidden" name="DestLinkType" value="GeneralSearchSummary">
&nbsp;<input type="text" name="topic" size="27" maxlength="255" value="Enter a topic to search" onfocus="this.value='';">&nbsp;<input type="submit" name="btnWS" value="Search">&nbsp;<input type="reset" name="btnR" value="Reset"></p>
<p align="right"><font face="Arial, Helvetica, sans-serif"><font size="1">Copyright 2014 <a href="http://thomsonreuters.com" target="_blank">Thomson Reuters</a>&nbsp;&nbsp;&nbsp;</font></font></p>
</td>
</tr>
</table>
</form>
#+END_HTML

This simple form just sends a GET http request to a cgi script at Web of Knowledge. Awesome, we can create a url that does just that to make an org link! We will make a link that you can click on to open the web page, and a simple formatting function to make the link work in html too when we export it.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "wos"
 (lambda (path)
   (browse-url
    (format  "http://gateway.webofknowledge.com/gateway/Gateway.cgi?topic=%s&GWVersion=2&SrcApp=WEB&SrcAuth=HSB&DestApp=UA&DestLinkType=GeneralSearchSummary"
	     (s-join "+"
	      (split-string path)))))
 ;; formatting function. Assume html
 (lambda (link desc format)
   (format "<a href=\"%s\">%s</a>"
	   (format  "http://gateway.webofknowledge.com/gateway/Gateway.cgi?topic=%s&GWVersion=2&SrcApp=WEB&SrcAuth=HSB&DestApp=UA&DestLinkType=GeneralSearchSummary"
	     (s-join "+"
	      (split-string path)))
	   (format "wos:%s" link)
	   )))
#+END_SRC

Now, here is a link: [[wos:alloy segregation]]

When I click on it in org-mode, Web of Science opens to articles that match that search. When I export the post to html, you should also see a link that opens to Web of Science (assuming you click on it from an IP address with access).

The link may not seem all that useful, but we can use the idea to highlight words, and send them to a web of science query, e.g. https://github.com/jkitchin/jmax/blob/master/words.el#L63, or in org-ref to query web of science for the words you typed into helm-bibtex that do not match any references in your database. One more powerful tool in doing research for a living!

* DONE Helm at the Emacs
  CLOSED: [2015-02-04 Wed 08:47]
  :PROPERTIES:
  :categories: emacs,helm
  :date:     2015/02/04 08:47:40
  :updated:  2015/02/04 08:47:40
  :END:
I have written several ([[http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/][intro]], [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/01/Handling-multiple-selections-in-helm/][multiple args]], [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/03/helm-and-prefix-functions/][prefix args)]] times about using Helm in Emacs so far. Today, I want to share a way I use helm to get me where I want to be in Emacs for my daily activities. This came out of a desire to have single command that would give me a lot of options to open exactly the buffer/file I wanted when I need it. I call the command hotspots, and it is bound to f9 for me, so when I press f9 I get a helm buffer to select what I want from.

So, what kinds of things do I want. First, I want to be able to open my mail, calendar, News feed or agenda from this command. Second, I have a list of hotspots I developed using the code at http://ergoemacs.org/emacs/emacs_hotkey_open_file_fast.html, which I want easy access to. Third, I want to be able to open any org-file in my agenda list. Fourth, any bookmark I have, or to set a bookmark. Fifth, I want recent files as candidates. There is certainly some redundancy in their, but that is ok, it gets me where I want to be.

Here is the code that does that for me. There are six helm sources that provide candidates and actions.

#+BEGIN_SRC emacs-lisp
(defun hotspots ()
  "helm interface to my hotspots, which includes my locations,
org-files and bookmarks"
  (interactive)
  (helm :sources `(((name . "Mail and News")
		    (candidates . (("Mail" . (lambda ()
					       (if (get-buffer "*mu4e-headers*")
						   (progn
						     (switch-to-buffer "*mu4e-headers*")
						     (delete-other-windows))

						 (mu4e))))
				   ("Calendar" . (lambda ()  (browse-url "https://www.google.com/calendar/render")))
				   ("RSS" . elfeed)
				   ("Agenda" . (lambda () (org-agenda "" "w")))))
		    (action . (("Open" . (lambda (x) (funcall x))))))
		   ((name . "My Locations")
		    (candidates . (("master" . "~/Dropbox/org-mode/master.org")
				   (".emacs.d" . "~/Dropbox/kitchingroup/jmax" )
				   ("blog" . "~/blogofile-jkitchin.github.com/_blog/blog.org")
				   ("ese" . "~/Dropbox/books/ese-book/ese.org" )
				   ("passwords" . "~/Dropbox/org-mode/passwords.org.gpg")
				   ("Pycse" . "~/Dropbox/books/pycse/pycse.org")
				   ("references" . "~/Dropbox/bibliography/references.bib")
				   ("notes" . "~/Dropbox/bibliography/notes.org")
				   ("journal" . "~/Dropbox/org-mode/journal.org")
				   ("tasks" . "~/Dropbox/org-mode/tasks.org")))
		    (action . (("Open" . (lambda (x) (find-file x))))))

		   ((name . "My org files")
		    (candidates . ,(f-entries "~/Dropbox/org-mode"))
		    (action . (("Open" . (lambda (x) (find-file x))))))
		   helm-source-recentf
		   helm-source-bookmarks
		   helm-source-bookmark-set)))
#+END_SRC

Interesting to me is that there are not a lot of actions in here. I mostly use this command for navigation to various places. For example, I press f9, type meet, and I can quickly get to the meetings file in my agenda list, or I can type the first few letters of a student's name and open the org-file associated with them. Or I press f9 and go down an entry to open my calendar, etc... I find this enormously helpful because it opens these files no matter where I am in Emacs, and it relieves my mind from remembering where they are, or the keystrokes/commands to get to them.
* DONE Extending the org-mode link syntax with attributes
  CLOSED: [2015-02-05 Thu 10:06]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/02/05 10:06:25
  :updated:  2015/02/05 10:06:25
  :END:
I make super heavy use of links in org-mode. I use them extensively in org-ref to create functional citations. One detail that has never been very satisfactory is the need for pre/post text in citations. I don't need that capability oftqen, but it seems important to some. I have implemented a kind of clunky solution where I use the description part of a link with the pre/post text separated by a ::. Although that works, I dislike the way it looks, the need to parse it, and that the description covers the link.

#+BEGIN_EXAMPLE
[[cite:key][pre text::post text]]
#+END_EXAMPLE

Some [[https://lists.gnu.org/archive/html/emacs-orgmode/2010-08/msg00404.html][time ago]] there was a suggestion of how to extend the link syntax, which was to my knowledge never implemented. Here is the proposed syntax:
#+BEGIN_EXAMPLE
$[link http://google.com
         :last-followed [2009-02-25 Wed 02:00]
         :label "click here for evil search engine"
         :export-label "click here for nice search engine"]
#+END_EXAMPLE

This is interesting because this syntax suggests the link has attributes which can be updated.

We will show here how to implement part of this idea with the existing link syntax. We will make a link that has attributes like that. The basic idea is to simply incorporate the attributes into the path, and use lisp to read them. We will wrap the link path in parentheses and read that as a lisp data structure. So, a link like [[link:key :pre "some pre text" :post "some post text"]] will be parsed as:

#+BEGIN_SRC emacs-lisp
(read "(key :pre \"some pre text\" :post \"some post text\")")
#+END_SRC

#+RESULTS:
| key | :pre | some pre text | :post | some post text |

The car of that list is the key, and the cdr contains the attributes. The quotes are necessary here to make sure all the text is correctly parsed as a single element for each attribute. So, here is an example link

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "slink"
 ;;  follow function
 (lambda (path)
   (let* ((data (read (format "(%s)" path)))
	  (head (car data))
	  (plist (cdr data))
	  (link (org-element-context))
	  (begin (org-element-property :begin link))
	  (end (org-element-property :end link)))
     (setq plist (plist-put plist :last-clicked (current-time-string)))
     (save-excursion
     (setf (buffer-substring begin end) "")
     (goto-char begin)
     (insert (format "[[slink:%s %s]]" head
         (substring (format "%S" plist) 1 -1))))))
 ;; format function
 (lambda (path description backend)
   (let* ((data (read (concat "(" path ")")))
	  (head (car data))
	  (plist (cadr data)))
     (format "\\%s[%s][%s]{%s}"
             (plist-get plist :type)
	     (plist-get plist :pre)
	     (plist-get plist :post)
             head))))
#+END_SRC

Now, each time I click on this link, the time stamp gets updated.

[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Thu Feb  5 09:31:15 2015"]]

#+BEGIN_EXAMPLE
[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Thu Feb  5 09:31:15 2015"]]
#+END_EXAMPLE


And, the generic export of this link is:

#+BEGIN_EXAMPLE
\cite[See for example][page 47]{kitchin-2010}
#+END_EXAMPLE

Is this a good idea? I am not using this for anything right now. Sometimes my version of org-mode has trouble recognizing that is a link. It is strange, as I am typing, sometimes it flashes in and out of being recognized as a link. Anyway, it is an interesting idea!

* DONE Turn an ISBN to a bibtex entry
  CLOSED: [2015-01-31 Sat 15:48]
  :PROPERTIES:
  :categories: bibtex
  :date:     2015/01/31 15:48:39
  :updated:  2015/01/31 15:50:22
  :END:
Occasionally, I need a bibtex entry for a book. Books are often identified by an ISBN number. Similar to using Crossref to get metadata about a DOI, we can use a web service to get metadata about an ISBN. From that, we might be able to construct a bibtex entry.

Here is an example of what we can get for ISBN 9780309095211. It does not seem to matter if there are dashes in the ISBN or not.

#+BEGIN_SRC emacs-lisp
(with-current-buffer
	(url-retrieve-synchronously
"http://xisbn.worldcat.org/webservices/xid/isbn/9780309095211?method=getMetadata&format=json&fl=*")
      (buffer-substring url-http-end-of-headers (point-max)))
#+END_SRC

#+RESULTS:
#+begin_example

{
 "stat":"ok",
 "list":[{
	"url":["http://www.worldcat.org/oclc/224969280?referer=xid"],
	"publisher":"National Academies Press",
	"form":["BC"],
	"lccn":["2006016786"],
	"lang":"eng",
	"city":"Washington, D.C.",
	"author":"Committee on the Guide to Recruiting and Advancing Women Scientists and Engineers in Academia, Committee on Women in Science and Engineering, Policy and Global Affairs, National Research Council of the National Academies.",
	"ed":"[Online-Ausg.]",
	"year":"2006",
	"isbn":["9780309095211"],
	"title":"To recruit and advance women students and faculty in science and engineering",
	"oclcnum":["224969280",
	 "70060944",
	 "756709329",
	 "804792476",
	 "817950524",
	 "833420290",
	 "836338922",
	 "704551455"]}]}
#+end_example

We get a nice json data string back. We can parst that to get an actual data structure.

#+BEGIN_SRC emacs-lisp  :results value code
(with-current-buffer
	(url-retrieve-synchronously
"http://xisbn.worldcat.org/webservices/xid/isbn/9780309095211?method=getMetadata&format=json&fl=*")
      (json-read-from-string
        (buffer-substring url-http-end-of-headers (point-max))))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((list .
       [((oclcnum .
		  ["224969280" "70060944" "756709329" "804792476" "817950524" "833420290" "836338922" "704551455"])
	 (title . "To recruit and advance women students and faculty in science and engineering")
	 (isbn .
	       ["9780309095211"])
	 (year . "2006")
	 (ed . "[Online-Ausg.]")
	 (author . "Committee on the Guide to Recruiting and Advancing Women Scientists and Engineers in Academia, Committee on Women in Science and Engineering, Policy and Global Affairs, National Research Council of the National Academies.")
	 (city . "Washington, D.C.")
	 (lang . "eng")
	 (lccn .
	       ["2006016786"])
	 (form .
	       ["BC"])
	 (publisher . "National Academies Press")
	 (url .
	      ["http://www.worldcat.org/oclc/224969280?referer=xid"]))])
 (stat . "ok"))
#+END_SRC

Ok, so we should check that stat is ok, then build the bibtex entry. Accessing the metadata below seems pretty hacky; but it works, and I don't understand the deep nesting of results, and there seems to be a vector in there.

#+BEGIN_SRC emacs-lisp
(let* ((results  (with-current-buffer
		    (url-retrieve-synchronously
		     "http://xisbn.worldcat.org/webservices/xid/isbn/9780309095211?method=getMetadata&format=json&fl=*")
		  (json-read-from-string
		   (buffer-substring url-http-end-of-headers (point-max)))))
       (status (cdr (nth 1 results)))
       (metadata (aref (cdar results) 0)))

  (unless (string= "ok" status)
    (error "Status is %s" status))

  (concat "@book{,\n"
	  (mapconcat (lambda (x)
		       (format "  %s={%s}," (car x) (cdr x)))
		     metadata "\n")
	  "}\n"))
#+END_SRC

#+RESULTS:
#+begin_example
@book{,
  oclcnum={[224969280 70060944 756709329 804792476 817950524 833420290 836338922 704551455]},
  title={To recruit and advance women students and faculty in science and engineering},
  isbn={[9780309095211]},
  year={2006},
  ed={[Online-Ausg.]},
  author={Committee on the Guide to Recruiting and Advancing Women Scientists and Engineers in Academia, Committee on Women in Science and Engineering, Policy and Global Affairs, National Research Council of the National Academies.},
  city={Washington, D.C.},
  lang={eng},
  lccn={[2006016786]},
  form={[BC]},
  publisher={National Academies Press},
  url={[http://www.worldcat.org/oclc/224969280?referer=xid]},}
#+end_example

That looks good to me. Let us finally wrap it into a function that will take an ISBN and bibtex file interactively, create a bibtex entry, and insert it if there is not an entry with a key like that already. If we have selected region, lI should note this code uses some functionality from my org-ref package (and when I am done here, I am adding it to the doi-utils package inside org-ref). This is a fancy function, built from the experience I have from writing doi-utils.

#+BEGIN_SRC emacs-lisp
(defun isbn-to-bibtex (isbn bibfile)
  "Get bibtex entry for ISBN and insert it into BIBFILE unless an
entry with the generated key already exists in the file."
  (interactive
   (list
    (read-input
     "ISBN: "
     ;; now set initial input
     (cond
      ;; If region is active and it starts with a number, we use it
      ((and  (region-active-p)
	     (s-match "^[0-9]" (buffer-substring (region-beginning) (region-end))))
       (buffer-substring (region-beginning) (region-end)))
      ;; if first entry in kill ring starts with a number assume it is an isbn
      ;; and use it as the guess
      ((if (s-match "^[0-9]" (car kill-ring))
	   (car kill-ring)))
      ;; type or paste it in
      (t
       nil)))
    (ido-completing-read
     "Bibfile: "
     (append (f-entries "." (lambda (f) (f-ext? f "bib")))
	     org-ref-default-bibliography))))

  (let* ((results (with-current-buffer
		      (url-retrieve-synchronously
		       (format
			"http://xisbn.worldcat.org/webservices/xid/isbn/%s?method=getMetadata&format=json&fl=*"
			isbn))
		    (json-read-from-string
		     (buffer-substring url-http-end-of-headers (point-max)))))
	 (status (cdr (nth 1 results)))
	 (metadata (aref (cdar results) 0))
	 (new-entry)
	 (new-key))

    ;; check if we got something
    (unless (string= "ok" status)
      (error "Status is %s" status))

    ;; construct an alphabetically sorted bibtex entry. I assume ISBN numbers go
    ;; with book entries.
    (setq new-entry
	  (concat "\n@book{,\n"
		  (mapconcat
		   'identity
		   (loop for field in (-sort 'string-lessp (mapcar 'car metadata))
			 collect
			 (format "  %s={%s}," field (cdr (assoc field metadata))))
		   "\n")
		  "\n}\n"))

    ;; build entry in temp buffer to get the key so we can check for duplicates
    (setq new-entry (with-temp-buffer
		      (insert new-entry)
		      (org-ref-clean-bibtex-entry)
		      (setq new-key (bibtex-key-in-head))
		      (buffer-string)))
    (find-file bibfile)
    (goto-char (point-min))
    (when (search-forward new-key nil t)
      (beep)
      (setq new-key (read-input
		     (format  "%s already exists. Enter new key (C-g to cancel): " new-key)
		     new-key)))
    (goto-char (point-max))
    (insert new-entry)
    ;; set key. It is simplest to just replace it, even if it is the same.
    (bibtex-beginning-of-entry)
    (re-search-forward bibtex-entry-maybe-empty-head)
    (if (match-beginning bibtex-key-in-head)
	(delete-region (match-beginning bibtex-key-in-head)
		       (match-end bibtex-key-in-head)))
    (insert new-key)
    (bibtex-fill-entry)
    (save-buffer)))
#+END_SRC

#+RESULTS:
: isbn-to-bibtex

That is it, for the one ISBN I have tested it on, I get a nicely sorted bibtex entry in the file I select! Hopefully that means no more tedious bibtex entry entering for books! If you use org-ref, just update to the latest version and you should be able to use this function.

Now, back to that proposal I am writing that needs a lot of citations to books that are not in my bibtex file yet, but will be soon ;)
* DONE org-mode links meet hydra
  CLOSED: [2015-02-22 Sun 19:06]
  :PROPERTIES:
  :categories: hydra,emacs,orgmode
  :date:     2015/02/22 19:06:41
  :updated:  2015/02/22 19:06:41
  :END:
I have played with a lot of options to give org-mode links extra functionality. Here are a few of the ideas I have looked at so far.

1. [[http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/][Enabling right clicks on links]]
2. A home made minibuffer menu in org-ref
3. A helm buffer in org-ref

Here, I want to explore a hydra menu for a link. The idea is pretty simple, we need functions that do something with the link at point, and a hydra interface to call them. We illustrate it here with a more functional doi link. Each function just gets the path property from the link at point. We have to wrap the call to the hydra in a lambda because the click function is expected to take a path argument, and hydras do not take arguments.

#+BEGIN_SRC emacs-lisp
(defun doi-crossref ()
  "Search DOI from link at point in CrossRef."
  (interactive)
  (browse-url
   (format
    "http://search.crossref.org/?q=%s"
    (url-hexify-string
     (org-element-property :path (org-element-context))))))

(defun doi-google-scholar ()
  "Google scholar the doi."
  (interactive)
  (browse-url
   (format
    "http://scholar.google.com/scholar?q=%s"
    (url-hexify-string
     (org-element-property :path (org-element-context))))))

(defun doi-pubmed ()
  "Pubmed the doi."
  (interactive)
  (browse-url
   (format
    "http://www.ncbi.nlm.nih.gov/pubmed/?term=%s"
    (url-hexify-string
     (org-element-property :path (org-element-context))))))

 (defhydra doi-hydra (:color blue)
   "org-ref"
   ("c" doi-crossref "Crossref")
   ("g" doi-google-scholar "Google Scholar")
   ("p" doi-pubmed "Pubmed"))

(org-add-link-type "doi"
   (lambda (path) (doi-hydra/body)))
#+END_SRC

#+RESULTS:
| lambda | (path) | (setq *doi-hydra-path* path) | (doi-hydra/body) |

Now for a test, doi:10.1021/jp047349j .

It works fine, when you click on a link, you get a minibuffer menu with context hints, and pressing any other key than is defined simply cancels the command.



* DONE org-ref meets hydra
  CLOSED: [2015-02-20 Fri 21:17]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/02/20 21:17:20
  :updated:  2015/02/20 21:17:20
  :END:
I am enjoying learning about [[https://github.com/abo-abo/hydra][abo-abo/hydra]], which is a nice package for making minibuffer menus to run commands. It is light-weight solution that does not mess up your window too much, and it is easier to use than any home-grown solution I have made in the past. Here is a simple little code that gives me three options when I press "zz" quickly (a key-chord). I can press "c" to put in a cite link using helm, "r" to insert a ref link using helm, and "l" to insert a new label. Any other key just cancels the menu. One thing to remember ("zz"), and hints for the rest!

#+BEGIN_SRC emacs-lisp
(require 'hydra)
(setq hydra-is-helpful t)

(require 'key-chord)
(key-chord-mode 1)
(key-chord-define-global
 "zz"
 (defhydra org-ref-hydra ()
   "org-ref"
   ("c" org-ref-helm-insert-cite-link "cite")
   ("r" org-ref-helm-insert-ref-link "ref")
   ("l" org-ref-helm-insert-label-link "label")
   ("R" org-ref "org-ref")))
#+END_SRC

#+RESULTS:
: org-ref-hydra/body

Pretty nice. Check out the nice hydra interface to [[https://github.com/jkitchin/jmax/blob/master/words.el][words.el]]. A simple press of "ww" gets you easy access to single key presses of all the nice words functions. What would you hydra for?



* DONE Making org-mode Python sessions look better
  CLOSED: [2015-03-12 Thu 10:45]
  :PROPERTIES:
  :categories: python,orgmode
  :date:     2015/03/12 10:45:25
  :updated:  2015/03/12 18:58:57
  :END:
Using sessions for python in org-mode has always bugged me a little bit. Mostly the appearance of >>> and ... in the output. For example:

#+BEGIN_SRC python :session
print 8
#+END_SRC

#+RESULTS:
:
: >>> >>> >>> 8

Today on the org-mode mailing list someone suggested a [[http://thread.gmane.org/gmane.emacs.orgmode/95980/focus=96011][patch]] that might fix that up. Hopefully that patch makes it into org-mode, but if you run off of ELPA like I do it will be some time before it appears in your working version.

In the meantime, inspired by my [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/11/Updating-Multiple-RESULTS-blocks-in-org-mode/][recent post]] on updating multiple results, here we add a new hook function that removes these annoying characters from a Python session results section. Here is my version of this code.
"^: >>>$"
#+BEGIN_SRC emacs-lisp
(defun org-babel-python-strip-session-chars ()
  "Remove >>> and ... from a Python session output."
  (when (and (string=
	      "python"
	      (org-element-property :language (org-element-at-point)))
	     (string-match
	      ":session"
	      (org-element-property :parameters (org-element-at-point))))

    (save-excursion
      (when (org-babel-where-is-src-block-result)
	(goto-char (org-babel-where-is-src-block-result))
	(end-of-line 1)
	;(while (looking-at "[\n\r\t\f ]") (forward-char 1))
	(while (re-search-forward
		"\\(>>> \\|\\.\\.\\. \\|: $\\|: >>>$\\)"
		(org-element-property :end (org-element-at-point))
		t)
	  (replace-match "")
	  ;; this enables us to get rid of blank lines and blank : >>>
	  (beginning-of-line)
	  (when (looking-at "^$")
	    (kill-line)))))))

(add-hook 'org-babel-after-execute-hook 'org-babel-python-strip-session-chars)
#+END_SRC

#+RESULTS:
| org-babel-python-strip-session-chars | (lambda nil (org-refresh-images)) |


#+BEGIN_SRC python :session
import matplotlib.pyplot as plt
plt.plot([3, 4, 5])
plt.show()

def f(s):
    x = 2 * s
    # blank lines look like indentation errors
    return x

print f(4)
#+END_SRC

#+RESULTS:
:
: [<matplotlib.lines.Line2D object at 0x10955c290>]
: 8

#+BEGIN_SRC python :session
print f(9)
#+END_SRC

#+RESULTS:
: 18

Here we can make an inline figure.
#+BEGIN_SRC python :session :results value file
plt.figure()
plt.plot([3, 4.5, 5])
plt.savefig('images/session-fig.png')
'images/session-fig.png'
#+END_SRC

#+RESULTS:
[[file:images/session-fig.png]]
Not bad. It seems to work! Maybe this will make sessions more usable for me.

[2015-03-12 Thu] New corner case, do not cause an error when results are silenced.

#+BEGIN_SRC python :session :results none
print 6
#+END_SRC


Testing getting rid of blank lines and empty : >>> lines.
#+BEGIN_SRC python :session :results output
a = 2
b = 3
c = 4
print
print 'a=      ', a
print 'b =     ', b
print 'a + b = ', a+b
#+END_SRC

#+RESULTS:
: a=       2
: b =      3
: a + b =  5

* DONE A helm-mu4e contact selector
  CLOSED: [2015-03-14 Sat 10:21]
  :PROPERTIES:
  :categories: emacs,email,helm
  :date:     2015/03/14 10:21:09
  :updated:  2015/03/14 10:21:09
  :END:
I have been using [[http://www.djcbsoftware.nl/code/mu/mu4e.html][mu4e]] in Emacs for email for about three months now. It is pretty good, and I hardly ever use the gmail web interface any more. The email completion in mu4e is ok, but I am frequently surprised at what it does not find, and totally spoiled by how good Gmail is at this. The built in completion seems to get lost if you don't start the search with the first few letters. Not always, but too often for me. I don't always remember the first letters, and want to search by name, or company. I would love to search by tags in org-contacts. This should be simple in helm, where you can build up candidates with different bits of information. Here I explore a helm interface, which I think might be better than the built in mu4e support, and even be better than gmail.

In my dream email completer, I want some easy way to define my own groups, I want to use org-contacts (and its tags), and I want every email address in the mails I have in my archive as completion candidates.  helm supports multiple sources, so I initially tried a separate source for each of these. Preliminary efforts suggested it is not possible to mark multiple selections from different sources and pass them all to one function. So, we combine all email candidates into one list of (searchable-string . email-address) cons cells. To get an idea of how many contacts we are looking at:

Here is what I have in my org-contacts file:
#+BEGIN_SRC emacs-lisp
(length (org-contacts-db))
#+END_SRC

#+RESULTS:
: 173

And here is what mu4e knows about. Interestingly, it takes a while for this variable to get populated because the request is asynchronous. After the first time though it sticks around. I think just opening mu4e will populate this variable.
#+BEGIN_SRC emacs-lisp
(length mu4e~contacts-for-completion)
#+END_SRC

#+RESULTS:
: 12717

So, I have close to 13,000 potential email addresses to choose from. For my email groups, I will just use a list of cons cells like (group-name . "comma-separated emails"). Then, I will loop through the org-contacts-db and the mu4e completion list to make the helm candidates. Finally, we add some functions to open our org-contact, and to tag org-contacts so it is easier to make groups.

Here is the code I have been using.

#+BEGIN_SRC emacs-lisp
;; here we set aliases for groups.
(setq email-groups
      '(("ms" . "email1, email2")
        ("phd" . "email3, email4")))


(defun org-contacts-open-from-email (email)
  "Open org-contact with matching EMAIL. If no match, create new
entry with prompts for first and last name."
  (let ((contact (catch 'contact
		   (loop for contact in  (org-contacts-db)
			 do
			 (when (string= email (cdr (assoc "EMAIL" (elt contact 2))))
			   (throw 'contact contact))))))

    (unless contact
		(set-buffer (find-file-noselect (ido-completing-read
						 "Select org-contact file: "
						 org-contacts-files)))
		(goto-char (point-max))
		(insert (format  "\n* %s %s\n"
				 (read-input "First name: ")
				 (read-input "Last name: ")))
		(org-entry-put (point) "EMAIL" email)
		(save-buffer))

    (when contact
      (find-file  (cdr (assoc "FILE" (elt contact 2))))
      (goto-char (elt contact 1))
      (show-subtree))))


(defun org-contacts-tag-selection (selection)
  "Prompts you for a tag, and tags each entry in org-contacts
that has a matching email in `helm-marked-candidates'. Ignore
emails that are not in an org-contact file. I am not sure what
the best thing to do there is. Probably prompt for a file, and
add an entry to the end of it."
  (save-excursion
    (let ((tag (read-input "Tag: ")))
      (loop for email in (helm-marked-candidates)
	    do
	    (let ((contact (catch 'contact
			     (loop for contact in  (org-contacts-db)
				   do
				   (when (string=
					  email
					  (cdr (assoc
						"EMAIL"
						(elt contact 2))))
				     (throw 'contact contact))))))
	      ;; add new contact and tag it
	      (unless contact
		(set-buffer (find-file-noselect (ido-completing-read
						 "Select org-contact file: "
						 org-contacts-files)))
		(goto-char (point-max))
		(insert (format  "\n* %s %s\n"
				 (read-input "First name: ")
				 (read-input "Last name: ")))
		(org-entry-put (point) "EMAIL" email)
		(org-set-tags-to (list tag))
		(save-buffer))
	      ;; update tags on existing entry
	      (when contact
		(find-file-noselect  (cdr (assoc "FILE" (elt contact 2))))
                (set-buffer (marker-buffer (elt contact 1)))
		(goto-char (elt contact 1))
		(org-set-tags-to (append (org-get-tags) (list tag)))))))))


(defun j-insert-emails ()
  "Helm interface to email addresses"
  (interactive)

  (helm :sources `(((name . "Email address candidates")
		   (candidates . ,(append
				   ;; my aliases
				   email-groups
				   ;; org-contacts
				   (loop for contact in (org-contacts-db)
					 collect
					 (cons (format
						"%s %s %s <%s> org-contact"
						(cdr (assoc "FIRSTNAME" (elt contact 2)))
						(cdr (assoc "LASTNAME" (elt contact 2)))
						(cdr (assoc "TAGS" (elt contact 2)))
						(cdr (assoc "EMAIL" (elt contact 2))))
					       (cdr (assoc "EMAIL" (elt contact 2)))))
				   ;; mu contacts
				   (loop for contact in mu4e~contacts-for-completion
					 collect (cons contact contact))))
		   ;; only action is to insert string at point.
		   (action . (("insert" . (lambda (x)
					    (insert
					     (mapconcat
					      'identity
					      (helm-marked-candidates)
					      ","))))
			      ("open" . org-contacts-open-from-email)
			      ("tag"  . org-contacts-tag-selection)))))))

;; Finally, let us bind this to something probably convenient. I use c-c ] for
;; citations. Lets try that in compose mode.
(define-key mu4e-compose-mode-map "\C-c]" 'j-insert-emails)
#+END_SRC
#+RESULTS:
: j-insert-emails

Now, I have a sweet helm interface with nearly 13,000 email candidates (there is a decent amount of duplication in this list, and some garbage emails from spam, but helm is so fast, this does not bother me). I can pretty quickly narrow to any tagged set of emails from org-contacts with a search that looks like :phd: for example, or [^phd]:group: to get org-contacts tagged group, but not phd. I can narrow the selection on first name, lastname, parts of email addresses, tags in org-contacts, etc... I can open a contact, or tag contacts, even add new contacts to org-contacts. I have been using this for a few weeks, and so far I like it. Occasionally I find mu4e~contacts-for-completion is empty, and then I only get my org-contacts emails, but that seems to only happen when I first open emacs. Since Emacs is usually open for days at a time, this has not been an issue very often.

* DONE Bibtex Entries from Arxiv.org
  CLOSED: [2015-03-09 Mon 15:14]
  :PROPERTIES:
  :categories: emacs,bibtex
  :date:     2015/03/09 15:14:52
  :updated:  2015/03/09 15:14:52
  :END:

http://arxiv.org is an open-source physics preprint server where copies of scientific manuscripts can be found. For example, http://arxiv.org/abs/0801.1144 is a paper I wrote, and you can find the PDF for that paper here: http://arxiv.org/pdf/0801.1144v1. Each entry at Arxiv has an arxiv number, and for this paper the number is "0801.1144". In this post, we explore some capabilities of the [[https://github.com/jkitchin/org-ref/blob/master/arxiv.el][arxiv.el]] library which is part of org-ref (https://github.com/jkitchin/org-ref).

To use this library, get the org-ref distribution, make sure it is on your path, and then require the library:
#+BEGIN_SRC emacs-lisp
(require 'arxiv)
#+END_SRC

First, there is a new org-link:  arxiv:0801.1144. This is a clickable link that simply opens arxiv.org at the URL for an arxiv number, and exports as a link to that entry in arxiv.

On the right hand side of the arxiv page, there is a link under References & Citations that takes you to a page where you can get a bibtex entry. The link for this entry is http://adsabs.harvard.edu/cgi-bin/bib_query?arXiv:0801.1144. On that page, there is a link to a bibtex entry (http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=2008PhRvB..77g5437K&data_type=BIBTEX&db_key=PHY&nocookieset=1).  We can construct this link pretty easily, we just need the bibcode for that entry. arxiv.el provides a function for that.

#+BEGIN_SRC emacs-lisp
(arxiv-get-bibliographic-code "0801.1144")
#+END_SRC

#+RESULTS:
: 2008PhRvB..77g5437K

Next, once we have a url, we can get the text of the bibtex entry.

#+BEGIN_SRC emacs-lisp
(arxiv-get-bibtex-entry "2008PhRvB..77g5437K")
#+END_SRC

#+RESULTS:
#+begin_example

@ARTICLE{2008PhRvB..77g5437K,
   author = {{Kitchin}, J.~R. and {Reuter}, K. and {Scheffler}, M.},
    title = "{Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag$_{3}$Pd(111) in oxygen atmospheres}",
  journal = {\prb},
archivePrefix = "arXiv",
   eprint = {0801.1144},
 primaryClass = "cond-mat.mtrl-sci",
 keywords = {Ab initio calculations of adsorbate structure and reactions, Density functional theory local density approximation gradient and other corrections, Oxidation},
     year = 2008,
    month = feb,
   volume = 77,
   number = 7,
      eid = {075437},
    pages = {075437},
      doi = {10.1103/PhysRevB.77.075437},
   adsurl = {http://adsabs.harvard.edu/abs/2008PhRvB..77g5437K},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}

#+end_example

Finally, arxiv.el wraps those to functions together into an interactive function =arxiv-add-bibtex-entry= which prompts you for an arxiv number, and then a bibtex file, and then adds the text above to your bibtex file. You can then clean the entry as you see fit. It is also possible to get the pdf for an arxiv entry via =arxiv-get-pdf=. This is an interactive function that will prompt you for an arxiv number and a pdf file name, and it will then get the pdf for you and open it. I have not integrated this with the bibtex entry function yet, but one would ideally clean the bibtex entry to get a uniform key, and then get the pdf and name it according to the key like we do in org-ref.

#+BEGIN_SRC emacs-lisp
(arxiv-get-pdf "0801.1144" "0801.1144.pdf")
#+END_SRC

#+RESULTS:

If you use [[https://github.com/jkitchin/jmax/blob/master/words.el][words.el]] you will find a new function =words-arxiv= which allows you to search the selected text or word at point on arxiv.org.

I do not use arxiv.org a lot, so this is not super well tested on many articles in arxiv.org, but it has worked on the few examples I have tested so far.


* DONE Updating Multiple RESULTS blocks in org-mode
  CLOSED: [2015-03-11 Wed 17:33]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/03/11 17:33:51
  :updated:  2015/03/11 17:33:51
  :END:

There was a recent question on the org-mode mailing list about getting multiple named block results to update when a named code block is run. I suppose you might want to do this if you need to see the results in more than one place. org-mode (at the moment) only updates the first named block that it finds from the beginning of the buffer. Challenge accepted ;)

Here is a function that will update all the named RESULTS blocks. The idea is to make a hook function that runs after you run a block. The hook function will get the block name, and if there is one, find all the named results in the buffer and update them.

#+BEGIN_SRC emacs-lisp
(defun update-results ()
  ;; get name of src block
  (let ((name (org-element-property :name (org-element-at-point)))
	(results)
	(begin))
    (when name
      (setq results
	    (save-excursion
	      (goto-char (org-babel-find-named-result name))
	      (forward-line)
	      (buffer-substring
	       (point) (org-element-property :end (org-element-at-point)))))
      (save-excursion
	(goto-char (point-min))
	(while (setq begin (org-babel-find-named-result name (point)))
	  (goto-char begin)
	  (forward-line)
	  (setf (buffer-substring
		 (point)
		 (org-element-property :end (org-element-at-point)))
		results))))))

(add-hook 'org-babel-after-execute-hook 'update-results)
#+END_SRC

#+RESULTS:
| update-results | (lambda nil (org-refresh-images)) |

Now let us test it out. Here is an unnamed block that should be ignored.
#+BEGIN_SRC python
print 4
#+END_SRC

#+RESULTS:
: 4

Here we have a named results block from a code block we will see later.
#+RESULTS: testcode
: [0.0825119635983067, 0.12793443834890417, 0.5235765147357154]

Here is our named code block that just prints three random numbers.

#+name: testcode
#+BEGIN_SRC python
import random

print [random.random() for i in range(3)]
#+END_SRC

#+RESULTS: testcode
: [0.0825119635983067, 0.12793443834890417, 0.5235765147357154]

Swell, everytime I run the block, the named results get updated everywhere! It isn't tested more than this post, so I would spend some time trying out your use cases before doing anything mission critical. Your mileage might vary. For example, if you have a named block outside a narrowed region it is not clear to me it would update. In other words, there might be other corners where this doesn't update like you thing.
