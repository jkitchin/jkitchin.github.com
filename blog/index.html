

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="selected">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation"></div>
      <h2 class="blog_post_title"><a href="/blog/2021/06/21/New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation/" rel="bookmark" title="Permanent Link to New publication "Machine-learning accelerated geometry optimization in molecular simulation"">New publication "Machine-learning accelerated geometry optimization in molecular simulation"</a></h2>
      <p><small><span class="blog_post_date">Posted June 21, 2021 at 11:52 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/news/'>news</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2021/06/21/New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Geometry optimization and transition state searches are two very common tasks in molecular simulation. Typically every one of these is done from scratch, and they can only be made faster by using a better initial guess. Typical optimization algorithms use some variation of gradient descent, and the best ones also use an iterative approach to estimate the Hessian (second derivatives). The problem is we do not know the underlying function that is being optimized, so there is hardly any choice to benefit from the Hessian (which allows bigger, more accurate steps to be taken).
</p>

<p>
In this paper, we use machine learning to develop a surrogate model that is cheap compared to the DFT calculations, and that has an uncertainty quantification so we can tell when it is accurate. This allows us to take many cheap steps when the surrogate model is accurate, and only do expensive calculations when needed. More importantly though, the surrogate model works across many different geometry optimizations, which allows us to benefit from previous calculations. We show this works on a variety of atomic geometries ranging from metal slabs, slabs with adsorbates, and nanoparticle geometries, as well as with nudged elastic band calculations for transitions state searches.
</p>


<div class="org-src-container">
<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">yang-2021-machin-learn</span>,
  <span style="color: #BA36A5;">author</span> =       {Yilin Yang and Omar A. Jim{\'e}nez-Negr{\'o}n and John R.
                  Kitchin},
  <span style="color: #BA36A5;">title</span> =        {Machine-Learning Accelerated Geometry Optimization in
                  Molecular Simulation},
  <span style="color: #BA36A5;">journal</span> =      {The Journal of Chemical Physics},
  <span style="color: #BA36A5;">volume</span> =       154,
  <span style="color: #BA36A5;">number</span> =       23,
  <span style="color: #BA36A5;">pages</span> =        234704,
  <span style="color: #BA36A5;">year</span> =         2021,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1063/5.0049665</span>},
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;">https://doi.org/10.1063/5.0049665</span>},
}
</pre>
</div>

<p>
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/5.0049665'></div>
</p>
<p>Copyright (C) 2021 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2021/06/21/New-publication-"Machine-learning-accelerated-geometry-optimization-in-molecular-simulation".org">org-mode source</a></p>
<p>Org-mode version = 9.4</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2021/06/21/New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models"></div>
      <h2 class="blog_post_title"><a href="/blog/2021/03/07/New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models/" rel="bookmark" title="Permanent Link to New publication - Semi-grand Canonical Monte Carlo Simulation of the Acrolein induced Surface Segregation and Aggregation of AgPd with Machine Learning Surrogate Models">New publication - Semi-grand Canonical Monte Carlo Simulation of the Acrolein induced Surface Segregation and Aggregation of AgPd with Machine Learning Surrogate Models</a></h2>
      <p><small><span class="blog_post_date">Posted March 07, 2021 at 04:00 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/news/'>news</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2021/03/07/New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated June 21, 2021 at 04:12 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Modeling alloys is tricky, and modeling dilute alloys has been an open challenge for a long time. Segregation is one of the biggest challenges; the surface composition is not the same as the bulk, and is influenced by adsorption. Although we know that the composition varies to lower the surface free energy, the configurational degrees of freedom make it difficult to find the lowest energy arrangement of atoms. In the dilute limit, the quantum chemical calculations and Monte Carlo simulates we do become very expensive due to the unit cell size. In this work, we use machine learning to build surrogate models for the configurational energy of an alloy slab in the dilute limit. Then, we use those models in conjunction with a semi-grand canonical Monte Carlo (MC) simulation to solve several of these problems. First, by fixing the alloy chemical potential at the desired dilute limit, we avoid the need for large unit cells. Second, the surrogate models are much more efficient than DFT, so we can use them in the MC simulations to run tens of thousands of simulation steps to get the required samples for reliable statistical averaging. In dilute alloys, the focus is on the unique catalytic properties of single atoms of an active metal like Pd in an inert metal like Ag. In the single atom limit though, there are few active sites. If you increase the bulk concentration, at some point the single atoms begin to aggregate into dimers and trimers, and adsorbates can make the aggregation happen faster. Aggregation is undesirable because it usually leads to lower selectivity, and more bulk like reactivity. An open question has been how do you design alloy catalysts under reaction conditions, given all this complexity. We apply this approach to the adsorption of acrolein on a dilute AgPd alloy, and show how to use the method to identify the bulk concentration where aggregation begins in a reactive environment.
</p>


<div class="org-src-container">
<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">liu-2021-semi-grand</span>,
  <span style="color: #BA36A5;">author</span> =       {Mingjie Liu and Yilin Yang and John R. Kitchin},
  <span style="color: #BA36A5;">title</span> =        {Semi-Grand Canonical Monte Carlo Simulation of the Acrolein
                  Induced Surface Segregation and Aggregation of {AgPd} With
                  Machine Learning Surrogate Models},
  <span style="color: #BA36A5;">journal</span> =      {The Journal of Chemical Physics},
  <span style="color: #BA36A5;">volume</span> =       154,
  <span style="color: #BA36A5;">number</span> =       13,
  <span style="color: #BA36A5;">pages</span> =        134701,
  <span style="color: #BA36A5;">year</span> =         2021,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1063/5.0046440</span>},
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;">https://doi.org/10.1063/5.0046440</span>},
}
</pre>
</div>

<p>
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/5.0046440'></div>
</p>
<p>Copyright (C) 2021 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2021-03-07/New-publication---Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models.org">org-mode source</a></p>
<p>Org-mode version = 9.4</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2021/03/07/New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability"></div>
      <h2 class="blog_post_title"><a href="/blog/2020/07/09/New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability/" rel="bookmark" title="Permanent Link to New publication SingleNN - Modified Behler–Parrinello Neural Network with Shared Weights for Atomistic Simulations with Transferability">New publication SingleNN - Modified Behler–Parrinello Neural Network with Shared Weights for Atomistic Simulations with Transferability</a></h2>
      <p><small><span class="blog_post_date">Posted July 09, 2020 at 11:35 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/news/'>news</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2020/07/09/New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated June 21, 2021 at 06:31 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Many machine learned potentials work by creating a numeric fingerprint that represents the local atomic environment around an atom, and then "machine learning" a function that computes the atomic energy for that atom. The total energy of an atomic configuration is then simply the sum of the atomic energies, and the forces are simply the derivative of that energy with respect to the atomic positions. In the Behler-Parrinello formulation, each element gets its own neural network for these calculations. In this work, we show that a single neural network with multiple outputs can be used instead. This means that all the elements share the weights in the neural network, and the atomic energy of each element is linearly proportional to the output of the last hidden layer. This has some benefits for transferability and suggests that there is a common nonlinear dimensional transform of the numeric fingerprints for the elements in this study.
</p>


<div class="org-src-container">
<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">liu-2020-singl</span>,
  <span style="color: #BA36A5;">author</span> =       {Mingjie Liu and John R. Kitchin},
  <span style="color: #BA36A5;">title</span> =        {Singlenn: Modified Behler-Parrinello Neural Network With
                  Shared Weights for Atomistic Simulations With Transferability},
  <span style="color: #BA36A5;">journal</span> =      {The Journal of Physical Chemistry C},
  <span style="color: #BA36A5;">volume</span> =       124,
  <span style="color: #BA36A5;">number</span> =       32,
  <span style="color: #BA36A5;">pages</span> =        {17811-17818},
  <span style="color: #BA36A5;">year</span> =         2020,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1021/acs.jpcc.0c04225</span>},
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;">https://doi.org/10.1021/acs.jpcc.0c04225</span>},
}
</pre>
</div>

<p>
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/acs.jpcc.0c04225'></div>
</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/nKwbpaV8dts" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>Copyright (C) 2021 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2020/07/09/New-publication-SingleNN---Modified-Behler–Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability.org">org-mode source</a></p>
<p>Org-mode version = 9.4</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2020/07/09/New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Using-autograd-to-plot-implicit-functions"></div>
      <h2 class="blog_post_title"><a href="/blog/2019/10/02/Using-autograd-to-plot-implicit-functions/" rel="bookmark" title="Permanent Link to Using autograd to plot implicit functions">Using autograd to plot implicit functions</a></h2>
      <p><small><span class="blog_post_date">Posted October 02, 2019 at 09:30 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear-algebra</a>, <a href='/blog/category/autograd/'>autograd</a>, <a href='/blog/category/implicit-function/'>implicit-function</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2019/10/02/Using-autograd-to-plot-implicit-functions#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Consider the solution to these equations (adapted from <a href="https://www.mathworks.com/help/optim/ug/fsolve.html">https://www.mathworks.com/help/optim/ug/fsolve.html</a>):
</p>

<p>
\(e^{-e^{-(x_1 + x_2)}} = x_2 (1 + x_1^2)\)
</p>

<p>
and
</p>

<p>
\(x_1 \cos(x_2) + x_2 \sin(x_1) = 1/2\)
</p>

<p>
It is not clear how many solutions there are to this set of equations, or what you should guess for the initial guess. Usually, the best way to see where a solution might be is to plot the equations and see where they intersect. These equations are implicit though, and it is not easy to plot them because we cannot solve for \(x_2\) in terms of \(x_1\) in either case. Here we explore a strategy to get plots so we can see where solutions could be.
</p>

<p>
The idea is that we find one solution to each equation independently. Then, we derive a differential equation for each equation so we can integrate it to find the curve that is defined by the implicit function.  First, we find a solution for each equation. We guess a value for \(x_2\) and then find the value of \(x_1\) that solves each equation independently.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f1</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(-np.exp(-(x1 + x2))) - x2 * (1 + x1**2)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f2</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x1 * np.cos(x2) + x2 * np.sin(x1) - 0.5

<span style="color: #BA36A5;">x2_1</span> = 0.6
x1_1, = fsolve(f1, 0, args=(x2_1,))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'f1: '</span>, x1_1, x2_1)

<span style="color: #BA36A5;">x2_2</span> = 1.0
x1_2, = fsolve(f2, 0 ,args=(x2_2,))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'f2: '</span>, x1_2, x2_2)
</pre>
</div>

<p>
f1:  0.08638978040861575 0.6
f2:  0.32842406163614396 1.0
</p>

<p>
Next, we need a differential equation that is \(dx_2/dx_1\). If we had that, we could just integrate it from one of the starting points above, and get the curve we want. The functions are implicit, so we have to use the implicit derivative, which for the first equation is \(dx_2/dx_1 = -df1/dx_1 / df1/dx_2\). We will get these gradients from autograd. Then, we just integrate the solution. Here we do this for the first equation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> solve_ivp
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #BA36A5;">df1dx1</span> = grad(f1, 0)
<span style="color: #BA36A5;">df1dx2</span> = grad(f1, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dx2dx1_1</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -df1dx1(x1, x2) / df1dx2(x1, x2)

<span style="color: #BA36A5;">x1_span</span> = (x1_1, 1)
<span style="color: #BA36A5;">x2_0</span> = (x2_1, )
<span style="color: #BA36A5;">sol1</span> = solve_ivp(dx2dx1_1, x1_span, x2_0, max_step=0.1)
</pre>
</div>

<p>
And then, we do it for the second equation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">df2dx1</span> = grad(f2, 0)
<span style="color: #BA36A5;">df2dx2</span> = grad(f2, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dx2dx1_2</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -df2dx1(x1, x2) / df2dx2(x1, x2)

<span style="color: #BA36A5;">x1_span</span> = (x1_2, 1)
<span style="color: #BA36A5;">x2_0</span> = (x2_2, )
<span style="color: #BA36A5;">sol2</span> = solve_ivp(dx2dx1_2, x1_span, x2_0, max_step=0.1)
</pre>
</div>

<p>
Finally, we plot the two solutions.
</p>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(sol1.t, sol1.y.T)
plt.plot(sol2.t, sol2.y.T)
plt.xlabel(<span style="color: #008000;">'$x_1$'</span>)
plt.ylabel(<span style="color: #008000;">'$x_2$'</span>)
plt.legend([<span style="color: #008000;">'f1'</span>, <span style="color: #008000;">'f2'</span>])
</pre>
</div>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/b770a79094dc5fa34b51ebeed23401d697cc0f01.png"></figure> 
</p>

<p>
You can see now that in this range, there is only one intersection, i.e. one solution, and it is near \(x_1=0.4, x_2=0.6\). We can finally use that as an initial guess to find the only solution in this region, with confidence we are not missing any solutions.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x1</span>, <span style="color: #BA36A5;">x2</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [f1(x1, x2), f2(x1, x2)]

fsolve(objective, [0.4, 0.6])
</pre>
</div>

<pre class="example">
array([0.35324662, 0.60608174])
</pre>

<p>
That is the same solution as reported at the Matlab site. Another use of autograd for the win here.
</p>
<p>Copyright (C) 2019 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2019/10/02/Using-autograd-to-plot-implicit-functions.org">org-mode source</a></p>
<p>Org-mode version = 9.2.3</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2019/10/02/Using-autograd-to-plot-implicit-functions#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-differential-algebraic-equations-with-help-from-autograd"></div>
      <h2 class="blog_post_title"><a href="/blog/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd/" rel="bookmark" title="Permanent Link to Solving differential algebraic equations with help from autograd">Solving differential algebraic equations with help from autograd</a></h2>
      <p><small><span class="blog_post_date">Posted September 22, 2019 at 12:59 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dae/'>dae</a>, <a href='/blog/category/ode/'>ode</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
This problem is adapted from one in "Problem Solving in Chemical Engineering with Numerical Methods, Michael B. Cutlip, Mordechai Shacham".
</p>

<p>
In the binary, batch distillation of benzene (1) and toluene (2), the moles of liquid \(L\) remaining as a function of the mole fraction of toluene (\(x_2\)) is expressed by:
</p>

<p>
\(\frac{dL}{dx_2} = \frac{L}{x_2 (k_2 - 1)}\)
</p>

<p>
where \(k_2\) is the vapor liquid equilibrium ratio for toluene. This can be computed as:
</p>

<p>
\(k_i = P_i / P\) where \(P_i = 10^{A_i + \frac{B_i}{T +C_i}}\) and that pressure is in mmHg, and the temperature is in degrees Celsius.
</p>

<p>
One difficulty in solving this problem is that the temperature is not constant; it changes with the composition. We know that the temperature changes to satisfy this constraint  \(k_1(T) x_1 + k_2(T) x_2 = 1\).
</p>

<p>
Sometimes, one can solve for T directly, and substitute it into the first ODE, but this is not a possibility here. One way you might solve this is to use the constraint to find \(T\) inside an ODE function, but that is tricky; nonlinear algebra solvers need a guess and don't always converge, or may converge to non-physical solutions. They also require iterative solutions, so they will be slower than an approach where we just have to integrate the solution.  A better way is to derive a second ODE \(dT/dx_2\) from the constraint.  The constraint is implicit in \(T\), so We  compute it as \(dT/dx_2 = -df/dx_2 / df/dT\) where \(f(x_2, T) = k_1(T) x_1 + k_2(T) x_2  - 1 = 0\). This equation is used to compute the bubble point temperature. Note, it is possible to derive these analytically, but who wants to?  We can use autograd to get those derivatives for us instead.
</p>

<p>
The following information is given:
</p>

<p>
The total pressure is fixed at 1.2 atm, and the distillation starts at \(x_2=0.4\). There are initially 100 moles in the distillation.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">species</th>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">benzene</td>
<td class="org-right">6.90565</td>
<td class="org-right">-1211.033</td>
<td class="org-right">220.79</td>
</tr>

<tr>
<td class="org-left">toluene</td>
<td class="org-right">6.95464</td>
<td class="org-right">-1344.8</td>
<td class="org-right">219.482</td>
</tr>
</tbody>
</table>

<p>
We have to start by finding the initial temperature from the constraint.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> solve_ivp
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">P</span> = 760 * 1.2 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mmHg</span>
<span style="color: #BA36A5;">A1</span>, <span style="color: #BA36A5;">B1</span>, <span style="color: #BA36A5;">C1</span> = 6.90565, -1211.033,  220.79
<span style="color: #BA36A5;">A2</span>, <span style="color: #BA36A5;">B2</span>, <span style="color: #BA36A5;">C2</span> = 6.95464, -1344.8, 219.482

<span style="color: #0000FF;">def</span> <span style="color: #006699;">k1</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 10**(A1 + B1 / (C1 + T)) / P

<span style="color: #0000FF;">def</span> <span style="color: #006699;">k2</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 10**(A2 + B2 / (C2 + T)) / P

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x2, T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x1</span> = 1 - x2
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> k1(T) * x1 + k2(T) * x2 - 1

T0, = fsolve(<span style="color: #0000FF;">lambda</span> T: f(0.4, T), 96)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The initial temperature is {T0:1.2f} degC.'</span>)
</pre>
</div>

<p>
The initial temperature is 95.59 degC.
</p>

<p>
Next, we compute the derivative we need. This derivative is derived from the constraint, which should ensure that the temperature changes as required to maintain the constraint.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">dfdx2</span> = grad(f, 0)
<span style="color: #BA36A5;">dfdT</span> = grad(f, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dTdx2</span>(x2, T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -dfdx2(x2, T) / dfdT(x2, T)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ode</span>(x2, X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">L</span>, <span style="color: #BA36A5;">T</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dLdx2</span> = L / (x2 * (k2(T) - 1))
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [dLdx2, dTdx2(x2, T)]
</pre>
</div>

<p>
Next we solve and plot the ODE.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">x2span</span> = (0.4, 0.8)
<span style="color: #BA36A5;">X0</span> = (100, T0)
<span style="color: #BA36A5;">sol</span> = solve_ivp(ode, x2span, X0, max_step=0.01)

plt.plot(sol.t, sol.y.T)
plt.legend([<span style="color: #008000;">'L'</span>, <span style="color: #008000;">'T'</span>]);
plt.xlabel(<span style="color: #008000;">'$x_2$'</span>)
plt.ylabel(<span style="color: #008000;">'L, T'</span>)
<span style="color: #BA36A5;">x2</span> = sol.t
<span style="color: #BA36A5;">L</span>, <span style="color: #BA36A5;">T</span> = sol.y
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'At x2={x2[-1]:1.2f} there are {L[-1]:1.2f} moles of liquid left at {T[-1]:1.2f} degC'</span>)
</pre>
</div>

<p>
At x2=0.80 there are 14.04 moles of liquid left at 108.57 degC
</p>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/a75e63c53e3c2cb02c40c808789084c337e174ff.png"></figure> 
</p>

<p>
You can see that the liquid level drops, and the temperature rises.
</p>

<p>
Let's double check that the constraint is actually met. We do that qualitatively here by plotting it, and quantitatively by showing all values are close to 0.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">constraint</span> = k1(T) * (1 - x2) + k2(T) * x2 - 1
plt.plot(x2, constraint)
plt.ylim([-1, 1])
plt.xlabel(<span style="color: #008000;">'$x_2$'</span>)
plt.ylabel(<span style="color: #008000;">'constraint value'</span>)
<span style="color: #0000FF;">print</span>(np.allclose(constraint, np.zeros_like(constraint)))
constraint
</pre>
</div>

<p>
True
</p>

<pre class="example">
array([ 2.22044605e-16,  4.44089210e-16,  2.22044605e-16,  0.00000000e+00,
        1.11022302e-15,  0.00000000e+00,  6.66133815e-16,  0.00000000e+00,
       -2.22044605e-16,  1.33226763e-15,  8.88178420e-16, -4.44089210e-16,
        4.44089210e-16,  1.11022302e-15, -2.22044605e-16,  0.00000000e+00,
       -2.22044605e-16, -1.11022302e-15,  4.44089210e-16,  0.00000000e+00,
       -4.44089210e-16,  4.44089210e-16, -6.66133815e-16, -4.44089210e-16,
        4.44089210e-16, -1.11022302e-16, -8.88178420e-16, -8.88178420e-16,
       -9.99200722e-16, -3.33066907e-16, -7.77156117e-16, -2.22044605e-16,
       -9.99200722e-16, -1.11022302e-15, -3.33066907e-16, -1.99840144e-15,
       -1.33226763e-15, -2.44249065e-15, -1.55431223e-15, -6.66133815e-16,
       -2.22044605e-16])
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/bb2b32002658b8724d214f2441c9f55a97c565c8.png"></figure> 
</p>


<p>
So indeed, the constraint is met! Once again, autograd comes to the rescue in making a computable derivative from an algebraic constraint so that we can solve a DAE as a set of ODEs using our regular machinery. Nice work autograd!
</p>
<p>Copyright (C) 2019 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.2.3</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/page/2">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2021/06/21/New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation/">New publication "Machine-learning accelerated geometry optimization in molecular simulation"</a></li>
      <li><a href="/blog/2021/03/07/New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models/">New publication - Semi-grand Canonical Monte Carlo Simulation of the Acrolein induced Surface Segregation and Aggregation of AgPd with Machine Learning Surrogate Models</a></li>
      <li><a href="/blog/2020/07/09/New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability/">New publication SingleNN - Modified Behler–Parrinello Neural Network with Shared Weights for Atomistic Simulations with Transferability</a></li>
      <li><a href="/blog/2019/10/02/Using-autograd-to-plot-implicit-functions/">Using autograd to plot implicit functions</a></li>
      <li><a href="/blog/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd/">Solving differential algebraic equations with help from autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2021
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



