

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Modeling-a-transient-plug-flow-reactor"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/06/Modeling-a-transient-plug-flow-reactor/" rel="bookmark" title="Permanent Link to Modeling a transient plug flow reactor">Modeling a transient plug flow reactor</a></h2>
      <p><small><span class="blog_post_date">Posted March 06, 2013 at 03:51 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/animation/'>animation</a>, <a href='/blog/category/pde/'>pde</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
        | <a href="http://jkitchin.github.io/blog/2013/03/06/Modeling-a-transient-plug-flow-reactor#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 25, 2013 at 09:50 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/17/modeling-a-transient-plug-flow-reactor" >Matlab post</a>



</p>

<p>
The PDE that describes the transient behavior of a plug flow reactor with constant volumetric flow rate is:
</p>

<p>
\( \frac{\partial C_A}{\partial dt} = -\nu_0 \frac{\partial C_A}{\partial dV} + r_A \).
</p>

<p>
To solve this numerically in python, we will utilize the method of lines. The idea is to discretize the reactor in volume, and approximate the spatial derivatives by finite differences. Then we will have a set of coupled ordinary differential equations that can be solved in the usual way. Let us simplify the notation with \(C = C_A\), and let \(r_A = -k C^2\). Graphically this looks like this:
</p>

<p><img src="/img/./images/pde-method-of-lines.png"><p>

<p>
This leads to the following set of equations:
</p>

\begin{eqnarray}
\frac{dC_0}{dt} &=& 0 \text{ (entrance concentration never changes)} \\
\frac{dC_1}{dt} &=& -\nu_0 \frac{C_1 - C_0}{V_1 - V_0} - k C_1^2 \\
\frac{dC_2}{dt} &=& -\nu_0 \frac{C_2 - C_1}{V_2 - V_1} - k C_2^2 \\
\vdots \\
\frac{dC_4}{dt} &=& -\nu_0 \frac{C_4 - C_3}{V_4 - V_3} - k C_4^2 
\end{eqnarray}

<p>
Last, we need initial conditions for all the nodes in the discretization. Let us assume the reactor was full of empty solvent, so that \(C_i = 0\) at \(t=0\). In the next block of code, we get the transient solutions, and the steady state solution.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

Ca0 = 2     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Entering concentration</span>
vo = 2      <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">volumetric flow rate</span>
volume = 20 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">total volume of reactor, spacetime = 10</span>
k = 1       <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">reaction rate constant</span>

N = 100     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of points to discretize the reactor volume on</span>

init = np.zeros(N)    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Concentration in reactor at t = 0</span>
init[0] = Ca0         <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">concentration at entrance</span>

V = np.linspace(0, volume, N) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">discretized volume elements</span>
tspan = np.linspace(0, 25)    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">time span to integrate over</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">method_of_lines</span>(C, t):
    <span style="color: #228b22;">'coupled ODES at each node point'</span>
    D = -vo * np.diff(C) / np.diff(V) - k * C[1:]**2
    <span style="color: #8b0000;">return</span> np.concatenate([[0], <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">C0 is constant at entrance</span>
                            D])


sol = odeint(method_of_lines, init, tspan)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">steady state solution</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">pfr</span>(C, V):
    <span style="color: #8b0000;">return</span> 1.0 / vo * (-k * C**2)

ssol = odeint(pfr, Ca0, V)
</pre>
</div>

<p>
The transient solution contains the time dependent behavior of each node in the discretized reactor. Each row contains the concentration as a function of volume at a specific time point. For example, we can plot the concentration of A at the exit vs. time (that is, the last entry of each row) as:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
plt.plot(tspan, sol[:, -1])
plt.xlabel(<span style="color: #228b22;">'time'</span>)
plt.ylabel(<span style="color: #228b22;">'$C_A$ at exit'</span>)
plt.savefig(<span style="color: #228b22;">'images/transient-pfr-1.png'</span>)
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D object at 0x05A18830&gt;]
&lt;matplotlib.text.Text object at 0x059FE1D0&gt;
&lt;matplotlib.text.Text object at 0x05A05270&gt;
</pre>


<p><img src="/img/./images/transient-pfr-1.png"><p>

<p>
After approximately one space time, the steady state solution is reached at the exit. For completeness, we also examine the steady state solution.
</p>
<div class="org-src-container">

<pre class="src src-python">plt.figure()
plt.plot(V, ssol, label=<span style="color: #228b22;">'Steady state'</span>)
plt.plot(V, sol[-1], label=<span style="color: #228b22;">'t = {}'</span>.format(tspan[-1]))
plt.xlabel(<span style="color: #228b22;">'Volume'</span>)
plt.ylabel(<span style="color: #228b22;">'$C_A$'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/transient-pfr-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/transient-pfr-2.png"><p>

<p>
There is some minor disagreement between the final transient solution and the steady state solution. That is due to the approximation in discretizing the reactor volume. In this example we used 100 nodes. You get better agreement with a larger number of nodes, say 200 or more. Of course, it takes slightly longer to compute then, since the number of coupled odes is equal to the number of nodes.
</p>

<p>
We can also create an animated gif to show how the concentration of A throughout the reactor varies with time. Note, I had to install ffmpeg (<a href="http://ffmpeg.org/" >http://ffmpeg.org/</a>) to save the animation.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> matplotlib <span style="color: #8b0000;">import</span> animation

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">make empty figure</span>
fig = plt.figure()
ax = plt.axes(xlim=(0, 20), ylim=(0, 2))
line, = ax.plot(V, init, lw=2)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">animate</span>(i):
    line.set_xdata(V)
    line.set_ydata(sol[i])
    ax.set_title(<span style="color: #228b22;">'t = {0}'</span>.format(tspan[i]))
    ax.figure.canvas.draw() 
    <span style="color: #8b0000;">return</span> line,
    

anim = animation.FuncAnimation(fig, animate, frames=50,  blit=<span style="color: #8b0000;">True</span>)

anim.save(<span style="color: #228b22;">'images/transient_pfr.mp4'</span>, fps=10)
</pre>
</div>

<p>
<a href="http://jkitchin.github.com/media/transient_pfr.mp4" >http://jkitchin.github.com/media/transient_pfr.mp4</a>
</p>

<p>
You can see from the animation that after about 10 time units, the solution is not changing further, suggesting steady state has been reached.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Modeling-a-transient-plug-flow-reactor.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/06/Modeling-a-transient-plug-flow-reactor#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Determining-linear-independence-of-a-set-of-vectors"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/01/Determining-linear-independence-of-a-set-of-vectors/" rel="bookmark" title="Permanent Link to Determining linear independence of a set of vectors">Determining linear independence of a set of vectors</a></h2>
      <p><small><span class="blog_post_date">Posted March 01, 2013 at 04:44 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/linear-algebra/'>linear algebra</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
        | <a href="http://jkitchin.github.io/blog/2013/03/01/Determining-linear-independence-of-a-set-of-vectors#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated May 05, 2013 at 02:10 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
 <a href="http://matlab.cheme.cmu.edu/2011/08/02/determining-linear-independence-of-a-set-of-vectors/" >Matlab post</a>
Occasionally we have a set of vectors and we need to determine whether the vectors are linearly independent of each other. This may be necessary to determine if the vectors form a basis, or to determine how many independent equations there are, or to determine how many independent reactions there are.
</p>

<p>
Reference: Kreysig, Advanced Engineering Mathematics, sec. 7.4
</p>

<p>
Matlab provides a rank command which gives you the number of singular values greater than some tolerance. The numpy.rank function, unfortunately, does not do that. It returns the number of dimensions in the array. We will just compute the rank from singular value decomposition.
</p>

<p>
The default tolerance used in Matlab is max(size(A))*eps(norm(A)). Let us break that down. eps(norm(A)) is the positive distance from abs(X) to the next larger in magnitude floating point number of the same precision as X. Basically, the smallest significant number. We multiply that by the size of A, and take the largest number. We have to use some judgment in what the tolerance is, and what &ldquo;zero&rdquo; means.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
v1 = [6, 0, 3, 1, 4, 2];
v2 = [0, -1, 2, 7, 0, 5];
v3 = [12, 3, 0, -19, 8, -11];

A = np.row_stack([v1, v2, v3])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">matlab definition</span>
eps = np.finfo(np.linalg.norm(A).dtype).eps
TOLERANCE = <span style="color: #8b0000;">max</span>(eps * np.array(A.shape))

U, s, V = np.linalg.svd(A)
<span style="color: #8b0000;">print</span> s
<span style="color: #8b0000;">print</span> np.sum(s &gt; TOLERANCE)

TOLERANCE = 1e-14
<span style="color: #8b0000;">print</span> np.sum(s &gt; TOLERANCE)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [  2.75209239e+01   9.30584482e+00   1.42425400e-15]
3
&gt;&gt;&gt; &gt;&gt;&gt; 2
</pre>

<p>
You can see if you choose too small a TOLERANCE, nothing looks like zero. the result with TOLERANCE=1e-14 suggests the rows are not linearly independent. Let us show that one row can be expressed as a linear combination of the other rows. 
</p>

<p>
The number of rows is greater than the rank, so these vectors are not
independent. Let's demonstrate that one vector can be defined as a linear
combination of the other two vectors. Mathematically we represent this
as:
</p>

<p>
\(x_1 \mathit{v1} + x_2 \mathit{v2} = v3\)
</p>

<p>
or
</p>

<p>
\([x_1 x_2][v1; v2] = v3\)
</p>

<p>
This is not the usual linear algebra form of Ax = b. To get there, we
transpose each side of the equation to get:
</p>

<p>
[v1.T v2.T][x_1; x_2] = v3.T
</p>

<p>
which is the form Ax = b. We solve it in a least-squares sense.
</p>

<div class="org-src-container">

<pre class="src src-python">A = np.column_stack([v1, v2])
x = np.linalg.lstsq(A, v3)
<span style="color: #8b0000;">print</span> x[0]
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; [ 2. -3.]
</pre>

<p>
This shows that v3 = 2*v1 - 3*v2
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> another example</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">Problem set 7.4 #17</span>
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

v1 = [0.2, 1.2, 5.3, 2.8, 1.6]
v2 = [4.3, 3.4, 0.9, 2.0, -4.3]

A = np.row_stack([v1, v2])
U, s, V = np.linalg.svd(A)
<span style="color: #8b0000;">print</span> s
</pre>
</div>

<pre class="example">
[ 7.57773162  5.99149259]
</pre>

<p>
You can tell by inspection the rank is 2 because there are no near-zero singular values. 
</p>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Near deficient rank</h2>
<div class="outline-text-2" id="text-2">
<p>
the rank command roughly works in the following way: the matrix is converted to a reduced row echelon form, and then the number of rows that are not all equal to zero are counted. Matlab uses a tolerance to determine what is equal to zero. If there is uncertainty in the numbers, you may have to define what zero is, e.g. if the absolute value of a number is less than 1e-5, you may consider that close enough to be zero. The default tolerance is usually very small, of order 1e-15. If we believe that any number less than 1e-5 is practically equivalent to zero, we can use that information to compute the rank like this.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

A = [[1, 2, 3],
     [0, 2, 3],
     [0, 0, 1e-6]]

U, s, V = np.linalg.svd(A)
<span style="color: #8b0000;">print</span> s
<span style="color: #8b0000;">print</span> np.sum(np.abs(s) &gt; 1e-15)
<span style="color: #8b0000;">print</span> np.sum(np.abs(s) &gt; 1e-5)
</pre>
</div>

<pre class="example">
[  5.14874857e+00   7.00277208e-01   5.54700196e-07]
3
2
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Application to independent chemical reactions.</h2>
<div class="outline-text-2" id="text-3">
<p>
reference: Exercise 2.4 in Chemical Reactor Analysis and Design Fundamentals by Rawlings and Ekerdt.
</p>

<p>
The following reactions are proposed in the hydrogenation of bromine:
</p>

<p>
Let this be our species vector: v = [H2 H Br2 Br HBr].T
</p>

<p>
the reactions are then defined by M*v where M is a stoichometric matrix in which each row represents a reaction with negative stoichiometric coefficients for reactants, and positive stoichiometric coefficients for products. A stoichiometric coefficient of 0 is used for species not participating in the reaction.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #ff0000; font-weight: bold;">#    </span><span style="color: #ff0000; font-weight: bold;">[H2  H Br2 Br HBr]</span>
M = [[-1,  0, -1,  0,  2],  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">H2 + Br2 == 2HBR</span>
     [ 0,  0, -1,  2,  0],  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Br2 == 2Br</span>
     [-1,  1,  0, -1,  1],  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Br + H2 == HBr + H</span>
     [ 0, -1, -1,  1,  1],  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">H + Br2 == HBr + Br</span>
     [ 1, -1,  0,  1,  -1], <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">H + HBr == H2 + Br</span>
     [ 0,  0,  1, -2,  0]]  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">2Br == Br2</span>

U, s, V = np.linalg.svd(M)
<span style="color: #8b0000;">print</span> s
<span style="color: #8b0000;">print</span> np.sum(np.abs(s) &gt; 1e-15)

<span style="color: #8b0000;">import</span> sympy 
M = sympy.Matrix(M)
reduced_form, inds = M.rref()

<span style="color: #8b0000;">print</span> reduced_form

labels = [<span style="color: #228b22;">'H2'</span>,  <span style="color: #228b22;">'H'</span>, <span style="color: #228b22;">'Br2'</span>, <span style="color: #228b22;">'Br'</span>, <span style="color: #228b22;">'HBr'</span>]
<span style="color: #8b0000;">for</span> row <span style="color: #8b0000;">in</span> reduced_form.tolist():
    s = <span style="color: #228b22;">'0 = '</span>
    <span style="color: #8b0000;">for</span> nu,species <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(row,labels):
        <span style="color: #8b0000;">if</span> nu != 0:
            
            s += <span style="color: #228b22;">' {0:+d}{1}'</span>.format(<span style="color: #8b0000;">int</span>(nu), species)
    <span style="color: #8b0000;">if</span> s != <span style="color: #228b22;">'0 = '</span>: <span style="color: #8b0000;">print</span> s
</pre>
</div>

<pre class="example">
[  3.84742803e+00   3.32555975e+00   1.46217301e+00   1.73313660e-16
   8.57422679e-17]
3
[1, 0, 0,  2, -2]
[0, 1, 0,  1, -1]
[0, 0, 1, -2,  0]
[0, 0, 0,  0,  0]
[0, 0, 0,  0,  0]
[0, 0, 0,  0,  0]
0 =  +1H2 +2Br -2HBr
0 =  +1H +1Br -1HBr
0 =  +1Br2 -2Br
</pre>

<p>
6 reactions are given, but the rank of the matrix is only 3. so there
are only three independent reactions. You can see that reaction 6 is just
the opposite of reaction 2, so it is clearly not independent. Also,
reactions 3 and 5 are just the reverse of each other, so one of them can
also be eliminated. finally, reaction 4 is equal to reaction 1 minus
reaction 3.
</p>

<p>
There are many possible independent reactions. In the code above, we use sympy to put the matrix into reduced row echelon form, which enables us to identify three independent reactions, and shows that three rows are all zero, i.e. they are not independent of the other three reactions. The choice of independent reactions is not unique.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/01/Determining-linear-independence-of-a-set-of-vectors.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/01/Determining-linear-independence-of-a-set-of-vectors#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Conservation-of-mass-in-chemical-reactions"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/27/Conservation-of-mass-in-chemical-reactions/" rel="bookmark" title="Permanent Link to Conservation of mass in chemical reactions">Conservation of mass in chemical reactions</a></h2>
      <p><small><span class="blog_post_date">Posted February 27, 2013 at 10:54 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/linear-algebra/'>linear algebra</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
        | <a href="http://jkitchin.github.io/blog/2013/02/27/Conservation-of-mass-in-chemical-reactions#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 04:27 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/18/conservation-of-mass-in-chemical-reactions/" >Matlab post</a>
</p>

<p>
Atoms cannot be destroyed in non-nuclear chemical reactions, hence it follows that the same number of atoms entering a reactor must also leave the reactor. The atoms may leave the reactor in a different molecular configuration due to the reaction, but the total mass leaving the reactor must be the same. Here we look at a few ways to show this.
</p>

<p>
We consider the water gas shift reaction : \(CO + H_2O \rightleftharpoons H_2 + CO_2\). We can illustrate the conservation of mass with the following equation: \(\bf{\nu}\bf{M}=\bf{0}\). Where \(\bf{\nu}\) is the stoichiometric coefficient vector and \(\bf{M}\) is a column vector of molecular weights. For simplicity, we use pure isotope molecular weights, and not the isotope-weighted molecular weights. This equation simply examines the mass on the right side of the equation and the mass on left side of the equation. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
nu = [-1, -1, 1, 1];
M = [28, 18, 2, 44];
<span style="color: #8b0000;">print</span> np.dot(nu, M)
</pre>
</div>

<pre class="example">
0
</pre>

<p>
You can see that sum of the stoichiometric coefficients times molecular weights is zero. In other words a CO and H_2O have the same mass as H_2 and CO_2.
</p>

<p>
For any balanced chemical equation, there are the same number of each kind of atom on each side of the equation. Since the mass of each atom is unchanged with reaction, that means the mass of all the species that are reactants must equal the mass of all the species that are products! Here we look at the number of C, O, and H on each side of the reaction. Now if we add the mass of atoms in the reactants and products, it should sum to zero (since we used the negative sign for stoichiometric coefficients of reactants).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
            <span style="color: #ff0000; font-weight: bold;"># C   O   H</span>
reactants = [-1, -2, -2]
products  = [ 1,  2,  2]

atomic_masses = [12.011, 15.999, 1.0079]  <span style="color: #ff0000; font-weight: bold;"># atomic masses</span>

<span style="color: #8b0000;">print</span> np.dot(reactants, atomic_masses) + np.dot(products, atomic_masses)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.0
</pre>

<p>
That is all there is to mass conservation with reactions. Nothing changes if there are lots of reactions, as long as each reaction is properly balanced, and none of them are nuclear reactions!
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Conservation-of-mass-in-chemical-reactions.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/27/Conservation-of-mass-in-chemical-reactions#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Integrating-the-batch-reactor-mole-balance"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/18/Integrating-the-batch-reactor-mole-balance/" rel="bookmark" title="Permanent Link to Integrating the batch reactor mole balance">Integrating the batch reactor mole balance</a></h2>
      <p><small><span class="blog_post_date">Posted February 18, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
        | <a href="http://jkitchin.github.io/blog/2013/02/18/Integrating-the-batch-reactor-mole-balance#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 03, 2013 at 10:36 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
An alternative approach of evaluating an integral is to integrate a differential equation. For the batch reactor, the differential equation that describes conversion as a function of time is:
</p>

<p>
\(\frac{dX}{dt} = -r_A V/N_{A0}\).
</p>

<p>
Given a value of initial concentration, or volume and initial number of moles of A, we can integrate this ODE to find the conversion at some later time. We assume that \(X(t=0)=0\). We will integrate the ODE over a time span of 0 to 10,000 seconds.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

k = 1.0e-3
Ca0 = 1.0  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">mol/L</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(X, t):
    ra = -k * (Ca0 * (1 - X))**2
    <span style="color: #8b0000;">return</span> -ra / Ca0

X0 = 0
tspan = np.linspace(0,10000)

sol = odeint(func, X0, tspan)
plt.plot(tspan,sol)
plt.xlabel(<span style="color: #228b22;">'Time (sec)'</span>)
plt.ylabel(<span style="color: #228b22;">'Conversion'</span>)
plt.savefig(<span style="color: #228b22;">'images/2013-01-06-batch-conversion.png'</span>)
</pre>
</div>

<p><img src="/img/./images/2013-01-06-batch-conversion.png"><p>

<p>
You can read off of this figure to find the time required to achieve a particular conversion.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Integrating-the-batch-reactor-mole-balance.org">org-mode source</a><p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/18/Integrating-the-batch-reactor-mole-balance#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Plug-flow-reactor-with-a-pressure-drop"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/18/Plug-flow-reactor-with-a-pressure-drop/" rel="bookmark" title="Permanent Link to Plug flow reactor with a pressure drop">Plug flow reactor with a pressure drop</a></h2>
      <p><small><span class="blog_post_date">Posted February 18, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: <a href='/blog/tag/fluids/'>fluids</a>, <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
        | <a href="http://jkitchin.github.io/blog/2013/02/18/Plug-flow-reactor-with-a-pressure-drop#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 04:39 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
If there is a pressure drop in a plug flow reactor, <sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> there are two equations needed to determine the exit conversion: one for the conversion, and one from the pressure drop.
</p>

\begin{eqnarray}
\frac{dX}{dW} &=& \frac{k'}{F_A0} \left ( \frac{1-X}{1 + \epsilon X} \right) y\\
\frac{dX}{dy} &=& -\frac{\alpha (1 + \epsilon X)}{2y}
\end{eqnarray}

<p>
Here is how to integrate these equations numerically in python.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

kprime = 0.0266
Fa0 = 1.08
alpha = 0.0166
epsilon = -0.15

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dFdW</span>(F, W):
    <span style="color: #228b22;">'set of ODEs to integrate'</span>
    X = F[0]
    y = F[1]
    dXdW = kprime / Fa0 * (1-X) / (1 + epsilon*X) * y
    dydW = -alpha * (1 + epsilon * X) / (2 * y)
    <span style="color: #8b0000;">return</span> [dXdW, dydW]

Wspan = np.linspace(0,60)
X0 = 0.0
y0 = 1.0
F0 = [X0, y0]
sol = odeint(dFdW, F0, Wspan)

<span style="color: #ff0000; font-weight: bold;"># now plot the results</span>
plt.plot(Wspan, sol[:,0], label=<span style="color: #228b22;">'Conversion'</span>)
plt.plot(Wspan, sol[:,1], <span style="color: #228b22;">'g--'</span>, label=<span style="color: #228b22;">'y=$P/P_0$'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.xlabel(<span style="color: #228b22;">'Catalyst weight (lb_m)'</span>)
plt.savefig(<span style="color: #228b22;">'images/2013-01-08-pdrop.png'</span>)
</pre>
</div>

<p>
Here is the resulting figure.
</p>

<p><img src="/img/./images/2013-01-08-pdrop.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Plug-flow-reactor-with-a-pressure-drop.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/18/Plug-flow-reactor-with-a-pressure-drop#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/tag/reaction-engineering/2">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/01/27/New-publication-in-Topics-in-Catalysis/">New publication in Topics in Catalysis</a></li>
      <li><a href="/blog/2018/01/03/New-publication-in-Molecular-Simulation/">New publication in Molecular Simulation</a></li>
      <li><a href="/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group/">2017 in a nutshell for the Kitchin Research group</a></li>
      <li><a href="/blog/2017/11/29/Solving-an-eigenvalue-differential-equation-with-a-neural-network/">Solving an eigenvalue differential equation with a neural network</a></li>
      <li><a href="/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd/">Solving ODEs with a neural network and autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



