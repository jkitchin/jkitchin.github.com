

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: statistics</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications/index.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Model-selection"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/18/Model-selection/" rel="bookmark" title="Permanent Link to Model selection">Model selection</a></h2>
      <p><small><span class="blog_post_date">Posted February 18, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/data-analysis/'>data analysis</a>, <a href='/blog/category/statistics/'>statistics</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/18/Model-selection#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 04:36 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/01/model-selection/" >Matlab post</a>
</p>

<p>
adapted from <a href="http://www.itl.nist.gov/div898/handbook/pmd/section4/pmd44.htm" >http://www.itl.nist.gov/div898/handbook/pmd/section4/pmd44.htm</a>
</p>

<p>
In this example, we show some ways to choose which of several models fit data the best. We have data for the total pressure and temperature of a fixed amount of a gas in a tank that was measured over the course of several days. We want to select a model that relates the pressure to the gas temperature.
</p>

<p>
The data is stored in a text file download PT.txt , with the following structure:
</p>

<pre class="example">
Run          Ambient                            Fitted
 Order  Day  Temperature  Temperature  Pressure    Value    Residual
  1      1      23.820      54.749      225.066   222.920     2.146
...
</pre>

<p>
We need to read the data in, and perform a regression analysis on P vs. T. In python we start counting at 0, so we actually want columns 3 and 4.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

data = np.loadtxt(<span style="color: #228b22;">'data/PT.txt'</span>, skiprows=2)
T = data[:, 3]
P = data[:, 4]

plt.plot(T, P, <span style="color: #228b22;">'k.'</span>)
plt.xlabel(<span style="color: #228b22;">'Temperature'</span>)
plt.ylabel(<span style="color: #228b22;">'Pressure'</span>)
plt.savefig(<span style="color: #228b22;">'images/model-selection-1.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x00000000084398D0&gt;]
&lt;matplotlib.text.Text object at 0x000000000841F6A0&gt;
&lt;matplotlib.text.Text object at 0x0000000008423DD8&gt;
</pre>

<p><img src="/img/./images/model-selection-1.png"><p>

<p>
It appears the data is roughly linear, and we know from the ideal gas law that PV = nRT, or P = nR/V*T, which says P should be linearly correlated with V. Note that the temperature data is in degC, not in K, so it is not expected that P=0 at T = 0. We will use linear algebra to compute the line coefficients. 
</p>

<div class="org-src-container">

<pre class="src src-python">A = np.vstack([T**0, T]).T
b = P

x, res, rank, s = np.linalg.lstsq(A, b)
intercept, slope = x
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'b, m ='</span>, intercept, slope

n = <span style="color: #8b0000;">len</span>(b)
k = <span style="color: #8b0000;">len</span>(x)

sigma2 = np.sum((b - np.dot(A,x))**2) / (n - k)

C = sigma2 * np.linalg.inv(np.dot(A.T, A))
se = np.sqrt(np.diag(C))

<span style="color: #8b0000;">from</span> scipy.stats.distributions <span style="color: #8b0000;">import</span>  t
alpha = 0.05

sT = t.ppf(1-alpha/2., n - k) <span style="color: #ff0000; font-weight: bold;"># student T multiplier</span>
CI = sT * se

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'CI = '</span>,CI
<span style="color: #8b0000;">for</span> beta, ci <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(x, CI):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'[{0} {1}]'</span>.format(beta - ci, beta + ci)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; b, m = 7.74899739238 3.93014043824
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; CI =  [ 4.76511545  0.1026405 ]
... ... [2.98388194638 12.5141128384]
[3.82749994079 4.03278093569]
</pre>

<p>
The confidence interval on the intercept is large, but it does not contain zero at the 95% confidence level.
</p>

<p>
The R^2 value accounts roughly for the fraction of variation in the data that can be described by the model. Hence, a value close to one means nearly all the variations are described by the model, except for random variations.
</p>

<div class="org-src-container">

<pre class="src src-python">ybar = np.mean(P)
SStot = np.sum((P - ybar)**2)
SSerr = np.sum((P - np.dot(A, x))**2)
R2 = 1 - SSerr/SStot
<span style="color: #8b0000;">print</span> R2
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.993715411798
</pre>

<div class="org-src-container">

<pre class="src src-python">plt.figure(); plt.clf()
plt.plot(T, P, <span style="color: #228b22;">'k.'</span>, T, np.dot(A, x), <span style="color: #228b22;">'b-'</span>)
plt.xlabel(<span style="color: #228b22;">'Temperature'</span>)
plt.ylabel(<span style="color: #228b22;">'Pressure'</span>)
plt.title(<span style="color: #228b22;">'R^2 = {0:1.3f}'</span>.format(R2))
plt.savefig(<span style="color: #228b22;">'images/model-selection-2.png'</span>)
</pre>
</div>

<pre class="example">
&lt;matplotlib.figure.Figure object at 0x0000000008423860&gt;
[&lt;matplotlib.lines.Line2D object at 0x00000000085BE780&gt;, &lt;matplotlib.lines.Line2D object at 0x00000000085BE940&gt;]
&lt;matplotlib.text.Text object at 0x0000000008449898&gt;
&lt;matplotlib.text.Text object at 0x000000000844CCF8&gt;
&lt;matplotlib.text.Text object at 0x000000000844ED30&gt;
</pre>

<p><img src="/img/./images/model-selection-2.png"><p>

<p>
The fit looks good, and R^2 is near one, but is it a good model? There are a few ways to examine this. We want to make sure that there are no systematic trends in the errors between the fit and the data, and we want to make sure there are not hidden correlations with other variables. The residuals are the error between the fit and the data. The residuals should not show any patterns when plotted against any variables, and they do not in this case.
</p>

<div class="org-src-container">

<pre class="src src-python">residuals = P - np.dot(A, x)

plt.figure()

f, (ax1, ax2, ax3) = plt.subplots(3)

ax1.plot(T,residuals,<span style="color: #228b22;">'ko'</span>)
ax1.set_xlabel(<span style="color: #228b22;">'Temperature'</span>)


run_order = data[:, 0]
ax2.plot(run_order, residuals,<span style="color: #228b22;">'ko '</span>)
ax2.set_xlabel(<span style="color: #228b22;">'run order'</span>)

ambientT = data[:, 2]
ax3.plot(ambientT, residuals,<span style="color: #228b22;">'ko'</span>)
ax3.set_xlabel(<span style="color: #228b22;">'ambient temperature'</span>)

plt.tight_layout() <span style="color: #ff0000; font-weight: bold;"># make sure plots do not overlap</span>

plt.savefig(<span style="color: #228b22;">'images/model-selection-3.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x00000000085C21D0&gt;
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x0000000008861CC0&gt;]
&lt;matplotlib.text.Text object at 0x00000000085D3A58&gt;
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x0000000008861E80&gt;]
&lt;matplotlib.text.Text object at 0x00000000085EC5F8&gt;
&gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x0000000008861C88&gt;]
&lt;matplotlib.text.Text object at 0x0000000008846828&gt;
</pre>

<p><img src="/img/./images/model-selection-3.png"><p>

<p>
There may be some correlations in the residuals with the run order. That could indicate an experimental source of error.
</p>

<p>
We assume all the errors are uncorrelated with each other. We can use a lag plot to assess this, where we plot residual[i] vs residual[i-1], i.e. we look for correlations between adjacent residuals. This plot should look random, with no correlations if the model is good.
</p>

<div class="org-src-container">

<pre class="src src-python">plt.figure(); plt.clf()
plt.plot(residuals[1:-1], residuals[0:-2],<span style="color: #228b22;">'ko'</span>)
plt.xlabel(<span style="color: #228b22;">'residual[i]'</span>)
plt.ylabel(<span style="color: #228b22;">'residual[i-1]'</span>)
plt.savefig(<span style="color: #228b22;">'images/model-selection-correlated-residuals.png'</span>)
</pre>
</div>

<pre class="example">
&lt;matplotlib.figure.Figure object at 0x000000000886EB00&gt;
[&lt;matplotlib.lines.Line2D object at 0x0000000008A02908&gt;]
&lt;matplotlib.text.Text object at 0x00000000089E8198&gt;
&lt;matplotlib.text.Text object at 0x00000000089EB908&gt;
</pre>

<p><img src="/img/./images/model-selection-correlated-residuals.png"><p>

<p>
It is hard to argue there is any correlation here. 
</p>

<p>
Lets consider a quadratic model instead.
</p>

<div class="org-src-container">

<pre class="src src-python">A = np.vstack([T**0, T, T**2]).T
b = P;

x, res, rank, s = np.linalg.lstsq(A, b)
<span style="color: #8b0000;">print</span> x

n = <span style="color: #8b0000;">len</span>(b)
k = <span style="color: #8b0000;">len</span>(x)

sigma2 = np.sum((b - np.dot(A,x))**2) / (n - k)

C = sigma2 * np.linalg.inv(np.dot(A.T, A))
se = np.sqrt(np.diag(C))

<span style="color: #8b0000;">from</span> scipy.stats.distributions <span style="color: #8b0000;">import</span>  t
alpha = 0.05

sT = t.ppf(1-alpha/2., n - k) <span style="color: #ff0000; font-weight: bold;"># student T multiplier</span>
CI = sT * se

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'CI = '</span>,CI
<span style="color: #8b0000;">for</span> beta, ci <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(x, CI):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'[{0} {1}]'</span>.format(beta - ci, beta + ci)


ybar = np.mean(P)
SStot = np.sum((P - ybar)**2)
SSerr = np.sum((P - np.dot(A,x))**2)
R2 = 1 - SSerr/SStot
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'R^2 = {0}'</span>.format(R2)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [  9.00353031e+00   3.86669879e+00   7.26244301e-04]
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; CI =  [  1.38030344e+01   6.62100654e-01   7.48516727e-03]
... ... [-4.79950412123 22.8065647329]
[3.20459813681 4.52879944409]
[-0.00675892296907 0.00821141157035]
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; R^2 = 0.993721969407
</pre>

<p>
You can see that the confidence interval on the constant and T^2 term includes zero. That is a good indication this additional parameter is not significant. You can see also that the R^2 value is not better than the one from a linear fit,  so adding a parameter does not increase the goodness of fit. This is an example of overfitting the data. Since the constant in this model is apparently not significant, let us consider the simplest model with a fixed intercept of zero.
</p>

<p>
Let us consider a model with intercept = 0, P = alpha*T. 
</p>

<div class="org-src-container">

<pre class="src src-python">A = np.vstack([T]).T
b = P;

x, res, rank, s = np.linalg.lstsq(A, b)

n = <span style="color: #8b0000;">len</span>(b)
k = <span style="color: #8b0000;">len</span>(x)

sigma2 = np.sum((b - np.dot(A,x))**2) / (n - k)

C = sigma2 * np.linalg.inv(np.dot(A.T, A))
se = np.sqrt(np.diag(C))

<span style="color: #8b0000;">from</span> scipy.stats.distributions <span style="color: #8b0000;">import</span>  t
alpha = 0.05

sT = t.ppf(1-alpha/2.0, n - k) <span style="color: #ff0000; font-weight: bold;"># student T multiplier</span>
CI = sT * se

<span style="color: #8b0000;">for</span> beta, ci <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(x, CI):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'[{0} {1}]'</span>.format(beta - ci, beta + ci)

plt.figure()
plt.plot(T, P, <span style="color: #228b22;">'k. '</span>, T, np.dot(A, x))
plt.xlabel(<span style="color: #228b22;">'Temperature'</span>)
plt.ylabel(<span style="color: #228b22;">'Pressure'</span>)
plt.legend([<span style="color: #228b22;">'data'</span>, <span style="color: #228b22;">'fit'</span>])

ybar = np.mean(P)
SStot = np.sum((P - ybar)**2)
SSerr = np.sum((P - np.dot(A,x))**2)
R2 = 1 - SSerr/SStot
plt.title(<span style="color: #228b22;">'R^2 = {0:1.3f}'</span>.format(R2))
plt.savefig(<span style="color: #228b22;">'images/model-selection-no-intercept.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... [4.05680124495 4.12308349899]
&lt;matplotlib.figure.Figure object at 0x0000000008870BE0&gt;
[&lt;matplotlib.lines.Line2D object at 0x00000000089F4550&gt;, &lt;matplotlib.lines.Line2D object at 0x00000000089F4208&gt;]
&lt;matplotlib.text.Text object at 0x0000000008A13630&gt;
&lt;matplotlib.text.Text object at 0x0000000008A16DA0&gt;
&lt;matplotlib.legend.Legend object at 0x00000000089EFD30&gt;
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;matplotlib.text.Text object at 0x000000000B26C0B8&gt;
</pre>

<p>
<p><img src="/img/./images/model-selection-no-intercept.png"><p>
The fit is visually still pretty good, and the R^2 value is only slightly worse. Let us examine the residuals again. 
</p>


<div class="org-src-container">

<pre class="src src-python">residuals = P - np.dot(A,x)

plt.figure()
plt.plot(T,residuals,<span style="color: #228b22;">'ko'</span>)
plt.xlabel(<span style="color: #228b22;">'Temperature'</span>)
plt.ylabel(<span style="color: #228b22;">'residuals'</span>)
plt.savefig(<span style="color: #228b22;">'images/model-selection-no-incpt-resid.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x0000000008A0F5C0&gt;
[&lt;matplotlib.lines.Line2D object at 0x000000000B29B0F0&gt;]
&lt;matplotlib.text.Text object at 0x000000000B276FD0&gt;
&lt;matplotlib.text.Text object at 0x000000000B283780&gt;
</pre>

<p><img src="/img/./images/model-selection-no-incpt-resid.png"><p>

<p>
You can see a slight trend of decreasing value of the residuals as the Temperature increases. This may indicate a deficiency in the model with no intercept. For the ideal gas law in degC: \(PV = nR(T+273)\) or \(P = nR/V*T + 273*nR/V\), so the intercept is expected to be non-zero in this case. Specifically, we expect the intercept to be 273*R*n/V. Since the molar density of a gas is pretty small, the intercept may be close to, but not equal to zero. That is why the fit still looks ok, but is not as good as letting the intercept be a fitting parameter. That is an example of the deficiency in our model.
</p>

<p>
In the end, it is hard to justify a model more complex than a line in this case. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Model-selection.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/18/Model-selection#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Random-thoughts"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/18/Random-thoughts/" rel="bookmark" title="Permanent Link to Random thoughts">Random thoughts</a></h2>
      <p><small><span class="blog_post_date">Posted February 18, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a>, <a href='/blog/category/math/'>math</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/18/Random-thoughts#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 07, 2013 at 08:46 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/04/random-thoughts/" >Matlab post</a>
</p>

<p>
Random numbers are used in a variety of simulation methods, most notably Monte Carlo simulations. In another later example, we will see how we can use random numbers for error propagation analysis. First, we discuss two types of pseudorandom numbers we can use in python: uniformly distributed and normally distributed numbers.
</p>

<p>
Say you are the gambling type, and bet your friend $5 the next random number will be greater than 0.49. Let us ask Python to roll the random number generator for us.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

n = np.random.uniform()
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'n = {0}'</span>.format(n)

<span style="color: #8b0000;">if</span> n &gt; 0.49:
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'You win!'</span>
<span style="color: #8b0000;">else:</span>
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'you lose.'</span>
</pre>
</div>

<pre class="example">
n = 0.381896986693
you lose.
</pre>

<p>
The odds of you winning the last bet are slightly stacked in your favor. There is only a 49% chance your friend wins, but a 51% chance that you win. Lets play the game a lot of times times and see how many times you win, and your friend wins. First, lets generate a bunch of numbers and look at the distribution with a histogram.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

N = 10000
games = np.random.uniform(size=(1,N))

wins = np.sum(games &gt; 0.49)
losses = N - wins

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'You won {0} times ({1:%})'</span>.format(wins, <span style="color: #8b0000;">float</span>(wins) / N)

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
count, bins, ignored = plt.hist(games)
plt.savefig(<span style="color: #228b22;">'images/random-thoughts-1.png'</span>)
</pre>
</div>

<pre class="example">
You won 5090 times (50.900000%)
</pre>

<p><img src="/img/./images/random-thoughts-1.png"><p>

<p>
As you can see you win slightly more than you lost.
</p>

<p>
It is possible to get random integers. Here are a few examples of getting a random integer between 1 and 100. You might do this to get random indices of a list, for example.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">print</span> np.random.random_integers(1, 100)
<span style="color: #8b0000;">print</span> np.random.random_integers(1, 100, 3)
<span style="color: #8b0000;">print</span> np.random.random_integers(1, 100, (2,2))
</pre>
</div>

<pre class="example">
96
[ 95  49 100]
[[69 54]
 [41 93]]
</pre>

<p>
The normal distribution is defined by \(f(x)=\frac{1}{\sqrt{2\pi \sigma^2}} \exp (-\frac{(x-\mu)^2}{2\sigma^2})\) where \(\mu\) is the mean value, and \(\sigma\) is the standard deviation. In the standard distribution, \(\mu=0\) and \(\sigma=1\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

mu = 1
sigma = 0.5
<span style="color: #8b0000;">print</span> np.random.normal(mu, sigma)
<span style="color: #8b0000;">print</span> np.random.normal(mu, sigma, 2)
</pre>
</div>

<pre class="example">
1.04225842065
[ 0.58105204  0.64853157]
</pre>

<p>
Let us compare the sampled distribution to the analytical distribution. We generate a large set of samples, and calculate the probability of getting each value using the matplotlib.pyplot.hist command.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0; sigma = 1

N = 5000
samples = np.random.normal(mu, sigma, N)

counts, bins, ignored = plt.hist(samples, 50, normed=<span style="color: #8b0000;">True</span>)

plt.plot(bins, 1.0/np.sqrt(2 * np.pi * sigma**2)*np.exp(-((bins - mu)**2)/(2*sigma**2)))
plt.savefig(<span style="color: #228b22;">'images/random-thoughts-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/random-thoughts-2.png"><p>

<p>
What fraction of points lie between plus and minus one standard deviation of the mean?
</p>

<p>
samples &gt;= mu-sigma will return a vector of ones where the inequality is true, and zeros where it is not. (samples &gt;= mu-sigma) &amp; (samples &lt;= mu+sigma) will return a vector of ones where there is a one in both vectors, and a zero where there is not. In other words, a vector where both inequalities are true. Finally, we can sum the vector to get the number of elements where the two inequalities are true, and finally normalize by the total number of samples to get the fraction of samples that are greater than -sigma and less than sigma.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0; sigma = 1

N = 5000
samples = np.random.normal(mu, sigma, N)

a = np.sum((samples &gt;= (mu - sigma)) &amp; (samples &lt;= (mu + sigma))) / <span style="color: #8b0000;">float</span>(N) 
b = np.sum((samples &gt;= (mu - 2*sigma)) &amp; (samples &lt;= (mu + 2*sigma))) / <span style="color: #8b0000;">float</span>(N) 
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0:%} of samples are within +- standard deviations of the mean'</span>.format(a)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0:%} of samples are within +- 2standard deviations of the mean'</span>.format(b)
</pre>
</div>

<pre class="example">
67.500000% of samples are within +- standard deviations of the mean
95.580000% of samples are within +- 2standard deviations of the mean
</pre>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
We only considered the numpy.random functions here, and not all of them. There are many distributions of random numbers to choose from. There are also random numbers in the python random module. Remember these are only <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator" >pseudorandom</a> numbers, but they are still useful for many applications.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Random-thoughts.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/18/Random-thoughts#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Numerical-propagation-of-errors"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/16/Numerical-propagation-of-errors/" rel="bookmark" title="Permanent Link to Numerical propagation of errors">Numerical propagation of errors</a></h2>
      <p><small><span class="blog_post_date">Posted February 16, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/16/Numerical-propagation-of-errors#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 07, 2013 at 08:46 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/05/numerical-propogation-of-errors/" >Matlab post</a>
</p>

<p>
Propagation of errors is essential to understanding how the uncertainty in a parameter affects computations that use that parameter. The uncertainty propagates by a set of rules into your solution. These rules are not easy to remember, or apply to complicated situations, and are only approximate for equations that are nonlinear in the parameters.
</p>

<p>
We will use a Monte Carlo simulation to illustrate error propagation. The idea is to generate a distribution of possible parameter values, and to evaluate your equation for each parameter value. Then, we perform statistical analysis on the results to determine the standard error of the results.
</p>

<p>
We will assume all parameters are defined by a normal distribution with known mean and standard deviation.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Addition and subtraction</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

N = 1e6 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of samples of parameters</span>

A_mu = 2.5; A_sigma = 0.4
B_mu = 4.1; B_sigma = 0.3

A = np.random.normal(A_mu, A_sigma, size=(1, N))
B = np.random.normal(B_mu, B_sigma, size=(1, N))

p = A + B
m = A - B

<span style="color: #8b0000;">print</span> np.std(p)
<span style="color: #8b0000;">print</span> np.std(m)

<span style="color: #8b0000;">print</span> np.sqrt(A_sigma**2 + B_sigma**2) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the analytical std dev</span>
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.500505424616
0.500113385681
&gt;&gt;&gt; 0.5
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Multiplication</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python">F_mu = 25.0; F_sigma = 1;
x_mu = 6.4; x_sigma = 0.4;

F = np.random.normal(F_mu, F_sigma, size=(1, N))
x = np.random.normal(x_mu, x_sigma, size=(1, N))

t = F * x
<span style="color: #8b0000;">print</span> np.std(t)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu * x_mu
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 11.8900166284
11.8726576637
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Division</h2>
<div class="outline-text-2" id="text-3">
<p>
This is really like multiplication: F / x = F * (1 / x).
</p>

<div class="org-src-container">

<pre class="src src-python">d = F / x
<span style="color: #8b0000;">print</span> np.std(d)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu / x_mu
</pre>
</div>

<pre class="example">
0.293757533168
0.289859806243
</pre>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> exponents</h2>
<div class="outline-text-2" id="text-4">
<p>
This rule is different than multiplication (A^2 = A*A) because in the previous examples we assumed the errors in A and B for A*B were uncorrelated. in A*A, the errors are not uncorrelated, so there is a different rule for error propagation.
</p>

<div class="org-src-container">

<pre class="src src-python">t_mu = 2.03; t_sigma = 0.01*t_mu; <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1% error</span>
A_mu = 16.07; A_sigma = 0.06;

t = np.random.normal(t_mu, t_sigma, size=(1, N))
A = np.random.normal(A_mu, A_sigma, size=(1, N))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Compute t^5 and sqrt(A) with error propagation</span>
<span style="color: #8b0000;">print</span> np.std(t**5)
<span style="color: #8b0000;">print</span> (5 * t_sigma / t_mu) * t_mu**5
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... 1.72454836176
1.72365440621
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">print</span> np.std(np.sqrt(A))
<span style="color: #8b0000;">print</span> 1.0 / 2.0 * A_sigma / A_mu * np.sqrt(A_mu)
</pre>
</div>

<pre class="example">
0.00748903477329
0.00748364738749
</pre>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> the chain rule in error propagation</h2>
<div class="outline-text-2" id="text-5">
<p>
let v = v0 + a*t, with uncertainties in vo,a and t
</p>

<div class="org-src-container">

<pre class="src src-python">vo_mu = 1.2; vo_sigma = 0.02;
a_mu = 3.0;  a_sigma  = 0.3;
t_mu = 12.0; t_sigma  = 0.12;

vo = np.random.normal(vo_mu, vo_sigma, (1, N))
a = np.random.normal(a_mu, a_sigma, (1, N))
t = np.random.normal(t_mu, t_sigma, (1, N))

v = vo + a*t

<span style="color: #8b0000;">print</span> np.std(v)
<span style="color: #8b0000;">print</span> np.sqrt(vo_sigma**2 + t_mu**2 * a_sigma**2 + a_mu**2 * t_sigma**2)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 3.62232509326
3.61801050303
</pre>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">

<p>
You can numerically perform error propagation analysis if you know the underlying distribution of errors on the parameters in your equations. One benefit of the numerical propogation is you do not have to remember the error propagation rules, and you directly look at the distribution in nonlinear cases. Some limitations of this approach include
</p>

<ol>
<li>You have to know the distribution of the errors in the parameters
</li>
<li>You have to assume the errors in parameters are uncorrelated.
</li>
</ol>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/16/Numerical-propagation-of-errors.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/16/Numerical-propagation-of-errors#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Numerical-propogation-of-errors"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/16/Numerical-propogation-of-errors/" rel="bookmark" title="Permanent Link to Numerical propogation of errors">Numerical propogation of errors</a></h2>
      <p><small><span class="blog_post_date">Posted February 16, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/16/Numerical-propogation-of-errors#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated February 27, 2013 at 02:36 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/05/numerical-propogation-of-errors/" >Matlab post</a>
</p>

<p>
Propagation of errors is essential to understanding how the uncertainty in a parameter affects computations that use that parameter. The uncertainty propogates by a set of rules into your solution. These rules are not easy to remember, or apply to complicated situations, and are only approximate for equations that are nonlinear in the parameters.
</p>

<p>
We will use a Monte Carlo simulation to illustrate error propogation. The idea is to generate a distribution of possible parameter values, and to evaluate your equation for each parameter value. Then, we perform statistical analysis on the results to determine the standard error of the results.
</p>

<p>
We will assume all parameters are defined by a normal distribution with known mean and standard deviation.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Addition and subtraction</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

N = 1e6 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of samples of parameters</span>

A_mu = 2.5; A_sigma = 0.4
B_mu = 4.1; B_sigma = 0.3

A = np.random.normal(A_mu, A_sigma, size=(1, N))
B = np.random.normal(B_mu, B_sigma, size=(1, N))

p = A + B
m = A - B

<span style="color: #8b0000;">print</span> np.std(p)
<span style="color: #8b0000;">print</span> np.std(m)

<span style="color: #8b0000;">print</span> np.sqrt(A_sigma**2 + B_sigma**2) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the analytical std dev</span>
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.500505424616
0.500113385681
&gt;&gt;&gt; 0.5
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Multiplication</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python">F_mu = 25.0; F_sigma = 1;
x_mu = 6.4; x_sigma = 0.4;

F = np.random.normal(F_mu, F_sigma, size=(1, N))
x = np.random.normal(x_mu, x_sigma, size=(1, N))

t = F * x
<span style="color: #8b0000;">print</span> np.std(t)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu * x_mu
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 11.8900166284
11.8726576637
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Division</h2>
<div class="outline-text-2" id="text-3">
<p>
This is really like multiplication: F / x = F * (1 / x).
</p>

<div class="org-src-container">

<pre class="src src-python">d = F / x
<span style="color: #8b0000;">print</span> np.std(d)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu / x_mu
</pre>
</div>

<pre class="example">
0.293757533168
0.289859806243
</pre>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> exponents</h2>
<div class="outline-text-2" id="text-4">
<p>
This rule is different than multiplication (A^2 = A*A) because in the previous examples we assumed the errors in A and B for A*B were uncorrelated. in A*A, the errors are not uncorrelated, so there is a different rule for error propagation.
</p>

<div class="org-src-container">

<pre class="src src-python">t_mu = 2.03; t_sigma = 0.01*t_mu; <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1% error</span>
A_mu = 16.07; A_sigma = 0.06;

t = np.random.normal(t_mu, t_sigma, size=(1, N))
A = np.random.normal(A_mu, A_sigma, size=(1, N))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Compute t^5 and sqrt(A) with error propogation</span>
<span style="color: #8b0000;">print</span> np.std(t**5)
<span style="color: #8b0000;">print</span> (5 * t_sigma / t_mu) * t_mu**5
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... 1.72454836176
1.72365440621
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">print</span> np.std(np.sqrt(A))
<span style="color: #8b0000;">print</span> 1.0 / 2.0 * A_sigma / A_mu * np.sqrt(A_mu)
</pre>
</div>

<pre class="example">
0.00748903477329
0.00748364738749
</pre>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> the chain rule in error propogation</h2>
<div class="outline-text-2" id="text-5">
<p>
let v = v0 + a*t, with uncertainties in vo,a and t
</p>

<div class="org-src-container">

<pre class="src src-python">vo_mu = 1.2; vo_sigma = 0.02;
a_mu = 3.0;  a_sigma  = 0.3;
t_mu = 12.0; t_sigma  = 0.12;

vo = np.random.normal(vo_mu, vo_sigma, (1, N))
a = np.random.normal(a_mu, a_sigma, (1, N))
t = np.random.normal(t_mu, t_sigma, (1, N))

v = vo + a*t

<span style="color: #8b0000;">print</span> np.std(v)
<span style="color: #8b0000;">print</span> np.sqrt(vo_sigma**2 + t_mu**2 * a_sigma**2 + a_mu**2 * t_sigma**2)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 3.62232509326
3.61801050303
</pre>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">

<p>
You can numerically perform error propogation analysis if you know the underlying distribution of errors on the parameters in your equations. One benefit of the numerical propogation is you do not have to remember the error propogation rules, and you directly look at the distribution in nonlinear cases. Some limitations of this approach include
</p>

<ol>
<li>You have to know the distribution of the errors in the parameters
</li>
<li>You have to assume the errors in parameters are uncorrelated.
</li>
</ol>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/16/Numerical-propogation-of-errors.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/16/Numerical-propogation-of-errors#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Confidence-interval-on-an-average"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/10/Confidence-interval-on-an-average/" rel="bookmark" title="Permanent Link to Confidence interval on an average">Confidence interval on an average</a></h2>
      <p><small><span class="blog_post_date">Posted February 10, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/10/Confidence-interval-on-an-average#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated April 09, 2013 at 08:54 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
nil has a statistical package available for getting statistical distributions. This is useful for computing confidence intervals using the student-t tables. Here is an example of computing a 95% confidence interval on an average.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.stats.distributions <span style="color: #8b0000;">import</span>  t

n = 10 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of measurements</span>
dof = n - 1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">degrees of freedom</span>
avg_x = 16.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">average measurement</span>
std_x = 0.01 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">standard deviation of measurements</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Find 95% prediction interval for next measurement</span>

alpha = 1.0 - 0.95

pred_interval = t.ppf(1-alpha/2.0, dof) * std_x / np.sqrt(n)

s = [<span style="color: #228b22;">'We are 95% confident the next measurement'</span>,
       <span style="color: #228b22;">' will be between {0:1.3f} and {1:1.3f}'</span>]
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">''</span>.join(s).format(avg_x - pred_interval, avg_x + pred_interval)
</pre>
</div>

<pre class="example">
We are 95% confident the next measurement will be between 16.093 and 16.107
</pre>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/10/Confidence-interval-on-an-average.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/10/Confidence-interval-on-an-average#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/statistics/1">Â« Previous Page</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2016/08/12/A-new-take-on-altmetrics-the-Altmetrics-API/">A new take on altmetrics - the Altmetrics API</a></li>
      <li><a href="/blog/2016/06/29/New-publication-in-ACS-Catalysis/">New publication in ACS Catalysis</a></li>
      <li><a href="/blog/2016/06/16/Copy-formatted-org-mode-text-from-Emacs-to-other-applications/">Copy formatted org-mode text from Emacs to other applications</a></li>
      <li><a href="/blog/2016/06/14/Using-prefix-args-in-ivy-actions/">Using prefix args in ivy actions</a></li>
      <li><a href="/blog/2016/06/14/New-publication-in-International-Journal-of-Digital-Libraries/">New publication in International Journal of Digital Libraries</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2016
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



