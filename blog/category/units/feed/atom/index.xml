<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2016-11-04T10:58:38Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Handling units with dimensionless equations]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/03/26/Handling-units-with-dimensionless-equations" />
    <id>http://jkitchin.github.io/blog/2013/03/26/Handling-units-with-dimensionless-equations</id>
    <updated>2013-03-26T16:47:39Z</updated>
    <published>2013-03-26T16:47:39Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="units" />
    <summary type="html"><![CDATA[Handling units with dimensionless equations]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/03/26/Handling-units-with-dimensionless-equations"><![CDATA[


<p>
As we have seen, handling units with third party functions is fragile, and often requires additional code to wrap the function to handle the units. An alternative approach that avoids the wrapping is to rescale the equations so they are dimensionless. Then, we should be able to use all the standard external functions without modification. We obtain the final solutions by rescaling back to the answers we want.
</p>

<p>
Before doing the examples, let us consider how the quantities package handles dimensionless numbers.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

a = 5 * u.m
L = 10 * u.m <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">characteristic length</span>

<span style="color: #8b0000;">print</span> a/L
<span style="color: #8b0000;">print</span> type(a/L)
</pre>
</div>

<pre class="example">
0.5 dimensionless
&lt;class 'quantities.quantity.Quantity'&gt;
</pre>

<p>
As you can see, the dimensionless number is scaled properly, and is listed as dimensionless. The result is still an instance of a quantities object though. That is not likely to be a problem.
</p>

<p>
Now, we consider using fsolve with dimensionless equations. Our goal is to solve \(C_A = C_{A0} \exp(-k t)\) for the time required to reach a desired \(C_A\). We let \(X = Ca / Ca0\) and \(\tau = t * k\), which leads to \(X = \exp{-\tau}\) in dimensionless terms.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">desired exit concentration</span>
k = 1.0 / u.s

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we need new dimensionless variables</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">let X = Ca / Ca0</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">so, Ca = Ca0 * X</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">let tau = t * k</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">so t = tau / k</span>

X = CA / CA0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">desired exit dimensionless concentration</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(tau):
    <span style="color: #8b0000;">return</span> X - np.exp(-tau)

tauguess = 2

<span style="color: #8b0000;">print</span> func(tauguess) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">confirm we have a dimensionless function</span>

tau_sol, = fsolve(func, tauguess)
t = tau_sol / k
<span style="color: #8b0000;">print</span> t
</pre>
</div>

<pre class="example">
-0.125335283237 dimensionless
4.60517018599 s
</pre>

<p>
Now consider the ODE \(\frac{dCa}{dt} = -k Ca\). We let \(X = Ca/Ca0\), so \(Ca0 dX = dCa\). Let \(\tau = t * k\) which in this case is dimensionless. That means \(d\tau = k dt\). Substitution of these new variables leads to:
</p>

<p>
\(Ca0*k \frac{dX}{d\tau} = -k Ca0 X \)
</p>

<p>
or equivalently:
\(\frac{dX}{d\tau} = -X \)
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

k = 0.23 / u.s
Ca0 = 1 * u.mol / u.L

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Let X = Ca/Ca0  -&gt; Ca = Ca0 * X  dCa = dX/Ca0</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">let tau = t * k -&gt; dt = 1/k dtau</span>


<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dXdtau</span>(X, tau):
    <span style="color: #8b0000;">return</span> -X

<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

tspan = np.linspace(0, 5) * u.s
tauspan = tspan * k

X0 = 1
X_sol = odeint(dXdtau, X0, tauspan)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Ca at t = {0} = {1}'</span>.format(tspan[-1], X_sol.flatten()[-1] * Ca0)
</pre>
</div>

<pre class="example">
Ca at t = 5.0 s = 0.316636777351 mol/L
</pre>

<p>
That is pretty much it. Using dimensionless quantities simplifies the need to write wrapper code, although it does increase the effort to rederive your equations (with corresponding increased opportunities to make mistakes). Using units to confirm your dimensionless derivation reduces those opportunities.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/26/Handling-units-with-dimensionless-equations.org">org-mode source</a><p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Units in ODEs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/03/25/Units-in-ODEs" />
    <id>http://jkitchin.github.io/blog/2013/03/25/Units-in-ODEs</id>
    <updated>2013-03-25T09:58:55Z</updated>
    <published>2013-03-25T09:58:55Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="odes" />
    <category scheme="http://jkitchin.github.io/blog" term="units" />
    <summary type="html"><![CDATA[Units in ODEs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/03/25/Units-in-ODEs"><![CDATA[


<p>
We reconsider a simple ODE but this time with units. We will use the quantities package again. 
</p>

<p>
Here is the ODE, \(\frac{dCa}{dt} = -k Ca\) with \(C_A(0) = 1.0\) mol/L and \(k = 0.23\) 1/s. Compute the concentration after 5 s.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

k = 0.23 / u.s
Ca0 = 1 * u.mol / u.L

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dCadt</span>(Ca, t):
    <span style="color: #8b0000;">return</span> -k * Ca

<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

tspan = np.linspace(0, 5) * u.s

sol = odeint(dCadt, Ca0, tspan)

<span style="color: #8b0000;">print</span> sol[-1]
</pre>
</div>

<pre class="example">
[ 0.31663678]
</pre>

<p>
No surprise, the units are lost. Now we start wrapping odeint. We wrap everything, and then test two examples including a single ODE, and a coupled set of ODEs with mixed units.
</p>


<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint <span style="color: #8b0000;">as</span> _odeint

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odeint</span>(func, y0, t, args=(),
           Dfun=<span style="color: #8b0000;">None</span>, col_deriv=0, full_output=0,
           ml=<span style="color: #8b0000;">None</span>, mu=<span style="color: #8b0000;">None</span>, rtol=<span style="color: #8b0000;">None</span>, atol=<span style="color: #8b0000;">None</span>,
           tcrit=<span style="color: #8b0000;">None</span>, h0=0.0, hmax=0.0, hmin=0.0,
           ixpr=0, mxstep=0, mxhnil=0, mxordn=12,
           mxords=5, printmessg=0):

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(Y0, T, *args):
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">put units on T if they are on the original t</span>
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">check for units so we don't put them on twice</span>
        <span style="color: #8b0000;">if</span> <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">hasattr</span>(T, <span style="color: #228b22;">'units'</span>) <span style="color: #8b0000;">and</span> <span style="color: #8b0000;">hasattr</span>(t, <span style="color: #228b22;">'units'</span>):
            T = T * t.units
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now for the dependent variable units. Y0 may be a scalar or</span>
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">a list or an array. we want to check each element of y0 for</span>
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">units, and add them to the corresponding element of Y0 if we</span>
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">need to.</span>
        <span style="color: #8b0000;">try:</span>
            uY0 = [x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> Y0] <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">a list copy of contents of Y0</span>
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this works if y0 is an iterable, eg. a list or array</span>
            <span style="color: #8b0000;">for</span> i, yi <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(y0):
                <span style="color: #8b0000;">if</span> <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">hasattr</span>(uY0[i],<span style="color: #228b22;">'units'</span>) <span style="color: #8b0000;">and</span> <span style="color: #8b0000;">hasattr</span>(yi, <span style="color: #228b22;">'units'</span>):
               
                    uY0[i] = uY0[i] * yi.units
                
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we have a scalar</span>
            <span style="color: #8b0000;">if</span> <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">hasattr</span>(Y0, <span style="color: #228b22;">'units'</span>) <span style="color: #8b0000;">and</span> <span style="color: #8b0000;">hasattr</span>(y0, <span style="color: #228b22;">'units'</span>):
                uY0 = Y0 * y0.units
       
        val = func(uY0, t, *args)

        <span style="color: #8b0000;">try:</span>
            <span style="color: #8b0000;">return</span> np.array([<span style="color: #8b0000;">float</span>(x) <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> val])
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(val)
    
    <span style="color: #8b0000;">if</span> full_output:
        y, infodict = _odeint(wrapped_func, y0, t, args,
                              Dfun, col_deriv, full_output,
                              ml, mu, rtol, atol,
                              tcrit, h0, hmax, hmin,
                              ixpr, mxstep, mxhnil, mxordn,
                              mxords, printmessg)
    <span style="color: #8b0000;">else:</span>
        y = _odeint(wrapped_func, y0, t, args,
                    Dfun, col_deriv, full_output,
                    ml, mu, rtol, atol,
                    tcrit, h0, hmax, hmin,
                    ixpr, mxstep, mxhnil, mxordn,
                    mxords, printmessg)

    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now we need to put units onto the solution units should be the</span>
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">same as y0. We cannot put mixed units in an array, so, we return a list</span>
    m,n = y.shape <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">y is an ndarray, so it has a shape</span>
    <span style="color: #8b0000;">if</span> n &gt; 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">more than one equation, we need a list</span>
        uY = [0 <span style="color: #8b0000;">for</span> yi <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(n)]
        
        <span style="color: #8b0000;">for</span> i, yi <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(y0):
            <span style="color: #8b0000;">if</span> <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">hasattr</span>(uY[i],<span style="color: #228b22;">'units'</span>) <span style="color: #8b0000;">and</span> <span style="color: #8b0000;">hasattr</span>(yi, <span style="color: #228b22;">'units'</span>):
                uY[i] = y[:,i] * yi.units
            <span style="color: #8b0000;">else:</span>
                uY[i] = y[:,i]
                
    <span style="color: #8b0000;">else:</span>
        uY = y * y0.units

    y = uY


    <span style="color: #8b0000;">if</span> full_output:
        <span style="color: #8b0000;">return</span> y, infodict
    <span style="color: #8b0000;">else:</span>
        <span style="color: #8b0000;">return</span> y

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">#################################################################</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">test a single ODE</span>
k = 0.23 / u.s
Ca0 = 1 * u.mol / u.L

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dCadt</span>(Ca, t):
    <span style="color: #8b0000;">return</span> -k * Ca

tspan = np.linspace(0, 5) * u.s
sol = odeint(dCadt, Ca0, tspan)

<span style="color: #8b0000;">print</span> sol[-1]

plt.plot(tspan, sol)
plt.xlabel(<span style="color: #228b22;">'Time ({0})'</span>.format(tspan.dimensionality.latex))
plt.ylabel(<span style="color: #228b22;">'$C_A$ ({0})'</span>.format(sol.dimensionality.latex))
plt.savefig(<span style="color: #228b22;">'images/ode-units-ca.png'</span>)

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">#################################################################</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">test coupled ODEs</span>
lbmol = 453.59237*u.mol

kprime = 0.0266 * lbmol / u.hr / u.lb
Fa0 = 1.08 * lbmol / u.hr
alpha = 0.0166 / u.lb
epsilon = -0.15

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dFdW</span>(F, W, alpha0):
    X, y = F
    dXdW = kprime / Fa0 * (1.0 - X)/(1.0 + epsilon * X) * y
    dydW = - alpha0 * (1.0 + epsilon * X) / (2.0 * y)
    <span style="color: #8b0000;">return</span> [dXdW, dydW]

X0 = 0.0 * u.dimensionless
y0 = 1.0

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial conditions</span>
F0 = [X0, y0] <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">one without units, one with units, both are dimensionless</span>

wspan = np.linspace(0,60) * u.lb

sol = odeint(dFdW, F0, wspan, args=(alpha,))
X, y = sol

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Test 2'</span>
<span style="color: #8b0000;">print</span> X[-1]
<span style="color: #8b0000;">print</span> y[-1]

plt.figure()
plt.plot(wspan, X, wspan, y)
plt.legend([<span style="color: #228b22;">'X'</span>,<span style="color: #228b22;">'$P/P_0$'</span>])
plt.xlabel(<span style="color: #228b22;">'Catalyst weight ({0})'</span>.format(wspan.dimensionality.latex))
plt.savefig(<span style="color: #228b22;">'images/ode-coupled-units-pdrpo.png'</span>)
</pre>
</div>

<pre class="example">
[ 0.31663678] mol/L
Test 2
0.665569578156 dimensionless
0.263300470681
</pre>

<p><img src="/img/./images/ode-units-ca.png"><p>

<p><img src="/img/./images/ode-coupled-units-pdrpo.png"><p>

<p>
That is not too bad. This is another example of a function you would want to save in a module for reuse. There is one bad feature of the wrapped odeint function, and that is that it changes the solution for coupled ODEs from an ndarray to a list. That is necessary because you apparently cannot have mixed units in an ndarray. It is fine, however, to have a list of mixed units. This is not a huge problem, but it changes the syntax for plotting results for the wrapped odeint function compared to the unwrapped function without units. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/25/Units-in-ODEs.org">org-mode source</a><p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Handling units with the quantities module]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/03/22/Handling-units-with-the-quantities-module" />
    <id>http://jkitchin.github.io/blog/2013/03/22/Handling-units-with-the-quantities-module</id>
    <updated>2013-03-23T09:22:54Z</updated>
    <published>2013-03-22T22:00:30Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="units" />
    <summary type="html"><![CDATA[Handling units with the quantities module]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/03/22/Handling-units-with-the-quantities-module"><![CDATA[


<p>
The quantities module (<a href="https://pypi.python.org/pypi/quantities" >https://pypi.python.org/pypi/quantities</a>) is another option for handling units in python. We are going to try the previous example. It does not work, because scipy.optimize.fsolve is not designed to work with units. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)

tguess = 4 * u.s

<span style="color: #8b0000;">print</span> func(tguess)

<span style="color: #8b0000;">print</span> fsolve(func, tguess)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; -0.00831563888873 mol/L
&gt;&gt;&gt; Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "c:\Python27\lib\site-packages\scipy\optimize\minpack.py", line 115, in fsolve
    _check_func('fsolve', 'func', func, x0, args, n, (n,))
  File "c:\Python27\lib\site-packages\scipy\optimize\minpack.py", line 13, in _check_func
    res = atleast_1d(thefunc(*((x0[:numinputs],) + args)))
  File "&lt;stdin&gt;", line 2, in func
  File "c:\Python27\lib\site-packages\quantities-0.10.1-py2.7.egg\quantities\quantity.py", line 231, in __array_prepare__
    res._dimensionality = p_dict[uf](*objs)
  File "c:\Python27\lib\site-packages\quantities-0.10.1-py2.7.egg\quantities\dimensionality.py", line 347, in _d_dimensionless
    raise ValueError("quantity must be dimensionless")
ValueError: quantity must be dimensionless
</pre>

<p>
Our function works fine with units, but fsolve does not pass numbers with units back to the function, so this function fails because the exponential function gets an argument with dimensions in it.  We can create a new function that solves this problem. We need to &ldquo;wrap&rdquo; the function we want to solve to make sure that it uses units, but returns a float number. Then, we put the units back onto the final solved value. Here is how we do that.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve <span style="color: #8b0000;">as</span> _fsolve

CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fsolve</span>(func, t0):
    <span style="color: #228b22;">'wrapped fsolve command to work with units'</span>
    tU = t0 / <span style="color: #8b0000;">float</span>(t0)  <span style="color: #ff0000; font-weight: bold;"># units on initial guess, normalized</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(t):
        <span style="color: #228b22;">'t will be unitless, so we add unit to it. t * tU has units.'</span>
        <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(func(t * tU))

    sol, = _fsolve(wrapped_func, t0)
    <span style="color: #8b0000;">return</span> sol * tU
    
tguess = 4 * u.s

<span style="color: #8b0000;">print</span> fsolve(func, tguess)
</pre>
</div>

<pre class="example">
4.60517018599 s
</pre>

<p>
It is a little tedious to do this, but we might only have to do it once if we store the new fsolve command in a module. You might notice the wrapped function we wrote above only works for one dimensional problems. If there are multiple dimensions, we have to be a little more careful. In the next example, we expand the wrapped function definition to do both one and multidimensional problems. It appears we cannot use numpy.array element-wise multiplication because you cannot mix units in an array. We will use lists instead. When the problem is one-dimensional, the function will take a scalar, but when it is multidimensional it will take a list or array. We will use try/except blocks to handle these two cases. We will assume multidimensional cases, and if that raises an exception because the argument is not a list, we assume it is scalar. Here is the more robust code example. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve <span style="color: #8b0000;">as</span> _fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fsolve</span>(func, t0):
    <span style="color: #228b22;">'''wrapped fsolve command to work with units. We get the units on</span>
<span style="color: #228b22;">    the function argument, then wrap the function so we can add units</span>
<span style="color: #228b22;">    to the argument and return floats. Finally we call the original</span>
<span style="color: #228b22;">    fsolve from scipy. Note: this does not support all of the options</span>
<span style="color: #228b22;">    to fsolve.'''</span> 

    <span style="color: #8b0000;">try:</span>
        tU = [t / <span style="color: #8b0000;">float</span>(t) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> t0]  <span style="color: #ff0000; font-weight: bold;"># units on initial guess, normalized</span>
    <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
        tU = t0 / <span style="color: #8b0000;">float</span>(t0)
    
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(t):
        <span style="color: #228b22;">'t will be unitless, so we add unit to it. t * tU has units.'</span>    
        <span style="color: #8b0000;">try:</span>
            T = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(t, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            T = t * tU

        <span style="color: #8b0000;">try:</span>
            <span style="color: #8b0000;">return</span> [<span style="color: #8b0000;">float</span>(x) <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> func(T)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(func(T))

    sol = _fsolve(wrapped_func, t0)
    <span style="color: #8b0000;">try:</span>
        <span style="color: #8b0000;">return</span> [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(sol, tU)]
    <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
        <span style="color: #8b0000;">return</span> sol * tU

<span style="color: #ff0000; font-weight: bold;">### Problem 1</span>
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)


tguess = 4 * u.s
sol1, = fsolve(func, tguess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'sol1 = '</span>,sol1

<span style="color: #ff0000; font-weight: bold;">### Problem 2</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func2</span>(X):
    a,b = X
    <span style="color: #8b0000;">return</span> [a**2 - 4*u.kg**2,
            b**2 - 25*u.J**2]

Xguess = [2.2*u.kg, 5.2*u.J]
s2a, s2b = fsolve(func2, Xguess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'s2a = {0}\ns2b = {1}'</span>.format(s2a, s2b)
</pre>
</div>

<pre class="example">
sol1 =  4.60517018599 s
s2a = 2.0 kg
s2b = 5.0 J
</pre>

<p>
That is pretty good. There is still room for improvement in the wrapped function, as it does not support all of the options that scipy.optimize.fsolve supports. Here is a draft of a function that does that. We have to return different numbers of arguments depending on the value of full_output. This function works, but I have not fully tested all the options. Here are three examples that work, including one with an argument.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve <span style="color: #8b0000;">as</span> _fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fsolve</span>(func, t0, args=(), 
           fprime=<span style="color: #8b0000;">None</span>, full_output=0, col_deriv=0, 
           xtol=1.49012e-08, maxfev=0, band=<span style="color: #8b0000;">None</span>, 
           epsfcn=0.0, factor=100, diag=<span style="color: #8b0000;">None</span>):
    <span style="color: #228b22;">'''wrapped fsolve command to work with units. We get the units on</span>
<span style="color: #228b22;">    the function argument, then wrap the function so we can add units</span>
<span style="color: #228b22;">    to the argument and return floats. Finally we call the original</span>
<span style="color: #228b22;">    fsolve from scipy. '''</span> 

    <span style="color: #8b0000;">try:</span>
        tU = [t / <span style="color: #8b0000;">float</span>(t) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> t0]  <span style="color: #ff0000; font-weight: bold;"># units on initial guess, normalized</span>
    <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
        tU = t0 / <span style="color: #8b0000;">float</span>(t0)
    
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(t, *args):
        <span style="color: #228b22;">'t will be unitless, so we add unit to it. t * tU has units.'</span>    
        <span style="color: #8b0000;">try:</span>
            T = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(t, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            T = t * tU

        <span style="color: #8b0000;">try:</span>
            <span style="color: #8b0000;">return</span> [<span style="color: #8b0000;">float</span>(x) <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> func(T, *args)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(func(T))

    sol = _fsolve(wrapped_func, t0, args, 
           fprime, full_output, col_deriv, 
           xtol, maxfev, band, 
           epsfcn, factor, diag)

    <span style="color: #8b0000;">if</span> full_output:
        x, infodict, ier, mesg = sol
        <span style="color: #8b0000;">try:</span>
            x = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(x, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            x = x * tU
        <span style="color: #8b0000;">return</span> x, infodict, ier, mesg
    <span style="color: #8b0000;">else:</span>
        <span style="color: #8b0000;">try:</span>
            x = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(sol, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            x = sol * tU
        <span style="color: #8b0000;">return</span> x

<span style="color: #ff0000; font-weight: bold;">### Problem 1</span>
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)


tguess = 4 * u.s
sol1, = fsolve(func, tguess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'sol1 = '</span>,sol1

<span style="color: #ff0000; font-weight: bold;">### Problem 2</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func2</span>(X):
    a,b = X
    <span style="color: #8b0000;">return</span> [a**2 - 4*u.kg**2,
            b**2 - 25*u.J**2]

Xguess = [2.2*u.kg, 5.2*u.J]
sol, infodict, ier, mesg = fsolve(func2, Xguess, full_output=1)
s2a, s2b = sol
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'s2a = {0}\ns2b = {1}'</span>.format(s2a, s2b)

<span style="color: #ff0000; font-weight: bold;">### Problem 3 - with an arg</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func3</span>(a, arg):
    <span style="color: #8b0000;">return</span> a**2 - 4*u.kg**2 + arg**2

Xguess = 1.5 * u.kg
arg = 0.0* u.kg

sol3, = fsolve(func3, Xguess, args=(arg,))
print<span style="color: #228b22;">'sol3 = '</span>, sol3
</pre>
</div>

<pre class="example">
sol1 =  4.60517018599 s
s2a = 2.0 kg
s2b = 5.0 J
sol3 =  2.0 kg
</pre>

<p>
The only downside I can see in the quantities module is that it only handle temperature differences, and not absolute temperatures. If you only use absolute temperatures, this would not be a problem I think. But, if you have mixed temperature scales, the quantities module does not convert them on an absolute scale.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

T = 20 * u.degC

<span style="color: #8b0000;">print</span> T.rescale(u.K)
<span style="color: #8b0000;">print</span> T.rescale(u.degF)
</pre>
</div>

<pre class="example">
20.0 K
36.0 degF
</pre>

<p>
Nevertheless, this module seems pretty promising, and there are a lot more features than shown here. Some documentation can be found at <a href="http://pythonhosted.org/quantities/" >http://pythonhosted.org/quantities/</a>.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/22/Handling-units-with-the-quantities-module.org">org-mode source</a><p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using units in python]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/01/19/Using-units-in-python" />
    <id>http://jkitchin.github.io/blog/2013/01/19/Using-units-in-python</id>
    <updated>2013-03-23T09:45:20Z</updated>
    <published>2013-01-19T09:00:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="units" />
    <summary type="html"><![CDATA[Using units in python]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/01/19/Using-units-in-python"><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/05/using-cmu-units-in-matlab-for-basic-calculations/" >Units in Matlab</a>
</p>

<p>
I think an essential feature in an engineering computational environment is properly handling units and unit conversions. Mathcad supports that pretty well. I wrote a <a href="https://github.com/jkitchin/matlab-cmu" >package</a> for doing it in Matlab. Today I am going to explore units in python. Here are some of the packages that I have found which support units to some extent
</p>

<ol>
<li><a href="http://pypi.python.org/pypi/units/" >http://pypi.python.org/pypi/units/</a>
</li>
<li><a href="http://packages.python.org/quantities/user/tutorial.html" >http://packages.python.org/quantities/user/tutorial.html</a>
</li>
<li><a href="http://dirac.cnrs-orleans.fr/ScientificPython/ScientificPythonManual/Scientific.Physics.PhysicalQuantities-module.html" >http://dirac.cnrs-orleans.fr/ScientificPython/ScientificPythonManual/Scientific.Physics.PhysicalQuantities-module.html</a>
</li>
<li><a href="http://home.scarlet.be/be052320/Unum.html" >http://home.scarlet.be/be052320/Unum.html</a>
</li>
<li><a href="https://simtk.org/home/python_units" >https://simtk.org/home/python_units</a>
</li>
<li><a href="http://docs.enthought.com/scimath/units/intro.html" >http://docs.enthought.com/scimath/units/intro.html</a>
</li>
</ol>

<p>
The last one looks most promising.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scimath.units.volume <span style="color: #8b0000;">import</span> liter
<span style="color: #8b0000;">from</span> scimath.units.substance <span style="color: #8b0000;">import</span> mol

q = np.array([1, 2, 3]) * mol
<span style="color: #8b0000;">print</span> q

P = q / liter
<span style="color: #8b0000;">print</span> P
</pre>
</div>

<pre class="example">
[1.0*mol 2.0*mol 3.0*mol]
[1000.0*m**-3*mol 2000.0*m**-3*mol 3000.0*m**-3*mol]
</pre>

<p>
That doesn't look too bad. It is a little clunky to have to import every unit, and it is clear the package is saving everything in SI units by default. Let us try to solve an equation.
</p>

<p>
Find the time that solves this equation. 
</p>

<p>
\(0.01 = C_{A0} e^{-kt}\)
</p>

<p>
First we solve without units. That way we know the answer.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

CA0 = 1.0  <span style="color: #ff0000; font-weight: bold;"># mol/L</span>
CA = 0.01  <span style="color: #ff0000; font-weight: bold;"># mol/L</span>
k = 1.0    <span style="color: #ff0000; font-weight: bold;"># 1/s</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    z = CA - CA0 * np.exp(-k*t)
    <span style="color: #8b0000;">return</span> z

t0 = 2.3

t, = fsolve(func, t0)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'t = {0:1.2f} seconds'</span>.format(t)
</pre>
</div>

<pre class="example">
t = 4.61 seconds
</pre>


<p>
Now, with units. I note here that I tried the obvious thing of just importing the units, and adding them on, but the package is unable to work with floats that have units. For some functions, there must be an ndarray with units which is practically what the UnitScalar code below does. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
<span style="color: #8b0000;">from</span> scimath.units.volume <span style="color: #8b0000;">import</span> liter
<span style="color: #8b0000;">from</span> scimath.units.substance <span style="color: #8b0000;">import</span> mol
<span style="color: #8b0000;">from</span> scimath.units.time <span style="color: #8b0000;">import</span> second
<span style="color: #8b0000;">from</span> scimath.units.api <span style="color: #8b0000;">import</span> has_units, UnitScalar

CA0 = UnitScalar(1.0, units = mol / liter)
CA = UnitScalar(0.01, units = mol / liter)
k = UnitScalar(1.0, units = 1 / second)

<span style="color: #8b0000;">@has_units</span>(inputs=<span style="color: #228b22;">"t::units=s"</span>,
           outputs=<span style="color: #228b22;">"result::units=mol/liter"</span>)
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    z = CA - CA0 * <span style="color: #8b0000;">float</span>(np.exp(-k*t))
    <span style="color: #8b0000;">return</span> z

t0 = UnitScalar(2.3, units = second)

t, = fsolve(func, t0)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'t = {0:1.2f} seconds'</span>.format(t)
<span style="color: #8b0000;">print</span> type(t)
</pre>
</div>

<pre class="example">
t = 4.61 seconds
&lt;type 'numpy.float64'&gt;
</pre>

<p>
This is some heavy syntax that in the end does not preserve the units. In my Matlab package, we had to &ldquo;wrap&rdquo; many functions like fsolve so they would preserve units. Clearly this package will need that as well. Overall, in its current implementation this package does not do what I would expect all the time.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/01/19/Using-units-in-python.org">org-mode source</a><p>]]></content>
  </entry>
</feed>
