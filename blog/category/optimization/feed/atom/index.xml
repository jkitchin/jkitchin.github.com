<?xml version="1.0" encoding="UTF-8"?>

<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
  >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2017-06-11T02:38:43Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding the maximum power of a photovoltaic device.]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device" />
    <id>http://jkitchin.github.io/blog/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device</id>
    <updated>2016-04-04T11:54:50Z</updated>
    <published>2014-04-15T20:38:10Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <summary type="html"><![CDATA[Finding the maximum power of a photovoltaic device.]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device"><![CDATA[



&lt;p&gt;
A photovoltaic device is characterized by a current-voltage relationship. Let us say, for argument's sake, that the relationship is known and defined by
&lt;/p&gt;

&lt;p&gt;
\(i = 0.5 - 0.5 * V^2\)
&lt;/p&gt;

&lt;p&gt;
The voltage is highest when the current is equal to zero, but of course then you get no power. The current is highest when the voltage is zero, i.e. short-circuited, but there is again no power. We seek the highest power condition, which is to find the maximum of \(i V\). This is a constrained optimization. We solve it by creating an objective function that returns the negative of (\i V\), and then find the minimum.
&lt;/p&gt;

&lt;p&gt;
First, let us examine the i-V relationship.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = np.linspace(0, 1)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;i&lt;/span&gt;(V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0.5 - 0.5 * V**2

plt.figure()
plt.plot(V, i(V))
plt.savefig(&lt;span style="color: #008000;"&gt;'images/iV.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;matplotlib.figure.Figure object at 0x11193ec18&amp;gt;
[&amp;lt;matplotlib.lines.Line2D object at 0x111d43668&amp;gt;]
&lt;/pre&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2014-04-15-Finding-the-maximum-power-of-a-photovoltaic-device./iV.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
Now, let us be sure there is a maximum in power.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = np.linspace(0, 1)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;i&lt;/span&gt;(V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0.5 - 0.5 * V**2

plt.plot(V, i(V) * V)
plt.savefig(&lt;span style="color: #008000;"&gt;'images/P1.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[&amp;lt;matplotlib.lines.Line2D object at 0x111d437f0&amp;gt;]
&lt;/pre&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2014-04-15-Finding-the-maximum-power-of-a-photovoltaic-device./P1.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
You can see in fact there is a maximum, near V=0.6. We could solve this problem analytically by taking the appropriate derivative and solving it for zero. That still might require solving a nonlinear problem though. We will directly setup and solve the constrained optimization.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fmin_slsqp
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(X):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = X
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; - i * V

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;eqc&lt;/span&gt;(X):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;'equality constraint'&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = X
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; (0.5 - 0.5 * V**2) - i

&lt;span style="color: #BA36A5;"&gt;X0&lt;/span&gt; = [0.2, 0.6]
&lt;span style="color: #BA36A5;"&gt;X&lt;/span&gt; = fmin_slsqp(objective, X0, eqcons=[eqc])

&lt;span style="color: #BA36A5;"&gt;imax&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Vmax&lt;/span&gt; = X


&lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = np.linspace(0, 1)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;i&lt;/span&gt;(V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0.5 - 0.5 * V**2

plt.plot(V, i(V), Vmax, imax, &lt;span style="color: #008000;"&gt;'ro'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #008000;"&gt;'images/P2.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Optimization terminated successfully.    (Exit mode 0)
            Current function value: -0.192450127337
            Iterations: 5
            Function evaluations: 20
            Gradient evaluations: 5
[&amp;lt;matplotlib.lines.Line2D object at 0x111946470&amp;gt;, &amp;lt;matplotlib.lines.Line2D object at 0x11192c518&amp;gt;]
&lt;/pre&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2014-04-15-Finding-the-maximum-power-of-a-photovoltaic-device./P2.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
You can see the maximum power is approximately 0.2 (unspecified units), at the conditions indicated by the red dot in the figure above.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device..org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Constrained fits to data]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/06/11/Constrained-fits-to-data" />
    <id>http://jkitchin.github.io/blog/2013/06/11/Constrained-fits-to-data</id>
    <updated>2013-06-12T08:31:16Z</updated>
    <published>2013-06-11T19:39:59Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <category scheme="http://jkitchin.github.io/blog" term="data analysis" />
    <summary type="html"><![CDATA[Constrained fits to data]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/06/11/Constrained-fits-to-data"><![CDATA[


&lt;p&gt;
Our objective here is to fit a quadratic function in the least squares sense to some data, but we want to constrain the fit so that the function has specific values at the end-points. The application is to fit a function to the lattice constant of an alloy at different compositions. We constrain the fit because we know the lattice constant of the pure metals, which are at the end-points of the fit and we want these to be correct. 
&lt;/p&gt;

&lt;p&gt;
We define the alloy composition in terms of the mole fraction of one species, e.g. \(A_xB_{1-x}\). For \(x=0\), the alloy is pure B, whereas for \(x=1\) the alloy is pure A. According to Vegard's law the lattice constant is a linear composition weighted average of the pure component lattice constants, but sometimes small deviations are observed. Here we will fit a quadratic function that is constrained to give the pure metal component lattice constants at the end points. 
&lt;/p&gt;

&lt;p&gt;
The quadratic function is \(y = a x^2 + b x + c\). One constraint is at \(x=0\) where \(y = c\), or \(c\) is the lattice constant of pure B. The second constraint is at \(x=1\), where \(a + b + c\) is equal to the lattice constant of pure A. Thus, there is only one degree of freedom. \(c = LC_B\), and \(b = LC_A - c - a\), so \(a\) is our only variable.
&lt;/p&gt;

&lt;p&gt;
We will solve this problem by minimizing the summed squared error between the fit and the data. We use the &lt;code&gt;fmin&lt;/code&gt; function in &lt;code&gt;scipy.optimize&lt;/code&gt;. First we create a fit function that encodes the constraints. Then we create an objective function that will be minimized. We have to make a guess about the value of \(a\) that minimizes the summed squared error. A line fits the data moderately well, so we guess a small value, i.e. near zero, for \(a\). Here is the solution.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Data to fit to&lt;/span&gt;
&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;x=0 is pure B&lt;/span&gt;
&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;x=1 is pure A&lt;/span&gt;
X = np.array([0.0, 0.1,  0.25, 0.5,  0.6,  0.8,  1.0])
Y = np.array([3.9, 3.89, 3.87, 3.78, 3.75, 3.69, 3.6])

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;func&lt;/span&gt;(a, XX):
    LC_A = 3.6
    LC_B = 3.9

    c = LC_B
    b = LC_A - c - a

    yfit = a * XX**2 + b * XX + c
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; yfit

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;objective&lt;/span&gt;(a):
    &lt;span style="color: #228b22;"&gt;'function to minimize'&lt;/span&gt;
    SSE = np.sum((Y - func(a, X))**2)
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; SSE


&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin

a_fit = fmin(objective, 0)
plt.plot(X, Y, &lt;span style="color: #228b22;"&gt;'bo '&lt;/span&gt;)

x = np.linspace(0, 1)
plt.plot(x, func(a_fit, x))
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/constrained-quadratic-fit.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Optimization terminated successfully.
         Current function value: 0.000445
         Iterations: 19
         Function evaluations: 38
&lt;/pre&gt;

&lt;p&gt;
Here is the result:
&lt;p&gt;&lt;img src="/img/./images/constrained-quadratic-fit.png"&gt;&lt;p&gt;
&lt;/p&gt;

&lt;p&gt;
You can see that the end points go through the end-points as prescribed. 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/06/11/Constrained-fits-to-data.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Gibbs energy minimization and the NIST webbook]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook" />
    <id>http://jkitchin.github.io/blog/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook</id>
    <updated>2013-03-06T16:31:14Z</updated>
    <published>2013-03-01T13:11:58Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Gibbs energy minimization and the NIST webbook]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/12/25/gibbs-energy-minimization-and-the-nist-webbook/" &gt;Matlab post&lt;/a&gt;
In Post 1536 we used the NIST webbook to compute a temperature dependent Gibbs energy of reaction, and then used a reaction extent variable to compute the equilibrium concentrations of each species for the water gas shift reaction.
&lt;/p&gt;

&lt;p&gt;
Today, we look at the direct minimization of the Gibbs free energy of the species, with no assumptions about stoichiometry of reactions. We only apply the constraint of conservation of atoms. We use the NIST Webbook to provide the data for the Gibbs energy of each species.
&lt;/p&gt;

&lt;p&gt;
As a reminder we consider equilibrium between the species \(CO\), \(H_2O\), \(CO_2\) and \(H_2\), at 1000K, and 10 atm total pressure with an initial equimolar molar flow rate of \(CO\) and \(H_2O\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

T = 1000  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# K&lt;/span&gt;
R = 8.314e-3 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# kJ/mol/K&lt;/span&gt;

P = 10.0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# atm, this is the total pressure in the reactor&lt;/span&gt;
Po = 1.0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# atm, this is the standard state pressure&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We are going to store all the data and calculations in vectors, so we need to assign each position in the vector to a species. Here are the definitions we use in this work.
&lt;/p&gt;

&lt;pre class="example"&gt;
1  CO
2  H2O
3  CO2
4  H2
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;species = [&lt;span style="color: #228b22;"&gt;'CO'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'H2O'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'CO2'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'H2'&lt;/span&gt;]

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# Heats of formation at 298.15 K&lt;/span&gt;

Hf298 = [
    -110.53,  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# CO&lt;/span&gt;
    -241.826, &lt;span style="color: #ff0000; font-weight: bold;"&gt;# H2O&lt;/span&gt;
    -393.51,  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# CO2&lt;/span&gt;
       0.0]   &lt;span style="color: #ff0000; font-weight: bold;"&gt;# H2&lt;/span&gt;

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# Shomate parameters for each species&lt;/span&gt;
&lt;span style="color: #ff0000; font-weight: bold;"&gt;#           A          B           C          D          E            F          G       H&lt;/span&gt;
WB = [[25.56759,  6.096130,     4.054656,  -2.671301,  0.131021, -118.0089, 227.3665,   -110.5271],  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# CO&lt;/span&gt;
      [30.09200,  6.832514,     6.793435,  -2.534480,  0.082139, -250.8810, 223.3967,   -241.8264],  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# H2O&lt;/span&gt;
      [24.99735,  55.18696,   -33.69137,    7.948387, -0.136638, -403.6075, 228.2431,   -393.5224],  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# CO2&lt;/span&gt;
      [33.066178, -11.363417,  11.432816,  -2.772874, -0.158558, -9.980797, 172.707974,    0.0]]     &lt;span style="color: #ff0000; font-weight: bold;"&gt;# H2&lt;/span&gt;

WB = np.array(WB)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# Shomate equations&lt;/span&gt;
t = T/1000
T_H = np.array([t,  t**2 / 2.0, t**3 / 3.0, t**4 / 4.0, -1.0 / t, 1.0, 0.0, -1.0])
T_S = np.array([np.log(t), t,  t**2 / 2.0,  t**3 / 3.0, -1.0 / (2.0 * t**2), 0.0, 1.0, 0.0])

H = np.dot(WB, T_H)        &lt;span style="color: #ff0000; font-weight: bold;"&gt;# (H - H_298.15) kJ/mol&lt;/span&gt;
S = np.dot(WB, T_S/1000.0) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# absolute entropy kJ/mol/K&lt;/span&gt;

Gjo = Hf298 + H - T*S      &lt;span style="color: #ff0000; font-weight: bold;"&gt;# Gibbs energy of each component at 1000 K&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, construct the Gibbs free energy function, accounting for the change in activity due to concentration changes (ideal mixing).
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;func&lt;/span&gt;(nj):
    nj = np.array(nj)
    Enj = np.sum(nj);
    Gj =  Gjo / (R * T) + np.log(nj / Enj * P / Po)
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.dot(nj, Gj)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We impose the constraint that all atoms are conserved from the initial conditions to the equilibrium distribution of species. These constraints are in the form of \(A_{eq} n = b_{eq}\), where \(n\) is the vector of mole numbers for each species.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;Aeq = np.array([[ 1,    0,    1,    0],  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# C balance&lt;/span&gt;
                [ 1,    1,    2,    0],  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# O balance&lt;/span&gt;
                [ 0,    2,    0,    2]]) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# H balance&lt;/span&gt;

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# equimolar feed of 1 mol H2O and 1 mol CO&lt;/span&gt;
beq = np.array([1,  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# mol C fed&lt;/span&gt;
                2,  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# mol O fed&lt;/span&gt;
                2]) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# mol H fed&lt;/span&gt;

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ec1&lt;/span&gt;(nj):
    &lt;span style="color: #228b22;"&gt;'conservation of atoms constraint'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.dot(Aeq, nj) - beq
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we are ready to solve the problem. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin_slsqp

n0 = [0.5, 0.5, 0.5, 0.5]  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# initial guesses&lt;/span&gt;
N = fmin_slsqp(func, n0, f_eqcons=ec1)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; N
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; Optimization terminated successfully.    (Exit mode 0)
            Current function value: -91.204832308
            Iterations: 2
            Function evaluations: 13
            Gradient evaluations: 2
[ 0.45502309  0.45502309  0.54497691  0.54497691]
&lt;/pre&gt;

&lt;div id="outline-container-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Compute mole fractions and partial pressures&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
The pressures here are in good agreement with the pressures found by other methods. The minor disagreement (in the third or fourth decimal place) is likely due to convergence tolerances in the different algorithms used.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;yj = N / np.sum(N)
Pj = yj * P

&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; s, y, p &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;zip&lt;/span&gt;(species, yj, Pj):
    &lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'{0:10s}: {1:1.2f} {2:1.2f}'&lt;/span&gt;.format(s, y, p)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... ... CO        : 0.23 2.28
H2O       : 0.23 2.28
CO2       : 0.27 2.72
H2        : 0.27 2.72
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Computing equilibrium constants&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
We can compute the equilibrium constant for the reaction \(CO + H_2O \rightleftharpoons CO_2 + H_2\). Compared to the value of K = 1.44 we found at the end of Post 1536 , the agreement is excellent. Note, that to define an equilibrium constant it is necessary to specify a reaction, even though it is not necessary to even consider a reaction to obtain the equilibrium distribution of species!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;nuj = np.array([-1, -1, 1, 1])  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# stoichiometric coefficients of the reaction&lt;/span&gt;
K = np.prod(yj**nuj)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; K
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; 1.43446295961
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding equilibrium composition by direct minimization of Gibbs free energy on mole numbers]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers" />
    <id>http://jkitchin.github.io/blog/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers</id>
    <updated>2014-09-10T13:15:30Z</updated>
    <published>2013-03-01T12:27:48Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Finding equilibrium composition by direct minimization of Gibbs free energy on mole numbers]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-1"&gt;1. The Gibbs energy of a mixture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-2"&gt;2. Linear equality constraints for atomic mass conservation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-3"&gt;3. Equilibrium constant based on mole numbers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-4"&gt;4. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/12/25/finding-equilibrium-composition-by-direct-minimization-of-gibbs-free-energy-on-mole-numbers/"&gt;Matlab post&lt;/a&gt; 
Adapted from problem 4.5 in Cutlip and Shacham
Ethane and steam are fed to a steam cracker at a total pressure of 1 atm and at 1000K at a ratio of 4 mol H2O to 1 mol ethane. Estimate the equilibrium distribution of products (CH4, C2H4, C2H2, CO2, CO, O2, H2, H2O, and C2H6).
&lt;/p&gt;

&lt;p&gt;
Solution method: We will construct a Gibbs energy function for the mixture, and obtain the equilibrium composition by minimization of the function subject to elemental mass balance constraints.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;R&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;00198588&lt;/span&gt; &lt;span style="color: #ff0000; font-weight: bold;"&gt;# kcal/mol/K&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;T&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1000&lt;/span&gt; &lt;span style="color: #ff0000; font-weight: bold;"&gt;# K&lt;/span&gt;

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;species&lt;/span&gt; = [&lt;span style="color: #228b22;"&gt;'CH4'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'C2H4'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'C2H2'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'CO2'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'CO'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'O2'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'H2'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'H2O'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'C2H6'&lt;/span&gt;]

# &lt;span style="color: #ff0000; font-weight: bold;"&gt;$G_^\circ for each species. These are the heats of formation for each&lt;/span&gt;
# &lt;span style="color: #ff0000; font-weight: bold;"&gt;species.&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;Gjo&lt;/span&gt; = np.array([&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;61&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;28&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;249&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;40&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;604&lt;/span&gt;, -&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;94&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;61&lt;/span&gt;, -&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;47&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;942&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;, -&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;46&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;03&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;26&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;13&lt;/span&gt;]) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# kcal/mol&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; The Gibbs energy of a mixture&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
We start with \(G=\sum\limits_j n_j \mu_j\). Recalling that we define \(\mu_j = G_j^\circ + RT \ln a_j\), and in the ideal gas limit, \(a_j = y_j P/P^\circ\), and that \(y_j = \frac{n_j}{\sum n_j}\). Since in this problem, P = 1 atm, this leads to the function \(\frac{G}{RT} = \sum\limits_{j=1}^n n_j\left(\frac{G_j^\circ}{RT} + \ln \frac{n_j}{\sum n_j}\right)\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;func&lt;/span&gt;(nj):
    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;nj&lt;/span&gt; = np.array(nj)
    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;Enj&lt;/span&gt; = np.sum(nj);
    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;G&lt;/span&gt; = np.sum(nj * (Gjo / R / T + np.log(nj / Enj)))
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; G
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Linear equality constraints for atomic mass conservation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The total number of each type of atom must be the same as what entered the reactor. These form equality constraints on the equilibrium composition. We express these constraints as: \(A_{eq} n = b\) where \(n\) is a vector of the moles of each species present in the mixture. CH4 C2H4 C2H2 CO2 CO O2 H2 H2O C2H6
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;Aeq&lt;/span&gt; = np.array([[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;],      &lt;span style="color: #ff0000; font-weight: bold;"&gt;# oxygen balance&lt;/span&gt;
                [&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;,    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;6&lt;/span&gt;],      &lt;span style="color: #ff0000; font-weight: bold;"&gt;# hydrogen balance&lt;/span&gt;
                [&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,  &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;,   &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;]])     &lt;span style="color: #ff0000; font-weight: bold;"&gt;# carbon balance&lt;/span&gt;

# &lt;span style="color: #ff0000; font-weight: bold;"&gt;the incoming feed was 4 mol H2O and 1 mol ethane&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;beq&lt;/span&gt; = np.array([&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;,  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# moles of oxygen atoms coming in&lt;/span&gt;
                &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;14&lt;/span&gt;, &lt;span style="color: #ff0000; font-weight: bold;"&gt;# moles of hydrogen atoms coming in&lt;/span&gt;
                &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;]) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# moles of carbon atoms coming in&lt;/span&gt;

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ec1&lt;/span&gt;(n):
    &lt;span style="color: #228b22;"&gt;'equality constraint'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.dot(Aeq, n) - beq

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ic1&lt;/span&gt;(n):
    &lt;span style="color: #228b22;"&gt;'''inequality constraint&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;       all n&amp;gt;=0&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;    '''&lt;/span&gt;   
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; n
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we solve the problem.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;# &lt;span style="color: #ff0000; font-weight: bold;"&gt;initial guess suggested in the example&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;n0&lt;/span&gt; = [1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;3&lt;/span&gt;, 1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;3&lt;/span&gt;, 1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;3&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;993&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;, 1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;5&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;992&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;, 1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;3&lt;/span&gt;] 

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;n0&lt;/span&gt; = [&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;066&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;8&lt;/span&gt;.7e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;08&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;.1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;14&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;545&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;39&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;5&lt;/span&gt;.7e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;14&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;5&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;346&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;521&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.58e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;7&lt;/span&gt;]

&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin_slsqp

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;X&lt;/span&gt; = fmin_slsqp(func, n0, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;f_eqcons&lt;/span&gt;=ec1,&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;f_ieqcons&lt;/span&gt;=ic1,&lt;span style="color: #cd0000;"&gt; iter&lt;/span&gt;=&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;300&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;acc&lt;/span&gt;=1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;12&lt;/span&gt;)

&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; s,x &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt;&lt;span style="color: #cd0000;"&gt; zip&lt;/span&gt;(species, X):
    &lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'{0:10s} {1:1.4g}'&lt;/span&gt;.format(s, x)

# &lt;span style="color: #ff0000; font-weight: bold;"&gt;check that constraints were met&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; np.dot(Aeq, X) - beq
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; np.all( np.abs( np.dot(Aeq, X) - beq) &amp;lt; 1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;12&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; Optimization terminated successfully.    (Exit mode 0)
            Current function value: -104.403951524
            Iterations: 16
            Function evaluations: 193
            Gradient evaluations: 15
&amp;gt;&amp;gt;&amp;gt; ... ... CH4        0.06644
C2H4       9.48e-08
C2H2       1.487e-13
CO2        0.545
CO         1.389
O2         3.096e-13
H2         5.346
H2O        1.521
C2H6       1.581e-07
... [  0.00000000e+00   0.00000000e+00   4.44089210e-16]
True
&lt;/pre&gt;

&lt;p&gt;
I found it necessary to tighten the accuracy parameter to get pretty good matches to the solutions found in Matlab. It was also necessary to increase the number of iterations. Even still, not all of the numbers match well, especially the very small numbers. You can, however, see that the constraints were satisfied pretty well.
&lt;/p&gt;


&lt;p&gt;
Interestingly there is a distribution of products! That is interesting because only steam and ethane enter the reactor, but a small fraction of methane is formed! The main product is hydrogen. The stoichiometry of steam reforming is ideally \(C_2H_6 + 4H_2O \rightarrow 2CO_2 + 7 H2\). Even though nearly all the ethane is consumed, we do not get the full yield of hydrogen. It appears that another equilibrium, one between CO, CO2, H2O and H2, may be limiting that, since the rest of the hydrogen is largely in the water. It is also of great importance that we have not said anything about reactions, i.e. how these products were formed. 
&lt;/p&gt;

&lt;p&gt;
The water gas shift reaction is: \(CO + H_2O \rightleftharpoons CO_2 + H_2\). We can compute the Gibbs free energy of the reaction from the heats of formation of each species. Assuming these are the formation energies at 1000K, this is the reaction free energy at 1000K.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;G_wgs&lt;/span&gt; = Gjo[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;3&lt;/span&gt;] + Gjo[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;6&lt;/span&gt;] - Gjo[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;] - Gjo[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;7&lt;/span&gt;]
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; G_wgs

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;K&lt;/span&gt; = np.exp(-G_wgs / (R*T))
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; K
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
-0.638
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; 1.37887528109
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Equilibrium constant based on mole numbers&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
One normally uses activities to define the equilibrium constant. Since there are the same number of moles on each side of the reaction all factors that convert mole numbers to activity, concentration or pressure cancel, so we simply consider the ratio of mole numbers here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; (X[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;3&lt;/span&gt;] * X[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;6&lt;/span&gt;]) / (X[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;] * X[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;7&lt;/span&gt;])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1.37887525547
&lt;/pre&gt;

&lt;p&gt;
This is very close to the equilibrium constant computed above. 
&lt;/p&gt;

&lt;p&gt;
Clearly, there is an equilibrium between these species that prevents the complete reaction of steam reforming.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
This is an appealing way to minimize the Gibbs energy of a mixture. No assumptions about reactions are necessary, and the constraints are easy to identify. The Gibbs energy function is especially easy to code.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.7c&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Constrained optimization]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Constrained-optimization" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Constrained-optimization</id>
    <updated>2013-02-27T14:43:37Z</updated>
    <published>2013-02-27T14:43:37Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Constrained optimization]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Constrained-optimization"><![CDATA[


&lt;p&gt;


&lt;a href="http://matlab.cheme.cmu.edu/2011/12/24/constrained-optimization/" &gt;Matlab post&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
adapted from &lt;a href="http://en.wikipedia.org/wiki/Lagrange_multipliers" &gt;http://en.wikipedia.org/wiki/Lagrange_multipliers&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Suppose we seek to minimize the function \(f(x,y)=x+y\) subject to the constraint that \(x^2 + y^2 = 1\). The function we seek to maximize is an unbounded plane, while the constraint is a unit circle. We could setup a Lagrange multiplier approach to solving this problem, but we will use a constrained optimization approach instead.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin_slsqp

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;objective&lt;/span&gt;(X):
    x, y = X
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; x + y

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;eqc&lt;/span&gt;(X):
    &lt;span style="color: #228b22;"&gt;'equality constraint'&lt;/span&gt;
    x, y = X
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; x**2 + y**2 - 1.0

X0 = [-1, -1]
X = fmin_slsqp(objective, X0, eqcons=[eqc])
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; X
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Optimization terminated successfully.    (Exit mode 0)
            Current function value: -1.41421356237
            Iterations: 5
            Function evaluations: 20
            Gradient evaluations: 5
[-0.70710678 -0.70710678]
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Constrained-optimization.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[The Gibbs free energy of a reacting mixture and the equilibrium composition]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition" />
    <id>http://jkitchin.github.io/blog/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition</id>
    <updated>2014-09-10T12:21:56Z</updated>
    <published>2013-02-18T09:00:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[The Gibbs free energy of a reacting mixture and the equilibrium composition]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-1"&gt;1. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/12/20/the-gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition/"&gt;Matlab post&lt;/a&gt; 
&lt;/p&gt;

&lt;p&gt;
In this post we derive the equations needed to find the equilibrium composition of a reacting mixture. We use the method of direct minimization of the Gibbs free energy of the reacting mixture.
&lt;/p&gt;

&lt;p&gt;
The Gibbs free energy of a mixture is defined as \(G = \sum\limits_j \mu_j n_j\) where \(\mu_j\) is the chemical potential of species \(j\), and it is temperature and pressure dependent, and \(n_j\) is the number of moles of species \(j\).
&lt;/p&gt;

&lt;p&gt;
We define the chemical potential as \(\mu_j = G_j^\circ + RT\ln a_j\), where \(G_j^\circ\) is the Gibbs energy in a standard state, and \(a_j\) is the activity of species \(j\) if the pressure and temperature are not at standard state conditions.
&lt;/p&gt;

&lt;p&gt;
If a reaction is occurring, then the number of moles of each species are related to each other through the reaction extent \(\epsilon\) and stoichiometric coefficients: \(n_j = n_{j0} + \nu_j \epsilon\). Note that the reaction extent has units of moles.
&lt;/p&gt;

&lt;p&gt;
Combining these three equations and expanding the terms leads to:
&lt;/p&gt;

&lt;p&gt;
$$G = \sum\limits_j n_{j0}G_j^\circ +\sum\limits_j \nu_j G_j^\circ \epsilon +RT\sum\limits_j(n_{j0} + \nu_j\epsilon)\ln a_j $$
&lt;/p&gt;

&lt;p&gt;
The first term is simply the initial Gibbs free energy that is present before any reaction begins, and it is a constant. It is difficult to evaluate, so we will move it to the left side of the equation in the next step, because it does not matter what its value is since it is a constant. The second term is related to the Gibbs free energy of reaction: \(\Delta_rG = \sum\limits_j \nu_j G_j^\circ\). With these observations we rewrite the equation as:
&lt;/p&gt;

&lt;p&gt;
$$G - \sum\limits_j n_{j0}G_j^\circ = \Delta_rG \epsilon +RT\sum\limits_j(n_{j0} + \nu_j\epsilon)\ln a_j $$
&lt;/p&gt;

&lt;p&gt;
Now, we have an equation that allows us to compute the change in Gibbs free energy as a function of the reaction extent, initial number of moles of each species, and the activities of each species. This difference in Gibbs free energy has no natural scale, and depends on the size of the system, i.e. on \(n_{j0}\). It is desirable to avoid this, so we now rescale the equation by the total initial moles present, \(n_{T0}\) and define a new variable \(\epsilon' = \epsilon/n_{T0}\), which is dimensionless. This leads to:
&lt;/p&gt;

&lt;p&gt;
$$ \frac{G - \sum\limits_j n_{j0}G_j^\circ}{n_{T0}} = \Delta_rG \epsilon' + RT \sum\limits_j(y_{j0} + \nu_j\epsilon')\ln a_j $$
&lt;/p&gt;

&lt;p&gt;
where \(y_{j0}\) is the initial mole fraction of species \(j\) present. The mole fractions are intensive properties that do not depend on the system size. Finally, we need to address \(a_j\). For an ideal gas, we know that \(A_j = \frac{y_j P}{P^\circ}\), where the numerator is the partial pressure of species \(j\) computed from the mole fraction of species \(j\) times the total pressure. To get the mole fraction we note:
&lt;/p&gt;

&lt;p&gt;
$$y_j = \frac{n_j}{n_T} = \frac{n_{j0} + \nu_j \epsilon}{n_{T0} + \epsilon \sum\limits_j \nu_j} = \frac{y_{j0} + \nu_j \epsilon'}{1 + \epsilon'\sum\limits_j \nu_j} $$
&lt;/p&gt;

&lt;p&gt;
This finally leads us to an equation that we can evaluate as a function of reaction extent:
&lt;/p&gt;

&lt;p&gt;
$$ \frac{G - \sum\limits_j n_{j0}G_j^\circ}{n_{T0}} = \widetilde{\widetilde{G}} = \Delta_rG \epsilon' + RT\sum\limits_j(y_{j0} + \nu_j\epsilon') \ln\left(\frac{y_{j0}+\nu_j\epsilon'}{1+\epsilon'\sum\limits_j\nu_j} \frac{P}{P^\circ}\right) $$
&lt;/p&gt;

&lt;p&gt;
we use a double tilde notation to distinguish this quantity from the quantity derived by Rawlings and Ekerdt which is further normalized by a factor of \(RT\). This additional scaling makes the quantities dimensionless, and makes the quantity have a magnitude of order unity, but otherwise has no effect on the shape of the graph.
&lt;/p&gt;

&lt;p&gt;
Finally, if we know the initial mole fractions, the initial total pressure, the Gibbs energy of reaction, and the stoichiometric coefficients, we can plot the scaled reacting mixture energy as a function of reaction extent. At equilibrium, this energy will be a minimum. We consider the example in Rawlings and Ekerdt where isobutane (I) reacts with 1-butene (B) to form 2,2,3-trimethylpentane (P). The reaction occurs at a total pressure of 2.5 atm at 400K, with equal molar amounts of I and B. The standard Gibbs free energy of reaction at 400K is -3.72 kcal/mol. Compute the equilibrium composition.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;R&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;8&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;314&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;P&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;250000&lt;/span&gt;  # &lt;span style="color: #ff0000; font-weight: bold;"&gt;Pa&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;P0&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;100000&lt;/span&gt; # &lt;span style="color: #ff0000; font-weight: bold;"&gt;Pa, approximately 1 atm&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;T&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;400&lt;/span&gt; # &lt;span style="color: #ff0000; font-weight: bold;"&gt;K&lt;/span&gt;

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;Grxn&lt;/span&gt; = -&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;15564&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt; #&lt;span style="color: #ff0000; font-weight: bold;"&gt;J/mol&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yi0&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;5&lt;/span&gt;; &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yb0&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;5&lt;/span&gt;; &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yp0&lt;/span&gt; = &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;; # &lt;span style="color: #ff0000; font-weight: bold;"&gt;initial mole fractions&lt;/span&gt;

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yj0&lt;/span&gt; = np.array([yi0, yb0, yp0])
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;nu_j&lt;/span&gt; = np.array([-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;, -&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;])   # &lt;span style="color: #ff0000; font-weight: bold;"&gt;stoichiometric coefficients&lt;/span&gt;

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;Gwigglewiggle&lt;/span&gt;(extentp):
    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;diffg&lt;/span&gt; = Grxn * extentp
    &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;sum_nu_j&lt;/span&gt; = np.sum(nu_j)
    &lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; i,y &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt;&lt;span style="color: #cd0000;"&gt; enumerate&lt;/span&gt;(yj0):
        &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;x1&lt;/span&gt; = yj0[i] + nu_j[i] * extentp
        &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;x2&lt;/span&gt; = x1 / (&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt; + extentp*sum_nu_j)
        &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;diffg&lt;/span&gt; += R * T * x1 * np.log(x2 * P / P0)
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; diffg
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
There are bounds on how large \(\epsilon'\) can be. Recall that \(n_j = n_{j0} + \nu_j \epsilon\), and that \(n_j \ge 0\). Thus, \(\epsilon_{max} = -n_{j0}/\nu_j\), and the maximum value that \(\epsilon'\) can have is therefore \(-y_{j0}/\nu_j\) where \(y_{j0}&gt;0\). When there are multiple species, you need the smallest \(epsilon'_{max}\) to avoid getting negative mole numbers.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;epsilonp_max&lt;/span&gt; =&lt;span style="color: #cd0000;"&gt; min&lt;/span&gt;(-yj0[yj0 &amp;gt; &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;] / nu_j[yj0 &amp;gt; &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;])
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;epsilonp&lt;/span&gt; = np.linspace(1e-&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;6&lt;/span&gt;, epsilonp_max, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1000&lt;/span&gt;);

&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

plt.plot(epsilonp,Gwigglewiggle(epsilonp))
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$\epsilon$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'Gwigglewiggle'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/gibbs-minim-1.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; __main__:7: RuntimeWarning: divide by zero encountered in log
__main__:7: RuntimeWarning: invalid value encountered in multiply
[&amp;lt;matplotlib.lines.Line2D object at 0x10b1c7710&amp;gt;]
&amp;lt;matplotlib.text.Text object at 0x10b1c3d10&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x10b1c9b90&amp;gt;
&lt;/pre&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2013-02-18-The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition/gibbs-minim-1.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
Now we simply minimize our Gwigglewiggle function. Based on the figure above, the miminum is near 0.45.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fminbound

&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;epsilonp_eq&lt;/span&gt; = fminbound(Gwigglewiggle, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;4&lt;/span&gt;, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;5&lt;/span&gt;)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; epsilonp_eq

plt.plot([epsilonp_eq], [Gwigglewiggle(epsilonp_eq)], &lt;span style="color: #228b22;"&gt;'ro'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/gibbs-minim-2.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; 0.46959618249
&amp;gt;&amp;gt;&amp;gt; [&amp;lt;matplotlib.lines.Line2D object at 0x10d4d3e50&amp;gt;]
&lt;/pre&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2013-02-18-The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition/gibbs-minim-2.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
To compute equilibrium mole fractions we do this:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yi&lt;/span&gt; = (yi0 + nu_j[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt;]*epsilonp_eq) / (&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt; + epsilonp_eq*np.sum(nu_j))
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yb&lt;/span&gt; = (yb0 + nu_j[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;]*epsilonp_eq) / (&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt; + epsilonp_eq*np.sum(nu_j))
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;yp&lt;/span&gt; = (yp0 + nu_j[&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;2&lt;/span&gt;]*epsilonp_eq) / (&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt; + epsilonp_eq*np.sum(nu_j))

&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; yi, yb, yp

# &lt;span style="color: #ff0000; font-weight: bold;"&gt;or this&lt;/span&gt;
&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;y_j&lt;/span&gt; = (yj0 + np.dot(nu_j, epsilonp_eq)) / (&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;.&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;0&lt;/span&gt; + epsilonp_eq*np.sum(nu_j))
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; y_j
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; 0.0573220186324 0.0573220186324 0.885355962735
&amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; [ 0.05732202  0.05732202  0.88535596]
&lt;/pre&gt;

&lt;p&gt;
\(K = \frac{a_P}{a_I a_B} = \frac{y_p P/P^\circ}{y_i P/P^\circ y_b P/P^\circ} = \frac{y_P}{y_i y_b}\frac{P^\circ}{P}\).
&lt;/p&gt;

&lt;p&gt;
We can express the equilibrium constant like this :\(K = \prod\limits_j a_j^{\nu_j}\), and compute it with a single line of code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;K&lt;/span&gt; = np.exp(-Grxn/R/T)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'K from delta G '&lt;/span&gt;,K
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'K as ratio of mole fractions '&lt;/span&gt;,yp / (yi * yb) * P0 / P
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'compact notation: '&lt;/span&gt;,np.prod((y_j * P / P0)**nu_j)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
K from delta G  107.776294742
K as ratio of mole fractions  107.779200065
compact notation:  107.779200065
&lt;/pre&gt;


&lt;p&gt;
These results are very close, and only disagree because of the default tolerance used in identifying the minimum of our function. You could tighten the tolerances by setting options to the fminbnd function.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
In this post we derived an equation for the Gibbs free energy of a reacting mixture and used it to find the equilibrium composition. In future posts we will examine some alternate forms of the equations that may be more useful in some circumstances.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.7c&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Find the minimum distance from a point to a curve.]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/14/Find-the-minimum-distance-from-a-point-to-a-curve" />
    <id>http://jkitchin.github.io/blog/2013/02/14/Find-the-minimum-distance-from-a-point-to-a-curve</id>
    <updated>2013-02-27T14:44:22Z</updated>
    <published>2013-02-14T09:00:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Find the minimum distance from a point to a curve.]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/14/Find-the-minimum-distance-from-a-point-to-a-curve"><![CDATA[


&lt;p&gt;

A problem that can be cast as a constrained minimization problem is to find the minimum distance from a point to a curve. Suppose we have \(f(x) = x^2\), and the point (0.5, 2). what is the minimum distance from that point to \(f(x)\)?
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin_cobyla

P = (0.5, 2)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;f&lt;/span&gt;(x):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; x**2

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;objective&lt;/span&gt;(X):
    x,y = X
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.sqrt((x - P[0])**2 + (y - P[1])**2)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;c1&lt;/span&gt;(X):
    x,y = X
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; f(x) - y

X = fmin_cobyla(objective, x0=[0.5,0.5], cons=[c1])

&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'The minimum distance is {0:1.2f}'&lt;/span&gt;.format(objective(X))

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# Verify the vector to this point is normal to the tangent of the curve&lt;/span&gt;
&lt;span style="color: #ff0000; font-weight: bold;"&gt;# position vector from curve to point&lt;/span&gt;
v1 = np.array(P) - np.array(X)
&lt;span style="color: #ff0000; font-weight: bold;"&gt;# position vector&lt;/span&gt;
v2 = np.array([1, 2.0 * X[0]])
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'dot(v1, v2) = '&lt;/span&gt;,np.dot(v1, v2)

x = np.linspace(-2, 2, 100)

plt.plot(x, f(x), &lt;span style="color: #228b22;"&gt;'r-'&lt;/span&gt;, label=&lt;span style="color: #228b22;"&gt;'f(x)'&lt;/span&gt;)
plt.plot(P[0], P[1], &lt;span style="color: #228b22;"&gt;'bo'&lt;/span&gt;, label=&lt;span style="color: #228b22;"&gt;'point'&lt;/span&gt;)
plt.plot([P[0], X[0]], [P[1], X[1]], &lt;span style="color: #228b22;"&gt;'b-'&lt;/span&gt;, label=&lt;span style="color: #228b22;"&gt;'shortest distance'&lt;/span&gt;)
plt.plot([X[0], X[0] + 1], [X[1], X[1] + 2.0 * X[0]], &lt;span style="color: #228b22;"&gt;'g-'&lt;/span&gt;, label=&lt;span style="color: #228b22;"&gt;'tangent'&lt;/span&gt;)
plt.axis(&lt;span style="color: #228b22;"&gt;'equal'&lt;/span&gt;)
plt.xlabel(&lt;span style="color: #228b22;"&gt;'x'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'y'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/min-dist-p-func.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The minimum distance is 0.86
dot(v1, v2) =  0.000336477214214

   Normal return from subroutine COBYLA

   NFVALS =   44   F = 8.579598E-01    MAXCV = 0.000000E+00
   X = 1.300793E+00   1.692061E+00
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/min-dist-p-func.png"&gt;&lt;p&gt;

&lt;p&gt;
In the code above, we demonstrate that the point we find on the curve that minimizes the distance satisfies the property that a vector from that point to our other point is normal to the tangent of the curve at that point. This is shown by the fact that the dot product of the two vectors is very close to zero. It is not zero because of the accuracy criteria that is used to stop the minimization is not high enough.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/14/Find-the-minimum-distance-from-a-point-to-a-curve..org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using constrained optimization to find the amount of each phase present]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present" />
    <id>http://jkitchin.github.io/blog/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present</id>
    <updated>2013-02-27T14:47:55Z</updated>
    <published>2013-02-12T09:00:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Using constrained optimization to find the amount of each phase present]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present"><![CDATA[


&lt;p&gt;
The problem we solve here is that we have several compounds containing Ni and Al, and a bulk mixture of a particular composition of Ni and Al. We want to know which mixture of phases will minimize the total energy. The tricky part is that the optimization is constrained because the mixture of phases must have the overall stoichiometry we want.  We formulate the problem like this.
&lt;/p&gt;

&lt;p&gt;
Basically, we want to minimize the function \(E = \sum w_i E_i\), where \(w_i\) is the mass of phase \(i\), and \(E_i\) is the energy per unit mass of phase \(i\). There are some constraints to ensure conservation of mass. Let us consider the following compounds: Al, NiAl, Ni3Al, and Ni, and consider a case where the bulk composition of our alloy is 93.8% Ni and balance Al. We want to know which phases are present, and in what proportions. There are some subtleties in considering the formula and molecular weight of an alloy. We consider the formula with each species amount normalized so the fractions all add up to one. For example, Ni_3Al is represented as Ni_{0.75}Al_{0.25}, and the molecular weight is computed as 0.75*MW_{Ni} + 0.25*MW_{Al}.
&lt;/p&gt;

&lt;p&gt;
We use scipy.optimize.fmin_slsqp to solve this problem, and define two equality constraint functions, and the bounds on each weight fraction.
&lt;/p&gt;

&lt;p&gt;
Note: the energies in this example were computed by density functional theory at 0K.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin_slsqp

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# these are atomic masses of each species&lt;/span&gt;
Ni = 58.693
Al = 26.982

COMPOSITIONS = [&lt;span style="color: #228b22;"&gt;'Al'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'NiAl'&lt;/span&gt;,              &lt;span style="color: #228b22;"&gt;'Ni3Al'&lt;/span&gt;,  &lt;span style="color: #228b22;"&gt;'Ni'&lt;/span&gt;]
MW = np.array(  [Al,  (Ni + Al)/2.0, (3*Ni + Al)/4.0, Ni])

xNi = np.array([0.0, 0.5, 0.75, 1.0])  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# mole fraction of nickel in each compd&lt;/span&gt;
WNi = xNi*Ni / MW                      &lt;span style="color: #ff0000; font-weight: bold;"&gt;# weight fraction of Ni in each cmpd&lt;/span&gt;

ENERGIES = np.array([0.0, -0.7, -0.5, 0.0])

BNi = 0.938

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;G&lt;/span&gt;(w):
    &lt;span style="color: #228b22;"&gt;'function to minimize. w is a vector of weight fractions, ENERGIES is defined above.'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.dot(w, ENERGIES)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ec1&lt;/span&gt;(w):
    &lt;span style="color: #228b22;"&gt;'conservation of Ni constraint'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; BNi - np.dot(w, WNi)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ec2&lt;/span&gt;(w):
    &lt;span style="color: #228b22;"&gt;'weight fractions sum to one constraint'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; 1 - np.sum(w)

w0 = np.array([0.0, 0.0, 0.5, 0.5]) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# guess weight fractions&lt;/span&gt;

y = fmin_slsqp(G,   
               w0,
               eqcons=[ec1, ec2], 
               bounds=[(0,1)]*&lt;span style="color: #8b0000;"&gt;len&lt;/span&gt;(w0))

&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; ci, wi &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;zip&lt;/span&gt;(COMPOSITIONS, y):
    &lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'{0:8s} {1:+8.2%}'&lt;/span&gt;.format(ci, wi)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Optimization terminated successfully.    (Exit mode 0)
            Current function value: -0.233299644373
            Iterations: 2
            Function evaluations: 12
            Gradient evaluations: 2
Al         -0.00%
NiAl       +0.00%
Ni3Al     +46.66%
Ni        +53.34%
&lt;/pre&gt;

&lt;p&gt;
So, the sample will be about 47% &lt;i&gt;by weight&lt;/i&gt; of Ni3Al, and 53% &lt;i&gt;by weight&lt;/i&gt; of pure Ni.
&lt;/p&gt;

&lt;p&gt;
It may be convenient to formulate this in terms of moles.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fmin_slsqp

COMPOSITIONS = [&lt;span style="color: #228b22;"&gt;'Al'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'NiAl'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'Ni3Al'&lt;/span&gt;,  &lt;span style="color: #228b22;"&gt;'Ni'&lt;/span&gt;]
xNi = np.array([0.0, 0.5, 0.75, 1.0])   &lt;span style="color: #ff0000; font-weight: bold;"&gt;# define this in mole fractions&lt;/span&gt;

ENERGIES = np.array([0.0, -0.7, -0.5, 0.0]) 

xNiB = 0.875  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# bulk Ni composition&lt;/span&gt;

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;G&lt;/span&gt;(n):
    &lt;span style="color: #228b22;"&gt;'function to minimize'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.dot(n, ENERGIES)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ec1&lt;/span&gt;(n):
    &lt;span style="color: #228b22;"&gt;'conservation of Ni'&lt;/span&gt;
    Ntot = np.sum(n)
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; (Ntot * xNiB) - np.dot(n,  xNi)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ec2&lt;/span&gt;(n):
    &lt;span style="color: #228b22;"&gt;'mole fractions sum to one'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; 1 - np.sum(n)

n0 = np.array([0.0, 0.0, 0.45, 0.55]) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# initial guess of mole fractions&lt;/span&gt;

y = fmin_slsqp(G,   
               n0,
               eqcons=[ec1, ec2], 
               bounds=[(0, 1)]*(&lt;span style="color: #8b0000;"&gt;len&lt;/span&gt;(n0)))

&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; ci, xi &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;zip&lt;/span&gt;(COMPOSITIONS, y):
    &lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'{0:8s} {1:+8.2%}'&lt;/span&gt;.format(ci, xi)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Optimization terminated successfully.    (Exit mode 0)
            Current function value: -0.25
            Iterations: 2
            Function evaluations: 12
            Gradient evaluations: 2
Al         +0.00%
NiAl       -0.00%
Ni3Al     +50.00%
Ni        +50.00%
&lt;/pre&gt;

&lt;p&gt;
This means we have a 1:1 molar ratio of Ni and Ni_{0.75}Al_{0.25}. That works out to the overall bulk composition in this particular problem.
&lt;/p&gt;

&lt;p&gt;
Let us verify that these two approaches really lead to the same conclusions. On a weight basis we estimate 53.3%wt Ni and 46.7%wt Ni3Al, whereas we predict an equimolar mixture of the two phases. Below we compute the mole fraction of Ni in each case.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;# these are atomic masses of each species&lt;/span&gt;
Ni = 58.693
Al = 26.982

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# Molar case&lt;/span&gt;
&lt;span style="color: #ff0000; font-weight: bold;"&gt;# 1 mol Ni + 1 mol Ni_{0.75}Al_{0.25}&lt;/span&gt;
N1 = 1.0; N2 = 1.0
mol_Ni = 1.0 * N1 + 0.75 * N2
xNi = mol_Ni / (N1 + N2)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; xNi

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# Mass case&lt;/span&gt;
M1 = 0.533; M2 = 0.467
MW1 = Ni; MW2 = 0.75*Ni + 0.25*Al

xNi2 = (1.0 * M1/MW1 + 0.75 * M2 / MW2) / (M1/MW1 + M2/MW2)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; xNi2
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0.875
0.874192746385
&lt;/pre&gt;

&lt;p&gt;
You can see the overall mole fraction of Ni is practically the same in each case.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Constrained minimization to find equilibrium compositions]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions" />
    <id>http://jkitchin.github.io/blog/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions</id>
    <updated>2016-04-04T13:35:51Z</updated>
    <published>2013-02-05T09:00:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Constrained minimization to find equilibrium compositions]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions"><![CDATA[



&lt;p&gt;
adapated from Chemical Reactor analysis and design fundamentals, Rawlings and Ekerdt, appendix A.2.3.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/08/12/constrained-minimization-to-find-equilibrium-compositions/"&gt;Matlab post&lt;/a&gt; 
&lt;/p&gt;

&lt;p&gt;
The equilibrium composition of a reaction is the one that minimizes the total Gibbs free energy. The Gibbs free energy of a reacting ideal gas mixture depends on the mole fractions of each species, which are determined by the initial mole fractions of each species, the extent of reactions that convert each species, and the equilibrium constants.
&lt;/p&gt;

&lt;p&gt;
Reaction 1: \(I + B \rightleftharpoons P1\)
&lt;/p&gt;

&lt;p&gt;
Reaction 2: \(I + B \rightleftharpoons P2\)
&lt;/p&gt;

&lt;p&gt;
Here we define the Gibbs free energy of the mixture as a function of the reaction extents.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;gibbs&lt;/span&gt;(E):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;'function defining Gibbs free energy as a function of reaction extents'&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e1&lt;/span&gt; = E[0]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e2&lt;/span&gt; = E[1]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;known equilibrium constants and initial amounts&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;K1&lt;/span&gt; = 108; &lt;span style="color: #BA36A5;"&gt;K2&lt;/span&gt; = 284; &lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = 2.5
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yI0&lt;/span&gt; = 0.5; &lt;span style="color: #BA36A5;"&gt;yB0&lt;/span&gt; = 0.5; &lt;span style="color: #BA36A5;"&gt;yP10&lt;/span&gt; = 0.0; &lt;span style="color: #BA36A5;"&gt;yP20&lt;/span&gt; = 0.0
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;compute mole fractions&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;d&lt;/span&gt; = 1 - e1 - e2
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yI&lt;/span&gt; = (yI0 - e1 - e2) / d
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yB&lt;/span&gt; = (yB0 - e1 - e2) / d
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yP1&lt;/span&gt; = (yP10 + e1) / d
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yP2&lt;/span&gt; = (yP20 + e2) / d
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;G&lt;/span&gt; = (-(e1 * np.log(K1) + e2 * np.log(K2)) +
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;d * np.log(P) + yI * d * np.log(yI) +
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;yB * d * np.log(yB) + yP1 * d * np.log(yP1) + yP2 * d * np.log(yP2))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; G
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The equilibrium constants for these reactions are known, and we seek to find the equilibrium reaction extents so we can determine equilibrium compositions. The equilibrium reaction extents are those that minimize the Gibbs free energy.  We have the following constraints, written in standard less than or equal to form:
&lt;/p&gt;

&lt;p&gt;
\(-\epsilon_1 \le 0\)
&lt;/p&gt;

&lt;p&gt;
\(-\epsilon_2 \le 0\)
&lt;/p&gt;

&lt;p&gt;
\(\epsilon_1 + \epsilon_2 \le 0.5\)
&lt;/p&gt;

&lt;p&gt;
In Matlab we express this in matrix form as Ax=b where
&lt;/p&gt;
\begin{equation}
A = \left[ \begin{array}{cc} -1 &amp; 0 \\ 0 &amp; -1 \\ 1 &amp; 1 \end{array} \right]
\end{equation}

&lt;p&gt;
and
&lt;/p&gt;

\begin{equation}
b = \left[ \begin{array}{c} 0 \\ 0 \\ 0.5\end{array} \right]
\end{equation}

&lt;p&gt;
Unlike in Matlab, in python we construct the inequality constraints as functions that are greater than or equal to zero when the constraint is met.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;constraint1&lt;/span&gt;(E):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e1&lt;/span&gt; = E[0]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; e1


&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;constraint2&lt;/span&gt;(E):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e2&lt;/span&gt; = E[1]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; e2


&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;constraint3&lt;/span&gt;(E):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e1&lt;/span&gt; = E[0]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e2&lt;/span&gt; = E[1]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0.5 - (e1 + e2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we minimize.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fmin_slsqp

&lt;span style="color: #BA36A5;"&gt;X0&lt;/span&gt; = [0.2, 0.2]
&lt;span style="color: #BA36A5;"&gt;X&lt;/span&gt; = fmin_slsqp(gibbs, X0, ieqcons=[constraint1, constraint2, constraint3],
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;  bounds=((0.001, 0.499),
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;  (0.001, 0.499)))
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(X)

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(gibbs(X))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Optimization terminated successfully.    (Exit mode 0)
            Current function value: -2.55942394906
            Iterations: 7
            Function evaluations: 31
            Gradient evaluations: 7
[ 0.13336503  0.35066486]
-2.55942394906
&lt;/pre&gt;



&lt;p&gt;
One way we can verify our solution is to plot the gibbs function and see where the minimum is, and whether there is more than one minimum. We start by making grids over the range of 0 to 0.5. Note we actually start slightly above zero because at zero there are some numerical imaginary elements of the gibbs function or it is numerically not defined since there are logs of zero there. We also set all elements where the sum of the two extents is greater than 0.5 to near zero, since those regions violate the constraints.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;gibbs&lt;/span&gt;(E):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;'function defining Gibbs free energy as a function of reaction extents'&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e1&lt;/span&gt; = E[0]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;e2&lt;/span&gt; = E[1]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;known equilibrium constants and initial amounts&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;K1&lt;/span&gt; = 108; &lt;span style="color: #BA36A5;"&gt;K2&lt;/span&gt; = 284; &lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = 2.5;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yI0&lt;/span&gt; = 0.5; &lt;span style="color: #BA36A5;"&gt;yB0&lt;/span&gt; = 0.5; &lt;span style="color: #BA36A5;"&gt;yP10&lt;/span&gt; = 0.0; &lt;span style="color: #BA36A5;"&gt;yP20&lt;/span&gt; = 0.0;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;compute mole fractions&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;d&lt;/span&gt; = 1 - e1 - e2;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yI&lt;/span&gt; = (yI0 - e1 - e2)/d;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yB&lt;/span&gt; = (yB0 - e1 - e2)/d;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yP1&lt;/span&gt; = (yP10 + e1)/d;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;yP2&lt;/span&gt; = (yP20 + e2)/d;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;G&lt;/span&gt; = (-(e1 * np.log(K1) + e2 * np.log(K2)) +
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;d * np.log(P) + yI * d * np.log(yI) +
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;yB * d * np.log(yB) + yP1 * d * np.log(yP1) + yP2 * d * np.log(yP2))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; G


&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = np.linspace(0.001, 0.5, 100)
&lt;span style="color: #BA36A5;"&gt;E1&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;E2&lt;/span&gt; = np.meshgrid(a,a)

&lt;span style="color: #BA36A5;"&gt;sumE&lt;/span&gt; = E1 + E2
&lt;span style="color: #BA36A5;"&gt;E1&lt;/span&gt;[sumE &amp;gt;= 0.5] = 0.00001
&lt;span style="color: #BA36A5;"&gt;E2&lt;/span&gt;[sumE &amp;gt;= 0.5] = 0.00001

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now evaluate gibbs&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;G&lt;/span&gt; = np.zeros(E1.shape)
&lt;span style="color: #BA36A5;"&gt;m&lt;/span&gt;,&lt;span style="color: #BA36A5;"&gt;n&lt;/span&gt; = E1.shape

&lt;span style="color: #BA36A5;"&gt;G&lt;/span&gt; = gibbs([E1, E2])

&lt;span style="color: #BA36A5;"&gt;CS&lt;/span&gt; = plt.contour(E1, E2, G, levels=np.linspace(G.&lt;span style="color: #006FE0;"&gt;min&lt;/span&gt;(),G.&lt;span style="color: #006FE0;"&gt;max&lt;/span&gt;(),100))
plt.xlabel(&lt;span style="color: #008000;"&gt;'$\epsilon_1$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'$\epsilon_2$'&lt;/span&gt;)
plt.colorbar()

plt.plot([0.13336503],  [0.35066486], &lt;span style="color: #008000;"&gt;'ro'&lt;/span&gt;)

plt.savefig(&lt;span style="color: #008000;"&gt;'images/gibbs-minimization-1.png'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #008000;"&gt;'images/gibbs-minimization-1.svg'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2013-02-05-Constrained-minimization-to-find-equilibrium-compositions/gibbs-minimization-1.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
You can see we found the minimum. We can compute the mole fractions pretty easily.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #BA36A5;"&gt;e1&lt;/span&gt; = X[0];
&lt;span style="color: #BA36A5;"&gt;e2&lt;/span&gt; = X[1];

&lt;span style="color: #BA36A5;"&gt;yI0&lt;/span&gt; = 0.5; &lt;span style="color: #BA36A5;"&gt;yB0&lt;/span&gt; = 0.5; &lt;span style="color: #BA36A5;"&gt;yP10&lt;/span&gt; = 0; &lt;span style="color: #BA36A5;"&gt;yP20&lt;/span&gt; = 0; &lt;span style="color: #8D8D84;"&gt;#&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;initial mole fractions&lt;/span&gt;

&lt;span style="color: #BA36A5;"&gt;d&lt;/span&gt; = 1 - e1 - e2;
&lt;span style="color: #BA36A5;"&gt;yI&lt;/span&gt; = (yI0 - e1 - e2) / d
&lt;span style="color: #BA36A5;"&gt;yB&lt;/span&gt; = (yB0 - e1 - e2) / d
&lt;span style="color: #BA36A5;"&gt;yP1&lt;/span&gt; = (yP10 + e1) / d
&lt;span style="color: #BA36A5;"&gt;yP2&lt;/span&gt; = (yP20 + e2) / d

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'y_I = {0:1.3f} y_B = {1:1.3f} y_P1 = {2:1.3f} y_P2 = {3:1.3f}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(yI,yB,yP1,yP2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
y_I = 0.031 y_B = 0.031 y_P1 = 0.258 y_P2 = 0.680
&lt;/pre&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
I found setting up the constraints in this example to be more confusing than the Matlab syntax.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using Lagrange multipliers in optimization]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/03/Using-Lagrange-multipliers-in-optimization" />
    <id>http://jkitchin.github.io/blog/2013/02/03/Using-Lagrange-multipliers-in-optimization</id>
    <updated>2013-02-27T14:43:27Z</updated>
    <published>2013-02-03T09:00:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Using Lagrange multipliers in optimization]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/03/Using-Lagrange-multipliers-in-optimization"><![CDATA[


&lt;p&gt;


&lt;a href="http://matlab.cheme.cmu.edu/2011/12/24/using-lagrange-multipliers-in-optimization/" &gt;Matlab post&lt;/a&gt;  (adapted from &lt;a href="http://en.wikipedia.org/wiki/Lagrange_multipliers" &gt;http://en.wikipedia.org/wiki/Lagrange_multipliers&lt;/a&gt;.)
&lt;/p&gt;

&lt;p&gt;
Suppose we seek to maximize the function \(f(x,y)=x+y\) subject to the constraint that \(x^2 + y^2 = 1\). The function we seek to maximize is an unbounded plane, while the constraint is a unit circle. We want the maximum value of the circle, on the plane. We plot these two functions here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

x = np.linspace(-1.5, 1.5)

[X, Y] = np.meshgrid(x, x)

&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; mpl
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; mpl_toolkits.mplot3d &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; Axes3D
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

fig = plt.figure()
ax = fig.gca(projection=&lt;span style="color: #228b22;"&gt;'3d'&lt;/span&gt;)

ax.plot_surface(X, Y, X + Y)

theta = np.linspace(0,2*np.pi);
R = 1.0
x1 = R * np.cos(theta)
y1 = R * np.sin(theta)

ax.plot(x1, y1, x1 + y1, &lt;span style="color: #228b22;"&gt;'r-'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/lagrange-1.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/lagrange-1.png"&gt;&lt;p&gt;

&lt;div id="outline-container-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Construct the Lagrange multiplier augmented function&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
To find the maximum, we construct the following function: \(\Lambda(x,y; \lambda) = f(x,y)+\lambda g(x,y)\) where \(g(x,y) = x^2 + y^2 - 1 = 0\), which is the constraint function. Since \(g(x,y)=0\), we are not really changing the original function, provided that the constraint is met!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;func&lt;/span&gt;(X):
    x = X[0]
    y = X[1]
    L = X[2] &lt;span style="color: #ff0000; font-weight: bold;"&gt;# this is the multiplier. lambda is a reserved keyword in python&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; x + y + L * (x**2 + y**2 - 1)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Finding the partial derivatives&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The minima/maxima of the augmented function are located where all of the partial derivatives of the augmented function are equal to zero, i.e. \(\partial \Lambda/\partial x = 0\), \(\partial \Lambda/\partial y = 0\), and \(\partial \Lambda/\partial \lambda = 0\). the process for solving this is usually to analytically evaluate the partial derivatives, and then solve the unconstrained resulting equations, which may be nonlinear.
&lt;/p&gt;

&lt;p&gt;
Rather than perform the analytical differentiation, here we develop a way to numerically approximate the partial derivatives.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;dfunc&lt;/span&gt;(X):
    dLambda = np.zeros(&lt;span style="color: #8b0000;"&gt;len&lt;/span&gt;(X))
    h = 1e-3 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# this is the step size used in the finite difference.&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; i &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;range&lt;/span&gt;(len(X)):
        dX = np.zeros(&lt;span style="color: #8b0000;"&gt;len&lt;/span&gt;(X))
        dX[i] = h
        dLambda[i] = (func(X+dX)-func(X-dX))/(2*h);
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; dLambda
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Now we solve for the zeros in the partial derivatives&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
The function we defined above (dfunc) will equal zero at a maximum or minimum. It turns out there are two solutions to this problem, but only one of them is the maximum value. Which solution you get depends on the initial guess provided to the solver. Here we have to use some judgement to identify the maximum.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; fsolve

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# this is the max&lt;/span&gt;
X1 = fsolve(dfunc, [1, 1, 0])
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; X1, func(X1)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# this is the min&lt;/span&gt;
X2 = fsolve(dfunc, [-1, -1, 0])
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; X2, func(X2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; [ 0.70710678  0.70710678 -0.70710678] 1.41421356237
&amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; [-0.70710678 -0.70710678  0.70710678] -1.41421356237
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Three dimensional plots in matplotlib are a little more difficult than in Matlab (where the code is almost the same as 2D plots, just different commands, e.g. plot vs plot3). In Matplotlib you have to import additional modules in the right order, and use the object oriented approach to plotting as shown here.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/03/Using-Lagrange-multipliers-in-optimization.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
</feed>
