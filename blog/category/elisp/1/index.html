

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: elisp</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="f-strings-in-emacs-lisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2018/05/14/f-strings-in-emacs-lisp/" rel="bookmark" title="Permanent Link to f-strings in emacs-lisp">f-strings in emacs-lisp</a></h2>
      <p><small><span class="blog_post_date">Posted May 14, 2018 at 05:27 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/elisp/'>elisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2018/05/14/f-strings-in-emacs-lisp#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated May 25, 2018 at 07:44 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I am a big fan of f-strings in Python 3. They let you put variable names and expressions in a string template that get expanded to create new strings. Here is a simple example of using those:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">username</span> = <span style="color: #008000;">'John Kitchin'</span>
<span style="color: #BA36A5;">somevar</span> = 5**0.5
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'{username:30s}{somevar:1.2f}'</span>)
</pre>
</div>

<pre class="example">
John Kitchin                  2.24


</pre>

<p>
String formatting in emacs-lisp is by comparison not as fun and easy. Out of the box we have:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((username <span style="color: #008000;">"John Kitchin"</span>)
      (somevar (sqrt 5)))
  (format <span style="color: #008000;">"%-30s%1.2f"</span> username somevar))
</pre>
</div>

<pre class="example">
John Kitchin                  2.24

</pre>

<p>
That is still three lines of code, but it is ugly and hard to read like the old python code:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">print</span>(<span style="color: #008000;">'%-30s%1.2f'</span> % (username, somevar))
</pre>
</div>

<pre class="example">
John Kitchin                  2.24


</pre>


<p>
My experience has shown that this gets harder to figure out as the strings get larger, and f-strings are easier to read.
</p>

<p>
The wonderful <a href="https://github.com/magnars/s.el">'s</a> library provides some salvation for emacs-lisp, if you don't want the format fields. You can refer to variables in a lexical environment like this.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((username <span style="color: #008000;">"John Kitchin"</span>)
      (somevar (sqrt 5)))
  (<span style="color: #0000FF;">s-lex-format</span> <span style="color: #008000;">"${username}${somevar}"</span>))
</pre>
</div>

<pre class="example">
John Kitchin2.23606797749979

</pre>

<p>
Today, I decided to do something about this, and wrote this little macro. It is a variation on s-lex-format that introduces a slightly new syntax. You can now add an optional format field separated from the variable name by a space.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">f-string</span> (fmt)
  <span style="color: #036A07;">"Like `</span><span style="color: #D0372D;">s-format</span><span style="color: #036A07;">' but with format fields in it.</span>
<span style="color: #036A07;">FMT is a string to be expanded against the current lexical</span>
<span style="color: #036A07;">environment. It is like what is used in `</span><span style="color: #D0372D;">s-lex-format</span><span style="color: #036A07;">', but has</span>
<span style="color: #036A07;">an expanded syntax to allow format-strings. For example:</span>
<span style="color: #036A07;">${user-full-name 20s} will be expanded to the current value of</span>
<span style="color: #036A07;">the variable `</span><span style="color: #D0372D;">user-full-name</span><span style="color: #036A07;">' in a field 20 characters wide.</span>
<span style="color: #036A07;">  (let ((f (sqrt 5)))  (f-string \"${f 1.2f}\"))</span>
<span style="color: #036A07;">  will render as: 2.24</span>
<span style="color: #036A07;">This function is inspired by the f-strings in Python 3.6, which I</span>
<span style="color: #036A07;">enjoy using a lot.</span>
<span style="color: #036A07;">"</span>
  (<span style="color: #0000FF;">let*</span> ((matches (s-match-strings-all<span style="color: #008000;">"${</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(?3:</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(?1:</span><span style="color: #008000;">[</span><span style="color: #008000;">^</span><span style="color: #008000;">} ]+</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;"> *</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(?2:</span><span style="color: #008000;">[</span><span style="color: #008000;">^</span><span style="color: #008000;">}]*</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">}"</span> fmt))
         (agetter (<span style="color: #0000FF;">cl-loop</span> for (m0 m1 m2 m3) in matches
                        collect `(cons ,m3  (format (format <span style="color: #008000;">"%%%s"</span> (<span style="color: #0000FF;">if</span> (string= ,m2 <span style="color: #008000;">""</span>)
                                                                      (<span style="color: #0000FF;">if</span> s-lex-value-as-lisp <span style="color: #008000;">"S"</span> <span style="color: #008000;">"s"</span>)
                                                                   ,m2))
                                                  (symbol-value (intern ,m1)))))))

    `<span style="color: #D0372D;">(s-format ,fmt </span>'aget (list ,@agetter))))
</pre>
</div>

<pre class="example">
f-string

</pre>

<p>
Here it is in action.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((username <span style="color: #008000;">"John Kitchin"</span>)
      (somevar (sqrt 5)))
  (<span style="color: #0000FF;">f-string</span> <span style="color: #008000;">"${username -30s}${somevar 1.2f}"</span>))
</pre>
</div>

<pre class="example">
John Kitchin                  2.24

</pre>

<p>
It still lacks some of the capability of f-strings in python, e.g. in Python, arguments inside the template to be expanded get evaluated. The solution used above is too simple for that, since it just used a regexp and is limited to the value of variables in the lexical environment.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'{5**0.5:1.3f}'</span>)
</pre>
</div>

<pre class="example">
2.236


</pre>

<p>
Nevertheless, this simple solution matches what I do most of the time anyway, so I still consider it an improvement!
</p>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/05/14/f-strings-in-emacs-lisp.org">org-mode source</a></p>
<p>Org-mode version = 9.1.13</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2018/05/14/f-strings-in-emacs-lisp#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Caching-searches-using-biblio-and-only-seeing-new-results"></div>
      <h2 class="blog_post_title"><a href="/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results/" rel="bookmark" title="Permanent Link to Caching searches using biblio and only seeing new results">Caching searches using biblio and only seeing new results</a></h2>
      <p><small><span class="blog_post_date">Posted April 11, 2018 at 08:46 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/elisp/'>elisp</a>, <a href='/blog/category/arxiv/'>arxiv</a>, <a href='/blog/category/biblio/'>biblio</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In this <a href="https://github.com/jkitchin/scimax/issues/196">issue</a> in scimax, Robert asked if it was possible to save searches, and then to repeat them every so often and only see the new results. This needs some persistent caching of the records, and a comparison of the current search results with the previous search results.
</p>

<p>
<a href="https://github.com/cpitclaudel/biblio.el">biblio</a> provides a nice interface to searching a range of resources for bibliographic references. In this post, I will focus on arxiv. Out of the box, biblio does not seem to support this use case, but as you will see, it has many of the pieces required to achieve it. Let's start picking those pieces apart.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">biblio</span>)
</pre>
</div>

<pre class="example">
biblio

</pre>

<p>
Here is the first piece we need: a way to run a query, and get results back as a data structure. Here we just look at the first result.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((query <span style="color: #008000;">"alloy segregration"</span>)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (<span style="color: #0000FF;">with-current-buffer</span> cb
                  (funcall backend 'parse-buffer))))
  (car results))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">((doi . <span style="color: #008000;">"10.1103/PhysRevB.76.014112"</span>)
 (identifier . <span style="color: #008000;">"0704.2752v2"</span>)
 (year . <span style="color: #008000;">"2007"</span>)
 (title . <span style="color: #008000;">"Modelling Thickness-Dependence of Ferroelectric Thin Film Properties"</span>)
 (authors nil nil nil nil nil nil nil nil nil nil nil nil nil <span style="color: #008000;">"L. Palova"</span> nil <span style="color: #008000;">"P. Chandra"</span> nil <span style="color: #008000;">"K. M. Rabe"</span> nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)
 (container . <span style="color: #008000;">"PRB 76, 014112 (2007)"</span>)
 (category . <span style="color: #008000;">"cond-mat.mtrl-sci"</span>)
 (references <span style="color: #008000;">"10.1103/PhysRevB.76.014112"</span> <span style="color: #008000;">"0704.2752v2"</span>)
 (type . <span style="color: #008000;">"eprint"</span>)
 (url . <span style="color: #008000;">"https://doi.org/10.1103/PhysRevB.76.014112"</span>)
 (direct-url . <span style="color: #008000;">"http://arxiv.org/pdf/0704.2752v2"</span>))
</pre>
</div>

<p>
Next, we need a database to store the results in. I will just use a flat file database with a file for each record. The filename will be the md5 hash of the doi or the record itself. Why is that a good idea? Well, the doi is a constant, so if it exists the md5 will also be a constant. The doi itself is not a good filename in general, but the md5 is. The md5 of the record itself will be fragile to any changes, so if it has a doi, we should use it. If it doesn't and later gets one, we should see it again since that could mean it has been published. Also, if it changes because of some new version we might want to see it again. In any case, the existence of that file will be evidence we have seen that record before, and will indicate we need to remove it from the current view.
</p>

<p>
The flat file database is not super inspired. It is modeled a little after elfeed, but other solutions might work better for large sets of records, but this approach will work fine for this post.
</p>

<p>
Here is a function that returns nil if the record has been seen, and if not, saves the record and returns it.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">db-dir</span> <span style="color: #008000;">"~/.arxiv-db/"</span>)

(<span style="color: #0000FF;">unless</span> (f-dir? db-dir) (make-directory db-dir t))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">unseen-record-p</span> (record)
  <span style="color: #036A07;">"Given a RECORD return it if it is unseen.</span>
<span style="color: #036A07;">Also, save the record so next time it will be marked seen. A</span>
<span style="color: #036A07;">record is seen if we have seen the DOI or the record as a string</span>
<span style="color: #036A07;">before."</span>
  (<span style="color: #0000FF;">let*</span> ((doi (cdr (assoc 'doi record)))
         (contents (<span style="color: #0000FF;">with-temp-buffer</span>
                     (prin1 record (current-buffer))
                     (buffer-string)))
         (hash (md5 (<span style="color: #0000FF;">or</span> doi contents)))
         (fname (expand-file-name hash db-dir)))

    (<span style="color: #0000FF;">if</span> (f-exists? fname)
        nil
      (<span style="color: #0000FF;">with-temp-file</span> fname
        (insert contents))
      record)))
</pre>
</div>

<pre class="example">
unseen-record-p

</pre>

<p>
Now we can use that as a filter that saves records by side effect.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scimax-arxiv</span> (query)
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"Query: "</span>)

  (<span style="color: #0000FF;">let*</span> ((backend 'biblio-arxiv-backend)
         (cb (url-retrieve-synchronously (funcall backend 'url query)))
         (results (-filter 'unseen-record-p (<span style="color: #0000FF;">with-current-buffer</span> cb
                                              (funcall backend 'parse-buffer))))
         (results-buffer (biblio--make-results-buffer (current-buffer) query backend)))
    (<span style="color: #0000FF;">with-current-buffer</span> results-buffer
      (biblio-insert-results results <span style="color: #008000;">""</span>))
    (pop-to-buffer results-buffer)))

(scimax-arxiv <span style="color: #008000;">"alloy segregation"</span>)
</pre>
</div>

<pre class="example">
#&lt;buffer *arXiv search*&gt;

</pre>

<p>
Now, when I run that once I see something like this:
</p>

<p>
<img src="/media/date-11-04-2018-time-20-19-52.png">
</p>


<p>
and if I run it again:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(scimax-arxiv <span style="color: #008000;">"alloy segregation"</span>)
</pre>
</div>

<pre class="example">
#&lt;buffer *arXiv search*&gt;

</pre>

<p>
Then the buffer is empty, since we have seen all the entries before.
</p>


<p>
<img src="/media/date-11-04-2018-time-20-20-37.png">
</p>

<p>
Here are the files in our database:
</p>

<div class="org-src-container">
<pre class="src src-sh">ls ~/.arxiv-db/
</pre>
</div>

<p>
Here are the contents of one of those files:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">with-temp-buffer</span>
 (insert-file-contents <span style="color: #008000;">"~/.arxiv-db/18085fe2512e15d66addc7dfb71f7cd2"</span>)
 (read (buffer-string)))
</pre>
</div>

<pre class="example">
((doi) (identifier . 1101.3464v3) (year . 2011) (title . Characterizing Solute Segregation and Grain Boundary Energy in a Binary
  Alloy Phase Field Crystal Model) (authors nil nil nil nil nil nil nil nil nil nil nil nil nil Jonathan Stolle nil Nikolas Provatas nil nil nil nil nil nil nil nil nil nil nil) (container) (category . cond-mat.mtrl-sci) (references nil 1101.3464v3) (type . eprint) (url . http://arxiv.org/abs/1101.3464v3) (direct-url . http://arxiv.org/pdf/1101.3464v3))

</pre>

<p>
So, if you need to read this in again later, no problem.
</p>

<p>
Now, what could go wrong? I don't know much about how the search results from arxiv are returned. For example, this query returns 10 hits.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((query <span style="color: #008000;">"alloy segregration"</span>)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (<span style="color: #0000FF;">with-current-buffer</span> cb
                  (funcall backend 'parse-buffer))))
  (length results))
</pre>
</div>

<pre class="example">
10

</pre>

<p>
There is just no way there are only 10 hits for this query. So, there must be a bunch more that you get by either changing the requested number in some argument, or by using subsequent queries to get the rest of them. I don't know if there are more advanced query options with biblio, e.g. to find entries newer than the last time it was run. On the advanced search <a href="https://arxiv.org/find">page</a> for arxiv, it looks like there is only a by year option.
</p>

<p>
This is still a good idea, and a lot of the pieces are here,
</p>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results.org">org-mode source</a></p>
<p>Org-mode version = 9.1.6</p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Overloading-mathematical-operators-in-elisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/23/Overloading-mathematical-operators-in-elisp/" rel="bookmark" title="Permanent Link to Overloading mathematical operators in elisp">Overloading mathematical operators in elisp</a></h2>
      <p><small><span class="blog_post_date">Posted July 23, 2017 at 02:13 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/elisp/'>elisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/23/Overloading-mathematical-operators-in-elisp#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated July 23, 2017 at 04:03 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgccfe3c4">1. Addendum</a></li>
</ul>
</div>
</div>
<p>
In Python I am used to some simple idioms like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>([1, 2, 3] * 2)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"ab"</span> * 3)
</pre>
</div>

<p>
[1, 2, 3, 1, 2, 3]
ababab
</p>

<p>
There is even such fanciness as defining operators for objects, as long as they have the appropriate dunder methods defined:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Point</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, x, y):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.x = x
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.y = y

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__str__</span>(<span style="color: #0000FF;">self</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">"Point ({}, {})"</span>.<span style="color: #006FE0;">format</span>(<span style="color: #0000FF;">self</span>.x, <span style="color: #0000FF;">self</span>.y)

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__mul__</span>(<span style="color: #0000FF;">self</span>, a):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> Point(<span style="color: #0000FF;">self</span>.x * a, <span style="color: #0000FF;">self</span>.y * a)

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__rmul__</span>(<span style="color: #0000FF;">self</span>, a):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> Point(<span style="color: #0000FF;">self</span>.x * a, <span style="color: #0000FF;">self</span>.y * a)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   
<span style="color: #BA36A5;">p</span> = Point(1, 1)
<span style="color: #0000FF;">print</span>(p * 2)
<span style="color: #0000FF;">print</span>(3 * p)
</pre>
</div>

<p>
Point (2, 2)
Point (3, 3)
</p>

<p>
Out of the box, these things are not possible in elisp. Operators like  * in elisp only take numbers or markers. We have a few options to change this. The worst option is to simply redefine these functions. That is bad because it is not reversible. We could define new functions that have the behavior we want, but then we lose the semantic meaning of "*" that we were aiming for. A better option is to <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">advise</a> these functions. This is reversible, because you can later unadvise them. Today we look at some strategies to do this.
</p>

<p>
We will use "around" advise because it will let us bypass the original intent of the function when we want to, or use it when we do. First, we create a function that will be the advice and add it to the * function. This first draft won't actually change the behavior of *; if all the args are numbers or markers it will simply use the original function as before.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">dash</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"if every arg is a number do *, else do something else."</span>
  (<span style="color: #0000FF;">cond</span>
   ((-every? (<span style="color: #0000FF;">lambda</span> (x) (<span style="color: #0000FF;">or</span> (numberp x) (markerp x))) args)
    (apply orig-fun args))))

(advice-add '* <span style="color: #006FE0;">:around</span> #'*--*-around)
</pre>
</div>

<p>
Let's just confirm
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(* 1 2 3)
</pre>
</div>

<pre class="example">
6

</pre>

<p>
Now, we can start modifying our function to handle some other cases. Let's do the list and string first. The * function is variadic, but in these cases it makes sense to limit to two arguments. We need two cases for each type since we can write (* 2 list) or (* list 2). We also should create a fall-through case that raises an error to alert us we can't multiply things.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"if every arg is a number do *, else do something else."</span>
  (<span style="color: #0000FF;">cond</span>
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">The original behavior</span>
   ((-every? (<span style="color: #0000FF;">lambda</span> (x) (<span style="color: #0000FF;">or</span> (numberp x) (markerp x))) args)
    (apply orig-fun args))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">create repeated copies of list</span>
   ((<span style="color: #0000FF;">and</span> (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) append (copy-list (first args))))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) append (copy-list (second args))))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Make repeated string</span>
   ((<span style="color: #0000FF;">and</span> (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) concat (first args)))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) concat (second args)))

   (t
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"You cannot * %s"</span> args))))
</pre>
</div>

<pre class="example">
*--*-around

</pre>

<p>
Here is the new advice in action. 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(list
 (* '(a b) 2)
 (* 2 '(c d))
 (* 2 <span style="color: #008000;">"ab"</span>)
 (* <span style="color: #008000;">"cd"</span> 2))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(a b a b)</td>
<td class="org-left">(c d c d)</td>
<td class="org-left">abab</td>
<td class="org-left">cdcd</td>
</tr>
</tbody>
</table>

<p>
That captures the spirit of overloading * for lists and strings. What about that object example? We have to make some assumptions here. Python looks for an uses a dunder <span class="underline"><span class="underline">mul</span></span> method. We will assume a double dash method (&#x2013;mul&#x2013;) in a similar spirit. We have to modify the advice one final time. We just add a condition to check if one of the arguments is an eieio-object, and then call the &#x2013;mul&#x2013; function on the arguments.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"if every arg is a number do *, else do something else."</span>
  (<span style="color: #0000FF;">cond</span>
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">The original behavior</span>
   ((-every? (<span style="color: #0000FF;">lambda</span> (x) (<span style="color: #0000FF;">or</span> (numberp x) (markerp x))) args)
    (apply orig-fun args))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">create repeated copies of list</span>
   ((<span style="color: #0000FF;">and</span> (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) append (copy-list (first args))))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) append (copy-list (second args))))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Make repeated string</span>
   ((<span style="color: #0000FF;">and</span> (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) concat (first args)))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) concat (second args)))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Handle object</span>
   ((<span style="color: #0000FF;">or</span> (<span style="color: #0000FF;">and</span> (eieio-object-p (first args))
             (numberp (second args)))
        (<span style="color: #0000FF;">and</span> (numberp (first args))
             (eieio-object-p (second args))))
    (apply '--mul-- args))

   (t
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"You cannot * %s"</span> args))))
</pre>
</div>

<pre class="example">
*--*-around

</pre>

<p>
Now, we can define a class and the &#x2013;mul&#x2013; function and show that our overloaded * function works. Note we can define two signatures of &#x2013;mul&#x2013; so it is not necessary to define an &#x2013;rmul&#x2013; in this case as it was with Python (although we still create two functions in the end).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">eieio</span>)

(<span style="color: #0000FF;">defclass</span> <span style="color: #6434A3;">Point</span> ()
  ((x <span style="color: #006FE0;">:initarg</span> <span style="color: #006FE0;">:x</span>)
   (y <span style="color: #006FE0;">:initarg</span> <span style="color: #006FE0;">:y</span>)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">--mul--</span> ((p Point) a)
  (Point <span style="color: #006FE0;">:x</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:x</span>) a) <span style="color: #006FE0;">:y</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:y</span>) a)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">--mul--</span> (a (p Point))
  (Point <span style="color: #006FE0;">:x</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:x</span>) a) <span style="color: #006FE0;">:y</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:y</span>) a)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">--str--</span> ((p Point))
  (format <span style="color: #008000;">"Point (%s, %s)"</span> (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:x</span>) (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:y</span>)))

(<span style="color: #0000FF;">let</span> ((P (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Point (2, 2)</td>
<td class="org-left">Point (3, 3)</td>
</tr>
</tbody>
</table>

<p>
That is pretty awesome. Before going on, here is how you remove the advice:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(advice-remove '* '*--*-around)
</pre>
</div>

<p>
This example has been pretty instructive. You have to handle overloading for all the intrinsic types. We did lists and strings here; you might also consider vectors. For objects, it looks like we can at least try using a generic method like &#x2013;mul&#x2013;. One detail I neglected to consider here is that * is natively variadic. For these special cases, we did not implement variadic versions. This isn't a feature of Python which uses infix notation, so every call is with two arguments. In some cases it might make sense to support variadic args, but that seems like a generally challenging thing to do. While (* "a" 2 3) might be expected to create a string of "aaaaaa", (* "a" 2 '(3)) doesn't make sense at all.
</p>

<p>
It would be straightforward to extend this to other operators like '+ to concatenate strings, lists and vectors, or '- to remove chars or elements, including extensions to objects using double-dash functions like &#x2013;add&#x2013;, &#x2013;subtract&#x2013;, etc. Another nice idea might be to advise print to use &#x2013;str&#x2013; on objects.
</p>

<p>
On the surface this looks useful so far. Python defines <i>a lot</i> of dunder methods that cover all kinds of scenarios including logical comparisons, bit shifting, mod, incrementing operators, casting, comparisons, right/left operations, indexing and assignment, length and others. That would be a lot of advices. This approach is moderately tedious to expand though; you have to keep adding conditional cases. 
</p>

<p>
An alternative to the big conditional statement used in the advice might be the use of a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html">generic function</a>. With this approach we define a generic function that just does multiplication by default. Then we define specific cases with specific signatures that are used for lists, strings, objects, etc. That is basically all our conditional above was doing, matching signatures and executing a chunk of code accordingly.
</p>

<p>
Here is our default case that does the original behavior. We still use advice to apply the function.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defgeneric</span> <span style="color: #006699;">generic-multiply</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"Generic multiply for when no specific case exists."</span>
  (apply orig-fun args))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around-generic</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  (apply 'generic-multiply orig-fun args))

(advice-add '* <span style="color: #006FE0;">:around</span> #'*--*-around-generic)
</pre>
</div>

<p>
That should just work as usual for regular multiplication.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(* 1 2 3 4)
</pre>
</div>

<pre class="example">
24

</pre>

<p>
Sure enough it does. Now, we can define a specific method for a string. We need a specialized method for each signature, e.g. pre and post multiplication.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (s string) (n integer))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n concat s))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (n integer) (s string))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n concat s))

(list
 (* <span style="color: #008000;">"Ac"</span> 2)
 (* 2 <span style="color: #008000;">"Ad"</span>))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">AcAc</td>
<td class="org-left">AdAd</td>
</tr>
</tbody>
</table>

<p>
That works fine, and we did not have to modify our original advice function at all! Next the  list:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (L list) (n integer))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n append (copy-list L)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (n integer) (L list))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n append (copy-list L)))

(list (* '(1 2) 2)
      (* 2 '(3 4)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>

<p>
That also works fine. Last, our class example. This should work on all objects I think (unless there is some way to make classes that do not inherit the default superclass).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (n integer) (obj eieio-default-superclass))
  (--mul-- n obj))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (obj eieio-default-superclass) (n integer))
  (--mul-- n obj))

(<span style="color: #0000FF;">let</span> ((P (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Point (2, 2)</td>
<td class="org-left">Point (3, 3)</td>
</tr>
</tbody>
</table>

<p>
This is a much better approach to extending the multiplication operator! If I continue this path in the future I would probably take this one.  This could be useful to make elisp more like some more popular contemporary languages like Python, as well as to add linear algebra like notation or mathematical operations on objects in elisp. It kind of feels like these operations ought to be generic functions to start with to make this kind of overloading easier from the beginning.  Functions like "*" are currently defined in the C source code though, maybe for performance reasons. It is not obvious what the consequences of making them generic might be.
</p>

<div id="outline-container-orgccfe3c4" class="outline-2">
<h2 id="orgccfe3c4"><span class="section-number-2">1</span> Addendum</h2>
<div class="outline-text-2" id="text-1">
<p>
Christopher Wellons <a href="http://disq.us/p/1kr76r9">pointed out</a> an important limitation of advice: they don't work on byte-compiled functions. Let's see what he means. Here is a simple function that will just multiply a Point object by an integer:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">to-be-bytten</span> (p1 n)
  (* p1 n))
</pre>
</div>

<pre class="example">
to-be-bytten

</pre>

<p>
Here it is in action, and here it works fine.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(to-be-bytten (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1) 2)
</pre>
</div>

<pre class="example">
[eieio-class-tag--Point 2 2]

</pre>

<p>
Now, let's byte-compile that function and try it again:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(byte-compile 'to-be-bytten)

(<span style="color: #0000FF;">condition-case</span> err
    (to-be-bytten (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1) 2)
  ((<span style="color: #ff0000; font-weight: bold;">error</span> r)
   (message <span style="color: #008000;">"Doh! Christopher was right. It did not work...\n%s"</span> err)))
</pre>
</div>

<pre class="example">
Doh! Christopher was right. It did not work...
(wrong-type-argument number-or-marker-p [eieio-class-tag--Point 1 1])

</pre>

<p>
So the advice is pretty limited since most of the functions in Emacs core are likely to be byte-compiled, and it might mean you have to redefine * completely, or define some new function that looks like it. Too bad, the advice was pretty easy! 
</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/23/Overloading-mathematical-operators-in-elisp.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/23/Overloading-mathematical-operators-in-elisp#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="A-callable-plist-data-structure-for-Emacs"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/04/16/A-callable-plist-data-structure-for-Emacs/" rel="bookmark" title="Permanent Link to A callable plist data structure for Emacs">A callable plist data structure for Emacs</a></h2>
      <p><small><span class="blog_post_date">Posted April 16, 2017 at 04:44 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/macro/'>macro</a>, <a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/elisp/'>elisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/04/16/A-callable-plist-data-structure-for-Emacs#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated February 04, 2018 at 05:06 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb831a3d">1. An update <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-04-21 Fri&gt;</span></span></a></li>
</ul>
</div>
</div>
<p>
Emacs lisp has a few data structures that store key-value pairs. Here are some canonical examples of these data structures and the way to get data out of them.
</p>

<ul class="org-ul">
<li>a-lists</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((data '((key1 . 4)
              (key2 . <span style="color: #008000;">"tree"</span>))))
  (cdr (assoc 'key2 data)))
</pre>
</div>

<pre class="example">
tree

</pre>

<ul class="org-ul">
<li>p-lists</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((data '(<span style="color: #006FE0;">:key1</span> 4 <span style="color: #006FE0;">:key2</span> <span style="color: #008000;">"tree"</span>)))
  (plist-get data <span style="color: #006FE0;">:key2</span>))
</pre>
</div>

<pre class="example">
tree

</pre>

<ul class="org-ul">
<li>A hash table</li>
</ul>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((data #s(hash-table data (key1 4 key2 <span style="color: #008000;">"tree"</span>))))
  (gethash 'key2 data))
</pre>
</div>

<pre class="example">
tree

</pre>

<p>
Each of these uses some function to get data out of them. I have been learning about closures today, and realized a way you can make a "callable" data structure using them. In a closure, the data is stored as part of a function. We will use a <a href="http://letoverlambda.com">"let over lambda"</a> with a defalias in a lexical environment to achieve this. I will wrap a p-list with this approach, but it could work with any of the examples above. We will make the function have a few behaviors that allow us to see the whole data structure with no args, to get a value with one arg that is a key, and to set a value if there are more than two args add them as key-val pairs to the data structure. This block binds the function to the symbol "d" which is then a callable function.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((data '(<span style="color: #006FE0;">:key1</span> 4 <span style="color: #006FE0;">:key2</span> <span style="color: #008000;">"tree"</span>)))
  (<span style="color: #0000FF;">defalias</span> '<span style="color: #006699;">d</span>
    (<span style="color: #0000FF;">lambda</span> (<span style="color: #6434A3;">&amp;rest</span> key-vals)
      (<span style="color: #0000FF;">cond</span>
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">no args, return data</span>
       ((= 0 (length key-vals))
        data)
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">just a key, get val</span>
       ((= 1 (length key-vals))
        (plist-get data (car key-vals)))
       (t
        (<span style="color: #0000FF;">loop</span> for key in (-slice key-vals 0 nil 2)
              for val in (-slice key-vals 1 nil 2)
              do
              (plist-put data key val))
        data)))))
</pre>
</div>

<pre class="example">
d

</pre>

<p>
Now we can use it like to get some data out:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d <span style="color: #006FE0;">:key2</span>)
</pre>
</div>

<pre class="example">
tree

</pre>

<p>
And add new values like:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d <span style="color: #006FE0;">:key3</span> <span style="color: #008000;">"oak"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">:key1</td>
<td class="org-right">4</td>
<td class="org-left">:key2</td>
<td class="org-left">tree</td>
<td class="org-left">:key3</td>
<td class="org-left">oak</td>
</tr>
</tbody>
</table>

<p>
You can update a value with this too:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d <span style="color: #006FE0;">:key3</span> <span style="color: #008000;">"pine"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">:key1</td>
<td class="org-right">4</td>
<td class="org-left">:key2</td>
<td class="org-left">tree</td>
<td class="org-left">:key3</td>
<td class="org-left">pine</td>
</tr>
</tbody>
</table>

<p>
or add multiple values like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d <span style="color: #006FE0;">:key4</span> 0 <span style="color: #006FE0;">:key5</span> 9)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">:key1</td>
<td class="org-right">4</td>
<td class="org-left">:key2</td>
<td class="org-left">tree</td>
<td class="org-left">:key3</td>
<td class="org-left">pine</td>
<td class="org-left">:key4</td>
<td class="org-right">0</td>
<td class="org-left">:key5</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>

<p>
And see the whole plist with no args:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">:key1</td>
<td class="org-right">4</td>
<td class="org-left">:key2</td>
<td class="org-left">tree</td>
<td class="org-left">:key3</td>
<td class="org-left">pine</td>
<td class="org-left">:key4</td>
<td class="org-right">0</td>
<td class="org-left">:key5</td>
<td class="org-right">9</td>
</tr>
</tbody>
</table>

<p>
Pretty nice! It seems like there ought to be a macro to facilitate creating those. Here is one.
This macro basically expands to the same code as above, but for fun I add a default value option.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">default-dict</span> (var <span style="color: #6434A3;">&amp;optional</span> default <span style="color: #6434A3;">&amp;rest</span> key-vals)
  <span style="color: #036A07;">"Bind a callable plist to VAR that contains KEY-VALS."</span>
  (<span style="color: #0000FF;">let</span> ()
    `<span style="color: #D0372D;">(let ((data </span>',key-vals))
       (<span style="color: #0000FF;">defalias</span> ',var
         (<span style="color: #0000FF;">lambda</span> (<span style="color: #6434A3;">&amp;rest</span> key-vals)
           (message <span style="color: #008000;">"%s"</span> key-vals)
           (<span style="color: #0000FF;">cond</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">no args, return data</span>
            ((= 0 (length key-vals))
             data)
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">just a key, get val</span>
            ((= 1 (length key-vals))
             (<span style="color: #0000FF;">or</span>  (plist-get data (car key-vals)) ,default))
            (t
             (<span style="color: #0000FF;">loop</span> for key in (-slice key-vals 0 nil 2)
                   for val in (-slice key-vals 1 nil 2)
                   do
                   (plist-put data key val))
             data)))))))
</pre>
</div>

<p>
Here is an instance of it.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(default-dict d2 <span style="color: #008000;">"None"</span> <span style="color: #006FE0;">:key1</span> 4 <span style="color: #006FE0;">:key2</span> <span style="color: #008000;">"tree"</span>)
</pre>
</div>

<pre class="example">
d2

</pre>

<p>
And here it is in use.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d2 <span style="color: #006FE0;">:key1</span>)
</pre>
</div>

<pre class="example">
4

</pre>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(d2 <span style="color: #006FE0;">:new-key</span>)
</pre>
</div>

<pre class="example">
None

</pre>

<p>
Not bad. If you come from Python, you might find this style of data structure to be more similar to what you are used to seeing. It sure seems less verbose than the usual plist boilerplate I have used before.
</p>

<div id="outline-container-orgb831a3d" class="outline-2">
<h2 id="orgb831a3d"><span class="section-number-2">1</span> An update <span class="timestamp-wrapper"><span class="timestamp">&lt;2017-04-21 Fri&gt;</span></span></h2>
<div class="outline-text-2" id="text-1">
<p>
One (perhaps undesirable even) feature of the approach above is that it creates a function in the global namespace. This might have unintended consequences with name clashes or shadowing, and if you later use the same variable name for a plist, you would change the function behavior. Here we consider a way to limit the scope of where these functions exist and work. The labels macro provides one way to do this, we just create temporary functions that only exist within a scope. There is a lot of backticking and comma operators in this, and it took quite a few iterations to get it working!
</p>

<p>
This macro creates temporary functions for each keyword that return the value in the plist.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">with-dict</span> (key-vals <span style="color: #6434A3;">&amp;rest</span> body)
  <span style="color: #036A07;">"A context-manager for a plist where each key is a callable</span>
<span style="color: #036A07;">function that returns the value."</span>
  (<span style="color: #0000FF;">declare</span> (indent 1))
  (<span style="color: #0000FF;">let*</span> ((g (<span style="color: #0000FF;">if</span> (symbolp key-vals)
                (symbol-value key-vals)
              key-vals))
         (keys (-slice g 0 nil 2)))
    `(<span style="color: #0000FF;">labels</span> ,(<span style="color: #0000FF;">loop</span> for key in keys
                    collect
                    (list key '() `<span style="color: #D0372D;">(plist-get </span>',g  ,key)))
       ,@body)))
</pre>
</div>

<pre class="example">
with-dict

</pre>

<p>
Here is how we use it:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(with-dict (<span style="color: #006FE0;">:a</span> 1 <span style="color: #006FE0;">:b</span> 'some-symbol <span style="color: #006FE0;">:c</span> 3)
  (<span style="color: #006FE0;">:b</span>))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">quote</td>
<td class="org-left">some-symbol</td>
</tr>
</tbody>
</table>

<p>
We can also use it with variables that hold mappings like this.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((d '(<span style="color: #006FE0;">:key1</span> 1 <span style="color: #006FE0;">:key2</span> some-other-symbol <span style="color: #006FE0;">:key3</span> 3)))
  (with-dict d
    (format <span style="color: #008000;">"We got %s"</span> (<span style="color: #006FE0;">:key2</span>))))
</pre>
</div>

<pre class="example">
We got some-other-symbol

</pre>

<p>
That is pretty interesting! In case that looks similar to a context manager in Python, now you know where Python got that idea ;)
</p>

<p>
Another related idea is to let-bind the values to variables within a scope. We can't use the keywords directly here, so I use some hackery to strip off the colon so it is a regular symbol. That is not quite as nice I guess since you have to remember to remove the : from the symbols in the body of your code.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">with-plist-vals</span> (plist <span style="color: #6434A3;">&amp;rest</span> body)
  <span style="color: #036A07;">"Bind the values of a plist to variables with the name of the keys."</span>
  (<span style="color: #0000FF;">declare</span> (indent 1))
  `(<span style="color: #0000FF;">let</span> ,(<span style="color: #0000FF;">loop</span> for key in (-slice plist 0 nil 2)
               for val in (-slice plist 1 nil 2)
               collect (list (intern
                              (substring (symbol-name key) 1))
                             val))
     ,@body))
</pre>
</div>

<pre class="example">
with-plist-vals

</pre>

<p>
Here is an example usage.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(with-plist-vals (<span style="color: #006FE0;">:a</span> 4 <span style="color: #006FE0;">:b</span> 6)
 (* 2 a))
</pre>
</div>

<pre class="example">
8

</pre>

<p>
Obviously that is just an alternate syntax for the let statement, but it lets you leverage the plist syntax for multiple purposes.</p>
</div>
</div>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/04/16/A-callable-plist-data-structure-for-Emacs.org">org-mode source</a></p>
<p>Org-mode version = 9.1.6</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/04/16/A-callable-plist-data-structure-for-Emacs#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="A-better-defun-for-emacs-lisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/03/22/A-better-defun-for-emacs-lisp/" rel="bookmark" title="Permanent Link to A better defun for emacs-lisp">A better defun for emacs-lisp</a></h2>
      <p><small><span class="blog_post_date">Posted March 22, 2017 at 04:30 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/macro/'>macro</a>, <a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/elisp/'>elisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/03/22/A-better-defun-for-emacs-lisp#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated October 15, 2017 at 01:57 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org20fd352">1. Summary</a></li>
</ul>
</div>
</div>
<p>
I have been thinking of better ways to write code that is more likely to have decent docstrings that are up to date, and maybe that enable automatic validation. One strategy is to keep documentation and code together, and by together I mean <i>close together</i>. The closer the better.  I made some interesting progress in the <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/19/A-Hy-macro-for-defining-functions-with-docstrings-on-each-argument/">last post</a>, where I used a macro to let me put argument specific documentation in the same place that the argument is defined. Here I expand the idea to also provide argument default values, and validation code where the argument is defined inside the function, in addition to generating docstrings. This post is written in Emacs-lisp, mostly because I am more familiar with the macro language. The idea should apply to other lisps too.
</p>

<p>
Let's consider this prototypical, vanilla function definition, usage, and docstring.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">f1</span> (arg1 arg2)
  <span style="color: #036A07;">"Add two numbers."</span>
  (+ arg1 arg2))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">usage</span>
(f1 3 4)
</pre>
</div>

<pre class="example">
7

</pre>

<p>
Here is what the help looks like from emacs.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'f1)
</pre>
</div>

<pre class="example">
f1 is a Lisp function.

(f1 ARG1 ARG2)

For more information check the manuals.

Add two numbers.

</pre>

<p>
It is clear I was lazy in writing the docstring; it does not even mention the arguments. There is also no validation of the arguments so if you pass a string and a number, you will get an error. There are no defaults either, so you have to provide both arguments. It seems like there could be significant room for improvement. Of course, I could bite the bullet and write a better function like this one:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">f1a</span> (arg1 <span style="color: #6434A3;">&amp;optional</span> arg2)
  <span style="color: #036A07;">"Add ARG1 and ARG2 together.</span>
<span style="color: #036A07;">ARG1 and  ARG2 should both be numbers."</span>
  (<span style="color: #0000FF;">when</span> (null arg2) (<span style="color: #0000FF;">setq</span> arg2 2))
  (<span style="color: #0000FF;">unless</span> (<span style="color: #0000FF;">and</span> (numberp arg1) (numberp arg2)) (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"arg1 and arg2 should both be numbers"</span>))
  (+ arg1 arg2))

(list (f1a 3 4) (f1a 3))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">7</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>

<p>
Yes, I could do that, but it is tedious to do it all the time. And it still leaves something to be desired for me. The docstring does not say what the default value is for example, and that is hard-coded in the code, i.e. not introspectible until you look at the code.  Next we consider an alternative way to write the function. Compare that to this function definition, usage and documentation. The function definition is a little more verbose. Providing documentation, defaults and validation code in any form would make it that way no matter what.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defn f2 ((arg1 <span style="color: #008000;">"A number"</span> <span style="color: #006FE0;">:validate</span> numberp)
          (arg2 <span style="color: #008000;">"A number"</span> <span style="color: #006FE0;">:validate</span> numberp <span style="color: #006FE0;">:default</span> 2))
  <span style="color: #008000;">"Add the arguments."</span>
  (+ arg1 arg2))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">usage</span>
(list (f2 3 4) (f2 3))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">7</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'f2)
</pre>
</div>

<pre class="example">
f2 is a Lisp function.

(f2 ARG1 &amp;optional ARG2)

For more information check the manuals.

Add the arguments.
ARG1 : A number (valid = numberp)
ARG2 : A number (default = 2) (valid = numberp)

</pre>

<p>
The documentation is built up from the information in the function definition, in a form that is mostly consistent with emacs-lisp documentation standards. <code>defn</code> is not a regular emacs-lisp function; it is a macro I developed to generate the function code. It turned out to be long, but the gist of it is that before defining the function I loop through the arguments and collect the docstrings, along with any information about default values and/or validation functions. Then I build up the list of arguments to put in the function. Then if any default values are set, I generate some code to set those values if they are not set in the function call, and finally a similar block of validation code. At the end, I construct the defun and return it. You can check out the code if you want here: <a href="https://github.com/jkitchin/scimax/blob/master/scimax-macros.el">https://github.com/jkitchin/scimax/blob/master/scimax-macros.el</a>.
</p>

<p>
Let's take a look at what this code expands to.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(macroexpand-1
 '(defn f2 ((arg1 <span style="color: #008000;">"A number"</span> <span style="color: #006FE0;">:validate</span> numberp)
            (arg2 <span style="color: #008000;">"A number"</span> <span style="color: #006FE0;">:validate</span> numberp <span style="color: #006FE0;">:default</span> 2))
    <span style="color: #008000;">"Add the arguments."</span>
    (+ arg1 arg2)))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">f2</span>
    (arg1 <span style="color: #6434A3;">&amp;optional</span> arg2)
  <span style="color: #036A07;">"Add the arguments.\nARG1 : A number (valid = numberp)\nARG2 : A number (default = 2) (valid = numberp)\n"</span>
  (<span style="color: #0000FF;">progn</span>
    (<span style="color: #0000FF;">when</span>
        (null arg2)
      (<span style="color: #0000FF;">setq</span> arg2 2)))
  (<span style="color: #0000FF;">progn</span>
    (<span style="color: #0000FF;">unless</span>
        (funcall 'numberp arg1)
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"In (%s %s) Expected %s to pass %S. Got %S"</span> <span style="color: #008000;">"f2"</span> <span style="color: #008000;">"(arg1 &amp;optional arg2)"</span> <span style="color: #008000;">"arg1"</span> 'numberp arg1))
    (<span style="color: #0000FF;">unless</span>
        (funcall 'numberp arg2)
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"In (%s %s) Expected %s to pass %S. Got %S"</span> <span style="color: #008000;">"f2"</span> <span style="color: #008000;">"(arg1 &amp;optional arg2)"</span> <span style="color: #008000;">"arg2"</span> 'numberp arg2)))
  (+ arg1 arg2))
</pre>
</div>

<p>
You can see it expands to a regular defun, with a generated docstring, generated default settings code block, and generated validation code. Pretty nice.
</p>

<p>
Let's see what happens with a function that fails the validation. We should get an error. Here we capture the error so we can see it in the post.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">condition-case</span> err
    (f2 <span style="color: #008000;">"oak"</span>)
  (<span style="color: #ff0000; font-weight: bold;">error</span>
   (error-message-string err)))
</pre>
</div>

<pre class="example">
In (f2 (arg1 &amp;optional arg2)) Expected arg1 to pass numberp. Got "oak"

</pre>

<p>
So we even get a useful error message when the wrong type of argument is provided. Compare that to the error message from the original version of this function. It tells us we got the wrong type, but not which argument.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">condition-case</span> err
    (f1 <span style="color: #008000;">"oak"</span> 4)
  (<span style="color: #ff0000; font-weight: bold;">error</span>
   (error-message-string err)))
</pre>
</div>

<pre class="example">
Wrong type argument: number-or-marker-p, "oak"

</pre>

<p>
One last example to check out the &amp;rest argument, with validation that every arg is a number.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(defn f4 ((rarg <span style="color: #006FE0;">:rest</span>
                <span style="color: #006FE0;">:validate</span> (<span style="color: #0000FF;">lambda</span> (x)
                            (-all-p 'identity (mapcar 'numberp x)))))
  <span style="color: #008000;">"multiply all the arguments."</span>
  (apply '* rarg))

(f4 1 2 3)
</pre>
</div>

<pre class="example">
6

</pre>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">condition-case</span> err
    (f4 <span style="color: #008000;">"oak"</span> 4)
  (<span style="color: #ff0000; font-weight: bold;">error</span>
   (error-message-string err)))
</pre>
</div>

<pre class="example">
In (f4 (&amp;rest rarg)) Expected rarg to pass (lambda (x) (-all-p (quote identity) (mapcar (quote numberp) x))). Got ("oak" 4)

</pre>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'f4)
</pre>
</div>

<pre class="example">
f4 is a Lisp function.

(f4 &amp;rest RARG)

For more information check the manuals.

multiply all the arguments.
RARG : No documentation

</pre>

<p>
That looks ok too.
</p>

<div id="outline-container-org20fd352" class="outline-2">
<h2 id="org20fd352"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
The motivation for this was to help me write better code with better documentation. Better code in the sense that it can provide run-time validation, with better feedback, and automatic documentation, including that there is none if that is the case. It is basically compatible with the regular defun, but enhances what kind of documentation is possible with less work on my part. I think it will make it easier to keep documentation in sync, since the argument documentation would be kept near the argument, and you can build in validation if you want to.
</p>

<p>
It is no news to lispers that macros are good for this kind of application.</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/03/22/A-better-defun-for-emacs-lisp.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/03/22/A-better-defun-for-emacs-lisp#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis/">A differentiable ODE integrator for sensitivity analysis</a></li>
      <li><a href="/blog/2018/10/10/Autograd-and-the-derivative-of-an-integral-function/">Autograd and the derivative of an integral function</a></li>
      <li><a href="/blog/2018/10/09/Compressibility-variation-from-an-implicit-equation-of-state/">Compressibility variation from an implicit equation of state</a></li>
      <li><a href="/blog/2018/10/08/Getting-derivatives-from-implicit-functions-with-autograd/">Getting derivatives from implicit functions with autograd</a></li>
      <li><a href="/blog/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches/">Compressibility factor variation from the van der Waals equation by three different approaches</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



