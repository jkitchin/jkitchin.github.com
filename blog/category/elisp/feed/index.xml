<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Sun, 15 Oct 2017 20:47:07 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Overloading mathematical operators in elisp</title>
      <link>http://jkitchin.github.io/blog/2017/07/23/Overloading-mathematical-operators-in-elisp</link>
      <pubDate>Sun, 23 Jul 2017 14:13:41 EDT</pubDate>
      <category><![CDATA[elisp]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">6wjMw9DC1Qi0d1qlZyaOfJiHcbA=</guid>
      <description>Overloading mathematical operators in elisp</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgccfe3c4"&gt;1. Addendum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In Python I am used to some simple idioms like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;([1, 2, 3] * 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;"ab"&lt;/span&gt; * 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
[1, 2, 3, 1, 2, 3]
ababab
&lt;/p&gt;

&lt;p&gt;
There is even such fanciness as defining operators for objects, as long as they have the appropriate dunder methods defined:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Point&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x = x
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y = y

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__str__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Point ({}, {})"&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__mul__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Point(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * a, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y * a)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__rmul__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Point(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * a, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y * a)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   
&lt;span style="color: #BA36A5;"&gt;p&lt;/span&gt; = Point(1, 1)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(p * 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(3 * p)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Point (2, 2)
Point (3, 3)
&lt;/p&gt;

&lt;p&gt;
Out of the box, these things are not possible in elisp. Operators like  * in elisp only take numbers or markers. We have a few options to change this. The worst option is to simply redefine these functions. That is bad because it is not reversible. We could define new functions that have the behavior we want, but then we lose the semantic meaning of "*" that we were aiming for. A better option is to &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html"&gt;advise&lt;/a&gt; these functions. This is reversible, because you can later unadvise them. Today we look at some strategies to do this.
&lt;/p&gt;

&lt;p&gt;
We will use "around" advise because it will let us bypass the original intent of the function when we want to, or use it when we do. First, we create a function that will be the advice and add it to the * function. This first draft won't actually change the behavior of *; if all the args are numbers or markers it will simply use the original function as before.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;dash&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))))

(advice-add '* &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; #'*--*-around)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Let's just confirm
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(* 1 2 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6

&lt;/pre&gt;

&lt;p&gt;
Now, we can start modifying our function to handle some other cases. Let's do the list and string first. The * function is variadic, but in these cases it makes sense to limit to two arguments. We need two cases for each type since we can write (* 2 list) or (* list 2). We also should create a fall-through case that raises an error to alert us we can't multiply things.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The original behavior&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create repeated copies of list&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) append (copy-list (first args))))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) append (copy-list (second args))))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make repeated string&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) concat (first args)))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) concat (second args)))

   (t
    (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"You cannot * %s"&lt;/span&gt; args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
*--*-around

&lt;/pre&gt;

&lt;p&gt;
Here is the new advice in action. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(list
 (* '(a b) 2)
 (* 2 '(c d))
 (* 2 &lt;span style="color: #008000;"&gt;"ab"&lt;/span&gt;)
 (* &lt;span style="color: #008000;"&gt;"cd"&lt;/span&gt; 2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;(a b a b)&lt;/td&gt;
&lt;td class="org-left"&gt;(c d c d)&lt;/td&gt;
&lt;td class="org-left"&gt;abab&lt;/td&gt;
&lt;td class="org-left"&gt;cdcd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That captures the spirit of overloading * for lists and strings. What about that object example? We have to make some assumptions here. Python looks for an uses a dunder &lt;span class="underline"&gt;&lt;span class="underline"&gt;mul&lt;/span&gt;&lt;/span&gt; method. We will assume a double dash method (&amp;#x2013;mul&amp;#x2013;) in a similar spirit. We have to modify the advice one final time. We just add a condition to check if one of the arguments is an eieio-object, and then call the &amp;#x2013;mul&amp;#x2013; function on the arguments.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The original behavior&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create repeated copies of list&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) append (copy-list (first args))))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) append (copy-list (second args))))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make repeated string&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) concat (first args)))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) concat (second args)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Handle object&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (eieio-object-p (first args))
             (numberp (second args)))
        (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (numberp (first args))
             (eieio-object-p (second args))))
    (apply '--mul-- args))

   (t
    (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"You cannot * %s"&lt;/span&gt; args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
*--*-around

&lt;/pre&gt;

&lt;p&gt;
Now, we can define a class and the &amp;#x2013;mul&amp;#x2013; function and show that our overloaded * function works. Note we can define two signatures of &amp;#x2013;mul&amp;#x2013; so it is not necessary to define an &amp;#x2013;rmul&amp;#x2013; in this case as it was with Python (although we still create two functions in the end).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;eieio&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defclass&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Point&lt;/span&gt; ()
  ((x &lt;span style="color: #006FE0;"&gt;:initarg&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;)
   (y &lt;span style="color: #006FE0;"&gt;:initarg&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--mul--&lt;/span&gt; ((p Point) a)
  (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) a) &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;) a)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--mul--&lt;/span&gt; (a (p Point))
  (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) a) &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;) a)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--str--&lt;/span&gt; ((p Point))
  (format &lt;span style="color: #008000;"&gt;"Point (%s, %s)"&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((P (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Point (2, 2)&lt;/td&gt;
&lt;td class="org-left"&gt;Point (3, 3)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That is pretty awesome. Before going on, here is how you remove the advice:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(advice-remove '* '*--*-around)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This example has been pretty instructive. You have to handle overloading for all the intrinsic types. We did lists and strings here; you might also consider vectors. For objects, it looks like we can at least try using a generic method like &amp;#x2013;mul&amp;#x2013;. One detail I neglected to consider here is that * is natively variadic. For these special cases, we did not implement variadic versions. This isn't a feature of Python which uses infix notation, so every call is with two arguments. In some cases it might make sense to support variadic args, but that seems like a generally challenging thing to do. While (* "a" 2 3) might be expected to create a string of "aaaaaa", (* "a" 2 '(3)) doesn't make sense at all.
&lt;/p&gt;

&lt;p&gt;
It would be straightforward to extend this to other operators like '+ to concatenate strings, lists and vectors, or '- to remove chars or elements, including extensions to objects using double-dash functions like &amp;#x2013;add&amp;#x2013;, &amp;#x2013;subtract&amp;#x2013;, etc. Another nice idea might be to advise print to use &amp;#x2013;str&amp;#x2013; on objects.
&lt;/p&gt;

&lt;p&gt;
On the surface this looks useful so far. Python defines &lt;i&gt;a lot&lt;/i&gt; of dunder methods that cover all kinds of scenarios including logical comparisons, bit shifting, mod, incrementing operators, casting, comparisons, right/left operations, indexing and assignment, length and others. That would be a lot of advices. This approach is moderately tedious to expand though; you have to keep adding conditional cases. 
&lt;/p&gt;

&lt;p&gt;
An alternative to the big conditional statement used in the advice might be the use of a &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html"&gt;generic function&lt;/a&gt;. With this approach we define a generic function that just does multiplication by default. Then we define specific cases with specific signatures that are used for lists, strings, objects, etc. That is basically all our conditional above was doing, matching signatures and executing a chunk of code accordingly.
&lt;/p&gt;

&lt;p&gt;
Here is our default case that does the original behavior. We still use advice to apply the function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defgeneric&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"Generic multiply for when no specific case exists."&lt;/span&gt;
  (apply orig-fun args))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around-generic&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  (apply 'generic-multiply orig-fun args))

(advice-add '* &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; #'*--*-around-generic)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That should just work as usual for regular multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(* 1 2 3 4)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
24

&lt;/pre&gt;

&lt;p&gt;
Sure enough it does. Now, we can define a specific method for a string. We need a specialized method for each signature, e.g. pre and post multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (s string) (n integer))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n concat s))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (s string))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n concat s))

(list
 (* &lt;span style="color: #008000;"&gt;"Ac"&lt;/span&gt; 2)
 (* 2 &lt;span style="color: #008000;"&gt;"Ad"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;AcAc&lt;/td&gt;
&lt;td class="org-left"&gt;AdAd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That works fine, and we did not have to modify our original advice function at all! Next the  list:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (L list) (n integer))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n append (copy-list L)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (L list))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n append (copy-list L)))

(list (* '(1 2) 2)
      (* 2 '(3 4)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That also works fine. Last, our class example. This should work on all objects I think (unless there is some way to make classes that do not inherit the default superclass).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (obj eieio-default-superclass))
  (--mul-- n obj))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (obj eieio-default-superclass) (n integer))
  (--mul-- n obj))

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((P (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Point (2, 2)&lt;/td&gt;
&lt;td class="org-left"&gt;Point (3, 3)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
This is a much better approach to extending the multiplication operator! If I continue this path in the future I would probably take this one.  This could be useful to make elisp more like some more popular contemporary languages like Python, as well as to add linear algebra like notation or mathematical operations on objects in elisp. It kind of feels like these operations ought to be generic functions to start with to make this kind of overloading easier from the beginning.  Functions like "*" are currently defined in the C source code though, maybe for performance reasons. It is not obvious what the consequences of making them generic might be.
&lt;/p&gt;

&lt;div id="outline-container-orgccfe3c4" class="outline-2"&gt;
&lt;h2 id="orgccfe3c4"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Addendum&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Christopher Wellons &lt;a href="http://disq.us/p/1kr76r9"&gt;pointed out&lt;/a&gt; an important limitation of advice: they don't work on byte-compiled functions. Let's see what he means. Here is a simple function that will just multiply a Point object by an integer:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;to-be-bytten&lt;/span&gt; (p1 n)
  (* p1 n))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
to-be-bytten

&lt;/pre&gt;

&lt;p&gt;
Here it is in action, and here it works fine.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(to-be-bytten (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1) 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[eieio-class-tag--Point 2 2]

&lt;/pre&gt;

&lt;p&gt;
Now, let's byte-compile that function and try it again:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(byte-compile 'to-be-bytten)

(&lt;span style="color: #0000FF;"&gt;condition-case&lt;/span&gt; err
    (to-be-bytten (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1) 2)
  ((&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; r)
   (message &lt;span style="color: #008000;"&gt;"Doh! Christopher was right. It did not work...\n%s"&lt;/span&gt; err)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Doh! Christopher was right. It did not work...
(wrong-type-argument number-or-marker-p [eieio-class-tag--Point 1 1])

&lt;/pre&gt;

&lt;p&gt;
So the advice is pretty limited since most of the functions in Emacs core are likely to be byte-compiled, and it might mean you have to redefine * completely, or define some new function that looks like it. Too bad, the advice was pretty easy! 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/23/Overloading-mathematical-operators-in-elisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A callable plist data structure for Emacs</title>
      <link>http://jkitchin.github.io/blog/2017/04/16/A-callable-plist-data-structure-for-Emacs</link>
      <pubDate>Sun, 16 Apr 2017 16:44:53 EDT</pubDate>
      <category><![CDATA[elisp]]></category>
      <category><![CDATA[macro]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">g-L-SDSuJKkcZwHQyGqqiWpzU7k=</guid>
      <description>A callable plist data structure for Emacs</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbe53949"&gt;1. An update &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2017-04-21 Fri&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Emacs lisp has a few data structures that store key-value pairs. Here are some canonical examples of these data structures and the way to get data out of them.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;a-lists&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data '((key1 . 4)
              (key2 . &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;))))
  (cdr (assoc 'key2 data)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;p-lists&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data '(&lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;)))
  (plist-get data &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;A hash table&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data #s(hash-table data (key1 4 key2 &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;))))
  (gethash 'key2 data))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Each of these uses some function to get data out of them. I have been learning about closures today, and realized a way you can make a "callable" data structure using them. In a closure, the data is stored as part of a function. We will use a &lt;a href="http://letoverlambda.com"&gt;"let over lambda"&lt;/a&gt; with a defalias in a lexical environment to achieve this. I will wrap a p-list with this approach, but it could work with any of the examples above. We will make the function have a few behaviors that allow us to see the whole data structure with no args, to get a value with one arg that is a key, and to set a value if there are more than two args add them as key-val pairs to the data structure. This block binds the function to the symbol "d" which is then a callable function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data '(&lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;)))
  (&lt;span style="color: #0000FF;"&gt;defalias&lt;/span&gt; '&lt;span style="color: #006699;"&gt;d&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; key-vals)
      (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;no args, return data&lt;/span&gt;
       ((= 0 (length key-vals))
        data)
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;just a key, get val&lt;/span&gt;
       ((= 1 (length key-vals))
        (plist-get data (car key-vals)))
       (t
        (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in (-slice key-vals 0 nil 2)
              for val in (-slice key-vals 1 nil 2)
              do
              (plist-put data key val))
        data)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we can use it like to get some data out:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And add new values like:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key3&lt;/span&gt; &lt;span style="color: #008000;"&gt;"oak"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You can update a value with this too:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key3&lt;/span&gt; &lt;span style="color: #008000;"&gt;"pine"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
or add multiple values like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key4&lt;/span&gt; 0 &lt;span style="color: #006FE0;"&gt;:key5&lt;/span&gt; 9)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And see the whole plist with no args:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Pretty nice! It seems like there ought to be a macro to facilitate creating those. Here is one.
This macro basically expands to the same code as above, but for fun I add a default value option.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;default-dict&lt;/span&gt; (var &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; default &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; key-vals)
  &lt;span style="color: #036A07;"&gt;"Bind a callable plist to VAR that contains KEY-VALS."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ()
    `&lt;span style="color: #D0372D;"&gt;(let ((data &lt;/span&gt;',key-vals))
       (&lt;span style="color: #0000FF;"&gt;defalias&lt;/span&gt; ',var
         (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; key-vals)
           (message &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt; key-vals)
           (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;no args, return data&lt;/span&gt;
            ((= 0 (length key-vals))
             data)
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;just a key, get val&lt;/span&gt;
            ((= 1 (length key-vals))
             (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt;  (plist-get data (car key-vals)) ,default))
            (t
             (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in (-slice key-vals 0 nil 2)
                   for val in (-slice key-vals 1 nil 2)
                   do
                   (plist-put data key val))
             data)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is an instance of it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;default-dict&lt;/span&gt; d2 &lt;span style="color: #008000;"&gt;"None"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And here it is in use.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d2 &lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d2 &lt;span style="color: #006FE0;"&gt;:new-key&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Not bad. If you come from Python, you might find this style of data structure to be more similar to what you are used to seeing. It sure seems less verbose than the usual plist boilerplate I have used before.
&lt;/p&gt;

&lt;div id="outline-container-orgbe53949" class="outline-2"&gt;
&lt;h2 id="orgbe53949"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; An update &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2017-04-21 Fri&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
One (perhaps undesirable even) feature of the approach above is that it creates a function in the global namespace. This might have unintended consequences with name clashes or shadowing, and if you later use the same variable name for a plist, you would change the function behavior. Here we consider a way to limit the scope of where these functions exist and work. The labels macro provides one way to do this, we just create temporary functions that only exist within a scope. There is a lot of backticking and comma operators in this, and it took quite a few iterations to get it working!
&lt;/p&gt;

&lt;p&gt;
This macro creates temporary functions for each keyword that return the value in the plist.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;with-dict&lt;/span&gt; (key-vals &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  &lt;span style="color: #036A07;"&gt;"A context-manager for a plist where each key is a callable&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;function that returns the value."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;declare&lt;/span&gt; (indent 1))
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((g (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (symbolp key-vals)
                (symbol-value key-vals)
              key-vals))
         (keys (-slice g 0 nil 2)))
    `(&lt;span style="color: #0000FF;"&gt;labels&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in keys
                    collect
                    (list key '() `&lt;span style="color: #D0372D;"&gt;(plist-get &lt;/span&gt;',g  ,key)))
       ,@body)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is how we use it:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-dict&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:a&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:b&lt;/span&gt; 'some-symbol &lt;span style="color: #006FE0;"&gt;:c&lt;/span&gt; 3)
  (&lt;span style="color: #006FE0;"&gt;:b&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can also use it with variables that hold mappings like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((d '(&lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; some-other-symbol &lt;span style="color: #006FE0;"&gt;:key3&lt;/span&gt; 3)))
  (&lt;span style="color: #0000FF;"&gt;with-dict&lt;/span&gt; d
    (format &lt;span style="color: #008000;"&gt;"We got %s"&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt;))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That is pretty interesting! In case that looks similar to a context manager in Python, now you know where Python got that idea ;)
&lt;/p&gt;

&lt;p&gt;
Another related idea is to let-bind the values to variables withing a scope. We can't use the keywords directly here, so I use some hackery to strip off the colon so it is a regular symbol. That is not quite as nice I guess since you have to remember to remove the : from the symbols in the body of your code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;with-plist-vals&lt;/span&gt; (plist &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  &lt;span style="color: #036A07;"&gt;"Bind the values of a plist to variables with the name of the keys."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;declare&lt;/span&gt; (indent 1))
  `(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in (-slice plist 0 nil 2)
               for val in (-slice plist 1 nil 2)
               collect (list (intern
                              (substring (symbol-name key) 1))
                             val))
     ,@body))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is an example usage.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-plist-vals&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:a&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:b&lt;/span&gt; 6)
 (* 2 a))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Obviously that is just an alternate syntax for the let statement, but it lets you leverage the plist syntax for multiple purposes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/04/16/A-callable-plist-data-structure-for-Emacs.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A better defun for emacs-lisp</title>
      <link>http://jkitchin.github.io/blog/2017/03/22/A-better-defun-for-emacs-lisp</link>
      <pubDate>Wed, 22 Mar 2017 16:30:33 EDT</pubDate>
      <category><![CDATA[elisp]]></category>
      <category><![CDATA[macro]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">RoQ2wpVtnKbGMQqdpFrDLjXCPWw=</guid>
      <description>A better defun for emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org56963be"&gt;1. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I have been thinking of better ways to write code that is more likely to have decent docstrings that are up to date, and maybe that enable automatic validation. One strategy is to keep documentation and code together, and by together I mean &lt;i&gt;close together&lt;/i&gt;. The closer the better.  I made some interesting progress in the &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/19/A-Hy-macro-for-defining-functions-with-docstrings-on-each-argument/"&gt;last post&lt;/a&gt;, where I used a macro to let me put argument specific documentation in the same place that the argument is defined. Here I expand the idea to also provide argument default values, and validation code where the argument is defined inside the function, in addition to generating docstrings. This post is written in Emacs-lisp, mostly because I am more familiar with the macro language. The idea should apply to other lisps too.
&lt;/p&gt;

&lt;p&gt;
Let's consider this prototypical, vanilla function definition, usage, and docstring.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;f1&lt;/span&gt; (arg1 arg2)
  &lt;span style="color: #036A07;"&gt;"Add two numbers."&lt;/span&gt;
  (+ arg1 arg2))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;usage&lt;/span&gt;
(f1 3 4)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is what the help looks like from emacs.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(describe-function 'f1)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It is clear I was lazy in writing the docstring; it does not even mention the arguments. There is also no validation of the arguments so if you pass a string and a number, you will get an error. There are no defaults either, so you have to provide both arguments. It seems like there could be significant room for improvement. Of course, I could bite the bullet and write a better function like this one:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;f1a&lt;/span&gt; (arg1 &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; arg2)
  &lt;span style="color: #036A07;"&gt;"Add ARG1 and ARG2 together.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;ARG1 and  ARG2 should both be numbers."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (null arg2) (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; arg2 2))
  (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (numberp arg1) (numberp arg2)) (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"arg1 and arg2 should both be numbers"&lt;/span&gt;))
  (+ arg1 arg2))

(list (f1a 3 4) (f1a 3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Yes, I could do that, but it is tedious to do it all the time. And it still leaves something to be desired for me. The docstring does not say what the default value is for example, and that is hard-coded in the code, i.e. not introspectible until you look at the code.  Next we consider an alternative way to write the function. Compare that to this function definition, usage and documentation. The function definition is a little more verbose. Providing documentation, defaults and validation code in any form would make it that way no matter what.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; f2 ((arg1 &lt;span style="color: #008000;"&gt;"A number"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:validate&lt;/span&gt; numberp)
          (arg2 &lt;span style="color: #008000;"&gt;"A number"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:validate&lt;/span&gt; numberp &lt;span style="color: #006FE0;"&gt;:default&lt;/span&gt; 2))
  &lt;span style="color: #008000;"&gt;"Add the arguments."&lt;/span&gt;
  (+ arg1 arg2))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;usage&lt;/span&gt;
(list (f2 3 4) (f2 3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(describe-function 'f2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The documentation is built up from the information in the function definition, in a form that is mostly consistent with emacs-lisp documentation standards. &lt;code&gt;defn&lt;/code&gt; is not a regular emacs-lisp function; it is a macro I developed to generate the function code. It turned out to be long, but the gist of it is that before defining the function I loop through the arguments and collect the docstrings, along with any information about default values and/or validation functions. Then I build up the list of arguments to put in the function. Then if any default values are set, I generate some code to set those values if they are not set in the function call, and finally a similar block of validation code. At the end, I construct the defun and return it. You can check out the code if you want here: &lt;a href="https://github.com/jkitchin/scimax/blob/master/scimax-macros.el"&gt;https://github.com/jkitchin/scimax/blob/master/scimax-macros.el&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Let's take a look at what this code expands to.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(macroexpand-1
 '(defn f2 ((arg1 &lt;span style="color: #008000;"&gt;"A number"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:validate&lt;/span&gt; numberp)
            (arg2 &lt;span style="color: #008000;"&gt;"A number"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:validate&lt;/span&gt; numberp &lt;span style="color: #006FE0;"&gt;:default&lt;/span&gt; 2))
    &lt;span style="color: #008000;"&gt;"Add the arguments."&lt;/span&gt;
    (+ arg1 arg2)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You can see it expands to a regular defun, with a generated docstring, generated default settings code block, and generated validation code. Pretty nice.
&lt;/p&gt;

&lt;p&gt;
Let's see what happens with a function that fails the validation. We should get an error. Here we capture the error so we can see it in the post.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;condition-case&lt;/span&gt; err
    (f2 &lt;span style="color: #008000;"&gt;"oak"&lt;/span&gt;)
  (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt;
   (error-message-string err)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
So we even get a useful error message when the wrong type of argument is provided. Compare that to the error message from the original version of this function. It tells us we got the wrong type, but not which argument.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;condition-case&lt;/span&gt; err
    (f1 &lt;span style="color: #008000;"&gt;"oak"&lt;/span&gt; 4)
  (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt;
   (error-message-string err)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
One last example to check out the &amp;amp;rest argument, with validation that every arg is a number.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; f4 ((rarg &lt;span style="color: #006FE0;"&gt;:rest&lt;/span&gt;
                &lt;span style="color: #006FE0;"&gt;:validate&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                            (-all-p 'identity (mapcar 'numberp x)))))
  &lt;span style="color: #008000;"&gt;"multiply all the arguments."&lt;/span&gt;
  (apply '* rarg))

(f4 1 2 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;condition-case&lt;/span&gt; err
    (f4 &lt;span style="color: #008000;"&gt;"oak"&lt;/span&gt; 4)
  (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt;
   (error-message-string err)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(describe-function 'f4)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That looks ok too.
&lt;/p&gt;

&lt;div id="outline-container-org56963be" class="outline-2"&gt;
&lt;h2 id="org56963be"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
The motivation for this was to help me write better code with better documentation. Better code in the sense that it can provide run-time validation, with better feedback, and automatic documentation, including that there is none if that is the case. It is basically compatible with the regular defun, but enhances what kind of documentation is possible with less work on my part. I think it will make it easier to keep documentation in sync, since the argument documentation would be kept near the argument, and you can build in validation if you want to.
&lt;/p&gt;

&lt;p&gt;
It is no news to lispers that macros are good for this kind of application.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/03/22/A-better-defun-for-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
