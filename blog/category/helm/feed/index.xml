<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>https://kitchingroup.cheme.cmu.edu/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Tue, 02 Jan 2024 13:58:49 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Modern use of helm - sortable candidates</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/01/24/Modern-use-of-helm-sortable-candidates</link>
      <pubDate>Sun, 24 Jan 2016 14:48:13 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">ZnitoN0_UnTciejiQ08oPeIrO0w=</guid>
      <description>Modern use of helm - sortable candidates</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="https://github.com/emacs-helm/helm"&gt;helm&lt;/a&gt; continues to be my goto completion engine. I was perusing the source for helm-top, and noticed some cool new features, like sorting the candidates in the completion buffer! I also noticed that helm sources are preferably created with some new factory functions (as opposed to the a-lists I used to use). Here I explore some of these and illustrate how to make a sortable helm source.
&lt;/p&gt;

&lt;p&gt;
First, we need a function to give us some candidates we will select from. I will use a function that returns a list of cons cells from a variable containing some data where each element in the data is a plist containing a number and key. I list strings as the number and key  so we can see what sorting does later. The data is just a list of plists containing a "number" and a key that is a string. We will create a helm function with these as candidates, and an ability to sort them in ascending/descending order on either the number or key.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-data '((&lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt; &lt;span style="color: #008000;"&gt;"apple"&lt;/span&gt;)
               (&lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt; 9 &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt; &lt;span style="color: #008000;"&gt;"berry"&lt;/span&gt;)
               (&lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt; 2 &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt; &lt;span style="color: #008000;"&gt;"cactus"&lt;/span&gt;)
               (&lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt; 5 &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt; &lt;span style="color: #008000;"&gt;"dog"&lt;/span&gt;)
               (&lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt; &lt;span style="color: #008000;"&gt;"frog"&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;h-candidates&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Returns candidates for the helm source."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for cand in h-data
        collect (cons (format &lt;span style="color: #008000;"&gt;"%s %s"&lt;/span&gt;
                              (plist-get cand &lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt;)
                              (plist-get cand &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt;))
                      cand)))

(print (h-candidates))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(("1 apple" :num 1 :key "apple") ("9 berry" :num 9 :key "berry") ("2 cactus" :num 2 :key "cactus") ("5 dog" :num 5 :key "dog") ("4 frog" :num 4 :key "frog"))
&lt;/pre&gt;


&lt;p&gt;
Now, provide sorting, we need to create a candidate transformer function. This function will take the current candidates and source, and return a new list of candidates, possibly sorted. We use a variable to store how to sort the candidates. We also need a way to trigger the sorting. We will bind M-&amp;lt;down&amp;gt; to a function that will set the sort function, and refresh helm. Here is a keymap definition we will use later.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;h-map&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((map (make-sparse-keymap)))
    (set-keymap-parent map helm-map)
    (define-key map (kbd &lt;span style="color: #008000;"&gt;"M-&amp;lt;down&amp;gt;"&lt;/span&gt;)   'h-sort)
    map)
  &lt;span style="color: #036A07;"&gt;"keymap for a helm source."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
h-map
&lt;/pre&gt;

&lt;p&gt;
Now, we define the sort variable, a function that sets the variable, refreshes the candidates, and finally resets the sort variable. A key point here is the sort functions must take two arguments, which will be two candidates, and each candidate is of the form (string . data). We want to sort on one of the elements in the data plists for this example.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;h-sort-fn&lt;/span&gt; nil)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;h-sort&lt;/span&gt; ()
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((action (read-char &lt;span style="color: #008000;"&gt;"#decreasing (d) | #increasing (i) | a-z (a) | z-a (z: "&lt;/span&gt;)))
    (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
     ((eq action ?d)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-sort-fn (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (c1 c2) (&amp;gt; (plist-get (cdr c1) &lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt;) (plist-get (cdr c2) &lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt;)))))
     ((eq action ?i)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-sort-fn (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (c1 c2) (&amp;lt; (plist-get (cdr c1) &lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt;) (plist-get (cdr c2) &lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt;)))))
     ((eq action ?a)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-sort-fn (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (c1 c2) (string&amp;lt; (plist-get (cdr c1) &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt;) (plist-get (cdr c2) &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt;)))))
     ((eq action ?z)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-sort-fn (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (c1 c2) (string&amp;gt; (plist-get (cdr c1) &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt;) (plist-get (cdr c2) &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt;)))))
     (t (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-sort-fn nil)))
     (helm-refresh)
     (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-sort-fn nil)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
h-sort
&lt;/pre&gt;

&lt;p&gt;
Next, we define a candidate transformer. This function takes the list of candidates and the source. Here, if we have defined a sort function, we use it to sort the candidates, and if not, return the candidates. A subtle point here is the use of -sort from dash.el, which does not modify the original list at all. The build in function sort does modify the candidate list somehow, and it does not work the way you want it to here. This function gets run as the helm pattern changes.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;h-candidate-transformer&lt;/span&gt; (candidates source)
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; h-sort-fn
    (&lt;span style="color: #0000FF;"&gt;progn&lt;/span&gt; (message &lt;span style="color: #008000;"&gt;"Sorting with %s"&lt;/span&gt; h-sort-fn)
    (&lt;span style="color: #0000FF;"&gt;-sort&lt;/span&gt; h-sort-fn candidates))
  candidates))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
h-candidate-transformer
&lt;/pre&gt;

&lt;p&gt;
Now, just for fun, we show that dynamically defined actions are possible. Here, we generate an action list that is different for even and odd numbers. These actions are pretty trivial, but give you an idea of what might be possible; custom, context specific actions.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make dynamic actions based on the candidate selected&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;h-action-transformer&lt;/span&gt; (actions candidate)
  &lt;span style="color: #036A07;"&gt;"Candidate is the result selected."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (evenp (plist-get candidate &lt;span style="color: #006FE0;"&gt;:num&lt;/span&gt;))
      '((&lt;span style="color: #008000;"&gt;"Even"&lt;/span&gt; . identity))
    '((&lt;span style="color: #008000;"&gt;"Odd"&lt;/span&gt; . identity))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
h-action-transformer
&lt;/pre&gt;

&lt;p&gt;
Finally, we are ready to create a helm source. We use the new factory function for creating the source with our keymap, candidates and transformer functions.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; h-source
      (&lt;span style="color: #0000FF;"&gt;helm-build-sync-source&lt;/span&gt; &lt;span style="color: #008000;"&gt;"number-selector"&lt;/span&gt;
        &lt;span style="color: #006FE0;"&gt;:keymap&lt;/span&gt; h-map
        &lt;span style="color: #006FE0;"&gt;:candidates&lt;/span&gt; #'h-candidates
        &lt;span style="color: #006FE0;"&gt;:filtered-candidate-transformer&lt;/span&gt; #'h-candidate-transformer
        &lt;span style="color: #006FE0;"&gt;:action-transformer&lt;/span&gt; #'h-action-transformer))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, you can run the helm source like this.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; 'h-source)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You can sort the numbers in descending order by typing M-&amp;lt;down&amp;gt; and pressing d. To get ascending order, press i instead. To sort on the keys, type a sort from a to z, and press z to sort on z to a. If you press tab on a selection, you will see that the actions you get depend on whether the selection is an even or odd number! So, you can get some context specific actions depending on your selection. Pretty awesome.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2016/01/24/Modern-use-of-helm---sortable-candidates.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>LDAP lookups from Emacs</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/11/25/LDAP-lookups-from-Emacs</link>
      <pubDate>Wed, 25 Nov 2015 09:31:58 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">hCJYD6RBQaqIGMwK9fKcKPED_0o=</guid>
      <description>LDAP lookups from Emacs</description>
      <content:encoded><![CDATA[



&lt;p&gt;
Now that I have email and Cisco Jabber totally integrated into Emacs it would be nice to tap into the CMU LDAP (Lightweight Directory Access Protocol) service  to find emails and phone numbers. We to use the ldapsearch command-line utility to query our LDAP service like this to find an email address.
&lt;/p&gt;

&lt;p&gt;
You might like the video explanation here: &lt;a href="https://www.youtube.com/watch?v=N7AaKHRd9uw"&gt;https://www.youtube.com/watch?v=N7AaKHRd9uw&lt;/a&gt; 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(shell-command-to-string &lt;span style="color: #008000;"&gt;"ldapsearch -x -LLL -h ldap.andrew.cmu.edu -b ou=Person,dc=cmu,dc=edu cn=\"John Kitchin\""&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
dn: guid=1976CCAA-B465-11D8-8000-080020CC75D3,ou=person,dc=cmu,dc=edu
objectClass: cmuPerson
eduPersonPrimaryAffiliation: Faculty
guid: 1976CCAA-B465-11D8-8000-080020CC75D3
cmuPrivate: homePostalAddress
cmuPrivate: homePhone
cn: John Kitchin
givenName: John
sn: Kitchin
cmuPrimaryCampus: Pittsburgh
cmuCampus: Pittsburgh
cmuAndrewId: jkitchin
cmueduId: jkitchin
cmuAndrewCommonNamespaceId: jkitchin
mail: jkitchin@cmu.edu
eduPersonSchoolCollegeName: CIT - Consolidated
cmuPersonPrincipalName: jkitchin@ANDREW.CMU.EDU
postalAddress: DH A207F
cmuDepartment: Chemical Engineering
cmuDepartment: MSE: Materials Science &amp;amp; Engineering
cmuPersonAffiliation: Tenure-Track Faculty
eduPersonAffiliation: Faculty
cmuAccount: uid=jkitchin,ou=account,dc=andrew,dc=cmu,dc=edu
cmuAccount: uid=jkitchin,ou=account,dc=cmu,dc=edu
cmuActiveDN: uid=jkitchin,ou=account,dc=andrew,dc=cmu,dc=edu
cmuActiveDN: uid=jkitchin,ou=account,dc=cmu,dc=edu
title: Professor
telephoneNumber: +1 412 268 7803
&lt;/pre&gt;

&lt;p&gt;
We actually get LDIF data from ldapsearch with a lot of details. Next we wrap the output in a function that converts each result from ldapsearch into a p-list that we will use later in a helm function to help us select a match.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;ldap-query&lt;/span&gt; (query-string)
  &lt;span style="color: #036A07;"&gt;"Send QUERY-STRING to our ldap server and parse results into a&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;list of p-lists for each entry returned."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt; &lt;span style="color: #008000;"&gt;"sLDAP query: "&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((output (butlast (split-string
                          (shell-command-to-string
                           (format (concat  &lt;span style="color: #008000;"&gt;"ldapsearch -x -LLL "&lt;/span&gt;
                                            &lt;span style="color: #008000;"&gt;"-h ldap.andrew.cmu.edu "&lt;/span&gt;
                                            &lt;span style="color: #008000;"&gt;"-b ou=Person,dc=cmu,dc=edu %s"&lt;/span&gt;)
                                   query-string))
                          &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;)))
        (lines '())
        (result '())
        (results '(())))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;cleanup trailing lines and ignore initial lines&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for line in output
          do
          (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;join lines that run over&lt;/span&gt;
           ((s-starts-with? &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; line)
            (&lt;span style="color: #0000FF;"&gt;setf&lt;/span&gt; (car (last lines))
                  (concat (car (last lines)) line)))
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;ignore this&lt;/span&gt;
           ((string-match &lt;span style="color: #008000;"&gt;"Size limit exceeded"&lt;/span&gt; line)
            nil)
           (t
            (add-to-list 'lines line t))))

    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now we need to parse the lines. A new entry starts with a dn: line.&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;dolist&lt;/span&gt; (line lines)
      (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
       ((s-starts-with? &lt;span style="color: #008000;"&gt;"dn:"&lt;/span&gt; line)
        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;add new entry&lt;/span&gt;
        (add-to-list 'results `(&lt;span style="color: #006FE0;"&gt;:dn&lt;/span&gt; ,line)))
       ((string-match &lt;span style="color: #008000;"&gt;":"&lt;/span&gt; line)
        (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((s (split-string line &lt;span style="color: #008000;"&gt;":"&lt;/span&gt;))
               (prop (intern (concat &lt;span style="color: #008000;"&gt;":"&lt;/span&gt; (s-trim (car s)))))
               (val (s-trim (cadr s))))
          (&lt;span style="color: #0000FF;"&gt;setf&lt;/span&gt; (car results) (plist-put (car results) prop val))))))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;last result seems to be nil so we drop it&lt;/span&gt;
    (-filter (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (not (null x))) results)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
ldap-query
&lt;/pre&gt;

&lt;p&gt;
Here is an example of that function:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(ldap-query &lt;span style="color: #008000;"&gt;"cn=\"John Kitchin\""&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;((&lt;span style="color: #006FE0;"&gt;:dn&lt;/span&gt; &lt;span style="color: #008000;"&gt;"dn: guid=1976CCAA-B465-11D8-8000-080020CC75D3,ou=person,dc=cmu,dc=edu"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:objectClass&lt;/span&gt; &lt;span style="color: #008000;"&gt;"cmuPerson"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:eduPersonPrimaryAffiliation&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Faculty"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:guid&lt;/span&gt; &lt;span style="color: #008000;"&gt;"1976CCAA-B465-11D8-8000-080020CC75D3"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuPrivate&lt;/span&gt; &lt;span style="color: #008000;"&gt;"homePhone"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cn&lt;/span&gt; &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:givenName&lt;/span&gt; &lt;span style="color: #008000;"&gt;"John"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:sn&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Kitchin"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuPrimaryCampus&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pittsburgh"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuCampus&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pittsburgh"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuAndrewId&lt;/span&gt; &lt;span style="color: #008000;"&gt;"jkitchin"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmueduId&lt;/span&gt; &lt;span style="color: #008000;"&gt;"jkitchin"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuAndrewCommonNamespaceId&lt;/span&gt; &lt;span style="color: #008000;"&gt;"jkitchin"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:mail&lt;/span&gt; &lt;span style="color: #008000;"&gt;"jkitchin@cmu.edu"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:eduPersonSchoolCollegeName&lt;/span&gt; &lt;span style="color: #008000;"&gt;"CIT - Consolidated"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuPersonPrincipalName&lt;/span&gt; &lt;span style="color: #008000;"&gt;"jkitchin@ANDREW.CMU.EDU"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:postalAddress&lt;/span&gt; &lt;span style="color: #008000;"&gt;"DH A207F"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuDepartment&lt;/span&gt; &lt;span style="color: #008000;"&gt;"MSE"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuPersonAffiliation&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Tenure-Track Faculty"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:eduPersonAffiliation&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Faculty"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuAccount&lt;/span&gt; &lt;span style="color: #008000;"&gt;"uid=jkitchin,ou=account,dc=cmu,dc=edu"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:cmuActiveDN&lt;/span&gt; &lt;span style="color: #008000;"&gt;"uid=jkitchin,ou=account,dc=cmu,dc=edu"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:title&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Professor"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:telephoneNumber&lt;/span&gt; &lt;span style="color: #008000;"&gt;"+1 412 268 7803"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
Now, we wrap a helm function around that to give us a nice menu to select entries from, and a few actions like sending an email, calling, copying the name and email, and seeing the information in a reasonable way. We also add a fallback method in case we don't find what we want and need to do a new search.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;helm-ldap&lt;/span&gt; (query-string)
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt; &lt;span style="color: #008000;"&gt;"sLDAP query: "&lt;/span&gt;)
  (helm
   &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt;
   `(((name . &lt;span style="color: #008000;"&gt;"HELM ldap"&lt;/span&gt;)
      (candidates . ,(mapcar
                      (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                        (cons
                         (format
                          &lt;span style="color: #008000;"&gt;"%20s|%30s|%30s|%20s|%s"&lt;/span&gt;
                          (s-truncate
                           20
                           (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (plist-get x &lt;span style="color: #006FE0;"&gt;:title&lt;/span&gt;) &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;))
                          (plist-get x &lt;span style="color: #006FE0;"&gt;:cn&lt;/span&gt;)
                          (plist-get x &lt;span style="color: #006FE0;"&gt;:mail&lt;/span&gt;)
                          (plist-get x &lt;span style="color: #006FE0;"&gt;:cmuDisplayAddress&lt;/span&gt;)
                          (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (plist-get x &lt;span style="color: #006FE0;"&gt;:telephoneNumber&lt;/span&gt;) &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;))
                         x))
                      (ldap-query
                       (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (string-match &lt;span style="color: #008000;"&gt;"="&lt;/span&gt; query-string)
                           query-string
                         (concat &lt;span style="color: #008000;"&gt;"cn=*"&lt;/span&gt; query-string &lt;span style="color: #008000;"&gt;"*"&lt;/span&gt;)))))
      (action . ((&lt;span style="color: #008000;"&gt;"Email"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                              (compose-mail)
                              (message-goto-to)
                              (insert (plist-get x &lt;span style="color: #006FE0;"&gt;:mail&lt;/span&gt;))
                              (message-goto-subject)))
                 (&lt;span style="color: #008000;"&gt;"Call"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                             (cisco-call
                              (plist-get x &lt;span style="color: #006FE0;"&gt;:telephoneNumber&lt;/span&gt;))))
                 (&lt;span style="color: #008000;"&gt;"Copy Name and email address"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                                                    (kill-new
                                                     (format
                                                      &lt;span style="color: #008000;"&gt;"%s &amp;lt;%s&amp;gt;"&lt;/span&gt;
                                                      (plist-get x &lt;span style="color: #006FE0;"&gt;:cn&lt;/span&gt;)
                                                      (plist-get x &lt;span style="color: #006FE0;"&gt;:mail&lt;/span&gt;)))))
                 (&lt;span style="color: #008000;"&gt;"Information"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                                    (switch-to-buffer
                                     (get-buffer-create &lt;span style="color: #008000;"&gt;"*helm ldap*"&lt;/span&gt;))
                                    (erase-buffer)
                                    (&lt;span style="color: #0000FF;"&gt;dolist&lt;/span&gt; (key (&lt;span style="color: #0000FF;"&gt;cl-loop&lt;/span&gt;
                                                  for key in x by #'cddr
                                                  collect key))
                                      (insert (format &lt;span style="color: #008000;"&gt;"|%s | %s|\n"&lt;/span&gt;
                                                      key (plist-get x key))))
                                    (org-mode)
                                    (goto-char 0)
                                    (org-ctrl-c-ctrl-c)
                                    (insert &lt;span style="color: #008000;"&gt;"press q to quit.\n\n"&lt;/span&gt;)
                                    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; buffer-read-only t)
                                    (use-local-map (copy-keymap org-mode-map))
                                    (local-set-key &lt;span style="color: #008000;"&gt;"q"&lt;/span&gt;
                                                   #'(lambda ()
                                                       (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt;)
                                                       (quit-window t))))))))
     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;fallback action&lt;/span&gt;
     ((name . &lt;span style="color: #008000;"&gt;"New search"&lt;/span&gt;)
      (dummy)
      (action . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (helm-ldap x)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
helm-ldap
&lt;/pre&gt;

&lt;p&gt;
That is pretty convenient!
&lt;/p&gt;

&lt;p&gt;
John Kitchin &amp;lt;jkitchin@cmu.edu&amp;gt;&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/11/25/LDAP-lookups-from-Emacs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Insert org-entities into org-mode with helm</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/11/21/Insert-org-entities-into-org-mode-with-helm</link>
      <pubDate>Sat, 21 Nov 2015 11:37:33 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">HOFkO2GHmFvr7GZodTHKgYB_0wI=</guid>
      <description>Insert org-entities into org-mode with helm</description>
      <content:encoded><![CDATA[


&lt;p&gt;
org-mode has a lot of pre-defined entities (see &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2013/10/03/Exporting-accented-characters-to-latex-from-org-mode/"&gt;http://kitchingroup.cheme.cmu.edu/blog/2013/10/03/Exporting-accented-characters-to-latex-from-org-mode/&lt;/a&gt; ), otherwise known to me as non-ascii characters. I rarely remember what these are, and occasionally want to insert the LaTeX or HTML code, so here we build a helm command to show them to me, and allow me to select one for insertion. We generate the helm sources from org-entities below. It works pretty well!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;helm-insert-org-entity&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Helm interface to insert an entity from `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;org-entities&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;F1 inserts utf-8 character&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;F2 inserts entity code&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;F3 inserts LaTeX code (does not wrap in math-mode)&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;F4 inserts HTML code"&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt;)
  (helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; (reverse
                  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((sources '())
                        toplevel
                        secondlevel)
                    (&lt;span style="color: #0000FF;"&gt;dolist&lt;/span&gt; (element (append
                                      '(&lt;span style="color: #008000;"&gt;"* User"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"** User entities"&lt;/span&gt;)
                                      org-entities-user org-entities))
                      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp element)
                                 (s-starts-with? &lt;span style="color: #008000;"&gt;"* "&lt;/span&gt; element))
                        (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; toplevel element))
                      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp element)
                                 (s-starts-with? &lt;span style="color: #008000;"&gt;"** "&lt;/span&gt; element))
                        (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; secondlevel element)
                        (add-to-list
                         'sources
                         `((name . ,(concat
                                     toplevel
                                     (replace-regexp-in-string
                                      &lt;span style="color: #008000;"&gt;"\\*\\*"&lt;/span&gt; &lt;span style="color: #008000;"&gt;" - "&lt;/span&gt; secondlevel)))
                           (candidates . nil)
                           (action . ((&lt;span style="color: #008000;"&gt;"insert utf-8 char"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                                                               (insert (nth 6 candidate))))
                                      (&lt;span style="color: #008000;"&gt;"insert org entity"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                                                           (insert (concat &lt;span style="color: #008000;"&gt;"\\"&lt;/span&gt; (car candidate)))))
                                      (&lt;span style="color: #008000;"&gt;"insert latex"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                                                          (insert (nth 1 candidate))))
                                      (&lt;span style="color: #008000;"&gt;"insert html"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                                                         (insert (nth 3 candidate)))))))))
                      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; element (listp element))
                        (&lt;span style="color: #0000FF;"&gt;setf&lt;/span&gt; (cdr (assoc 'candidates (car sources)))
                              (append
                               (cdr (assoc 'candidates (car sources)))
                               (list (cons
                                      (format &lt;span style="color: #008000;"&gt;"%10s %s"&lt;/span&gt; (nth 6 element) element)
                                      element))))))
                    sources))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
helm-insert-org-entity
&lt;/pre&gt;

&lt;p&gt;
Now I can write things like the particle was 60 Å in diameter at a temperature of 600°C, leading to an expansion coefficient of α=0.2 ± 0.01. It isn't quite as fast as knowing the keyboard shortcuts for those symbols, but a lot faster than looking them up then copy and pasting them. So far it seems like these export to HTML and LaTeX just fine, and they are more convenient and better looking than using the org-entities codes. This will make its way into jmax soon.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/11/21/Insert-org-entities-into-org-mode-with-helm.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A helm-mu4e contact selector</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/03/14/A-helm-mu4e-contact-selector</link>
      <pubDate>Sat, 14 Mar 2015 10:21:09 EDT</pubDate>
      <category><![CDATA[email]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[helm]]></category>
      <guid isPermaLink="false">YlAI6hrApwjWc1WC0qZq1P4Dy1c=</guid>
      <description>A helm-mu4e contact selector</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I have been using &lt;a href="http://www.djcbsoftware.nl/code/mu/mu4e.html"&gt;mu4e&lt;/a&gt; in Emacs for email for about three months now. It is pretty good, and I hardly ever use the gmail web interface any more. The email completion in mu4e is ok, but I am frequently surprised at what it does not find, and totally spoiled by how good Gmail is at this. The built in completion seems to get lost if you don't start the search with the first few letters. Not always, but too often for me. I don't always remember the first letters, and want to search by name, or company. I would love to search by tags in org-contacts. This should be simple in helm, where you can build up candidates with different bits of information. Here I explore a helm interface, which I think might be better than the built in mu4e support, and even be better than gmail.
&lt;/p&gt;

&lt;p&gt;
In my dream email completer, I want some easy way to define my own groups, I want to use org-contacts (and its tags), and I want every email address in the mails I have in my archive as completion candidates.  helm supports multiple sources, so I initially tried a separate source for each of these. Preliminary efforts suggested it is not possible to mark multiple selections from different sources and pass them all to one function. So, we combine all email candidates into one list of (searchable-string . email-address) cons cells. To get an idea of how many contacts we are looking at:
&lt;/p&gt;

&lt;p&gt;
Here is what I have in my org-contacts file:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(length (org-contacts-db))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
173
&lt;/pre&gt;

&lt;p&gt;
And here is what mu4e knows about. Interestingly, it takes a while for this variable to get populated because the request is asynchronous. After the first time though it sticks around. I think just opening mu4e will populate this variable.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(length mu4e~contacts-for-completion)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
12717
&lt;/pre&gt;

&lt;p&gt;
So, I have close to 13,000 potential email addresses to choose from. For my email groups, I will just use a list of cons cells like (group-name . "comma-separated emails"). Then, I will loop through the org-contacts-db and the mu4e completion list to make the helm candidates. Finally, we add some functions to open our org-contact, and to tag org-contacts so it is easier to make groups.
&lt;/p&gt;

&lt;p&gt;
Here is the code I have been using.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;here we set aliases for groups.&lt;/span&gt;
(setq email-groups
      '((&lt;span style="color: #008000;"&gt;"ms"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"email1, email2"&lt;/span&gt;)
        (&lt;span style="color: #008000;"&gt;"phd"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"email3, email4"&lt;/span&gt;)))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;org-contacts-open-from-email&lt;/span&gt; (email)
  &lt;span style="color: #036A07;"&gt;"Open org-contact with matching EMAIL. If no match, create new&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;entry with prompts for first and last name."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((contact (&lt;span style="color: #0000FF;"&gt;catch&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;contact&lt;/span&gt;
                   (loop for contact in  (org-contacts-db)
                         do
                         (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (string= email (cdr (assoc &lt;span style="color: #008000;"&gt;"EMAIL"&lt;/span&gt; (elt contact 2))))
                           (&lt;span style="color: #0000FF;"&gt;throw&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;contact&lt;/span&gt; contact))))))

    (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; contact
                (set-buffer (find-file-noselect (ido-completing-read
                                                 &lt;span style="color: #008000;"&gt;"Select org-contact file: "&lt;/span&gt;
                                                 org-contacts-files)))
                (goto-char (point-max))
                (insert (format  &lt;span style="color: #008000;"&gt;"\n* %s %s\n"&lt;/span&gt;
                                 (read-input &lt;span style="color: #008000;"&gt;"First name: "&lt;/span&gt;)
                                 (read-input &lt;span style="color: #008000;"&gt;"Last name: "&lt;/span&gt;)))
                (org-entry-put (point) &lt;span style="color: #008000;"&gt;"EMAIL"&lt;/span&gt; email)
                (save-buffer))

    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; contact
      (find-file  (cdr (assoc &lt;span style="color: #008000;"&gt;"FILE"&lt;/span&gt; (elt contact 2))))
      (goto-char (elt contact 1))
      (show-subtree))))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;org-contacts-tag-selection&lt;/span&gt; (selection)
  &lt;span style="color: #036A07;"&gt;"Prompts you for a tag, and tags each entry in org-contacts&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;that has a matching email in `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;helm-marked-candidates&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'. Ignore&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;emails that are not in an org-contact file. I am not sure what&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;the best thing to do there is. Probably prompt for a file, and&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;add an entry to the end of it."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((tag (read-input &lt;span style="color: #008000;"&gt;"Tag: "&lt;/span&gt;)))
      (loop for email in (helm-marked-candidates)
            do
            (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((contact (&lt;span style="color: #0000FF;"&gt;catch&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;contact&lt;/span&gt;
                             (loop for contact in  (org-contacts-db)
                                   do
                                   (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (string=
                                          email
                                          (cdr (assoc
                                                &lt;span style="color: #008000;"&gt;"EMAIL"&lt;/span&gt;
                                                (elt contact 2))))
                                     (&lt;span style="color: #0000FF;"&gt;throw&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;contact&lt;/span&gt; contact))))))
              &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;add new contact and tag it&lt;/span&gt;
              (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; contact
                (set-buffer (find-file-noselect (ido-completing-read
                                                 &lt;span style="color: #008000;"&gt;"Select org-contact file: "&lt;/span&gt;
                                                 org-contacts-files)))
                (goto-char (point-max))
                (insert (format  &lt;span style="color: #008000;"&gt;"\n* %s %s\n"&lt;/span&gt;
                                 (read-input &lt;span style="color: #008000;"&gt;"First name: "&lt;/span&gt;)
                                 (read-input &lt;span style="color: #008000;"&gt;"Last name: "&lt;/span&gt;)))
                (org-entry-put (point) &lt;span style="color: #008000;"&gt;"EMAIL"&lt;/span&gt; email)
                (org-set-tags-to (list tag))
                (save-buffer))
              &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;update tags on existing entry&lt;/span&gt;
              (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; contact
                (find-file-noselect  (cdr (assoc &lt;span style="color: #008000;"&gt;"FILE"&lt;/span&gt; (elt contact 2))))
                (set-buffer (marker-buffer (elt contact 1)))
                (goto-char (elt contact 1))
                (org-set-tags-to (append (org-get-tags) (list tag)))))))))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;j-insert-emails&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Helm interface to email addresses"&lt;/span&gt;
  (interactive)

  (helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; `(((name . &lt;span style="color: #008000;"&gt;"Email address candidates"&lt;/span&gt;)
                   (candidates . ,(append
                                   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;my aliases&lt;/span&gt;
                                   email-groups
                                   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;org-contacts&lt;/span&gt;
                                   (loop for contact in (org-contacts-db)
                                         collect
                                         (cons (format
                                                &lt;span style="color: #008000;"&gt;"%s %s %s &amp;lt;%s&amp;gt; org-contact"&lt;/span&gt;
                                                (cdr (assoc &lt;span style="color: #008000;"&gt;"FIRSTNAME"&lt;/span&gt; (elt contact 2)))
                                                (cdr (assoc &lt;span style="color: #008000;"&gt;"LASTNAME"&lt;/span&gt; (elt contact 2)))
                                                (cdr (assoc &lt;span style="color: #008000;"&gt;"TAGS"&lt;/span&gt; (elt contact 2)))
                                                (cdr (assoc &lt;span style="color: #008000;"&gt;"EMAIL"&lt;/span&gt; (elt contact 2))))
                                               (cdr (assoc &lt;span style="color: #008000;"&gt;"EMAIL"&lt;/span&gt; (elt contact 2)))))
                                   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;mu contacts&lt;/span&gt;
                                   (loop for contact in mu4e~contacts-for-completion
                                         collect (cons contact contact))))
                   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;only action is to insert string at point.&lt;/span&gt;
                   (action . ((&lt;span style="color: #008000;"&gt;"insert"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                                            (insert
                                             (mapconcat
                                              'identity
                                              (helm-marked-candidates)
                                              &lt;span style="color: #008000;"&gt;","&lt;/span&gt;))))
                              (&lt;span style="color: #008000;"&gt;"open"&lt;/span&gt; . org-contacts-open-from-email)
                              (&lt;span style="color: #008000;"&gt;"tag"&lt;/span&gt;  . org-contacts-tag-selection)))))))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Finally, let us bind this to something probably convenient. I use c-c ] for&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;citations. Lets try that in compose mode.&lt;/span&gt;
(define-key mu4e-compose-mode-map &lt;span style="color: #008000;"&gt;"\C-c]"&lt;/span&gt; 'j-insert-emails)
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
j-insert-emails
&lt;/pre&gt;

&lt;p&gt;
Now, I have a sweet helm interface with nearly 13,000 email candidates (there is a decent amount of duplication in this list, and some garbage emails from spam, but helm is so fast, this does not bother me). I can pretty quickly narrow to any tagged set of emails from org-contacts with a search that looks like :phd: for example, or [^phd]:group: to get org-contacts tagged group, but not phd. I can narrow the selection on first name, lastname, parts of email addresses, tags in org-contacts, etc&amp;#x2026; I can open a contact, or tag contacts, even add new contacts to org-contacts. I have been using this for a few weeks, and so far I like it. Occasionally I find mu4e~contacts-for-completion is empty, and then I only get my org-contacts emails, but that seems to only happen when I first open emacs. Since Emacs is usually open for days at a time, this has not been an issue very often.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/03/14/A-helm-mu4e-contact-selector.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Helm at the Emacs</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/02/04/Helm-at-the-Emacs</link>
      <pubDate>Wed, 04 Feb 2015 08:47:40 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">BQa4exu2NqS2LIJDkrMHfiML8kw=</guid>
      <description>Helm at the Emacs</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I have written several (&lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source/"&gt;intro&lt;/a&gt; , &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/02/01/Handling-multiple-selections-in-helm/"&gt;multiple args&lt;/a&gt; , &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/02/03/helm-and-prefix-functions/"&gt;prefix args)&lt;/a&gt; times about using Helm in Emacs so far. Today, I want to share a way I use helm to get me where I want to be in Emacs for my daily activities. This came out of a desire to have single command that would give me a lot of options to open exactly the buffer/file I wanted when I need it. I call the command hotspots, and it is bound to f9 for me, so when I press f9 I get a helm buffer to select what I want from.
&lt;/p&gt;

&lt;p&gt;
So, what kinds of things do I want. First, I want to be able to open my mail, calendar, News feed or agenda from this command. Second, I have a list of hotspots I developed using the code at &lt;a href="http://ergoemacs.org/emacs/emacs_hotkey_open_file_fast.html"&gt;http://ergoemacs.org/emacs/emacs_hotkey_open_file_fast.html&lt;/a&gt; , which I want easy access to. Third, I want to be able to open any org-file in my agenda list. Fourth, any bookmark I have, or to set a bookmark. Fifth, I want recent files as candidates. There is certainly some redundancy in their, but that is ok, it gets me where I want to be.
&lt;/p&gt;

&lt;p&gt;
Here is the code that does that for me. There are six helm sources that provide candidates and actions.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;hotspots&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"helm interface to my hotspots, which includes my locations,&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;org-files and bookmarks"&lt;/span&gt;
  (interactive)
  (helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; `(((name . &lt;span style="color: #008000;"&gt;"Mail and News"&lt;/span&gt;)
                    (candidates . ((&lt;span style="color: #008000;"&gt;"Mail"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ()
                                               (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (get-buffer &lt;span style="color: #008000;"&gt;"*mu4e-headers*"&lt;/span&gt;)
                                                   (&lt;span style="color: #0000FF;"&gt;progn&lt;/span&gt;
                                                     (switch-to-buffer &lt;span style="color: #008000;"&gt;"*mu4e-headers*"&lt;/span&gt;)
                                                     (delete-other-windows))

                                                 (mu4e))))
                                   (&lt;span style="color: #008000;"&gt;"Calendar"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ()  (browse-url &lt;span style="color: #008000;"&gt;"https://www.google.com/calendar/render"&lt;/span&gt;)))
                                   (&lt;span style="color: #008000;"&gt;"RSS"&lt;/span&gt; . elfeed)
                                   (&lt;span style="color: #008000;"&gt;"Agenda"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; () (org-agenda &lt;span style="color: #008000;"&gt;""&lt;/span&gt; &lt;span style="color: #008000;"&gt;"w"&lt;/span&gt;)))))
                    (action . ((&lt;span style="color: #008000;"&gt;"Open"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (funcall x))))))
                   ((name . &lt;span style="color: #008000;"&gt;"My Locations"&lt;/span&gt;)
                    (candidates . ((&lt;span style="color: #008000;"&gt;"master"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/org-mode/master.org"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;".emacs.d"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/kitchingroup/jmax"&lt;/span&gt; )
                                   (&lt;span style="color: #008000;"&gt;"blog"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/blogofile-jkitchin.github.com/_blog/blog.org"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;"ese"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/books/ese-book/ese.org"&lt;/span&gt; )
                                   (&lt;span style="color: #008000;"&gt;"passwords"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/org-mode/passwords.org.gpg"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;"Pycse"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/books/pycse/pycse.org"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;"references"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/bibliography/references.bib"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;"notes"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/bibliography/notes.org"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;"journal"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/org-mode/journal.org"&lt;/span&gt;)
                                   (&lt;span style="color: #008000;"&gt;"tasks"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"~/Dropbox/org-mode/tasks.org"&lt;/span&gt;)))
                    (action . ((&lt;span style="color: #008000;"&gt;"Open"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (find-file x))))))

                   ((name . &lt;span style="color: #008000;"&gt;"My org files"&lt;/span&gt;)
                    (candidates . ,(f-entries &lt;span style="color: #008000;"&gt;"~/Dropbox/org-mode"&lt;/span&gt;))
                    (action . ((&lt;span style="color: #008000;"&gt;"Open"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (find-file x))))))
                   helm-source-recentf
                   helm-source-bookmarks
                   helm-source-bookmark-set)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Interesting to me is that there are not a lot of actions in here. I mostly use this command for navigation to various places. For example, I press f9, type meet, and I can quickly get to the meetings file in my agenda list, or I can type the first few letters of a student's name and open the org-file associated with them. Or I press f9 and go down an entry to open my calendar, etc&amp;#x2026; I find this enormously helpful because it opens these files no matter where I am in Emacs, and it relieves my mind from remembering where they are, or the keystrokes/commands to get to them.&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/02/04/Helm-at-the-Emacs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>helm and prefix functions</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/02/03/helm-and-prefix-functions</link>
      <pubDate>Tue, 03 Feb 2015 11:12:53 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">8N-R8vMLReQ31rBXzaetXNyodro=</guid>
      <description>helm and prefix functions</description>
      <content:encoded><![CDATA[


&lt;p&gt;
Helm modifies how you use &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Prefix-Command-Arguments.html"&gt;prefix arguments&lt;/a&gt; in Emacs. A prefix argument is when you type C-u before a command to modify its behavior. There are a few variations of prefix arguments. Basically, pressing C-u once sets a prefix variable to '(4), pressing twice sets it to '(16). Alternatively, C-u 7 sets the prefix to 7. In regular emacs commands, you type the prefix keys before the command. In helm, you type the after you enter the helm selection buffer, and before you press enter or select your action. In helm, you access the prefix arg in the variable helm-current-prefix-arg. Let us look at how you might use it.
&lt;/p&gt;

&lt;p&gt;
We make an action function that does something conditionally depending on the prefix arg. Yes, you could write several functions to accomplish that too, but maybe there is just a little difference that you can use the prefix arg to handle. What you cannot remember 4 prefix options? You do write good doc strings on your functions right ;) If not, you probably ought to write four functions with meaningful names, and meaningful helm descriptions!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;action&lt;/span&gt; (candidate)
  &lt;span style="color: #036A07;"&gt;"Our action function.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;with no prefix message no prefix arg&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;with one prefix arg message C-u&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;with two prefix args message C-u C-u&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;with a numeric prefix arg, message the number."&lt;/span&gt;
  (interactive &lt;span style="color: #008000;"&gt;"p"&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq nil helm-current-prefix-arg)
    (message-box &lt;span style="color: #008000;"&gt;"no prefix arg"&lt;/span&gt;))
   ((equal helm-current-prefix-arg '(4))
    (message-box &lt;span style="color: #008000;"&gt;"C-u"&lt;/span&gt;))
   ((equal helm-current-prefix-arg '(16))
    (message-box &lt;span style="color: #008000;"&gt;"C-u C-u"&lt;/span&gt;))
   (t
    (message-box (format &lt;span style="color: #008000;"&gt;"C-u %s"&lt;/span&gt; helm-current-prefix-arg)))))

(setq some-helm-source
      '((name . &lt;span style="color: #008000;"&gt;"HELM at the Emacs"&lt;/span&gt;)
        (candidates . (1 2 3 4))
        (action . action)))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(some-helm-source))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
C-u (64)
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/02/03/helm-and-prefix-functions.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Handling multiple selections in helm</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/02/01/Handling-multiple-selections-in-helm</link>
      <pubDate>Sun, 01 Feb 2015 08:51:26 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">N5qxsrIWtmCMMl_qTvm4aKnq_-Y=</guid>
      <description>Handling multiple selections in helm</description>
      <content:encoded><![CDATA[


&lt;p&gt;
The basic usage pattern of helm is you run a command which opens a buffer of choices. You enter some text in the minibuffer which eliminates choices that do not match what you type in. You can select multiple choices by using C-spc, or M-a to mark them all. When you press enter, the current selection is sent to the default action defined. The action is a function that does something, usually on the selected item(s). Here, we explore writing the action function to do what we want. The reason this is somewhat tricky is that when you mark an item in helm, the "cursor" moves to the next item, which means when you press enter it may be possible that the current highlighted item is not part of the items you have marked. If your action will perform a delete action, for example, you may have wanted to delete the marked items, and &lt;i&gt;not&lt;/i&gt; the current selection! So, what we need is a way to get what we want.
&lt;/p&gt;

&lt;p&gt;
An action function in helm should normally take one argument, which is going to be the currently selected item from helm. However, we can use two different functions to access either the selected item (helm-get-selection) or the marked items (helm-marked-candidates). So, we can write our function to do "do what we mean". Note, even if you do not mark any candidates,  (helm-marked-candidates) will return a list that has the current selection in it. So we can write our action function to act on this list so it works on what is marked or what is selected if nothing is marked. That is probably "what we mean".
&lt;/p&gt;

&lt;p&gt;
Here is one way to work on a selection or marked list of selections. We define an action function that takes an arg, but inside we operate on each element of the marked candidates.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;some-action&lt;/span&gt; (candidate)
  (loop for cand in (helm-marked-candidates)
        do
        (message-box &lt;span style="color: #008000;"&gt;"working on %s"&lt;/span&gt; cand)))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(((name . &lt;span style="color: #008000;"&gt;"HELM"&lt;/span&gt;)
                  (candidates . (1 2 3 4))
                  (action . ((&lt;span style="color: #008000;"&gt;"open"&lt;/span&gt; . some-action))))))
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
Here is an alternative approach. Here we define the action function to work on one candidate. That might be helpful for testing, for example. Then, we use mapc to apply the function to each marked candidate.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;some-action&lt;/span&gt; (candidate)
  (message-box &lt;span style="color: #008000;"&gt;"single working on %s"&lt;/span&gt; candidate))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(((name . &lt;span style="color: #008000;"&gt;"HELM"&lt;/span&gt;)
                  (candidates . (1 2 3 4))
                  (action . ((&lt;span style="color: #008000;"&gt;"open"&lt;/span&gt; . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                                         (mapc
                                          'some-action
                                          (helm-marked-candidates)))))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
A little more verbose method might be like this. Here we just pull out the lambda function to another function, to make the helm source definition a little shorter. I cannot tell if this is easier to follow, it is just another option.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;some-action&lt;/span&gt; (candidate)
  (message-box &lt;span style="color: #008000;"&gt;"single2 working on %s"&lt;/span&gt; candidate))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;some-actions&lt;/span&gt; (candidate)
  (mapc 'some-action (helm-marked-candidates)))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(((name . &lt;span style="color: #008000;"&gt;"HELM"&lt;/span&gt;)
                  (candidates . (1 2 3 4))
                  (action . some-actions))))
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
So there you have it. You can select multiple things in helm, and then operate on them with your action function!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/02/01/Handling-multiple-selections-in-helm.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Anatomy of a helm source</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2015/01/24/Anatomy-of-a-helm-source</link>
      <pubDate>Sat, 24 Jan 2015 11:15:56 EST</pubDate>
      <category><![CDATA[helm]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">sKB9b8y5sNX60wQGXo0OvhrEk0c=</guid>
      <description>Anatomy of a helm source</description>
      <content:encoded><![CDATA[



&lt;p&gt;
I have been integrating &lt;a href="https://github.com/emacs-helm/helm"&gt;helm&lt;/a&gt; into my emacs work flows almost anywhere I need to make interactive selections and do something with them. In this post, I will go through the simplest helm examples I can think of that get you to writing your own example.
&lt;/p&gt;

&lt;p&gt;
To run a helm selection process you basically just call a function that calls this minimal function:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(some-helm-source))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
In that code, the symbol some-helm-source will provide the input for the helm buffer. Let us look at the simplest example here. Each source should have a name, a list of candidates, and an action that works on the selected candidate. We construct a source as a list of cons cells. Here, we make a source with the name "HELM at the Emacs", a static list of candidates, which are simply a list of numbers, and a single action that will operate on the selected candidate.
&lt;/p&gt;

&lt;p&gt;
If you run this block, you will get a helm buffer, you can select an entry, press enter, and you should see a message box pop up telling you what entry you selected. I like to separate the source definition from the helm call like this, but only for readability.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(setq some-helm-source
      '((name . &lt;span style="color: #008000;"&gt;"HELM at the Emacs"&lt;/span&gt;)
        (candidates . (1 2 3 4))
        (action . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                    (message-box &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt; candidate)))))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(some-helm-source))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3
&lt;/pre&gt;


&lt;p&gt;
Not bad, but what if we want some dynamic candidates? The usual way we will do that is to define a function that calculates the candidates for us. Let us work out an example that just shows us random numbers between 0 and 10 to select from. In a real example, you would use this function to generate a list of candidates like bibtex keys, email-addresses, etc&amp;#x2026;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;random-candidates&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Return a list of 4 random numbers from 0 to 10"&lt;/span&gt;
  (loop for i below 4 collect (random 10)))

(setq some-helm-source
      '((name . &lt;span style="color: #008000;"&gt;"HELM at the Emacs"&lt;/span&gt;)
        (candidates . random-candidates)
        (action . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                    (message &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt; candidate)))))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(some-helm-source))
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
So far, we have looked at the simplest list of candidates: a simple list. It may be that this is not the most convenient way to see the candidates. We might like to have one set of candidates that we use for searching, but another set of equivalent candidates used for the action. For example, we might want a list of names for selecting, but then have the action work on the corresponding email address. Let us consider a case where we have a list of cons cells of names and email addresses.
&lt;/p&gt;

&lt;p&gt;
We use the `, way to create the source variable to make sure our list of candidates is constructed. Then, in our function we take the selection and get the corresponding entry in the data a-list.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(setq data '((&lt;span style="color: #008000;"&gt;"John"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"john@email.com"&lt;/span&gt;)
             (&lt;span style="color: #008000;"&gt;"Jim"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"jim@email.com"&lt;/span&gt;)
             (&lt;span style="color: #008000;"&gt;"Jane"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"jane@email.com"&lt;/span&gt;)
             (&lt;span style="color: #008000;"&gt;"Jill"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"jill@email.com"&lt;/span&gt;)))

(setq some-helm-source
      `((name . &lt;span style="color: #008000;"&gt;"HELM at the Emacs"&lt;/span&gt;)
        (candidates . ,(mapcar 'car data))
        (action . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                    (message &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt; (cdr (assoc candidate data)))))))

(helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(some-helm-source))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
jim@email.com
&lt;/pre&gt;

&lt;p&gt;
That is not too bad, and might be a general way to get to the data you want. But, helm can integrate this directly by using the a-list &lt;i&gt;directly&lt;/i&gt; as the list of candidates. Helm will show you the car of each cell, but return the cdr of the selected entry.
&lt;/p&gt;

&lt;p&gt;
Let us try this to make a function that will give us a helm buffer to select some names from, and then insert a comma separated list of emails from our selection at the point. We make our action function just return the list of marked candidates. Then we create a function that calls helm, and inserts a concatenated string.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(setq data '((&lt;span style="color: #008000;"&gt;"John"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"john@email.com"&lt;/span&gt;)
             (&lt;span style="color: #008000;"&gt;"Jim"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"jim@email.com"&lt;/span&gt;)
             (&lt;span style="color: #008000;"&gt;"Jane"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"jane@email.com"&lt;/span&gt;)
             (&lt;span style="color: #008000;"&gt;"Jill"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"jill@email.com"&lt;/span&gt;)))

(setq some-helm-source
      `((name . &lt;span style="color: #008000;"&gt;"HELM at the Emacs"&lt;/span&gt;)
        (candidates . ,data)
        (action . (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (candidate)
                    (helm-marked-candidates)))))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;helm-select-and-insert-emails&lt;/span&gt; ()
  (interactive)
  (insert
   (mapconcat 'identity
              (helm &lt;span style="color: #006FE0;"&gt;:sources&lt;/span&gt; '(some-helm-source))
              &lt;span style="color: #008000;"&gt;","&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
helm-select-and-insert-emails
&lt;/pre&gt;


&lt;p&gt;
Here is what I get when I run the command, select John and Jill, and press enter: john@email.com,jill@email.com
&lt;/p&gt;

&lt;p&gt;
That is it for this post. We looked at:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;the simplest kind of helm interface with a fixed set of candidates
&lt;/li&gt;
&lt;li&gt;A simple dynamic set of candidates
&lt;/li&gt;
&lt;li&gt;A simple fixed set of candidates from a list of cons cells.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
This barely scratches the surface of helm, but is already enough to do some useful things.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/01/24/Anatomy-of-a-helm-source.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
