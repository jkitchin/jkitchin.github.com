<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Wed, 10 Sep 2014 17:27:13 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Automatic downloading of a pdf from a journal site</title>
      <link>http://jkitchin.github.io/blog/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site</link>
      <pubDate>Fri, 23 May 2014 11:44:11 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">UWmVnxHyixLN3IL5WLWxQNP6n_g=</guid>
      <description>Automatic downloading of a pdf from a journal site</description>
      <content:encoded><![CDATA[


<p>
Many bibliography software packages can automatically download a pdf for you. In this post, we explore how that can be done from emacs. The principle idea is that the pdf is obtained from a url, and that you can calculate the url by some method. Then you can download the file. 
</p>

<p>
For example, consider this article in Phys. Rev. Lett. <a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105">http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105</a> . There is a link to get the pdf for this article at <a href="http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105">http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105</a> . It is not difficult to construct that url; you just replace <code>/abstract/</code> with <code>/pdf/</code>.
</p>

<p>
The trick is how to get the first url. We have previously seen that we can construct a bibtex entry from a doi. In fact, we can use the doi to get the url above. If you visit <a href="http://dx.doi.org/10.1103/PhysRevLett.99.016105">http://dx.doi.org/10.1103/PhysRevLett.99.016105</a> , you will be redirected to the url. It so happens that you can use code to get the redirected url. In emacs-lisp it is a little convoluted; you have to use url-retrieve, and provide a callback that sets the redirect. Here is an example. It appears you need to run this block twice to get the right variable setting. That seems like some kind of error in what I have set up, but I cannot figure out why.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defvar *doi-utils-redirect*)

(defun callback (&amp;optional status)
 (when status ;  is nil if there none
   (setq *doi-utils-redirect* (plist-get status :redirect))))

(url-retrieve 
  "http://dx.doi.org/10.1103/PhysRevLett.99.016105"
  'callback)

(print *doi-utils-redirect*)
</pre>
</div>

<pre class="example">
"http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105"
</pre>

<p>
From there, creating the pdf url is as simple as
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(replace-regexp-in-string "prl/abstract" "prl/pdf" "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105")
</pre>
</div>

<pre class="example">
http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105
</pre>

<p>
And finally we download the file with
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(url-copy-file "http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105" "PhysRevLett.99.016105.pdf" nil)
</pre>
</div>

<pre class="example">
t
</pre>

<p>
So that is the gist of automating pdf downloads. You do these steps:
</p>
<ol class="org-ol">
<li>Get the DOI
</li>
<li>Get the url that the DOI redirects to
</li>
<li>Calculate the link to the pdf
</li>
<li>Download the pdf
</li>
</ol>

<p>
Each publisher does something a little bit different, so you have to work this out for each one. I have worked alot of them out at <a href="https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el">https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el</a> . That file is a work in progress, but it is a project I intend to use on a regular basis.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Converting a doi to a bibtex entry</title>
      <link>http://jkitchin.github.io/blog/2014/05/22/Converting-a-doi-to-a-bibtex-entry</link>
      <pubDate>Thu, 22 May 2014 16:22:31 EDT</pubDate>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">qyqvfhXJMg-F_CObJnHY22xS968=</guid>
      <description>Converting a doi to a bibtex entry</description>
      <content:encoded><![CDATA[


<p>
Many citation management packages allow you to download a bibliography entry from a doi. I want to be able to do that in emacs. I found this <a href="http://homepages.see.leeds.ac.uk/~eeaol/notes/2013/02/doi-metadata/">page</a> that shows it is possible to get metadata about a doi with an http request, and from that data, we can create a bibtex entry. So, here is the basic code for getting metadata about a doi. We specify that we want json code, and then use <a href="http://edward.oconnor.cx/2006/03/json.el">json.el</a> to view the results.
</p>

<p>
We temporarily set a few url-* variables with affect the url-retrieve results. And we rely on url-http-end-of-headers which tells us the end of the headers that get returned, so we can use the remaining text as the data.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(require 'json)

(let ((url-request-method "GET") 
      (url-mime-accept-string "application/citeproc+json")
      (json-object-type 'plist)
      (results))
  (setq results 
	(with-current-buffer (url-retrieve-synchronously "http://dx.doi.org/10.1016/S0022-0248(97)00279-0")
	  (json-read-from-string (buffer-substring url-http-end-of-headers (point-max))))))
</pre>
</div>

<p>
(:volume 181 :indexed (:timestamp 1389218884442 :date-parts <i>2014 1 8</i>) :publisher Elsevier BV :source CrossRef :URL <a href="http://dx.doi.org/10.1016/S0022-0248(97)">http://dx.doi.org/10.1016/S0022-0248(97)</a> 00279-0 :ISSN [0022-0248] :DOI 10.1016/s0022-0248(97)00279-0 :type journal-article :title Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process :issue 3 :deposited (:timestamp 1386028800000 :date-parts <i>2013 12 3</i>) :page 259-264 :reference-count nil :container-title Journal of Crystal Growth :author [(:given Jaan :family Aarik) (:given Aleks :family Aidla) (:given Väino :family Sammelselg) (:given Teet :family Uustare)] :prefix <a href="http://id.crossref.org/prefix/10.1016">http://id.crossref.org/prefix/10.1016</a> :score 1.0 :issued (:date-parts <i>1997 11</i>) :subject [Condensed Matter Physics Inorganic Chemistry Materials Chemistry] :subtitle [])
</p>

<p>
That data is now sufficient for us to consider constructing a bibtex entry. For an article, a prototypical entry looks like:
</p>

<pre class="example">
@Article{,
  author = 	 {},
  title = 	 {},
  journal = 	 {},
  year = 	 {},
  OPTkey = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTpages = 	 {},
  OPTmonth = 	 {},
  OPTnote = 	 {},
  OPTannote = 	 {}
}
</pre>

<p>
Let us create a function that takes a doi and constructs a bibtex entry. I do not use all the metadata, so I just store the json data in the annote field. Maybe I should use another field for that, but annote seems ok since I do not use if for anything. I am going to use a template expansion function I developed earlier to make the bibtex entry template easier to write and read. Here is the code.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(require 'json)

(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
                            (lambda (arg)
                              (let ((sexp (substring arg 2 -1)))
                                (format "%s" (eval (read sexp))))) s))

(defun doi-to-bibtex-article (doi)
 "insert a bibtex entry for doi at point"
 (interactive "sDOI: ")
 (let ((url-request-method "GET") 
       (url-mime-accept-string "application/citeproc+json")
       (json-object-type 'plist)
       type
       results
       author
       title
       journal
       year
       volume
       number
       pages
       month
       url json-data)
   
   (setq results 
	 (with-current-buffer
	     (url-retrieve-synchronously
	      (concat "http://dx.doi.org/" doi))
	 (json-read-from-string (buffer-substring url-http-end-of-headers (point-max))))
         type (plist-get results :type)
	 author (mapconcat (lambda (x) (concat (plist-get x :given) " " (plist-get x :family)))
		     (plist-get results :author) " and ")
	 title (plist-get results :title)
	 journal (plist-get results :container-title)
	 volume (plist-get results :volume)
	 issue (plist-get results :issue)
	 year (elt (elt (plist-get (plist-get results :issued) :date-parts) 0) 0)
	 month (elt (elt (plist-get (plist-get results :issued) :date-parts) 0) 1)
	 pages (plist-get results :page)
	 doi (plist-get results :DOI)
	 url (plist-get results :URL)
	 json-data (format "%s" results))

   (when (string= type "journal-article")

     (expand-template "@article{,
  author = 	 {%{author}},
  title = 	 {%{title}},
  journal = 	 {%{journal}},
  year = 	 {%{year}},
  volume = 	 {%{volume}},
  number = 	 {%{issue}},
  pages = 	 {%{pages}},
  doi =          {%{doi}},
  url =          {%{url}},
  month = 	 {%{month}},
  json = 	 {%{json-data}}
}"))))
   
(doi-to-bibtex-article "10.1016/s0022-0248(97)00279-0")
</pre>
</div>

<pre class="example">
@article{,
  author = 	 {Jaan Aarik and Aleks Aidla and Väino Sammelselg and Teet Uustare},
  title = 	 {Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process},
  journal = 	 {Journal of Crystal Growth},
  year = 	 {1997},
  volume = 	 {181},
  number = 	 {3},
  pages = 	 {259-264},
  doi =          {10.1016/s0022-0248(97)00279-0},
  url =          {http://dx.doi.org/10.1016/s0022-0248(97)00279-0},
  month = 	 {11},
  json = 	 {(:volume 181 :indexed (:timestamp 1389218884442 :date-parts [[2014 1 8]]) :publisher Elsevier BV :source CrossRef :URL http://dx.doi.org/10.1016/s0022-0248(97)00279-0 :ISSN [0022-0248] :DOI 10.1016/s0022-0248(97)00279-0 :type journal-article :title Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process :issue 3 :deposited (:timestamp 1386028800000 :date-parts [[2013 12 3]]) :page 259-264 :reference-count nil :container-title Journal of Crystal Growth :author [(:given Jaan :family Aarik) (:given Aleks :family Aidla) (:given Väino :family Sammelselg) (:given Teet :family Uustare)] :prefix http://id.crossref.org/prefix/10.1016 :score 1.0 :issued (:date-parts [[1997 11]]) :subject [Condensed Matter Physics Inorganic Chemistry Materials Chemistry] :subtitle [])}
}
</pre>

<p>
That looks excellent. Note there are some non-ascii characters in it, which would have to be fixed. Let us try it on an ASAP article.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(doi-to-bibtex-article "10.1021/ie403744u")
</pre>
</div>

<pre class="example">
@article{,
  author = 	 {José A. Delgado and V. I. Águeda and M. A. Uguina and J. L. Sotelo and P. Brea and Carlos A. Grande},
  title = 	 { Adsorption and Diffusion of H 2 , CO, CH 4 , and CO 2 in BPL Activated Carbon and 13X Zeolite: Evaluation of Performance in Pressure Swing Adsorption Hydrogen Purification by Simulation },
  journal = 	 {Industrial &amp; Engineering Chemistry Research},
  year = 	 {2014},
  volume = 	 {nil},
  number = 	 {nil},
  pages = 	 {140117091024005},
  doi =          {10.1021/ie403744u},
  url =          {http://dx.doi.org/10.1021/ie403744u},
  month = 	 {1},
  json = 	 {(:indexed (:timestamp 1392935578089 :date-parts [[2014 2 20]]) :publisher American Chemical Society (ACS) :source CrossRef :URL http://dx.doi.org/10.1021/ie403744u :ISSN [0888-5885 1520-5045] :DOI 10.1021/ie403744u :type journal-article :title  Adsorption and Diffusion of H 2 , CO, CH 4 , and CO 2 in BPL Activated Carbon and 13X Zeolite: Evaluation of Performance in Pressure Swing Adsorption Hydrogen Purification by Simulation  :deposited (:timestamp 1389916800000 :date-parts [[2014 1 17]]) :page 140117091024005 :reference-count nil :container-title Industrial &amp; Engineering Chemistry Research :author [(:given José A. :family Delgado) (:given V. I. :family Águeda) (:given M. A. :family Uguina) (:given J. L. :family Sotelo) (:given P. :family Brea) (:given Carlos A. :family Grande)] :prefix http://id.crossref.org/prefix/10.1021 :score 1.0 :issued (:date-parts [[2014 1 17]]) :subject [Chemistry(all) Industrial and Manufacturing Engineering Chemical Engineering(all)] :subtitle [])}
}
</pre>

<p>
You see that nil is put in for missing entries. That is probably ok. There is an &amp; in the journal that needs to be cleaned up, but that is easily done with org-ref-clean-bibtex-entry. In summary, this looks like a very convenient way to get bibtex entries inside emacs. I should probably have the function insert that string to a buffer at point, but that is not difficult to do.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/22/Converting-a-doi-to-a-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>org-shift hooks for ordering citations</title>
      <link>http://jkitchin.github.io/blog/2014/05/21/org-shift-hooks-for-ordering-citations</link>
      <pubDate>Wed, 21 May 2014 11:11:56 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">7KY-zIMPuu1Q12Q-Rtiw1N_CItg=</guid>
      <description>org-shift hooks for ordering citations</description>
      <content:encoded><![CDATA[


<p>
I wrote a function that sorts citations by year, but there might be a reason to order them some other way. Here we develop a method to use shift-arrow keys to do the ordering. We will need to write a function that gets the citations in a link, gets the key under point, and then swap with neighboring keys depending on the arrow pressed. It is trivial to get the key under point (org-ref-get-bibtex-key-under-cursor), and we saw before it is easy to get the keys in a link. Let us examine swapping elements of a list here. This is an old algorithm, we store the first value, replace it with the second value, and then set the second value.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-ref-swap-keys (i j keys)
 "swap the keys in a list with index i and j"
 (let ((tempi (nth i keys)))
   (setf (nth i keys) (nth j keys))
   (setf (nth j keys) tempi))
  keys)

(org-ref-swap-keys 2 3 '(1 2 3 4))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">2</td>
<td class="right">4</td>
<td class="right">3</td>
</tr>
</tbody>
</table>

<p>
So, we need to get the keys in the link at point, the key at point, the index of the key at point, and then we can swap them, and reconstruct the link. Here is the function that does this, and that adds the hooks.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-ref-swap-citation-link (direction)
 "move citation at point in direction +1 is to the right, -1 to the left"
 (interactive)
 (let* ((object (org-element-context))	 
        (type (org-element-property :type object))
	(begin (org-element-property :begin object))
	(end (org-element-property :end object))
	(link-string (org-element-property :path object))
        (key (org-ref-get-bibtex-key-under-cursor))
	(keys (org-ref-split-and-strip-string link-string))
        (i (index key keys)) point) ;; defined in org-ref
   (if (&gt; direction 0) ;; shift right
     (org-ref-swap-keys i (+ i 1) keys)
     (org-ref-swap-keys i (- i 1) keys))	
  (setq keys (mapconcat 'identity keys ","))
  ;; and replace the link with the sorted keys
  (cl--set-buffer-substring begin end (concat type ":" keys))
  ;; now go forward to key so we can move with the key
  (re-search-forward key) 
  (goto-char (match-beginning 0))))

(add-hook 'org-shiftright-hook (lambda () (org-ref-swap-citation-link 1)))
(add-hook 'org-shiftleft-hook (lambda () (org-ref-swap-citation-link -1)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">lambda</td>
<td class="left">nil</td>
<td class="left">(org-ref-swap-citation-link -1)</td>
</tr>
</tbody>
</table>

<p>
<a href="#kanan-2008-in-situ">kanan-2008-in-situ</a>,<a href="#kanan-2009-cobal">kanan-2009-cobal</a>,<a href="#lutterman-2009-self-healin">lutterman-2009-self-healin</a>,<a href="#mcalpin-2010-epr-eviden">mcalpin-2010-epr-eviden</a>,<a href="#liu-2014-spect-studies">liu-2014-spect-studies</a>! 
</p>

<p>
That is it! Wow, not hard at all. Check out this video of the code in action: <a href="http://screencast.com/t/YmgA0fnZ1Ogl">http://screencast.com/t/YmgA0fnZ1Ogl</a> 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/21/org-shift-hooks-for-ordering-citations.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Sorting citation links by year</title>
      <link>http://jkitchin.github.io/blog/2014/05/21/Sorting-citation-links-by-year</link>
      <pubDate>Wed, 21 May 2014 09:57:48 EDT</pubDate>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">EhKT-zMVUPA62IgnNvApoaL8Y8g=</guid>
      <description>Sorting citation links by year</description>
      <content:encoded><![CDATA[



<p>
When there are several citations grouped together, I like them sorted by year. For example, I do not like this <a href="#liu-2014-spect-studies">liu-2014-spect-studies</a>,<a href="#mcalpin-2010-epr-eviden">mcalpin-2010-epr-eviden</a>,<a href="#kanan-2009-cobal">kanan-2009-cobal</a>,<a href="#lutterman-2009-self-healin">lutterman-2009-self-healin</a>,<a href="#kanan-2008-in-situ">kanan-2008-in-situ</a>. I prefer <a href="#kanan-2008-in-situ">kanan-2008-in-situ</a>,<a href="#kanan-2009-cobal">kanan-2009-cobal</a>,<a href="#lutterman-2009-self-healin">lutterman-2009-self-healin</a>,<a href="#mcalpin-2010-epr-eviden">mcalpin-2010-epr-eviden</a>,<a href="#liu-2014-spect-studies">liu-2014-spect-studies</a>. It is just a preference, but it seems appropriate to cite things in chronological order. 
</p>

<p>
It is actually a little tedious to sort this by hand though. Hence, today we examine some tools to automate the sorting. The idea is to make a function that will get the keys, sort them by year, and then replace the link with the sorted text.
</p>

<p>
Let us try some sorting. We will construct a set of cons cells with a year and key, sort that list by year, and then concatenate the keys. Here is an example of the sorting. The years will come as strings from the bibtex file.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq data '(("2014" . "key1") ("2012" . "key2")("2016" . "key3")))
(setq data 
	(cl-sort data (lambda (x y) (&lt; (string-to-int (car x)) (string-to-int (car y))))))
(mapconcat (lambda (x) (cdr x)) data ",")
</pre>
</div>

<pre class="example">
key2,key1,key3
</pre>

<p>
That is easy enough. Now, a function to get the year, and then the function to sort a link. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-ref-get-citation-year (key)
  "get the year of an entry with key"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file key))
	 (bibfile (cdr results))
	 (cb (current-buffer)))
    (message "---------%s %s" key bibfile)
    (set-buffer (find-file-noselect bibfile))
    (bibtex-search-entry key nil 0)
    (prog1 (reftex-get-bib-field "year" (bibtex-parse-entry t))
      (set-buffer cb))))

(defun org-ref-sort-citation-link ()
 "replace link at point with sorted link by year"
 (interactive)
 (let* ((object (org-element-context))	 
        (type (org-element-property :type object))
	(begin (org-element-property :begin object))
	(end (org-element-property :end object))
	(link-string (org-element-property :path object))
	keys years data)
  (setq keys (org-ref-split-and-strip-string link-string))
  (setq years (mapcar 'org-ref-get-citation-year keys)) 
  (setq data (mapcar* (lambda (a b) `(,a . ,b)) years keys))
  (setq data (cl-sort data (lambda (x y) (&lt; (string-to-int (car x)) (string-to-int (car y))))))
  ;; now get the keys separated by commas
  (setq keys (mapconcat (lambda (x) (cdr x)) data ","))
  ;; and replace the link with the sorted keys
  (cl--set-buffer-substring begin end (concat type ":" keys))
))
</pre>
</div>

<p>
Now, you put your cursor on a link, run M-x org-ref-sort-citation-link, and the magic happens  <a href="#kanan-2008-in-situ">kanan-2008-in-situ</a>,<a href="#kanan-2009-cobal">kanan-2009-cobal</a>,<a href="#lutterman-2009-self-healin">lutterman-2009-self-healin</a>,<a href="#mcalpin-2010-epr-eviden">mcalpin-2010-epr-eviden</a>,<a href="#liu-2014-spect-studies">liu-2014-spect-studies</a>! It would also be nice to have some arrow commands so you could do something like manually reorder them with S-arrow or something like in the calendar, but that will be another day.</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/21/Sorting-citation-links-by-year.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Creating bibliographies in other formats with org-ref</title>
      <link>http://jkitchin.github.io/blog/2014/05/18/Creating-bibliographies-in-other-formats-with-org-ref</link>
      <pubDate>Sun, 18 May 2014 10:11:18 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">wieL2k9MV3MVAIHJiFZsfkfiC5A=</guid>
      <description>Creating bibliographies in other formats with org-ref</description>
      <content:encoded><![CDATA[



<p>
org-ref automatically generates bibliographies in LaTeX export, and it does a reasonable job automatically generating HTML bibliographies (ox-bibtex probably does this better, but it relies on an external program, whereas this approach is all elisp). Here we illustrate how to generate other formats, e.g. plain text, or org-mode formatted.
</p>

<p>
org-ref provides a convenient function that generates a bibliography entry for a key formatted according to the variable org-ref-bibliography-entry-format. This variable is a string that uses the reftex percent escapes to create an entry. The default is setup for an HTML entry like this:
</p>

<pre class="example">
  "%a, %t, &lt;i&gt;%j&lt;/i&gt;, &lt;b&gt;%v(%n)&lt;/b&gt;, %p (%y). &lt;a href=\"%U\"&gt;link&lt;/a&gt;. &lt;a href=\"http://dx.doi.org/%D\"&gt;doi&lt;/a&gt;."
</pre>

<p>
We can redefine it temporarily to get other formats. Here is an example of getting an org-formatted entry with some italics and bold text.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((org-ref-bibliography-entry-format "%a, %t, /%j/, *%v(%n)*, %p (%y). [[%U][link]]. [[http://dx.doi.org/%D][doi]]."))
(org-ref-get-bibtex-entry-citation "andriotis-2014-infor"))
</pre>
</div>

<p>
"Andriotis, Mpourmpakis, , Broderick, Rajan, Datta, Somnath, Sunkara \&amp; Menon, Informatics guided discovery of surface  structure-chemistry relationships in catalytic  nanoparticles, <i>The Journal of Chemical Physics</i>, <b>140(9)</b>, 094705 (2014). <a href="http://scitation.aip.org/content/aip/journal/jcp/140/9/10.1063/1.4867010">link</a> . <a href="http://dx.doi.org/10.1063/1.4867010">doi</a> .
</p>

<p>
Now, we put some citations of various types in for water splitting <a href="#mccrory-2013-bench-heter">mccrory-2013-bench-heter</a>, CO<sub>2</sub> capture <a href="#alesi-2012-evaluat-primar">alesi-2012-evaluat-primar</a>, and microfluidic devices <a href="#voicu-2014-microf-studies">voicu-2014-microf-studies</a>. We will convert these links to a bibliography shortly.
</p>

<p>
Next, we generate an org-formatted bibliography. We will create a bracketed label at the beginning of the entry, and the org-format after that. This is a functional enough bibliography to be useful I think, and it illustrates the ideas. We will do some light transforming to replace escaped &amp; with regular &amp; in the bibliography.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">;; temorarily redefine the format
(let ((org-ref-bibliography-entry-format "%a, %t, /%j/, *%v(%n)*, %p (%y). [[%U][link]]. [[http://dx.doi.org/%D][doi]]."))

  (mapconcat 
   (lambda (key)
     (format "[%s] %s" key 
	     (replace-regexp-in-string 
	      "\\\\&amp;" 
	      "&amp;" (org-ref-get-bibtex-entry-citation key))))
   (org-ref-get-bibtex-keys) "\n\n"))
</pre>
</div>

<p>
[alesi-2012-evaluat-primar] Alesi &amp; Kitchin, Evaluation of a Primary Amine-Functionalized  Ion-Exchange Resin for \ce{CO_2} Capture, <i>Industrial &amp; Engineering Chemistry Research</i>, <b>51(19)</b>, 6907-6915 (2012). <a href="http://dx.doi.org/10.1021/ie300452c">link</a> . <a href="http://dx.doi.org/10.1021/ie300452c">doi</a> .
</p>

<p>
[mccrory-2013-bench-heter] McCrory, Jung, Peters, Jonas &amp; Jaramillo, Benchmarking Heterogeneous Electrocatalysts for the  Oxygen Evolution Reaction, <i>J. Am. Chem. Soc.</i>, <b>135(45)</b>, 16977&#x2013;16987 (2013). <a href="http://dx.doi.org/10.1021/ja407115p">link</a> . <a href="http://dx.doi.org/10.1021/ja407115p">doi</a> .
</p>

<p>
[voicu-2014-microf-studies] Voicu, Abolhasani, Choueiri, Rachelle, Lestari, Seiler, , Menard, Greener, Guenther, Axel, Stephan &amp; Kumacheva, Microfluidic Studies of \ce{CO_2} Sequestration by  Frustrated {L}ewis Pairs, <i>Journal of the American Chemical Society</i>, <b>0(0)</b>, null (2014). [[][link]]. <a href="http://dx.doi.org/10.1021/ja411601a">doi</a> .
</p>

<p>
You can see some minor issues with the formatting, e.g. sometimes the link is empty, if there is no url in the bibtex entry. There is no easy way to fix that. The 0 and null values in the last entry are because that is an ASAP article, and that is what is in the bibtex entry. I do not try to expand the latex code, and do not plan to do that. I do not know why there appears to be a blank author in the last entry, or why the author full names are not used. Those are reftex issues and  low priority to fix for me. They do not exist in the LaTeX export. The main point here is to get a reasonably useful bibliography that you can adapt as you want.
</p>


<p>
<h1>Bibliography</h1>
<ul><li><a id="alesi-2012-evaluat-primar">[alesi-2012-evaluat-primar] Alesi \& Kitchin, Evaluation of a Primary Amine-Functionalized  Ion-Exchange Resin for \ce{CO_2} Capture, <i>Industrial \& Engineering Chemistry Research</i>, <b>51(19)</b>, 6907-6915 (2012). <a href="http://dx.doi.org/10.1021/ie300452c">link</a>. <a href="http://dx.doi.org/10.1021/ie300452c">doi</a>.</a></li>
<li><a id="mccrory-2013-bench-heter">[mccrory-2013-bench-heter] McCrory, Jung, Peters, Jonas \& Jaramillo, Benchmarking Heterogeneous Electrocatalysts for the  Oxygen Evolution Reaction, <i>J. Am. Chem. Soc.</i>, <b>135(45)</b>, 16977--16987 (2013). <a href="http://dx.doi.org/10.1021/ja407115p">link</a>. <a href="http://dx.doi.org/10.1021/ja407115p">doi</a>.</a></li>
<li><a id="voicu-2014-microf-studies">[voicu-2014-microf-studies] Voicu, Abolhasani, Choueiri, Rachelle, Lestari, Seiler, , Menard, Greener, Guenther, Axel, Stephan \& Kumacheva, Microfluidic Studies of \ce{CO_2} Sequestration by  Frustrated {L}ewis Pairs, <i>Journal of the American Chemical Society</i>, <b>0(0)</b>, null (2014). <a href="">link</a>. <a href="http://dx.doi.org/10.1021/ja411601a">doi</a>.</a></li>
</ul>
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/18/Creating-bibliographies-in-other-formats-with-org-ref.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Using org-ref to keep your bibtex files in order</title>
      <link>http://jkitchin.github.io/blog/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order</link>
      <pubDate>Thu, 15 May 2014 10:59:19 EDT</pubDate>
      <category><![CDATA[bibtex]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">F76lZEkWpqEQm1tOI153NwJwZpA=</guid>
      <description>Using org-ref to keep your bibtex files in order</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. "cleaning" a bibtex entry</a></li>
<li><a href="#sec-2">2. Validating your bibliography</a></li>
<li><a href="#sec-3">3. Sorting your bibtex file</a></li>
<li><a href="#sec-4">4. Make a full bibliography pdf</a></li>
<li><a href="#sec-5">5. Finding bad citation links</a></li>
<li><a href="#sec-6">6. Extracting citations entries</a></li>
<li><a href="#sec-7">7. Summary</a></li>
<li><a href="#sec-8">8. References</a></li>
<li><a href="#sec-9">9. Bibtex entries</a></li>
</ul>
</div>
</div>

<p>
Maintaining an accurate, useful bibliography of references is critical for scientific writing. It is also not trivial. While it is easy to download and copy bibliographic entries to your database, these entries are often incomplete, not consistently formatted, and can contain invalid characters. org-ref provides several utility functions to help with this.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> "cleaning" a bibtex entry</h2>
<div class="outline-text-2" id="text-1">
<p>
Consider this bibtex entry from <a href="http://pubs.acs.org/action/showCitFormats?doi=10.1021%2Fie500588j">http://pubs.acs.org/action/showCitFormats?doi=10.1021%2Fie500588j</a> .
</p>

<div class="org-src-container">

<pre class="src src-bibtex">@article{doi:10.1021/ie500588j,
author = {Okada, Tomohiko and Ozono, Shoya and Okamoto, Masami and Takeda, Yohei and Minamisawa, Hikari M. and Haeiwa, Tetsuji and Sakai, Toshio and Mishima, Shozi},
title = {Magnetic Rattle-Type Coreâ€“Shell Particles Containing Iron Compounds with Acid Tolerance by Dense Silica},
journal = {Industrial &amp; Engineering Chemistry Research},
volume = {0},
number = {0},
pages = {null},
year = {0},
doi = {10.1021/ie500588j},

URL = {http://pubs.acs.org/doi/abs/10.1021/ie500588j},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie500588j}
}
</pre>
</div>

<p>
On the surface it looks fine, but there are the following issues with it:
</p>

<ol class="org-ol">
<li>The bibtex key is hard to remember. I like systematically named keys.
</li>
<li>There is a bare &amp; in the journal title, which is not legal in LaTeX.
</li>
<li>There is no year entry, even though it is a 2014 entry. The pages, volume, and number are also problematic, but this is an ASAP article and the reference does not have those yet.
</li>
<li>It is hard to see, but the dash between core and shell is a non-ascii character, which can cause problems in LaTeX.
</li>
<li>The entry is not very nicely aligned or indented.
</li>
</ol>

<p>
You can fix these problems by putting your cursor on the bibtex entry, and typing M-x org-ref-clean-bibtex-entry. This will fix the bibtex key to a standard form, align and indent the entry, escape the &amp; so it is legal syntax, prompt you for a year, and show you the non-ascii characters so you can replace them. The resulting, nicely formatted entry is shown below.
</p>

<div class="org-src-container">

<pre class="src src-bibtex">@article{okada-2014-magnet-rattl,
  author =	 {Okada, Tomohiko and Ozono, Shoya and Okamoto, Masami
                  and Takeda, Yohei and Minamisawa, Hikari M. and
                  Haeiwa, Tetsuji and Sakai, Toshio and Mishima,
                  Shozi},
  title =	 {Magnetic Rattle-Type Core-Shell Particles Containing
                  Iron Compounds with Acid Tolerance by Dense Silica},
  journal =	 {Industrial \&amp; Engineering Chemistry Research},
  volume =	 0,
  pages =	 {null},
  year =	 2014,
  doi =		 {10.1021/ie500588j},
  number =	 0,
  url =		 {http://pubs.acs.org/doi/abs/10.1021/ie500588j},
  eprint =	 {http://pubs.acs.org/doi/pdf/10.1021/ie500588j},
}
</pre>
</div>

<p>
The key formatting comes from these definitions:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">;; variables that control bibtex key format for auto-generation
;; I want firstauthor-year-title-words
;; this usually makes a legitimate filename to store pdfs under.
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
</pre>
</div>

<p>
You should develop a discipline to clean each entry as you add them, and before you cite them. It is a pain to change the key, and then find and change all the places you used that key before. Now that you have a systematic key, go ahead and download the pdf for the article, and save it in your pdf directory by that key name. Set the variable org-ref-pdf-directory to this directory, and later when you click on citations you will be able to open the pdf easily.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Validating your bibliography</h2>
<div class="outline-text-2" id="text-2">
<p>
<pre>elisp:bibtex-validate</pre> will check your bibliography for valid syntax. This is a bibtex command.
</p>

<p>
<a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Sorting your bibtex file</h2>
<div class="outline-text-2" id="text-3">
<p>
It is a good idea to keep your bibtex file sorted. This will facilitate finding duplicate entries, and will make it easier to find things. I usually add entries to the top of the file, and then clean them. Then run the command <pre>elisp:bibtex-sort-buffer</pre> . This will sort the entries for you. This is also a bibtex command.
</p>

<p>
<a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Make a full bibliography pdf</h2>
<div class="outline-text-2" id="text-4">
<p>
A good way to check your bibliography for duplicates, spelling errors, and invalid formats is to make a pdf containing all the entries. Open your bibtex file, and run <pre>elisp:org-ref-build-full-bibliography</pre> . If all goes well, you will get a pdf of your bibliography that you can check for accuracy. If there are errors, you will have to fix them until the pdf is generated.
</p>

<p>
Try it out: <a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Finding bad citation links</h2>
<div class="outline-text-2" id="text-5">
<p>
Sometimes you will get bad citation links in your document. Maybe there is no corresponding entry, maybe you typed in the wrong key, maybe you changed the key. Either way, you need to find them and fix them. Run the command <pre>elisp:org-ref-find-bad-citations</pre> to find them. <pre>cite:test</pre> 
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Extracting citations entries</h2>
<div class="outline-text-2" id="text-6">
<p>
You will often work from your default bibliography for your own work. Eventually you will need to extract the entries cited so you can send them to someone. The command  <pre>elisp:org-ref-extract-bibtex-entries</pre> will do that for you. If I have cited something <pre>cite:calle-vallejo-2010-trend-stabil</pre> .
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Summary</h2>
<div class="outline-text-2" id="text-7">
<p>
You can see a screen cast of this post here: <a href="http://screencast.com/t/yZCOdO6kJ">http://screencast.com/t/yZCOdO6kJ</a> 
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> References</h2>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Bibtex entries</h2>
<div class="outline-text-2" id="text-9">
<p>
#+BEGIN<sub>SRC</sub>: text :tangle extract-bib7108tYg.bib
@article{calle-vallejo-2010-trend-stabil,
  author =         {Calle-Vallejo, F. and Martinez, J. I. and Garcia-
                  Lastra, J. M. and Mogensen, M. and Rossmeisl, J.},
  title =         {Trends in Stability of Perovskite Oxides},
  journal =         "Angewandte Chemie-International Edition",
  volume =         49,
  number =         42,
  pages =         {7699-7701},
  year =         2010,
  doi =                 {10.1002/anie.201002301},
  keyword =         {density functional calculations heats of formation
                  perovskites thermochemistry transition-metals
                  catalysts ferroelectricity},
}
#+END<sub>SRC</sub>
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Finding missing citation entries in an org-file</title>
      <link>http://jkitchin.github.io/blog/2014/04/29/Finding-missing-citation-entries-in-an-org-file</link>
      <pubDate>Tue, 29 Apr 2014 10:37:51 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">w1ZsdzsG-Q0zDmB-YyEtI5sFYcA=</guid>
      <description>Finding missing citation entries in an org-file</description>
      <content:encoded><![CDATA[



<p>
Today we consider how to find citations in a document that have no corresponding entries in a bibtex file. There are a couple of pieces to this which we work out in stages below. First, we specify the bibtex file using a bibliography link defined in jorg-bib.el. 
</p>


<p>

</p>

<p>
jorg-bib provides a function that gives us the relevant bibliography files found in this file.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cite-find-bibliography)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">bib1.bib</td>
<td class="left">bib2.bib</td>
</tr>
</tbody>
</table>

<p>
We can get a list of keys in these files 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((bibtex-files (cite-find-bibliography)))
(bibtex-global-key-alist))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">(adams-1993-orien-imagin . t)</td>
<td class="left">(aarik-1997-effec-tio2 . t)</td>
<td class="left">(aruga-1985-struc-iron . t)</td>
</tr>
</tbody>
</table>


<p>
Now, here are some citations that we want to include in this document.
</p>

<p>
<pre>cite:aruga-1985-struc-iron,aarik-1997-effec-tio2</pre> 
</p>

<p>
Here is a citation that is not in the bibtex file <pre>cite:kitchin-2016-nobel-lecture</pre> 
</p>


<p>
To find out if any of these are missing, we need a list of the citation keys in this document. We first get all the content from the cite links.  We parse the buffer, and for each cite link, we get the path of the link, which contains our keys.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((parsetree (org-element-parse-buffer)))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (plist-get plist ':path))))))
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">aruga-1985-struc-iron,aarik-1997-effec-tio2</td>
<td class="left">kitchin-2016-nobel-lecture</td>
</tr>
</tbody>
</table>

<p>
That is almost what we need, but we need to separate the keys that are joined by commas. That function already exists in jorg-bib as cite-split-keys. We need to make a slight variation to get a list of all the entries, since the cite-split-keys returns a list of entries for each link. Here is on approach to that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((parsetree (org-element-parse-buffer))
      (results '()))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (setq results (append results (cite-split-keys (plist-get plist ':path))))))))
results)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">aruga-1985-struc-iron</td>
<td class="left">aarik-1997-effec-tio2</td>
<td class="left">kitchin-2016-nobel-lecture</td>
</tr>
</tbody>
</table>

<p>
Ok, now we just need to check each entry of that list against the list of entries in the bibtex files, and highlight any that are not good. We use an index function below to tell us if an element is in a list. This index function works for strings. We use the strange remove-if-not function, which requires something like triple negative logic to get the list of keys that are not in the bibtex files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (parsetree (org-element-parse-buffer))
       (cited-keys))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))			     
	(when (equal (plist-get plist ':type) "cite")
	  (setq cited-keys (append cited-keys (cite-split-keys (plist-get plist ':path))))))))

(princ (remove-if-not (lambda (arg) (not (index arg bibtex-keys))) cited-keys))
)
</pre>
</div>

<pre class="example">
(kitchin-2016-nobel-lecture)
</pre>


<p>
The only improvement from here would be if this generated a temporary buffer with clickable links to find that bad entry! Let us take a different approach here, and print this to a temporary buffer of clickable links. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (bad-citations '()))

  (org-element-map (org-element-parse-buffer) 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))			     
	(when (equal (plist-get plist ':type) "cite")
	  (dolist (key (cite-split-keys (plist-get plist ':path)) )
	    (when (not (index key bibtex-keys))
	      (setq bad-citations (append bad-citations
			    `(,(format "%s [[elisp:(progn (find-file \"%s\")(goto-char %s))][not found here]]\n"
		      key (buffer-file-name)(plist-get plist ':begin)))))
			    ))))))

(mapconcat 'identity bad-citations ""))
</pre>
</div>

<p>
kitchin-2016-nobel-lecture <pre>elisp:(progn (find-file "/home-research/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org")(goto-char 1052))</pre> 
</p>

<p>
That is likely to come in handy. I have put a variation of this code in jorb-bib, in the function called jorg-bib-find-bad-citations.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/29/Finding-missing-citation-entries-in-an-org-file.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>
]]></content:encoded>
    </item>
    <item>
      <title>A popup menu for citation links in org-mode</title>
      <link>http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode</link>
      <pubDate>Mon, 28 Apr 2014 10:13:17 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">D_eQK5m79Ys7SO6BCAnHlUecTBM=</guid>
      <description>A popup menu for citation links in org-mode</description>
      <content:encoded><![CDATA[



<p>
I have been exploring ways to get more information out of links in org-mode. I have considered <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode/">popups</a> , and <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/">right-clicking</a> . Here I show how to get a popup menu on a citation link. The idea is that clicking or opening the ditation link should give you a menu. The menu should give you some context, e.g. if the bibtex key even exists. If it does, you should be able to get a quick view of the citation in the minibuffer. You should be able to open the entry in the bibtex file from the menu. If you have a pdf of the reference, you should have an option to open it. You should be able to open the url associated with the entry from the menu too.
</p>

<p>
Here is the function. We use <a href="https://github.com/auto-complete/popup-el">https://github.com/auto-complete/popup-el</a> , and some code from <a href="https://github.com/jkitchin/jmax/blob/master/jorg-bib.el">https://github.com/jkitchin/jmax/blob/master/jorg-bib.el</a> .
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 "cite"
 ;; this function is run when you click on the link
 (lambda (link-string) 
   (let* ((menu-choice)
         ;; this is in jorg-bib.el
         (results (get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat jorg-bib-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))
     (setq menu-choice
	   (popup-menu* 
	    (list (popup-make-item (if 
				       (progn
					 (let ((cb (current-buffer)) result)					
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       "Simple citation"
				     "No key found")  :value "cite")
		  (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)					  
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       (format "Open %s in %s" key bibfile)
				     "No key found") :value "bib")
		  (popup-make-item 
		   ;; check if pdf exists.jorg-bib-pdf-directory is a user defined directory.
                   ;; pdfs are stored by bibtex key in that directory
		   (if (file-exists-p pdf-file)
		       (format "Open PDF for %s" key)
		     "No pdf found") :value "pdf")
		  (popup-make-item "Open URL" :value "web")
		  (popup-make-item "Open Notes" :value "notes")
		  )))

     (cond
      ;; goto entry in bibfile
      ((string= menu-choice "bib")       
       (find-file bibfile)
       (bibtex-search-entry key))

      ;; goto entry and try opening the url
      ((string= menu-choice "web")   
       (let ((cb (current-buffer)))
	 (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (bibtex-url))
	 (switch-to-buffer cb)))
       
      ;; goto entry and open notes, create notes entry if there is none
      ((string= menu-choice "notes")   
       (find-file bibfile)
       (bibtex-search-entry key)       
       (jorg-bib-open-bibtex-notes))

     ;; open the pdf file if it exists
     ((string= menu-choice "pdf")
      (when (file-exists-p pdf-file)
	  (org-open-file pdf-file)))

     ;; print citation to minibuffer
     ((string= menu-choice "cite")
      (let ((cb (current-buffer)))	
	(message "%s" (save-excursion (find-file bibfile)
				      (bibtex-search-entry key)  
				      (jorg-bib-citation)))
	(switch-to-buffer cb))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(&lt;cite&gt;%s&lt;/cite&gt;)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))
</pre>
</div>


<p>
<pre>cite:daza-2014-carbon-dioxid,mehta-2014-ident-poten,test,ahuja-2001-high-ruo2</pre> 
</p>


<p>

</p>



<p>
Here you can see an example of a menu where I have the PDF:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-1.png"> 
</p>
</div>

<p>
Here is an example menu of a key with no entry:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-2.png"> 
</p>

<p>
And, and entry with no PDF:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-3.png"> 
</p>

<p>
Here is the simple citation:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-4.png"> 
</p>
</div>

<p>
And a reference from the other bibliography:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-5.png"> 
</p>
</div>

<p>
Not bad! I will probably replace the cite link in jorg-bib with something like this.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/28/A-popup-menu-for-citation-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>A better insert citation function for org-mode</title>
      <link>http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode</link>
      <pubDate>Sun, 27 Apr 2014 14:40:45 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">Qfs4wMjjmBPuieOYzteNJS_L0KQ=</guid>
      <description>A better insert citation function for org-mode</description>
      <content:encoded><![CDATA[



<p>
I have setup a reftex citation format that inserts a cite link using reftex like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l"))))))
</pre>
</div>

<p>
I mostly like this, but it does not let me add citations to an existing citation; doing that leads to the insertion of an additional cite within the citation, which is an error. One way to make this simple is to add another cite format which simple returns the selected keys. You would use this with the cursor at the end of the link, and it will just append the results.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))
</pre>
</div>

<p>
That actually works nicely. I would like a better approach though, that involves less keywork. Ideally, a single function that does what I want, which is when on a link, append to it, and otherwise insert a new citation link. Today I will develop a function that fixes that problem. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun insert-cite-link ()
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))    
    (if (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "cite"))
	(progn
	  (goto-char link-string-end)
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))
      (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))
      )))
</pre>
</div>

<p>
That function is it! Org-mode just got a lot better. That function only puts a cite link in, but since that is all I use 99.99+% of the time, it works fine for me!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/27/A-better-insert-citation-function-for-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Multiple search criteria to find bibtex entries</title>
      <link>http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries</link>
      <pubDate>Tue, 08 Apr 2014 20:45:35 EDT</pubDate>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">ZPeThMxMZLintsRIQT8wrSAmq9o=</guid>
      <description>Multiple search criteria to find bibtex entries</description>
      <content:encoded><![CDATA[



<p>
I have been thinking about ways to search my bibtex file with multiple criteria. Eventually, I want a decent natural language search like "au=kitchin and alloy" to find papers authored by me about alloys. For now, I am going to settle with a way to find these. This strategy will create a search function that prints the entries that are found. Here is the prototype idea:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">my-search</span> (key start end)
  (<span style="color: #8b0000;">when</span> (and (re-search-forward <span style="color: #228b22;">"kitchin"</span> end t)
           (re-search-forward <span style="color: #228b22;">"alloy"</span> end t))
      (princ (format <span style="color: #228b22;">"%s\n"</span> (buffer-substring start end)))))

(<span style="color: #8b0000;">with-temp-buffer</span>
  (insert-file-contents <span style="color: #228b22;">"../../bibliography/references.bib"</span>)
  (bibtex-map-entries  'my-search))
</pre>
</div>

<pre class="example">
@ARTICLE{inoglu-2011-ident-sulfur,
  pdf =		 {[[file:bibtex-pdfs/inoglu-2011-ident-sulfur.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::inoglu-2011-ident-sulfur]]},
  author =	 {Inoglu, Nilay and Kitchin, John R.},
  title =	 {Identification of Sulfur-Tolerant Bimetallic
                  Surfaces Using {DFT} Parametrized Models and
                  Atomistic Thermodynamics},
  journal =	 {ACS Catalysis},
  year =	 2011,
  pages =	 {399--407},
  abstract =	 {The identification of sulfur-tolerant alloys for
                  catalytic applications is difficult due to the
                  combinatorially large number of alloy compositions
                  and surface structures that may be
                  considered. Density functional theory calculations
                  (DFT) are not fast enough to enumerate all the
                  possible structures and their sulfur tolerance. In
                  this work, a DFT parametrized algebraic model that
                  accounts for structure and composition was used to
                  estimate the d-band properties and sulfur adsorption
                  energies of 370 transition metal-based bimetallic
                  alloy surfaces.  The estimated properties were
                  validated by DFT calculations for 110 of the surface
                  structures. We then utilized an atomistic
                  thermodynamic framework that includes surface
                  segregation, the presence of adsorbates, and effects
                  of environmental conditions to identify alloy
                  compositions and structures with enhanced sulfur
                  tolerance that are likely to be stable under the
                  environmental conditions. As a case study, we show
                  how this database can be used to identify
                  sulfur-tolerant Cu-based catalysts and compare the
                  results with what is known about these catalysts
                  experimentally.},
  doi =		 {10.1021/cs200039t},
  issn =	 {null},
  type =	 {Journal Article}
}
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {http://dx.doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
@ARTICLE{tierney-2009-hydrog-dissoc,
  pdf =		 {[[file:bibtex-pdfs/tierney-2009-hydrog-dissoc.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::tierney-2009-hydrog-dissoc]]},
  author =	 {Tierney, H. L. and Baber, A. E. and Kitchin,
                  J. R. and Sykes, E.  C. H.},
  title =	 {Hydrogen Dissociation and Spillover on Individual
                  Isolated Palladium Atoms},
  journal =	 {Physical Review Letters},
  year =	 2009,
  volume =	 103,
  number =	 24,
  abstract =	 {Using a combination of low-temperature scanning
                  tunneling microscopy and density functional theory
                  it is demonstrated how the nature of an inert host
                  metal of an alloy can affect the thermodynamics and
                  kinetics of a reaction pathway in a much more
                  profound way than simply a dilution, electronic, or
                  geometric effect. This study reveals that
                  individual, isolated Pd atoms can promote H-2
                  dissociation and spillover onto a Cu(111) surface,
                  but that the same mechanism is not observed for an
                  identical array of Pd atoms in Au(111).},
  pages =	 246102,
  doi =		 {10.1103/PhysRevLett.103.246102},
  issn =	 {0031-9007},
  url =		 {http://prl.aps.org/abstract/PRL/v103/i24/e246102},
  type =	 {Journal Article}
}
</pre>

<p>
That is not too bad. If I had a parser like <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags/">this one</a> , I could do some reasonable searches. I could try integrating it with reftex or something similar for selecting citations. I would like that a lot.
</p>

<p>
What if I wanted to find articles with Kitchin as an author, and alloy in the title? This is my best effort at doing that, where I explicitly match the fields in the bibtex entries.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(find-file <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
(bibtex-map-entries (<span style="color: #8b0000;">lambda</span> (bibtex-key start end) 
                      (<span style="color: #8b0000;">let*</span> ((entry (bibtex-parse-entry))
                             (title (cdr (assoc <span style="color: #228b22;">"title"</span> entry)))
                             (authors (cdr (assoc <span style="color: #228b22;">"author"</span> entry))))
                        (<span style="color: #8b0000;">when</span> (and title (string-match <span style="color: #228b22;">"alloy"</span> title) 
                                   authors (string-match <span style="color: #228b22;">"kitchin"</span> authors))
                          (princ (buffer-substring start end)))))))
</pre>
</div>

<pre class="example">
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {http://dx.doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
</pre>

<p>
This is a more precise search, which yields only one entry. That is not exactly nimble searching, but it does provide precision. I need to think about this some more.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
  </channel>
</rss>
