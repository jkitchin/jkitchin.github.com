

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: bibtex</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Finding-similar-bibtex-entries"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/09/16/Finding-similar-bibtex-entries/" rel="bookmark" title="Permanent Link to Finding similar bibtex entries">Finding similar bibtex entries</a></h2>
      <p><small><span class="blog_post_date">Posted September 16, 2017 at 10:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/similarity/'>similarity</a>, <a href='/blog/category/bibtex/'>bibtex</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/09/16/Finding-similar-bibtex-entries#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
A common task while writing scientific papers is citing previous research. I use org-ref extensively for that, and it makes it pretty easy to find similar references, e.g. that have common authors, or common keywords. It also lets me find similar articles in Web of Science or Scopus. Suppose that I have cited a particular paper, e.g. e <a class='org-ref-reference' href="#boes-2016-neural-networ">boes-2016-neural-networ</a>, and I want to find similar references to it that are <i>already</i> in my bibtex file, and similar by <i>my definition</i>. With org-ref I can easily search by keyword or author to find similar entries, but these are limited by what I search for, and they are not sorted. Today, I will explore the first step in a recommender system that calculates similarity, and provides a sorted list of candidates with the most relevant ones first. 
</p>

<p>
The idea is to calculate some measure of similarity between the title of that reference, and the titles of other references in my bibtex file, and then sort them by similarity. This is the reference I want to find similar entries for:
</p>

<p>
Boes, J. R., Groenenboom, M. C., Keith, J. A., &amp; Kitchin, J. R., Neural network and Reaxff comparison for Au properties, Int. J. Quantum Chem., 116(13), 979–987 (2016).  <a href="http://dx.doi.org/10.1002/qua.25115">http://dx.doi.org/10.1002/qua.25115</a>
</p>

<p>
The first thing we do is read in our bibtex file, and print a representative entry.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> bibtexparser
<span style="color: #0000FF;">from</span> bibtexparser.bparser <span style="color: #0000FF;">import</span> BibTexParser

<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'/Users/jkitchin/Dropbox/bibliography/references.bib'</span>) <span style="color: #0000FF;">as</span> bibtex_file:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">parser</span> = BibTexParser()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">bib_database</span> = bibtexparser.load(bibtex_file, parser=parser)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">entries</span> = bib_database.entries

<span style="color: #0000FF;">print</span>(entries[10])
</pre>
</div>

<p>
{'author': 'Jaan Aarik and Aleks Aidla and V{\\"a}ino Sammelselg and Teet\nUustare', 'title': 'Effect of Growth Conditions on Formation of \\ce{TiO_2}-{II}\nThin Films in Atomic Layer Deposition Process', 'journal': 'Journal of Crystal Growth', 'volume': '181', 'number': '3', 'pages': '259 - 264', 'year': '1997', 'doi': '10.1016/S0022-0248(97)00279-0', 'link': 'http://www.sciencedirect.com/science/article/pii/S0022024897002790', 'issn': '0022-0248', 'ENTRYTYPE': 'article', 'ID': 'aarik-1997-effec-growt'}
</p>

<p>
Each entry is a dictionary containing the fields and their values. For this exploration, I will only consider similarities between titles. The next step is we find which entry corresponds to the reference we want to find similarities to.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">ids</span> = [e[<span style="color: #008000;">'ID'</span>] <span style="color: #0000FF;">for</span> e <span style="color: #0000FF;">in</span> entries]
<span style="color: #BA36A5;">i</span> = ids.index(<span style="color: #008000;">'boes-2016-neural-networ'</span>)
<span style="color: #0000FF;">print</span>(entries[i])
</pre>
</div>

<p>
{'author': 'Jacob R. Boes and Mitchell C. Groenenboom and John A. Keith\nand John R. Kitchin', 'title': 'Neural Network and {Reaxff} Comparison for {Au} Properties', 'journal': 'Int. J. Quantum Chem.', 'volume': '116', 'number': '13', 'pages': '979-987', 'year': '2016', 'doi': '10.1002/qua.25115', 'link': 'http://dx.doi.org/10.1002/qua.25115', 'issn': '1097-461X', 'keyword': 'Kohn-Sham density functional theory, neural networks, reactive\nforce fields, potential energy surfaces, machine learning', 'ENTRYTYPE': 'article', 'ID': 'boes-2016-neural-networ'}
</p>

<p>
It is best if we make the entry we want to find similarities to the first one, so here we swap the first and i<sup>th</sup> entries.
</p>

<div class="org-src-container">
<pre class="src src-ipython">entries[0], <span style="color: #BA36A5;">entries</span>[i] = entries[i], entries[0]
</pre>
</div>

<p>
Now, we prepare the list of strings to get similarities for. 
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">titles</span> = [e.get(<span style="color: #008000;">'title'</span>, <span style="color: #008000;">''</span>) <span style="color: #0000FF;">for</span> e <span style="color: #0000FF;">in</span> entries]
</pre>
</div>


<p>
We will use <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">term frequency–inverse document frequency</a> to get a vector that represents each title, and then use <a href="https://en.wikipedia.org/wiki/Cosine_similarity">cosine similarity</a> as a measure of similarity. Here is the place to note that <i>I chose</i> these, and could choose other ones too. Also, it is worth noting that in this measure of similarity I did <i>not</i> choose which keywords to measure similarity on.
</p>

<p>
The functionality for this is provided by <a href="http://scikit-learn.org/stable/">sklearn</a>. It has implemented functions for the algorithms above, and in just a few lines of code you get an array of tf-idf features to analyze. The array we get from our vectorizer contains normalized vectors, so we can get the cosine similarity just from a dot product of the vectors. The first row corresponds to the similarity of the first string to all the others. I want them sorted in descending order. The argsort function returns ascending order, so we use a trick to sort the negative of the similarity score which achieves that. There are certainly more advanced treatments of the text we could use by <a href="http://scikit-learn.org/stable/modules/feature_extraction.html#customizing-the-vectorizer-classes">customizing the vectorizer</a>, e.g. word stemming, but for now we neglect that.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> sklearn.feature_extraction.text <span style="color: #0000FF;">import</span> TfidfVectorizer

<span style="color: #BA36A5;">vectorizer</span> = TfidfVectorizer(stop_words=<span style="color: #008000;">'english'</span>)
<span style="color: #BA36A5;">X</span> = vectorizer.fit_transform(titles)

<span style="color: #BA36A5;">cosine_similarities</span> = (X * X.T).A[0]

<span style="color: #BA36A5;">related_docs_indices</span> = (-cosine_similarities).argsort()

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The top 10 recommendations for {} are:\n'</span>.<span style="color: #006FE0;">format</span>(S[0]))
<span style="color: #0000FF;">for</span> i, j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(related_docs_indices[1:11]):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{i}. {ID}: {title}, {author}\n'</span>.<span style="color: #006FE0;">format</span>(i=i + 1, **entries[j]))
</pre>
</div>

<p>
The top 10 recommendations for Neural Network and {Reaxff} Comparison for {Au} Properties are:
</p>

<ol class="org-ol">
<li>behler-2010-neural: Neural network potential-energy surfaces for atomistic</li>
</ol>
<p>
simulations, J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>boes-2017-neural-networ: Neural Network Predictions of Oxygen Interactions on a Dynamic</li>
</ol>
<p>
{Pd} Surface, Jacob R. Boes and John R. Kitchin
</p>

<ol class="org-ol">
<li>eshet-2010-ab: Ab Initio Quality Neural-Network Potential for Sodium, Hagai Eshet and Rustam Z. Khaliullin and Thomas D. K{\"u}hne</li>
</ol>
<p>
and J{\"o}rg Behler and Michele Parrinello
</p>

<ol class="org-ol">
<li>behler-2014-repres-poten: Representing Potential Energy Surfaces By High-Dimensional</li>
</ol>
<p>
Neural Network Potentials, J Behler
</p>

<ol class="org-ol">
<li>behler-2007-gener-neural: Generalized Neural-Network Representation of High-Dimensional</li>
</ol>
<p>
Potential-Energy Surfaces, J{\"o}rg Behler and Michele Parrinello
</p>

<ol class="org-ol">
<li>artrith-2012-high: High-Dimensional Neural Network Potentials for Metal Surfaces:</li>
</ol>
<p>
A Prototype Study for Copper, Nongnuch Artrith and J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>behler-2015-const: Constructing High-Dimensional Neural Network Potentials: A</li>
</ol>
<p>
Tutorial Review, J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>artrith-2011-high: High-Dimensional Neural-Network Potentials for Multicomponent</li>
</ol>
<p>
Systems: Applications To Zinc Oxide, Nongnuch Artrith and Tobias Morawietz and J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>sosso-2012-neural-gete: Neural Network Interatomic Potential for the Phase Change</li>
</ol>
<p>
Material \ce{GeTe}, Gabriele C. Sosso and Giacomo Miceli and Sebastiano Caravati
and J{\"o}rg Behler and Marco Bernasconi
</p>

<ol class="org-ol">
<li>lorenz-2006-descr: Descriptions of Surface Chemical Reactions Using a Neural</li>
</ol>
<p>
Network Representation of the Potential-Energy Surface, S{\"o}nke Lorenz and Matthias Scheffler and Axel Gross
</p>

<p>
It is evident that this is showing other references containing the words "neural network"! I guess that is a little disappointing, since these would just as easily been narrowed down in org-ref. On the other hand, they are sorted and grouped, which would not happen in org-ref. This is a comparison of pretty short strings (just the titles), so maybe this would be much more interesting if abstracts were also included. Including authors would give a different set as well (I tried it, and got a bunch of my own references!).
</p>

<p>
I don't think it would be very difficult to get this into an Emacs selection tool, e.g. helm/ivy. Check this out:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> pycse.lisp

related_docs_indices[1:6].lisp
</pre>
</div>

<p>

</p>

<p>
'(1592 1650 299 1751 103)'
</p>


<p>
That is a result that can be read directly by lisp, so we could simply write the code above as a shell script that takes an argument, and returns a list of indices to sort the candidates on. The alternative is to implement this in elisp, perhaps via a dynamic module if there is already a good C library for this. My sense is the Python libraries are more advanced in functionality.
</p>

<p>
This could have a number of other applications. Given some reference content, you could imagine finding emails that are similar to it, finding RSS entries that are similar to it, finding org headlines that are related, similar files, or similarity with any other set of strings that can be gathered, e.g. from Crossref or some other search, etc. I predict there will be more on these topics in the future!
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/09/16/Finding-similar-bibtex-entries.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/09/16/Finding-similar-bibtex-entries#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Automated-bibtex-entry-tweeting"></div>
      <h2 class="blog_post_title"><a href="/blog/2016/08/25/Automated-bibtex-entry-tweeting/" rel="bookmark" title="Permanent Link to Automated bibtex entry tweeting">Automated bibtex entry tweeting</a></h2>
      <p><small><span class="blog_post_date">Posted August 25, 2016 at 12:14 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/twitter/'>twitter</a>, <a href='/blog/category/bibtex/'>bibtex</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2016/08/25/Automated-bibtex-entry-tweeting#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated August 25, 2016 at 02:09 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The goal in this post is to develop an elisp function that will tweet a bibtex entry. What I want is to be on a bibtex entry, and run a command that will generate a tweet and tweet it. Here is an example bibtex entry I will use in this post. Clearly, I couldn't simply tweet the entry, it is too long. What I want instead is to generate a picture of a formatted citation, to make a gist out of the bibtex entry so we can link to it, and then to provide links in the tweet to the doi, and the bibtex entry gist. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect <span style="color: #008000;">"~/Dropbox/bibliography/references.bib"</span>)
  (goto-char (point-min))
  (re-search-forward <span style="color: #008000;">"kitchin-2016-autom-data,"</span>)
  (bibtex-copy-entry-as-kill)
  (<span style="color: #0000FF;">with-temp-buffer</span>
    (bibtex-yank 1)
    (buffer-string)))
</pre>
</div>

<p>
First, we tackle making an image. Emacs has some capability to generate svg, and we can readily convert that to png for the tweet. Here we just go to the entry, and then generate a png. I build off the citation capability of org-ref to generate a pretty reasonably formatted entry. It isn't perfect; the volume is missing in the entry, so there is a blank space between two commas, but this is good enough for me. Note we need a png for twitter. It appears you cannot upload svg yet.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((entry (<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect <span style="color: #008000;">"~/Dropbox/bibliography/references.bib"</span>)
                (goto-char (point-min))
                (re-search-forward <span style="color: #008000;">"kitchin-2016-autom-data,"</span>)
                (bibtex-beginning-of-entry)
                (bibtex-parse-entry t)))
       (formatted-entry (orhc-formatted-citation entry))
       (lines (<span style="color: #0000FF;">with-temp-buffer</span>
                (insert formatted-entry)
                (fill-paragraph)
                (split-string  (buffer-string) <span style="color: #008000;">"\n"</span>)))
       (svg (svg-create 500 (* 20 (length lines)))))

  (<span style="color: #0000FF;">loop</span> for i from 0
        for line in lines
        do
        (svg-text svg line
                  <span style="color: #006FE0;">:font-size</span> <span style="color: #008000;">"12"</span>
                  <span style="color: #006FE0;">:stroke</span> <span style="color: #008000;">"black"</span>
                  <span style="color: #006FE0;">:x</span> 0
                  <span style="color: #006FE0;">:y</span> (+ 15 (* i 15))
                  <span style="color: #006FE0;">:stroke-width</span> 0.3))

  (<span style="color: #0000FF;">with-temp-file</span> <span style="color: #008000;">"authoring.svg"</span>
    (svg-print svg)))

(shell-command <span style="color: #008000;">"convert authoring.svg authoring.png"</span>)
</pre>
</div>

<p>
<img src="/media/authoring.png"> 
</p>

<p>
It is easy enough to get the doi, and generate the url to it.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((entry (<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect <span style="color: #008000;">"~/Dropbox/bibliography/references.bib"</span>)
                (goto-char (point-min))
                (re-search-forward <span style="color: #008000;">"kitchin-2016-autom-data,"</span>)
                (bibtex-beginning-of-entry)
                (bibtex-parse-entry t))))
  (format <span style="color: #008000;">"http://dx.doi.org/%s"</span> (cdr (assoc <span style="color: #008000;">"doi"</span> entry ))))
</pre>
</div>

<p>
Next, we will put the entry as a gist on Github, so we can provide a link to it. I use the gist.el package, and here just do some trickery to put the entry in a temp-file named by the key so that the gist has a nice name. This returns the url to the gist, which we would want to incorporate into a tweet.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect <span style="color: #008000;">"~/Dropbox/bibliography/references.bib"</span>)
  (goto-char (point-min))
  (re-search-forward <span style="color: #008000;">"kitchin-2016-autom-data,"</span>)
  (<span style="color: #0000FF;">save-restriction</span>
    (bibtex-narrow-to-entry)
    (bibtex-beginning-of-entry)
    (<span style="color: #0000FF;">let*</span> ((entry-string (buffer-string))
           (entry (bibtex-parse-entry))
           (key (cdr (assoc <span style="color: #008000;">"=key="</span> entry)))
           (tfile (expand-file-name (format <span style="color: #008000;">"%s.bib"</span> key) temporary-file-directory)))
      (<span style="color: #0000FF;">with-temp-file</span> tfile
        (insert entry-string))
      (<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect tfile) 
        (gist-buffer)))
    (<span style="color: #0000FF;">with-temp-buffer</span>
      (yank)
      (buffer-string))))
</pre>
</div>


<p>
Ok, All the pieces are in place. The only piece left is creating the tweet, and tweeting it. I couldn't see an obvious way to do this with twittering mode, since I didn't see where to add an image. There is a <a href="https://pypi.python.org/pypi/TwitterAPI/2.4.2">Python library</a> for this though, and it looks pretty easy to use. Here is an example usage. 
</p>


<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">from</span> TwitterAPI <span style="color: #0000FF;">import</span> TwitterAPI
<span style="color: #0000FF;">from</span> twitter_secrets <span style="color: #0000FF;">import</span> CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN_KEY, ACCESS_TOKEN_SECRET

<span style="color: #BA36A5;">api</span> = TwitterAPI(CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN_KEY, ACCESS_TOKEN_SECRET)
<span style="color: #006FE0;">file</span> = <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'authoring.png'</span>, <span style="color: #008000;">'rb'</span>)
<span style="color: #BA36A5;">data</span> = <span style="color: #006FE0;">file</span>.read()
<span style="color: #BA36A5;">r</span> = api.request(<span style="color: #008000;">'statuses/update_with_media'</span>, {<span style="color: #008000;">'status'</span>:<span style="color: #008000;">'A test tweet using the TwitterAPI with an image.'</span>}, {<span style="color: #008000;">'media[]'</span>:data})
<span style="color: #0000FF;">print</span>(r.status_code)
</pre>
</div>

<p>
200
</p>

<p>
It will be a tad hacky, but the script is so simple we can just make a template, and run it. We need to do these things: 1) make the image, 2) make the gist 3) format and send the tweet. Here is the elisp function to do that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">tweet-bibtex</span> ()
  <span style="color: #036A07;">"Tweet the bibtex entry at point."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (bibtex-beginning-of-entry)
  (bibtex-set-field <span style="color: #008000;">"tweeted"</span> (current-time-string))

  (<span style="color: #0000FF;">let*</span> ((entry-string (<span style="color: #0000FF;">save-restriction</span>
                         (bibtex-beginning-of-entry)
                         (bibtex-narrow-to-entry)
                         (buffer-substring-no-properties (point-min) (point-max))))
         (entry (bibtex-parse-entry t))
         (key (cdr (assoc <span style="color: #008000;">"=key="</span> entry)))
         (doi (cdr (assoc <span style="color: #008000;">"doi"</span> entry)))
         (svg-file (expand-file-name (format <span style="color: #008000;">"%s.svg"</span> key) temporary-file-directory))
         (png-file (expand-file-name (format <span style="color: #008000;">"%s.png"</span> key) temporary-file-directory))
         (bib-file (expand-file-name (format <span style="color: #008000;">"%s.bib"</span> key) temporary-file-directory))
         (py-file (expand-file-name (format <span style="color: #008000;">"%s.py"</span> key) temporary-file-directory))
         (formatted-entry (orhc-formatted-citation entry))
         (lines (<span style="color: #0000FF;">with-temp-buffer</span>
                  (insert formatted-entry)
                  (fill-paragraph)
                  (split-string  (buffer-string) <span style="color: #008000;">"\n"</span>)))
         (svg (svg-create 500 (* 20 (length lines))))
         (tweet (read-string <span style="color: #008000;">"Tweet: "</span>))
         gist-url
         full-tweet) 

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">delete buffers and files</span>
    (<span style="color: #0000FF;">loop</span> for buf in (list (concat key <span style="color: #008000;">".bib"</span>)
                           (concat key <span style="color: #008000;">".png"</span>)
                           (concat key <span style="color: #008000;">".svg"</span>)
                           (concat key <span style="color: #008000;">".py"</span>))
          do 
          (<span style="color: #0000FF;">when</span> (get-buffer buf) 
            (kill-buffer (get-buffer buf))))

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Step 1 make the image</span>
    (<span style="color: #0000FF;">loop</span> for i from 0
          for line in lines
          do
          (svg-text svg line
                    <span style="color: #006FE0;">:font-size</span> <span style="color: #008000;">"12"</span>
                    <span style="color: #006FE0;">:stroke</span> <span style="color: #008000;">"black"</span>
                    <span style="color: #006FE0;">:x</span> 0
                    <span style="color: #006FE0;">:y</span> (+ 15 (* i 15))
                    <span style="color: #006FE0;">:stroke-width</span> 0.3))

    (<span style="color: #0000FF;">with-temp-file</span> svg-file
      (svg-print svg))

    (shell-command (format <span style="color: #008000;">"convert %s %s"</span> svg-file png-file))

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Step 2, make the gist. Make a temp-file so the gist has a reasonable name</span>
    (<span style="color: #0000FF;">with-temp-file</span> bib-file
      (insert entry-string))

    (<span style="color: #0000FF;">let</span> ((bib-buffer (find-file-noselect bib-file)))
      (<span style="color: #0000FF;">with-current-buffer</span> bib-buffer
        (gist-buffer))
      (kill-buffer bib-buffer))

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">get url off clipboard</span>
    (<span style="color: #0000FF;">setq</span> gist-url (<span style="color: #0000FF;">with-temp-buffer</span>
                     (yank)
                     (buffer-string)))

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Format and send the tweet:</span>
    (<span style="color: #0000FF;">setq</span> full-tweet (format <span style="color: #008000;">"#publication %s\nhttp://dx.doi.org/%s\nbibtex: %s"</span> tweet doi gist-url))

    (<span style="color: #0000FF;">with-temp-file</span> py-file
      (insert (format <span style="color: #008000;">"from TwitterAPI import TwitterAPI</span>
<span style="color: #008000;">from twitter_secrets import CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN_KEY, ACCESS_TOKEN_SECRET</span>

<span style="color: #008000;">api = TwitterAPI(CONSUMER_KEY, CONSUMER_SECRET, ACCESS_TOKEN_KEY, ACCESS_TOKEN_SECRET)</span>
<span style="color: #008000;">file = open('%s', 'rb')</span>
<span style="color: #008000;">data = file.read()</span>
<span style="color: #008000;">r = api.request('statuses/update_with_media', {'status':'''%s'''}, {'media[]':data})"</span>
                      png-file
                      full-tweet)))

    (<span style="color: #0000FF;">if</span> (= 0 (shell-command (format <span style="color: #008000;">"python %s"</span> py-file)))
        (message <span style="color: #008000;">"%s"</span> full-tweet)
      (message <span style="color: #008000;">"tweet failed ;("</span>))))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Now, try it out.</span>
(<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect <span style="color: #008000;">"~/Dropbox/bibliography/references.bib"</span>)
  (goto-char (point-min))
  (re-search-forward <span style="color: #008000;">"kitchin-2016-autom-data,"</span>)
  (tweet-bibtex))
</pre>
</div>

<p>
You can see what this tweet looks like here:
</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr"><a href="https://twitter.com/hashtag/publication?src=hash">#publication</a> I tweeted this from a bibtex file.<a href="https://t.co/NGVlRGqKSJ">https://t.co/NGVlRGqKSJ</a><br>bibtex: <a href="https://t.co/0UEkvyBKAM">https://t.co/0UEkvyBKAM</a> <a href="https://t.co/OpbAt1h3OP">pic.twitter.com/OpbAt1h3OP</a></p>&mdash; John Kitchin (@johnkitchin) <a href="https://twitter.com/johnkitchin/status/768838551140261894">August 25, 2016</a></blockquote> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>
That seems pretty reasonable. Now I only need to use it about 48,000 times to benefit from the time-savings M-x tweet-bibtex offers compared to manually making all those tweets ;) 
</p>
<p>Copyright (C) 2016 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2016/08/25/Automated-bibtex-entry-tweeting.org">org-mode source</a></p>
<p>Org-mode version = 8.3.4</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2016/08/25/Automated-bibtex-entry-tweeting#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="A-python-version-of-the-s-exp-bibtex-entry"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry/" rel="bookmark" title="Permanent Link to A python version of the s-exp bibtex entry">A python version of the s-exp bibtex entry</a></h2>
      <p><small><span class="blog_post_date">Posted June 11, 2015 at 10:02 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/python/'>python</a>, <a href='/blog/category/bibtex/'>bibtex</a>, <a href='/blog/category/ref/'>ref</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/">post</a> we explored representing a bibtex entry in lisp s-exp notation, and showed interesting things that enables. Here, I explore something similar in Python. The s-exp notation in Python is really more like tuples. It looks almost identical, except we need a lot of commas for the Python syntax. One significant difference in Python is we need to define the functions in advance because otherwise the function symbols are undefined. Similar to lisp, we can define the field functions at run-time in a loop. We have to use an eval statement, which some Pythonistas find distasteful, but it is not that different to me than what we did in lisp.
</p>

<p>
The syntax for "executing" the data structure is quite different than in lisp, because this data is <i>not</i> code in Python. Instead, we have to deconstruct the data, knowing that the function is the first object, and it takes the remaining arguments in the tuple.
</p>

<p>
Here is the proof of concept:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">article</span>(bibtex_key, *args):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Return the bibtex formatted entry"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">',\n'</span>.join([<span style="color: #008000;">'@article{{{0}}}'</span>.<span style="color: #006FE0;">format</span>(bibtex_key)] +[arg[0](arg[1]) <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> args[0]] + [<span style="color: #008000;">'}'</span>])

<span style="color: #BA36A5;">fields</span> = (<span style="color: #008000;">"author"</span>, <span style="color: #008000;">"title"</span>, <span style="color: #008000;">"journal"</span>, <span style="color: #008000;">"pages"</span>, <span style="color: #008000;">"number"</span>, <span style="color: #008000;">"doi"</span>, <span style="color: #008000;">"url"</span>, <span style="color: #008000;">"eprint"</span>, <span style="color: #008000;">"year"</span>)

<span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> fields:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #006FE0;">locals</span>()[f] = <span style="color: #006FE0;">eval</span> (<span style="color: #008000;">'lambda x: "  {0} = {{{1}}}".format("'</span> + f + <span style="color: #008000;">'", x)'</span>)

<span style="color: #BA36A5;">entry</span> = (article, <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (author, <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>),
         (title, <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>),
         (journal, <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>),
         (pages, <span style="color: #008000;">"10788-10794"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (year, 2013),
         (number, 31),
         (doi, <span style="color: #008000;">"10.1021/ie400582a"</span>),
         (url, <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>),
         (eprint, <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))


<span style="color: #0000FF;">print</span> entry[0](entry[1], entry[2:])
</pre>
</div>

<pre class="example">
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \&amp; Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
</pre>

<p>
We can still get specific fields out. Since we used a tuple here, it is not quite as nice as using a dictionary, but it is neither too bad, and it can be wrapped in a reasonably convenient function.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">article</span>(bibtex_key, *args):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Return the bibtex formatted entry"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">',\n'</span>.join([<span style="color: #008000;">'@article{{{0}}}'</span>.<span style="color: #006FE0;">format</span>(bibtex_key)] +[arg[0](arg[1]) <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> args[0]] + [<span style="color: #008000;">'}'</span>])

<span style="color: #BA36A5;">fields</span> = (<span style="color: #008000;">"author"</span>, <span style="color: #008000;">"title"</span>, <span style="color: #008000;">"journal"</span>, <span style="color: #008000;">"pages"</span>, <span style="color: #008000;">"number"</span>, <span style="color: #008000;">"doi"</span>, <span style="color: #008000;">"url"</span>, <span style="color: #008000;">"eprint"</span>, <span style="color: #008000;">"year"</span>)

<span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> fields:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #006FE0;">locals</span>()[f] = <span style="color: #006FE0;">eval</span> (<span style="color: #008000;">'lambda x: "  {0} = {{{1}}}".format("'</span> + f + <span style="color: #008000;">'", x)'</span>)

<span style="color: #BA36A5;">entry</span> = (article, <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (author, <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>),
         (title, <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>),
         (journal, <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>),
         (pages, <span style="color: #008000;">"10788-10794"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (year, 2013),
         (number, 31),
         (doi, <span style="color: #008000;">"10.1021/ie400582a"</span>),
         (url, <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>),
         (eprint, <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))


<span style="color: #0000FF;">for</span> field <span style="color: #0000FF;">in</span> entry[2:]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> field[0] == author:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span> field

<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_field</span>(entry, field):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> element <span style="color: #0000FF;">in</span> entry[2:]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> element[0] == field:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> element[1]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">None</span>

<span style="color: #0000FF;">print</span> get_field(entry, title)
<span style="color: #0000FF;">print</span> get_field(entry, <span style="color: #008000;">"bad"</span>)
</pre>
</div>

<pre class="example">
(&lt;function &lt;lambda&gt; at 0x1005975f0&gt;, 'Hallenbeck, Alexander P. and Kitchin, John R.')
Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent
None
</pre>

<p>
So, it seems Python can do some things like lisp in treating functions like first-class objects that can be used as functions, or keys. I still like the lisp s-exp better, but this is an interesting idea for Python too.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="A-sexp-version-of-a-bibtex-entry"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/" rel="bookmark" title="Permanent Link to A sexp version of a bibtex entry">A sexp version of a bibtex entry</a></h2>
      <p><small><span class="blog_post_date">Posted June 10, 2015 at 08:54 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/lisp/'>lisp</a>, <a href='/blog/category/bibtex/'>bibtex</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
Below you see a typical bibtex entry. Today we explore an alternate approach to represent the information (data) in that entry as s-expressions, i.e. as a lisp data structure. Why? because it seems like an interesting exploration!
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">hallenbeck-2013-effec-o2</span>,
  <span style="color: #BA36A5;">author</span> =       "Hallenbeck, Alexander P. and Kitchin, John R.",
  <span style="color: #BA36A5;">title</span> =        {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a
                  primary-amine based polymeric \ce{CO_2} sorbent},
  <span style="color: #BA36A5;">keywords</span> =     {RUA, orgmode},
  <span style="color: #BA36A5;">journal</span> =      "Industrial \&amp; Engineering Chemistry Research",
  <span style="color: #BA36A5;">pages</span> =        "10788-10794",
  <span style="color: #BA36A5;">year</span> =         2013,
  <span style="color: #BA36A5;">volume</span> =       {52},
  <span style="color: #BA36A5;">number</span> =       {31},
  <span style="color: #BA36A5;">doi</span> =          "<span style="color: #006DAF; text-decoration: underline;">10.1021/ie400582a</span>",
  <span style="color: #BA36A5;">url</span> =          "<span style="color: #006DAF; text-decoration: underline;">http://pubs.acs.org/doi/abs/10.1021/ie400582a</span>",
  <span style="color: #BA36A5;">eprint</span> =       "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
</pre>
</div>

<p>
Here is what that same data structure might look like as a sexp-based lisp data structure.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
         (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
         (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
         (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
         (pages <span style="color: #008000;">"10788-10794"</span>)
         (year 2013)
         (number 31)
         (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
         (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
         (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))
</pre>
</div>

<p>
We can retrieve data from the sexp form pretty easily. Here we get the authors.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((art '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                      (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                      (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                      (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                      (pages <span style="color: #008000;">"10788-10794"</span>)
                      (year 2013)
                      (number 31)
                      (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                      (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                      (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>)))
       (fields (cddr art)))
  (cadr (assoc 'author fields)))
</pre>
</div>

<pre class="example">
Hallenbeck, Alexander P. and Kitchin, John R.
</pre>

<p>
That is simple enough you might just write a little function to streamline it like this, and return a formatted string.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-article-field</span> (article field)
  <span style="color: #036A07;">"Return value of FIELD in ARTICLE."</span>
  (cadr (assoc field (cddr article))))

(<span style="color: #0000FF;">let</span> ((art '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                     (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                     (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                     (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                     (pages <span style="color: #008000;">"10788-10794"</span>)
                     (year 2013)
                     (number 31)
                     (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                     (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                     (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
  (format <span style="color: #008000;">"%s, doi:%s (%s)"</span>
          (get-article-field art 'author)
          (get-article-field art 'doi)
          (get-article-field art 'year)))
</pre>
</div>

<pre class="example">
Hallenbeck, Alexander P. and Kitchin, John R., doi:10.1021/ie400582a (2013)
</pre>

<p>
You might be wondering, why is that even a little bit interesting? One reason is that it looks a little like what lisp returns after parsing an xml file. Another is, the data structure looks kind of like data, but it is also some code, if article was defined as a function!  Let us consider what this might look like. I use a macro to define the field functions since in this case they all do the same thing, and these simply return a string with the field-name and value in curly brackets. We eval the macro to make sure it defines the function. I define an article function that wraps the fields in @bibtex-key{fields}, which defines a bibtex entry.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">make-field</span> (field-name)
  <span style="color: #036A07;">"define a field that returns a string"</span>
  `(<span style="color: #0000FF;">defun</span> ,(intern field-name) (content)
     (format <span style="color: #008000;">"  %s = {%s}"</span> ,field-name content)))

(<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span> <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
  do (eval `(make-field ,field)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">article</span> (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
  (concat
   (format <span style="color: #008000;">"@article{%s,\n"</span> bibtex-key)
   (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">",\n"</span>)
   <span style="color: #008000;">"\n}\n"</span>))

(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
         (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
         (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
         (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
         (pages <span style="color: #008000;">"10788-10794"</span>)
         (number 31)
         (year 2013)
         (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
         (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
         (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))
</pre>
</div>

<pre class="example">
@article{hallenbeck-2013-effec-o2,
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent},
  journal = {Industrial &amp; Engineering Chemistry Research},
  pages = {10788-10794},
  number = {31},
  year = {2013},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a}
}
</pre>

<p>
Wow. We <i>executed</i> our data structure, and got a bibtex entry! That seems moderately interesting to me. Next is an example of taking the same data structure and rendering it as xml. This is some lispy wizardry, rather than use a macro to define functions, I temporarily define functions within a cl-flet macro, which I have to collect as a list of code. Then, I eval the list. This feels pretty odd, but seems like a lispy kind of thing to do.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval
 (list 'cl-flet
       (append (<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span>
                                      <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
                       collect (list (intern field)
                                     '(content)
                                     `(format <span style="color: #008000;">"  &lt;%s&gt;%s&lt;/%s&gt;"</span> ,field content ,field)))
               '((article (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
                          (concat
                           (format
                            <span style="color: #008000;">"&lt;article bibtex-key=\"%s\"&gt;\n"</span> bibtex-key)
                           (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">"\n"</span>)
                           <span style="color: #008000;">"\n&lt;/article&gt;"</span>)))
               )
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">body of cl-flet</span>
       '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                (pages <span style="color: #008000;">"10788-10794"</span>)
                (number 31)
                (year 2013)
                (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
</pre>
</div>

<pre class="example">
&lt;article bibtex-key="hallenbeck-2013-effec-o2"&gt;
  &lt;author&gt;Hallenbeck, Alexander P. and Kitchin, John R.&lt;/author&gt;
  &lt;title&gt;Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent&lt;/title&gt;
  &lt;journal&gt;Industrial &amp; Engineering Chemistry Research&lt;/journal&gt;
  &lt;pages&gt;10788-10794&lt;/pages&gt;
  &lt;number&gt;31&lt;/number&gt;
  &lt;year&gt;2013&lt;/year&gt;
  &lt;doi&gt;10.1021/ie400582a&lt;/doi&gt;
  &lt;url&gt;http://pubs.acs.org/doi/abs/10.1021/ie400582a&lt;/url&gt;
  &lt;eprint&gt;http://pubs.acs.org/doi/pdf/10.1021/ie400582a&lt;/eprint&gt;
&lt;/article&gt;
</pre>

<p>
Prefer json? No problem, just reformat the functions!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval
 (list 'cl-flet
       (append (<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span>
                                      <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
                       collect (list (intern field)
                                     '(content)
                                     `(format <span style="color: #008000;">"   \"%s\": \"%s\""</span> ,field content)))
               '((article (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
                          (concat
                           (format
                            <span style="color: #008000;">"{\"article\":\n  {\"bibtex-key\": \"%s\",\n"</span> bibtex-key)
                           (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">",\n"</span>)
                           <span style="color: #008000;">"}\n}"</span>))))
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">body of cl-flet</span>
       '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                (pages <span style="color: #008000;">"10788-10794"</span>)
                (number 31)
                (year 2013)
                (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
</pre>
</div>

<pre class="example">
{"article":
  {"bibtex-key": "hallenbeck-2013-effec-o2",
   "author": "Hallenbeck, Alexander P. and Kitchin, John R.",
   "title": "Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent",
   "journal": "Industrial &amp; Engineering Chemistry Research",
   "pages": "10788-10794",
   "number": "31",
   "year": "2013",
   "doi": "10.1021/ie400582a",
   "url": "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
   "eprint": "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"}
}
</pre>

<p>
Is this useful? Great question. I don't plan to convert by bibtex files to sexp format anytime soon ;) The format I used above is just a simple one. It might be desirable to include individual authors instead of an author string, and maybe support attributes to establish an author order. An author structure might be more complex to include scientific ids like an orcid, alternative names, etc&#x2026; Finally, the s-exp data structure is super easy to use in lisp, but other languages would have parse it into some native structure the way they parse json or xml. There is limited support for s-expressions in most other non-lispy languages.
</p>

<p>
I like the idea of data representation as code, and its conversion to some other kind of format. It is subtle here, but notice we <i>never</i> had to write a parser for the sexp notation. That <i>already exists as the lisp interpreter</i>. We did write code to use the data, and convert the data. The sexp notation is pretty easy to write, in contrast to the xml or json representations. Some interesting issues might be what to do with fields that are not defined, perhaps a macro would be used on the fly, or in the cl-flet definition. It is hard to imagine doing these things in another language than lisp!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/10/A-sexp-version-of-a-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Bibtex-Entries-from-Arxiv-org"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/03/09/Bibtex-Entries-from-Arxiv-org/" rel="bookmark" title="Permanent Link to Bibtex Entries from Arxiv.org">Bibtex Entries from Arxiv.org</a></h2>
      <p><small><span class="blog_post_date">Posted March 09, 2015 at 03:14 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bibtex/'>bibtex</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/03/09/Bibtex-Entries-from-Arxiv-org#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
<a href="http://arxiv.org">http://arxiv.org</a> is an open-source physics preprint server where copies of scientific manuscripts can be found. For example, <a href="http://arxiv.org/abs/0801.1144">http://arxiv.org/abs/0801.1144</a> is a paper I wrote, and you can find the PDF for that paper here: <a href="http://arxiv.org/pdf/0801.1144v1">http://arxiv.org/pdf/0801.1144v1</a> . Each entry at Arxiv has an arxiv number, and for this paper the number is "0801.1144". In this post, we explore some capabilities of the <a href="https://github.com/jkitchin/org-ref/blob/master/arxiv.el">arxiv.el</a> library which is part of org-ref (<a href="https://github.com/jkitchin/org-ref">https://github.com/jkitchin/org-ref</a> ).
</p>

<p>
To use this library, get the org-ref distribution, make sure it is on your path, and then require the library:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">arxiv</span>)
</pre>
</div>

<p>
First, there is a new org-link:  <a href="http://arxiv.org/abs/0801.1144">arxiv:0801.1144</a>. This is a clickable link that simply opens arxiv.org at the URL for an arxiv number, and exports as a link to that entry in arxiv.
</p>

<p>
On the right hand side of the arxiv page, there is a link under References &amp; Citations that takes you to a page where you can get a bibtex entry. The link for this entry is <a href="http://adsabs.harvard.edu/cgi-bin/bib_query?arXiv:0801.1144">http://adsabs.harvard.edu/cgi-bin/bib_query?arXiv:0801.1144</a> . On that page, there is a link to a bibtex entry (<a href="http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=2008PhRvB..77g5437K&data_type=BIBTEX&db_key=PHY&nocookieset=1">http://adsabs.harvard.edu/cgi-bin/nph-bib_query?bibcode=2008PhRvB..77g5437K&data_type=BIBTEX&db_key=PHY&nocookieset=1</a> ).  We can construct this link pretty easily, we just need the bibcode for that entry. arxiv.el provides a function for that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(arxiv-get-bibliographic-code <span style="color: #008000;">"0801.1144"</span>)
</pre>
</div>

<pre class="example">
2008PhRvB..77g5437K
</pre>

<p>
Next, once we have a url, we can get the text of the bibtex entry.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(arxiv-get-bibtex-entry <span style="color: #008000;">"2008PhRvB..77g5437K"</span>)
</pre>
</div>

<pre class="example">
@ARTICLE{2008PhRvB..77g5437K,
   author = {{Kitchin}, J.~R. and {Reuter}, K. and {Scheffler}, M.},
    title = "{Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag$_{3}$Pd(111) in oxygen atmospheres}",
  journal = {\prb},
archivePrefix = "arXiv",
   eprint = {0801.1144},
 primaryClass = "cond-mat.mtrl-sci",
 keywords = {Ab initio calculations of adsorbate structure and reactions, Density functional theory local density approximation gradient and other corrections, Oxidation},
     year = 2008,
    month = feb,
   volume = 77,
   number = 7,
      eid = {075437},
    pages = {075437},
      doi = {10.1103/PhysRevB.77.075437},
   adsurl = {http://adsabs.harvard.edu/abs/2008PhRvB..77g5437K},
  adsnote = {Provided by the SAO/NASA Astrophysics Data System}
}
</pre>

<p>
Finally, arxiv.el wraps those to functions together into an interactive function <code>arxiv-add-bibtex-entry</code> which prompts you for an arxiv number, and then a bibtex file, and then adds the text above to your bibtex file. You can then clean the entry as you see fit. It is also possible to get the pdf for an arxiv entry via <code>arxiv-get-pdf</code>. This is an interactive function that will prompt you for an arxiv number and a pdf file name, and it will then get the pdf for you and open it. I have not integrated this with the bibtex entry function yet, but one would ideally clean the bibtex entry to get a uniform key, and then get the pdf and name it according to the key like we do in org-ref.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(arxiv-get-pdf <span style="color: #008000;">"0801.1144"</span> <span style="color: #008000;">"0801.1144.pdf"</span>)
</pre>
</div>

<p>
If you use <a href="https://github.com/jkitchin/jmax/blob/master/words.el">words.el</a> you will find a new function <code>words-arxiv</code> which allows you to search the selected text or word at point on arxiv.org.
</p>

<p>
I do not use arxiv.org a lot, so this is not super well tested on many articles in arxiv.org, but it has worked on the few examples I have tested so far.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/03/09/Bibtex-Entries-from-Arxiv.org.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/03/09/Bibtex-Entries-from-Arxiv-org#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/bibtex/2">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2017/09/25/New-publication-in-J-Phys-Chem-Lett/">New publication in J. Phys. Chem. Lett.</a></li>
      <li><a href="/blog/2017/09/16/Finding-similar-bibtex-entries/">Finding similar bibtex entries</a></li>
      <li><a href="/blog/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter/">New publication in Journal of Physics Condensed Matter</a></li>
      <li><a href="/blog/2017/08/05/New-publication-in-Crystal-Growth-Design/">New publication in Crystal Growth & Design</a></li>
      <li><a href="/blog/2017/07/23/Overloading-mathematical-operators-in-elisp/">Overloading mathematical operators in elisp</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2017
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



