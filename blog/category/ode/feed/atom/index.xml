<?xml version="1.0" encoding="UTF-8"?>

<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
  >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2018-04-16T17:54:04Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Solving ODEs with a neural network and autograd]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd" />
    <id>http://jkitchin.github.io/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd</id>
    <updated>2017-11-28T07:23:59Z</updated>
    <published>2017-11-28T07:23:03Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="autograd" />
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Solving ODEs with a neural network and autograd]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd"><![CDATA[


&lt;p&gt;
In the last &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd/"&gt;post&lt;/a&gt; I explored using a neural network to solve a BVP. Here, I expand the idea to solving an initial value ordinary differential equation. The idea is basically the same, we just have a slightly different objective function.
&lt;/p&gt;

&lt;p&gt;
\(dCa/dt = -k Ca(t)\) where \(Ca(t=0) = 2.0\).
&lt;/p&gt;

&lt;p&gt;
Here is the code that solves this equation, along with a comparison to the analytical solution: \(Ca(t) = Ca0 \exp -kt\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; grad, elementwise_grad
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy.random &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; npr
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd.misc.optimizers &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; adam

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;init_random_params&lt;/span&gt;(scale, layer_sizes, rs=npr.RandomState(0)):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"""Build a list of (weights, biases) tuples, one for each layer."""&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; [(rs.randn(insize, outsize) * scale,   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;weight matrix&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;rs.randn(outsize) * scale)           &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;bias vector&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; insize, outsize &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;zip&lt;/span&gt;(layer_sizes[:-1], layer_sizes[1:])]


&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;swish&lt;/span&gt;(x):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"see https://arxiv.org/pdf/1710.05941.pdf"&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x / (1.0 + np.exp(-x))


&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;Ca&lt;/span&gt;(params, inputs):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"Neural network functions"&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; W, b &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; params:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;outputs&lt;/span&gt; = np.dot(inputs, W) + b
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;inputs&lt;/span&gt; = swish(outputs)    
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; outputs

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   
&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Here is our initial guess of params:&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = init_random_params(0.1, layer_sizes=[1, 8, 1])

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Derivatives&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;dCadt&lt;/span&gt; = elementwise_grad(Ca, 1)

&lt;span style="color: #BA36A5;"&gt;k&lt;/span&gt; = 0.23
&lt;span style="color: #BA36A5;"&gt;Ca0&lt;/span&gt; = 2.0
&lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt; = np.linspace(0, 10).reshape((-1, 1))

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;This is the function we seek to minimize&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(params, step):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;These should all be zero at the solution&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;dCadt = -k * Ca(t)&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;zeq&lt;/span&gt; = dCadt(params, t) - (-k * Ca(params, t))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;ic&lt;/span&gt; = Ca(params, 0) - Ca0
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.mean(zeq**2) + ic**2

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;callback&lt;/span&gt;(params, step, g):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; step % 1000 == 0:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;"Iteration {0:3d} objective {1}"&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(step,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; objective(params, step)))

&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = adam(grad(objective), params,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; step_size=0.001, num_iters=5001, callback=callback) 


&lt;span style="color: #BA36A5;"&gt;tfit&lt;/span&gt; = np.linspace(0, 20).reshape(-1, 1)
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
plt.plot(tfit, Ca(params, tfit), label=&lt;span style="color: #008000;"&gt;'soln'&lt;/span&gt;)
plt.plot(tfit, Ca0 * np.exp(-k * tfit), &lt;span style="color: #008000;"&gt;'r--'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'analytical soln'&lt;/span&gt;)
plt.legend()
plt.xlabel(&lt;span style="color: #008000;"&gt;'time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'$C_A$'&lt;/span&gt;)
plt.xlim([0, 20])
plt.savefig(&lt;span style="color: #008000;"&gt;'nn-ode.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Iteration   0 objective [[ 3.20374053]]
Iteration 1000 objective [[  3.13906829e-05]]
Iteration 2000 objective [[  1.95894699e-05]]
Iteration 3000 objective [[  1.60381564e-05]]
Iteration 4000 objective [[  1.39930673e-05]]
Iteration 5000 objective [[  1.03554970e-05]]

&lt;/pre&gt;


&lt;p&gt;
&lt;img src="/media/nn-ode.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
Huh. Those two solutions are nearly indistinguishable. Since we used a neural network, let's hype it up and say we learned the solution to a differential equation! But seriously, note that although we got an "analytical" solution, we should only rely on it in the region we trained the solution on. You can see the solution above is not that good past t=10, even perhaps going negative (which is not even physically correct). That is a reminder that the function we have for the solution &lt;i&gt;is not the same as the analytical solution&lt;/i&gt;, it just approximates it really well over the region we solved over. Of course, you can expand that region to the region you care about, but the main point is don't rely on the solution outside where you know it is good.
&lt;/p&gt;

&lt;p&gt;
This idea isn't new. There are several papers in the literature on using neural networks to solve differential equations, e.g. &lt;a href="http://www.sciencedirect.com/science/article/pii/S0255270102002076"&gt;http://www.sciencedirect.com/science/article/pii/S0255270102002076&lt;/a&gt; and &lt;a href="https://arxiv.org/pdf/physics/9705023.pdf"&gt;https://arxiv.org/pdf/physics/9705023.pdf&lt;/a&gt;, and other blog posts that are similar (&lt;a href="https://becominghuman.ai/neural-networks-for-solving-differential-equations-fa230ac5e04c"&gt;https://becominghuman.ai/neural-networks-for-solving-differential-equations-fa230ac5e04c&lt;/a&gt;, even using autograd). That means to me that there is some merit to continuing to investigate this approach to solving differential equations.
&lt;/p&gt;

&lt;p&gt;
There are some interesting challenges for engineers to consider with this approach though. When is the solution accurate enough? How reliable are derivatives of the solution? What network architecture is appropriate or best? How do you know how good the solution is? Is it possible to build in solution features, e.g. asymptotes, or constraints on derivatives, or that the solution should be monotonic, etc. These would help us trust the solutions not to do weird things, and to extrapolate more reliably.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.2&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Uncertainty in the solution of an ODE]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE" />
    <id>http://jkitchin.github.io/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE</id>
    <updated>2013-10-18T15:55:01Z</updated>
    <published>2013-07-14T13:36:36Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <category scheme="http://jkitchin.github.io/blog" term="uncertainty" />
    <summary type="html"><![CDATA[Uncertainty in the solution of an ODE]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE"><![CDATA[



&lt;p&gt;
Our objective in this post is to examine the effects of uncertainty in parameters that define an ODE on the integrated solution of the ODE. My favorite method for numerical uncertainty analysis is Monte Carlo simulation because it is easy to code and usually easy to understand. We take that approach first.
&lt;/p&gt;

&lt;p&gt;
The problem to solve is to estimate the conversion in a constant volume batch reactor with a second order reaction \(A \rightarrow B\), and the rate law: \(-r_A = k C_A^2\), after one hour of reaction. There is 5% uncertainty in the rate constant \(k=0.001\) and in the initial concentration \(C_{A0}=1\). 
&lt;/p&gt;

&lt;p&gt;
The relevant differential equation is:
&lt;/p&gt;

&lt;p&gt;
\(\frac{dX}{dt} = -r_A /C_{A0}\).
&lt;/p&gt;

&lt;p&gt;
We have to assume that 5% uncertainty refers to a normal distribution of error that has a standard deviation of 5% of the mean value. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #8b008b;"&gt;N&lt;/span&gt; = 1000

&lt;span style="color: #8b008b;"&gt;K&lt;/span&gt; = np.random.normal(0.001, 0.05*0.001, N)
&lt;span style="color: #8b008b;"&gt;CA0&lt;/span&gt; = np.random.normal(1, 0.05*1, N)

&lt;span style="color: #8b008b;"&gt;X&lt;/span&gt; = [] &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;to store answer in&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; k, Ca0 &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #cd0000;"&gt;zip&lt;/span&gt;(K, CA0):
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;define ODE&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(X, t):
        &lt;span style="color: #8b008b;"&gt;ra&lt;/span&gt; = -k * (Ca0 * (1 - X))**2
        &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; -ra / Ca0
    
    &lt;span style="color: #8b008b;"&gt;X0&lt;/span&gt; = 0
    &lt;span style="color: #8b008b;"&gt;tspan&lt;/span&gt; = np.linspace(0,3600)

    &lt;span style="color: #8b008b;"&gt;sol&lt;/span&gt; = odeint(ode, X0, tspan)

    &lt;span style="color: #8b008b;"&gt;X&lt;/span&gt; += [sol[-1][0]]

&lt;span style="color: #8b008b;"&gt;s&lt;/span&gt; = &lt;span style="color: #228b22;"&gt;'Final conversion at one hour is {0:1.3f} +- {1:1.3f} (1 sigma)'&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; s.&lt;span style="color: #cd0000;"&gt;format&lt;/span&gt;(np.average(X),
               np.std(X))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Final conversion at one hour is 0.782 +- 0.013 (1 sigma)
&lt;/pre&gt;

&lt;p&gt;
See, it is not too difficulty to write. It is however, a little on the expensive side to run, since we typically need 1e3-1e6 samples to get the statistics reasonable. Let us try the uncertainties package too. For this we have to wrap a function that takes uncertainties and returns a single float number. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; uncertainties &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; u

&lt;span style="color: #8b008b;"&gt;k&lt;/span&gt; = u.ufloat(0.001, 0.05*0.001)
&lt;span style="color: #8b008b;"&gt;Ca0&lt;/span&gt; = u.ufloat(1.0, 0.05)

&lt;span style="color: #4682b4;"&gt;@u.wrap&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;func&lt;/span&gt;(k, Ca0):
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;define the ODE&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(X, t):
        &lt;span style="color: #8b008b;"&gt;ra&lt;/span&gt; = -k * (Ca0 * (1 - X))**2
        &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; -ra / Ca0
    
    &lt;span style="color: #8b008b;"&gt;X0&lt;/span&gt; = 0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;initial condition&lt;/span&gt;
    &lt;span style="color: #8b008b;"&gt;tspan&lt;/span&gt; = np.linspace(0, 3600)
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;integrate it&lt;/span&gt;
    &lt;span style="color: #8b008b;"&gt;sol&lt;/span&gt; = odeint(ode, X0, tspan)
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; sol[-1][0]

&lt;span style="color: #8b008b;"&gt;result&lt;/span&gt; = func(k, Ca0)
&lt;span style="color: #8b008b;"&gt;s&lt;/span&gt; = &lt;span style="color: #228b22;"&gt;'Final conversion at one hour is {0}(1 sigma)'&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; s.&lt;span style="color: #cd0000;"&gt;format&lt;/span&gt;(result)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Final conversion at one hour is 0.783+/-0.012(1 sigma)
&lt;/pre&gt;

&lt;p&gt;
This is about the same amount of code as the Monte Carlo approach, but it runs much faster, and gets approximately the same results. You have to remember the wrapping technique, since the uncertainties package does not run natively with the odeint function. 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/07/14/Uncertainty-in-the-solution-of-an-ODE.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Linear algebra approaches to solving systems of constant coefficient ODEs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs</id>
    <updated>2013-02-27T14:33:11Z</updated>
    <published>2013-02-27T14:33:11Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Linear algebra approaches to solving systems of constant coefficient ODEs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/10/20/linear-algebra-approaches-to-solving-systems-of-constant-coefficient-odes" &gt;Matlab post&lt;/a&gt;

Today we consider how to solve a system of first order, constant coefficient ordinary differential equations using linear algebra. These equations could be solved numerically, but in this case there are analytical solutions that can be derived. The equations we will solve are:
&lt;/p&gt;

&lt;p&gt;
\(y'_1 = -0.02 y_1 + 0.02 y_2\)
&lt;/p&gt;

&lt;p&gt;
\(y'_2 = 0.02 y_1 - 0.02 y_2\)
&lt;/p&gt;

&lt;p&gt;
We can express this set of equations in matrix form as: \(\left[\begin{array}{c}y'_1\\y'_2\end{array}\right] = \left[\begin{array}{cc} -0.02 &amp; 0.02 \\ 0.02 &amp; -0.02\end{array}\right] \left[\begin{array}{c}y_1\\y_2\end{array}\right]\)
&lt;/p&gt;

&lt;p&gt;
The general solution to this set of equations is
&lt;/p&gt;

&lt;p&gt;
\(\left[\begin{array}{c}y_1\\y_2\end{array}\right] = \left[\begin{array}{cc}v_1 &amp; v_2\end{array}\right] \left[\begin{array}{cc} c_1 &amp; 0 \\ 0 &amp; c_2\end{array}\right] \exp\left(\left[\begin{array}{cc} \lambda_1 &amp; 0 \\ 0 &amp; \lambda_2\end{array}\right] \left[\begin{array}{c}t\\t\end{array}\right]\right)\)
&lt;/p&gt;

&lt;p&gt;
where \(\left[\begin{array}{cc} \lambda_1 &amp; 0 \\ 0 &amp; \lambda_2\end{array}\right]\) is a diagonal matrix of the eigenvalues of the constant coefficient matrix, \(\left[\begin{array}{cc}v_1 &amp; v_2\end{array}\right]\) is a matrix of eigenvectors where the \(i^{th}\) column corresponds to the eigenvector of the \(i^{th}\) eigenvalue, and \(\left[\begin{array}{cc} c_1 &amp; 0 \\ 0 &amp; c_2\end{array}\right]\) is a matrix determined by the initial conditions.
&lt;/p&gt;

&lt;p&gt;
In this example, we evaluate the solution using linear algebra. The initial conditions we will consider are \(y_1(0)=0\) and \(y_2(0)=150\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

A = np.array([[-0.02,  0.02],
              [ 0.02, -0.02]])

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.&lt;/span&gt;
evals, evecs = np.linalg.eigh(A)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; evals
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; evecs
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; [-0.04  0.  ]
[[ 0.70710678  0.70710678]
 [-0.70710678  0.70710678]]
&lt;/pre&gt;

&lt;p&gt;
The eigenvectors are the &lt;i&gt;columns&lt;/i&gt; of evecs.
&lt;/p&gt;

&lt;p&gt;
Compute the \(c\) matrix
&lt;/p&gt;

&lt;p&gt;
V*c = Y0
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;Y0 = [0, 150]

c = np.diag(np.linalg.solve(evecs, Y0))
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; c
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; [[-106.06601718    0.        ]
 [   0.          106.06601718]]
&lt;/pre&gt;

&lt;p&gt;
Constructing the solution
&lt;/p&gt;

&lt;p&gt;
We will create a vector of time values, and stack them for each solution, \(y_1(t)\) and \(Y_2(t)\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

t = np.linspace(0, 100)
T = np.row_stack([t, t])

D = np.diag(evals)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;y = V*c*exp(D*T);&lt;/span&gt;
y = np.dot(np.dot(evecs, c), np.exp(np.dot(D, T)))

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;y has a shape of (2, 50) so we have to transpose it&lt;/span&gt;
plt.plot(t, y.T)
plt.xlabel(&lt;span style="color: #228b22;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'y'&lt;/span&gt;)
plt.legend([&lt;span style="color: #228b22;"&gt;'$y_1$'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'$y_2$'&lt;/span&gt;])
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-la.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1d4db950&amp;gt;, &amp;lt;matplotlib.lines.Line2D object at 0x1d4db4d0&amp;gt;]
&amp;lt;matplotlib.text.Text object at 0x1d35fbd0&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1c222390&amp;gt;
&amp;lt;matplotlib.legend.Legend object at 0x1d34ee90&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-la.png"&gt;&lt;p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Another way to parameterize an ODE - nested function]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function</id>
    <updated>2013-02-27T14:32:05Z</updated>
    <published>2013-02-27T14:31:51Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Another way to parameterize an ODE - nested function]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/18/another-way-to-parameterize-an-ode-nested-function/" &gt;Matlab post&lt;/a&gt;

We saw one method to parameterize an ODE, by creating an ode function that takes an extra parameter argument, and then making a function handle that has the syntax required for the solver, and passes the parameter the ode function. 
&lt;/p&gt;

&lt;p&gt;
Here we define the ODE function in a loop. Since the nested function is in the namespace of the main function, it can &amp;ldquo;see&amp;rdquo; the values of the variables in the main function. We will use this method to look at the solution to the van der Pol equation for several different values of mu.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

MU = [0.1, 1, 2, 5]
tspan = np.linspace(0, 100, 5000)
Y0 = [0, 3]

&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; mu &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; MU:
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;define the ODE&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;vdpol&lt;/span&gt;(Y, t):
        x,y = Y
        dxdt = y
        dydt = -x + mu * (1 - x**2) * y
        &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt;  [dxdt, dydt]
    
    Y = odeint(vdpol, Y0, tspan)
    
    x = Y[:,0]; y = Y[:,1]
    plt.plot(x, y, label=&lt;span style="color: #228b22;"&gt;'mu={0:1.2f}'&lt;/span&gt;.format(mu))

plt.axis(&lt;span style="color: #228b22;"&gt;'equal'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-nested-parameterization.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-nested-parameterization.png"&gt;&lt;p&gt;

&lt;p&gt;
You can see the solution changes dramatically for different values of mu. The point here is not to understand why, but to show an easy way to study a parameterize ode with a nested function. Nested functions can be a great way to &amp;ldquo;share&amp;rdquo; variables between functions especially for ODE solving, and nonlinear algebra solving, or any other application where you need a lot of parameters defined in one function in another function.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Another-way-to-parameterize-an-ODE---nested-function.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Yet another way to parameterize an ODE]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE</id>
    <updated>2013-02-27T14:31:44Z</updated>
    <published>2013-02-27T14:31:44Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Yet another way to parameterize an ODE]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/11/06/yet-another-way-to-parameterize-an-ode/" &gt;Matlab post&lt;/a&gt;

We previously examined a way to parameterize an ODE. In those methods, we either used an anonymous function to parameterize an ode function, or we used a nested function that used variables from the shared workspace.
&lt;/p&gt;

&lt;p&gt;
We want a convenient way to solve \(dCa/dt = -k Ca\) for multiple values of \(k\). Here we use a trick to pass a parameter to an ODE through the initial conditions. We expand the ode function definition to include this parameter, and set its derivative to zero, effectively making it a constant.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(F, t):
    Ca, k = F
    dCadt = -k * Ca
    dkdt = 0.0
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; [dCadt, dkdt]

tspan = np.linspace(0, 4)

Ca0 = 1;
K = [2.0, 3.0]
&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; k &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; K:
    F = odeint(ode, [Ca0, k], tspan)
    Ca = F[:,0]
    plt.plot(tspan, Ca, label=&lt;span style="color: #228b22;"&gt;'k={0}'&lt;/span&gt;.format(k))
plt.xlabel(&lt;span style="color: #228b22;"&gt;'time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$C_A$'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-parameterized-1.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-parameterized-1.png"&gt;&lt;p&gt;

&lt;p&gt;
I do not think this is a very elegant way to pass parameters around compared to the previous methods, but it nicely illustrates that there is more than one way to do it. And who knows, maybe it will be useful in some other context one day!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Yet-another-way-to-parameterize-an-ODE.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Error tolerance in numerical solutions to ODEs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Error-tolerance-in-numerical-solutions-to-ODEs" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Error-tolerance-in-numerical-solutions-to-ODEs</id>
    <updated>2013-02-27T14:31:18Z</updated>
    <published>2013-02-27T14:31:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Error tolerance in numerical solutions to ODEs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Error-tolerance-in-numerical-solutions-to-ODEs"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/18/error-tolerance-in-numerical-solutions-to-odes/" &gt;Matlab post&lt;/a&gt;

Usually, the numerical ODE solvers in python work well with the standard settings. Sometimes they do not, and it is not always obvious they have not worked! Part of using a tool like python is checking how well your solution really worked. We use an example of integrating an ODE that defines the van der Waal equation of an ideal gas here.
&lt;/p&gt;

&lt;p&gt;
we plot the analytical solution to the van der waal equation in reduced form here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

Tr = 0.9
Vr = np.linspace(0.34,4,1000)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;#&lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;analytical equation for Pr&lt;/span&gt;
Prfh = &lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; Vr: 8.0 / 3.0 * Tr / (Vr - 1.0 / 3.0) - 3.0 / (Vr**2)
Pr = Prfh(Vr) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;evaluated on our reduced volume vector.&lt;/span&gt;

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Plot the EOS&lt;/span&gt;
plt.plot(Vr,Pr)
plt.ylim([0, 2])
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$V_R$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$P_R$'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-vw-1.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1c5a3550&amp;gt;]
(0, 2)
&amp;lt;matplotlib.text.Text object at 0x1c22f750&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1d4e0750&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-vw-1.png"&gt;&lt;p&gt;

&lt;p&gt;
we want an equation for dPdV, which we will integrate we use symbolic math to do the derivative for us.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; sympy &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; diff, Symbol
Vrs = Symbol(&lt;span style="color: #228b22;"&gt;'Vrs'&lt;/span&gt;)

Prs = 8.0 / 3.0 * Tr / (Vrs - 1.0/3.0) - 3.0/(Vrs**2) 
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; diff(Prs,Vrs)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; -2.4/(Vrs - 0.333333333333333)**2 + 6.0/Vrs**3
&lt;/pre&gt;

&lt;p&gt;
Now, we solve the ODE. We will specify a large relative tolerance criteria (Note the default is much smaller than what we show here).
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;myode&lt;/span&gt;(Pr, Vr):
    dPrdVr = -2.4/(Vr - 0.333333333333333)**2 + 6.0/Vr**3
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; dPrdVr

Vspan = np.linspace(0.334, 4)
Po = Prfh(Vspan[0])
P = odeint(myode, Po, Vspan, rtol=1e-4)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Plot the EOS&lt;/span&gt;
plt.plot(Vr,Pr) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;analytical solution&lt;/span&gt;
plt.plot(Vspan, P[:,0], &lt;span style="color: #228b22;"&gt;'r.'&lt;/span&gt;)
plt.ylim([0, 2])
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$V_R$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$P_R$'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-vw-2.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1d4f3b90&amp;gt;]
[&amp;lt;matplotlib.lines.Line2D object at 0x2ac47518e710&amp;gt;]
(0, 2)
&amp;lt;matplotlib.text.Text object at 0x1c238fd0&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1c22af10&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-vw-2.png"&gt;&lt;p&gt;

&lt;p&gt;
You can see there is disagreement between the analytical solution and numerical solution. The origin of this problem is accuracy at the initial condition, where the derivative is extremely large.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; myode(Po, 0.34)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
-53847.3437818
&lt;/pre&gt;

&lt;p&gt;
We can increase the tolerance criteria to get a better answer. The defaults in odeint are actually set to 1.49012e-8.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;Vspan = np.linspace(0.334, 4)
Po = Prfh(Vspan[0])
P = odeint(myode, Po, Vspan)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Plot the EOS&lt;/span&gt;
plt.plot(Vr,Pr) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;analytical solution&lt;/span&gt;
plt.plot(Vspan, P[:,0], &lt;span style="color: #228b22;"&gt;'r.'&lt;/span&gt;)
plt.ylim([0, 2])
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$V_R$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$P_R$'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-vw-3.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1d4dbf10&amp;gt;]
[&amp;lt;matplotlib.lines.Line2D object at 0x1c6e5550&amp;gt;]
(0, 2)
&amp;lt;matplotlib.text.Text object at 0x1d4e31d0&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1d9d3710&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-vw-3.png"&gt;&lt;p&gt;

&lt;p&gt;
The problem here was the derivative value varied by four orders of magnitude over the integration range, so the default tolerances were insufficient to accurately estimate the numerical derivatives over that range. Tightening the tolerances helped resolve that problem. Another approach might be to split the integration up into different regions. For instance, if instead of starting at Vr = 0.34, which is very close to a sigularity in the van der waal equation at Vr = 1/3, if you start at Vr = 0.5, the solution integrates just fine with the standard tolerances.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Error-tolerance-in-numerical-solutions-to-ODEs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding minima and maxima in ODE solutions with events]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Finding-minima-and-maxima-in-ODE-solutions-with-events" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Finding-minima-and-maxima-in-ODE-solutions-with-events</id>
    <updated>2013-02-27T14:31:10Z</updated>
    <published>2013-02-27T14:31:01Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Finding minima and maxima in ODE solutions with events]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Finding-minima-and-maxima-in-ODE-solutions-with-events"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/17/finding-minima-and-maxima-in-ode-solutions-with-events" &gt;Matlab post&lt;/a&gt;

Today we look at another way to use events in an ode solver. We use an events function to find minima and maxima, by evaluating the ODE in the event function to find conditions where the first derivative is zero, and approached from the right direction. A maximum is when the fisrt derivative is zero and increasing, and a minimum is when the first derivative is zero and decreasing.
&lt;/p&gt;

&lt;p&gt;
We use a simple ODE, \(y' = sin(x)*e^{-0.05x}\), which has minima and maxima.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; pycse &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; *
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(y, x):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.sin(x) * np.exp(-0.05 * x)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;minima&lt;/span&gt;(y, x):
    &lt;span style="color: #228b22;"&gt;'''Approaching a minumum, dydx is negatime and going to zero. our event function is increasing'''&lt;/span&gt;
    value = ode(y, x)
    direction = 1
    isterminal = &lt;span style="color: #8b0000;"&gt;False&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; value,  isterminal, direction

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;maxima&lt;/span&gt;(y, x):
    &lt;span style="color: #228b22;"&gt;'''Approaching a maximum, dydx is positive and going to zero. our event function is decreasing'''&lt;/span&gt;
    value = ode(y, x)
    direction = -1
    isterminal = &lt;span style="color: #8b0000;"&gt;False&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; value,  isterminal, direction

xspan = np.linspace(0, 20, 100)

y0 = 0

X, Y, XE, YE, IE = odelay(ode, y0, xspan, events=[minima, maxima])
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; IE
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt
plt.plot(X, Y)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;blue is maximum, red is minimum&lt;/span&gt;
colors = &lt;span style="color: #228b22;"&gt;'rb'&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; xe, ye, ie &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;zip&lt;/span&gt;(XE, YE, IE):
    plt.plot([xe], [ye], &lt;span style="color: #228b22;"&gt;'o'&lt;/span&gt;, color=colors[ie])

plt.savefig(&lt;span style="color: #228b22;"&gt;'./images/ode-events-min-max.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[1, 0, 1, 0, 1, 0]
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-events-min-max.png"&gt;&lt;p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Finding-minima-and-maxima-in-ODE-solutions-with-events.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Stopping the integration of an ODE at some condition]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/Stopping-the-integration-of-an-ODE-at-some-condition" />
    <id>http://jkitchin.github.io/blog/2013/02/27/Stopping-the-integration-of-an-ODE-at-some-condition</id>
    <updated>2013-02-27T14:30:49Z</updated>
    <published>2013-02-27T14:30:30Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Stopping the integration of an ODE at some condition]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/Stopping-the-integration-of-an-ODE-at-some-condition"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/02/stopping-the-integration-of-an-ode-at-some-condition/" &gt;Matlab post&lt;/a&gt;

In Post 968 we learned how to get the numerical solution to an ODE, and then to use the deval function to solve the solution for a particular value. The deval function uses interpolation to evaluate the solution at other valuse. An alternative approach would be to stop the ODE integration when the solution has the value you want. That can be done in Matlab by using an &amp;ldquo;event&amp;rdquo; function. You setup an event function and tell the ode solver to use it by setting an option.
&lt;/p&gt;

&lt;p&gt;
Given that the concentration of a species A in a constant volume, batch reactor obeys this differential equation \(\frac{dC_A}{dt}=- k C_A^2\) with the initial condition \(C_A(t=0) = 2.3\) mol/L and \(k = 0.23\) L/mol/s, compute the time it takes for \(C_A\) to be reduced to 1 mol/L.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; pycse &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; *
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

k = 0.23
Ca0 = 2.3

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;dCadt&lt;/span&gt;(Ca, t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; -k * Ca**2

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;stop&lt;/span&gt;(Ca, t):
    isterminal = &lt;span style="color: #8b0000;"&gt;True&lt;/span&gt;
    direction = 0
    value = 1.0 - Ca
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; value, isterminal, direction

tspan = np.linspace(0.0, 10.0)

t, CA, TE, YE, IE = odelay(dCadt, Ca0, tspan, events=[stop], full_output=1)

&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'At t = {0:1.2f} seconds the concentration of A is {1:1.2f} mol/L.'&lt;/span&gt;.format(t[-1], CA[-1])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
At t = 2.46 seconds the concentration of A is 1.00 mol/L.
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Stopping-the-integration-of-an-ODE-at-some-condition.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A simple first order ode evaluated at specific points]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/27/A-simple-first-order-ode-evaluated-at-specific-points" />
    <id>http://jkitchin.github.io/blog/2013/02/27/A-simple-first-order-ode-evaluated-at-specific-points</id>
    <updated>2013-02-27T14:30:23Z</updated>
    <published>2013-02-27T14:30:23Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[A simple first order ode evaluated at specific points]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/27/A-simple-first-order-ode-evaluated-at-specific-points"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/08/05/a-simple-first-order-ode-evaluated-at-specific-points/" &gt;Matlab post&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
We have integrated an ODE over a specific time span. Sometimes it is desirable to get the solution at specific points, e.g. at t = [0 0.2 0.4 0.8]; This could be desirable to compare with experimental measurements at those time points. This example demonstrates how to do that.
&lt;/p&gt;

&lt;p&gt;
$$\frac{dy}{dt} = y(t)$$
&lt;/p&gt;

&lt;p&gt;
The initial condition is y(0) = 1.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint

y0 = 1
tspan = [0, 0.2, 0.4, 0.8]

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;dydt&lt;/span&gt;(y, t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; y

Y = odeint(dydt, y0, tspan)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; Y[:,0]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[ 1.          1.22140275  1.49182469  2.22554103]
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/A-simple-first-order-ode-evaluated-at-specific-points.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Numerical solution to a simple ode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/02/26/Numerical-solution-to-a-simple-ode" />
    <id>http://jkitchin.github.io/blog/2013/02/26/Numerical-solution-to-a-simple-ode</id>
    <updated>2013-03-23T16:03:44Z</updated>
    <published>2013-02-26T21:17:44Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="interpolation" />
    <category scheme="http://jkitchin.github.io/blog" term="ode" />
    <summary type="html"><![CDATA[Numerical solution to a simple ode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/02/26/Numerical-solution-to-a-simple-ode"><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/08/03/numerical-solution-to-a-simple-ode/" &gt;Matlab post&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Integrate this ordinary differential equation (ode):
&lt;/p&gt;

&lt;p&gt;
$$\frac{dy}{dt} = y(t)$$
&lt;/p&gt;

&lt;p&gt;
over the time span of 0 to 2. The initial condition is y(0) = 1.
&lt;/p&gt;

&lt;p&gt;
to solve this equation, you need to create a function of the form: dydt = f(y, t) and then use one of the odesolvers, e.g. odeint.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fprime&lt;/span&gt;(y,t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; y

tspan = np.linspace(0, 2)
y0 = 1
ysol = odeint(fprime, y0, tspan)

plt.plot(tspan, ysol, label=&lt;span style="color: #228b22;"&gt;'numerical solution'&lt;/span&gt;)
plt.plot(tspan, np.exp(tspan), &lt;span style="color: #228b22;"&gt;'r--'&lt;/span&gt;, label=&lt;span style="color: #228b22;"&gt;'analytical solution'&lt;/span&gt;)
plt.xlabel(&lt;span style="color: #228b22;"&gt;'time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'y(t)'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/simple-ode.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/simple-ode.png"&gt;&lt;p&gt;

&lt;p&gt;
The numerical and analytical solutions agree.
&lt;/p&gt;

&lt;p&gt;
Now, suppose you want to know at what time is the solution equal to 3? There are several approaches to this, including setting up a solver, or using an event like approach to stop integration at y=3. A simple approach is to use reverse interpolation. We simply reverse the x and y vectors so that y is the independent variable, and we interpolate the corresponding x-value.

&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fprime&lt;/span&gt;(y,t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; y

tspan = np.linspace(0, 2)
y0 = 1
ysol = odeint(fprime, y0, tspan)

&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.interpolate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; interp1d

ip = interp1d(ysol[:,0], tspan) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# reverse interpolation&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'y = 3 at x = {0}'&lt;/span&gt;.format(ip(3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
y = 3 at x = 1.09854780564
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/26/Numerical-solution-to-a-simple-ode.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content>
  </entry>
</feed>
