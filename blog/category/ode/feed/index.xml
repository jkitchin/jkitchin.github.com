<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Sat, 05 Aug 2017 17:11:30 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Uncertainty in the solution of an ODE</title>
      <link>http://jkitchin.github.io/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE</link>
      <pubDate>Sun, 14 Jul 2013 13:36:36 EDT</pubDate>
      <category><![CDATA[uncertainty]]></category>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">vgxLM1eNdDWFxYoYzKL_cdL_bP8=</guid>
      <description>Uncertainty in the solution of an ODE</description>
      <content:encoded><![CDATA[



&lt;p&gt;
Our objective in this post is to examine the effects of uncertainty in parameters that define an ODE on the integrated solution of the ODE. My favorite method for numerical uncertainty analysis is Monte Carlo simulation because it is easy to code and usually easy to understand. We take that approach first.
&lt;/p&gt;

&lt;p&gt;
The problem to solve is to estimate the conversion in a constant volume batch reactor with a second order reaction \(A \rightarrow B\), and the rate law: \(-r_A = k C_A^2\), after one hour of reaction. There is 5% uncertainty in the rate constant \(k=0.001\) and in the initial concentration \(C_{A0}=1\). 
&lt;/p&gt;

&lt;p&gt;
The relevant differential equation is:
&lt;/p&gt;

&lt;p&gt;
\(\frac{dX}{dt} = -r_A /C_{A0}\).
&lt;/p&gt;

&lt;p&gt;
We have to assume that 5% uncertainty refers to a normal distribution of error that has a standard deviation of 5% of the mean value. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #8b008b;"&gt;N&lt;/span&gt; = 1000

&lt;span style="color: #8b008b;"&gt;K&lt;/span&gt; = np.random.normal(0.001, 0.05*0.001, N)
&lt;span style="color: #8b008b;"&gt;CA0&lt;/span&gt; = np.random.normal(1, 0.05*1, N)

&lt;span style="color: #8b008b;"&gt;X&lt;/span&gt; = [] &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;to store answer in&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; k, Ca0 &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #cd0000;"&gt;zip&lt;/span&gt;(K, CA0):
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;define ODE&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(X, t):
        &lt;span style="color: #8b008b;"&gt;ra&lt;/span&gt; = -k * (Ca0 * (1 - X))**2
        &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; -ra / Ca0
    
    &lt;span style="color: #8b008b;"&gt;X0&lt;/span&gt; = 0
    &lt;span style="color: #8b008b;"&gt;tspan&lt;/span&gt; = np.linspace(0,3600)

    &lt;span style="color: #8b008b;"&gt;sol&lt;/span&gt; = odeint(ode, X0, tspan)

    &lt;span style="color: #8b008b;"&gt;X&lt;/span&gt; += [sol[-1][0]]

&lt;span style="color: #8b008b;"&gt;s&lt;/span&gt; = &lt;span style="color: #228b22;"&gt;'Final conversion at one hour is {0:1.3f} +- {1:1.3f} (1 sigma)'&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; s.&lt;span style="color: #cd0000;"&gt;format&lt;/span&gt;(np.average(X),
               np.std(X))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Final conversion at one hour is 0.782 +- 0.013 (1 sigma)
&lt;/pre&gt;

&lt;p&gt;
See, it is not too difficulty to write. It is however, a little on the expensive side to run, since we typically need 1e3-1e6 samples to get the statistics reasonable. Let us try the uncertainties package too. For this we have to wrap a function that takes uncertainties and returns a single float number. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; uncertainties &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; u

&lt;span style="color: #8b008b;"&gt;k&lt;/span&gt; = u.ufloat(0.001, 0.05*0.001)
&lt;span style="color: #8b008b;"&gt;Ca0&lt;/span&gt; = u.ufloat(1.0, 0.05)

&lt;span style="color: #4682b4;"&gt;@u.wrap&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;func&lt;/span&gt;(k, Ca0):
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;define the ODE&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(X, t):
        &lt;span style="color: #8b008b;"&gt;ra&lt;/span&gt; = -k * (Ca0 * (1 - X))**2
        &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; -ra / Ca0
    
    &lt;span style="color: #8b008b;"&gt;X0&lt;/span&gt; = 0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;initial condition&lt;/span&gt;
    &lt;span style="color: #8b008b;"&gt;tspan&lt;/span&gt; = np.linspace(0, 3600)
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;integrate it&lt;/span&gt;
    &lt;span style="color: #8b008b;"&gt;sol&lt;/span&gt; = odeint(ode, X0, tspan)
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; sol[-1][0]

&lt;span style="color: #8b008b;"&gt;result&lt;/span&gt; = func(k, Ca0)
&lt;span style="color: #8b008b;"&gt;s&lt;/span&gt; = &lt;span style="color: #228b22;"&gt;'Final conversion at one hour is {0}(1 sigma)'&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; s.&lt;span style="color: #cd0000;"&gt;format&lt;/span&gt;(result)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Final conversion at one hour is 0.783+/-0.012(1 sigma)
&lt;/pre&gt;

&lt;p&gt;
This is about the same amount of code as the Monte Carlo approach, but it runs much faster, and gets approximately the same results. You have to remember the wrapping technique, since the uncertainties package does not run natively with the odeint function. 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/07/14/Uncertainty-in-the-solution-of-an-ODE.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Linear algebra approaches to solving systems of constant coefficient ODEs</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs</link>
      <pubDate>Wed, 27 Feb 2013 14:33:11 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">zNDsNinXh264YgGTqRhzeDTMzpk=</guid>
      <description>Linear algebra approaches to solving systems of constant coefficient ODEs</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/10/20/linear-algebra-approaches-to-solving-systems-of-constant-coefficient-odes" &gt;Matlab post&lt;/a&gt;

Today we consider how to solve a system of first order, constant coefficient ordinary differential equations using linear algebra. These equations could be solved numerically, but in this case there are analytical solutions that can be derived. The equations we will solve are:
&lt;/p&gt;

&lt;p&gt;
\(y'_1 = -0.02 y_1 + 0.02 y_2\)
&lt;/p&gt;

&lt;p&gt;
\(y'_2 = 0.02 y_1 - 0.02 y_2\)
&lt;/p&gt;

&lt;p&gt;
We can express this set of equations in matrix form as: \(\left[\begin{array}{c}y'_1\\y'_2\end{array}\right] = \left[\begin{array}{cc} -0.02 &amp; 0.02 \\ 0.02 &amp; -0.02\end{array}\right] \left[\begin{array}{c}y_1\\y_2\end{array}\right]\)
&lt;/p&gt;

&lt;p&gt;
The general solution to this set of equations is
&lt;/p&gt;

&lt;p&gt;
\(\left[\begin{array}{c}y_1\\y_2\end{array}\right] = \left[\begin{array}{cc}v_1 &amp; v_2\end{array}\right] \left[\begin{array}{cc} c_1 &amp; 0 \\ 0 &amp; c_2\end{array}\right] \exp\left(\left[\begin{array}{cc} \lambda_1 &amp; 0 \\ 0 &amp; \lambda_2\end{array}\right] \left[\begin{array}{c}t\\t\end{array}\right]\right)\)
&lt;/p&gt;

&lt;p&gt;
where \(\left[\begin{array}{cc} \lambda_1 &amp; 0 \\ 0 &amp; \lambda_2\end{array}\right]\) is a diagonal matrix of the eigenvalues of the constant coefficient matrix, \(\left[\begin{array}{cc}v_1 &amp; v_2\end{array}\right]\) is a matrix of eigenvectors where the \(i^{th}\) column corresponds to the eigenvector of the \(i^{th}\) eigenvalue, and \(\left[\begin{array}{cc} c_1 &amp; 0 \\ 0 &amp; c_2\end{array}\right]\) is a matrix determined by the initial conditions.
&lt;/p&gt;

&lt;p&gt;
In this example, we evaluate the solution using linear algebra. The initial conditions we will consider are \(y_1(0)=0\) and \(y_2(0)=150\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

A = np.array([[-0.02,  0.02],
              [ 0.02, -0.02]])

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.&lt;/span&gt;
evals, evecs = np.linalg.eigh(A)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; evals
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; evecs
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; [-0.04  0.  ]
[[ 0.70710678  0.70710678]
 [-0.70710678  0.70710678]]
&lt;/pre&gt;

&lt;p&gt;
The eigenvectors are the &lt;i&gt;columns&lt;/i&gt; of evecs.
&lt;/p&gt;

&lt;p&gt;
Compute the \(c\) matrix
&lt;/p&gt;

&lt;p&gt;
V*c = Y0
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;Y0 = [0, 150]

c = np.diag(np.linalg.solve(evecs, Y0))
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; c
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; [[-106.06601718    0.        ]
 [   0.          106.06601718]]
&lt;/pre&gt;

&lt;p&gt;
Constructing the solution
&lt;/p&gt;

&lt;p&gt;
We will create a vector of time values, and stack them for each solution, \(y_1(t)\) and \(Y_2(t)\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

t = np.linspace(0, 100)
T = np.row_stack([t, t])

D = np.diag(evals)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;y = V*c*exp(D*T);&lt;/span&gt;
y = np.dot(np.dot(evecs, c), np.exp(np.dot(D, T)))

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;y has a shape of (2, 50) so we have to transpose it&lt;/span&gt;
plt.plot(t, y.T)
plt.xlabel(&lt;span style="color: #228b22;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'y'&lt;/span&gt;)
plt.legend([&lt;span style="color: #228b22;"&gt;'$y_1$'&lt;/span&gt;, &lt;span style="color: #228b22;"&gt;'$y_2$'&lt;/span&gt;])
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-la.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1d4db950&amp;gt;, &amp;lt;matplotlib.lines.Line2D object at 0x1d4db4d0&amp;gt;]
&amp;lt;matplotlib.text.Text object at 0x1d35fbd0&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1c222390&amp;gt;
&amp;lt;matplotlib.legend.Legend object at 0x1d34ee90&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-la.png"&gt;&lt;p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Another way to parameterize an ODE - nested function</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function</link>
      <pubDate>Wed, 27 Feb 2013 14:31:51 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">u3mJNx-1UEuGfUuSR_D1-Gz473I=</guid>
      <description>Another way to parameterize an ODE - nested function</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/18/another-way-to-parameterize-an-ode-nested-function/" &gt;Matlab post&lt;/a&gt;

We saw one method to parameterize an ODE, by creating an ode function that takes an extra parameter argument, and then making a function handle that has the syntax required for the solver, and passes the parameter the ode function. 
&lt;/p&gt;

&lt;p&gt;
Here we define the ODE function in a loop. Since the nested function is in the namespace of the main function, it can &amp;ldquo;see&amp;rdquo; the values of the variables in the main function. We will use this method to look at the solution to the van der Pol equation for several different values of mu.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

MU = [0.1, 1, 2, 5]
tspan = np.linspace(0, 100, 5000)
Y0 = [0, 3]

&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; mu &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; MU:
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;define the ODE&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;vdpol&lt;/span&gt;(Y, t):
        x,y = Y
        dxdt = y
        dydt = -x + mu * (1 - x**2) * y
        &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt;  [dxdt, dydt]
    
    Y = odeint(vdpol, Y0, tspan)
    
    x = Y[:,0]; y = Y[:,1]
    plt.plot(x, y, label=&lt;span style="color: #228b22;"&gt;'mu={0:1.2f}'&lt;/span&gt;.format(mu))

plt.axis(&lt;span style="color: #228b22;"&gt;'equal'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-nested-parameterization.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-nested-parameterization.png"&gt;&lt;p&gt;

&lt;p&gt;
You can see the solution changes dramatically for different values of mu. The point here is not to understand why, but to show an easy way to study a parameterize ode with a nested function. Nested functions can be a great way to &amp;ldquo;share&amp;rdquo; variables between functions especially for ODE solving, and nonlinear algebra solving, or any other application where you need a lot of parameters defined in one function in another function.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Another-way-to-parameterize-an-ODE---nested-function.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Yet another way to parameterize an ODE</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE</link>
      <pubDate>Wed, 27 Feb 2013 14:31:44 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">0ShdfvBeKn5XbD-SY1Lh5FwYquI=</guid>
      <description>Yet another way to parameterize an ODE</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/11/06/yet-another-way-to-parameterize-an-ode/" &gt;Matlab post&lt;/a&gt;

We previously examined a way to parameterize an ODE. In those methods, we either used an anonymous function to parameterize an ode function, or we used a nested function that used variables from the shared workspace.
&lt;/p&gt;

&lt;p&gt;
We want a convenient way to solve \(dCa/dt = -k Ca\) for multiple values of \(k\). Here we use a trick to pass a parameter to an ODE through the initial conditions. We expand the ode function definition to include this parameter, and set its derivative to zero, effectively making it a constant.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(F, t):
    Ca, k = F
    dCadt = -k * Ca
    dkdt = 0.0
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; [dCadt, dkdt]

tspan = np.linspace(0, 4)

Ca0 = 1;
K = [2.0, 3.0]
&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; k &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; K:
    F = odeint(ode, [Ca0, k], tspan)
    Ca = F[:,0]
    plt.plot(tspan, Ca, label=&lt;span style="color: #228b22;"&gt;'k={0}'&lt;/span&gt;.format(k))
plt.xlabel(&lt;span style="color: #228b22;"&gt;'time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$C_A$'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-parameterized-1.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-parameterized-1.png"&gt;&lt;p&gt;

&lt;p&gt;
I do not think this is a very elegant way to pass parameters around compared to the previous methods, but it nicely illustrates that there is more than one way to do it. And who knows, maybe it will be useful in some other context one day!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Yet-another-way-to-parameterize-an-ODE.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Error tolerance in numerical solutions to ODEs</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Error-tolerance-in-numerical-solutions-to-ODEs</link>
      <pubDate>Wed, 27 Feb 2013 14:31:18 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">q6gskTh9R9wzxLx8ZZlHbc1BhJs=</guid>
      <description>Error tolerance in numerical solutions to ODEs</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/18/error-tolerance-in-numerical-solutions-to-odes/" &gt;Matlab post&lt;/a&gt;

Usually, the numerical ODE solvers in python work well with the standard settings. Sometimes they do not, and it is not always obvious they have not worked! Part of using a tool like python is checking how well your solution really worked. We use an example of integrating an ODE that defines the van der Waal equation of an ideal gas here.
&lt;/p&gt;

&lt;p&gt;
we plot the analytical solution to the van der waal equation in reduced form here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

Tr = 0.9
Vr = np.linspace(0.34,4,1000)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;#&lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;analytical equation for Pr&lt;/span&gt;
Prfh = &lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; Vr: 8.0 / 3.0 * Tr / (Vr - 1.0 / 3.0) - 3.0 / (Vr**2)
Pr = Prfh(Vr) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;evaluated on our reduced volume vector.&lt;/span&gt;

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Plot the EOS&lt;/span&gt;
plt.plot(Vr,Pr)
plt.ylim([0, 2])
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$V_R$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$P_R$'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-vw-1.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1c5a3550&amp;gt;]
(0, 2)
&amp;lt;matplotlib.text.Text object at 0x1c22f750&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1d4e0750&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-vw-1.png"&gt;&lt;p&gt;

&lt;p&gt;
we want an equation for dPdV, which we will integrate we use symbolic math to do the derivative for us.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; sympy &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; diff, Symbol
Vrs = Symbol(&lt;span style="color: #228b22;"&gt;'Vrs'&lt;/span&gt;)

Prs = 8.0 / 3.0 * Tr / (Vrs - 1.0/3.0) - 3.0/(Vrs**2) 
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; diff(Prs,Vrs)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; -2.4/(Vrs - 0.333333333333333)**2 + 6.0/Vrs**3
&lt;/pre&gt;

&lt;p&gt;
Now, we solve the ODE. We will specify a large relative tolerance criteria (Note the default is much smaller than what we show here).
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;myode&lt;/span&gt;(Pr, Vr):
    dPrdVr = -2.4/(Vr - 0.333333333333333)**2 + 6.0/Vr**3
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; dPrdVr

Vspan = np.linspace(0.334, 4)
Po = Prfh(Vspan[0])
P = odeint(myode, Po, Vspan, rtol=1e-4)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Plot the EOS&lt;/span&gt;
plt.plot(Vr,Pr) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;analytical solution&lt;/span&gt;
plt.plot(Vspan, P[:,0], &lt;span style="color: #228b22;"&gt;'r.'&lt;/span&gt;)
plt.ylim([0, 2])
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$V_R$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$P_R$'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-vw-2.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
... &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1d4f3b90&amp;gt;]
[&amp;lt;matplotlib.lines.Line2D object at 0x2ac47518e710&amp;gt;]
(0, 2)
&amp;lt;matplotlib.text.Text object at 0x1c238fd0&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1c22af10&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-vw-2.png"&gt;&lt;p&gt;

&lt;p&gt;
You can see there is disagreement between the analytical solution and numerical solution. The origin of this problem is accuracy at the initial condition, where the derivative is extremely large.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; myode(Po, 0.34)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
-53847.3437818
&lt;/pre&gt;

&lt;p&gt;
We can increase the tolerance criteria to get a better answer. The defaults in odeint are actually set to 1.49012e-8.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;Vspan = np.linspace(0.334, 4)
Po = Prfh(Vspan[0])
P = odeint(myode, Po, Vspan)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;Plot the EOS&lt;/span&gt;
plt.plot(Vr,Pr) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;analytical solution&lt;/span&gt;
plt.plot(Vspan, P[:,0], &lt;span style="color: #228b22;"&gt;'r.'&lt;/span&gt;)
plt.ylim([0, 2])
plt.xlabel(&lt;span style="color: #228b22;"&gt;'$V_R$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'$P_R$'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-vw-3.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;gt;&amp;gt;&amp;gt; ... [&amp;lt;matplotlib.lines.Line2D object at 0x1d4dbf10&amp;gt;]
[&amp;lt;matplotlib.lines.Line2D object at 0x1c6e5550&amp;gt;]
(0, 2)
&amp;lt;matplotlib.text.Text object at 0x1d4e31d0&amp;gt;
&amp;lt;matplotlib.text.Text object at 0x1d9d3710&amp;gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-vw-3.png"&gt;&lt;p&gt;

&lt;p&gt;
The problem here was the derivative value varied by four orders of magnitude over the integration range, so the default tolerances were insufficient to accurately estimate the numerical derivatives over that range. Tightening the tolerances helped resolve that problem. Another approach might be to split the integration up into different regions. For instance, if instead of starting at Vr = 0.34, which is very close to a sigularity in the van der waal equation at Vr = 1/3, if you start at Vr = 0.5, the solution integrates just fine with the standard tolerances.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Error-tolerance-in-numerical-solutions-to-ODEs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Finding minima and maxima in ODE solutions with events</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Finding-minima-and-maxima-in-ODE-solutions-with-events</link>
      <pubDate>Wed, 27 Feb 2013 14:31:01 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">SlbAMvLVBhBKbOsDWj9f0N2oBq0=</guid>
      <description>Finding minima and maxima in ODE solutions with events</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/17/finding-minima-and-maxima-in-ode-solutions-with-events" &gt;Matlab post&lt;/a&gt;

Today we look at another way to use events in an ode solver. We use an events function to find minima and maxima, by evaluating the ODE in the event function to find conditions where the first derivative is zero, and approached from the right direction. A maximum is when the fisrt derivative is zero and increasing, and a minimum is when the first derivative is zero and decreasing.
&lt;/p&gt;

&lt;p&gt;
We use a simple ODE, \(y' = sin(x)*e^{-0.05x}\), which has minima and maxima.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; pycse &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; *
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;ode&lt;/span&gt;(y, x):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; np.sin(x) * np.exp(-0.05 * x)

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;minima&lt;/span&gt;(y, x):
    &lt;span style="color: #228b22;"&gt;'''Approaching a minumum, dydx is negatime and going to zero. our event function is increasing'''&lt;/span&gt;
    value = ode(y, x)
    direction = 1
    isterminal = &lt;span style="color: #8b0000;"&gt;False&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; value,  isterminal, direction

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;maxima&lt;/span&gt;(y, x):
    &lt;span style="color: #228b22;"&gt;'''Approaching a maximum, dydx is positive and going to zero. our event function is decreasing'''&lt;/span&gt;
    value = ode(y, x)
    direction = -1
    isterminal = &lt;span style="color: #8b0000;"&gt;False&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; value,  isterminal, direction

xspan = np.linspace(0, 20, 100)

y0 = 0

X, Y, XE, YE, IE = odelay(ode, y0, xspan, events=[minima, maxima])
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; IE
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt
plt.plot(X, Y)

&lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;blue is maximum, red is minimum&lt;/span&gt;
colors = &lt;span style="color: #228b22;"&gt;'rb'&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; xe, ye, ie &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;zip&lt;/span&gt;(XE, YE, IE):
    plt.plot([xe], [ye], &lt;span style="color: #228b22;"&gt;'o'&lt;/span&gt;, color=colors[ie])

plt.savefig(&lt;span style="color: #228b22;"&gt;'./images/ode-events-min-max.png'&lt;/span&gt;)
plt.show()
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[1, 0, 1, 0, 1, 0]
&lt;/pre&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-events-min-max.png"&gt;&lt;p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Finding-minima-and-maxima-in-ODE-solutions-with-events.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Stopping the integration of an ODE at some condition</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Stopping-the-integration-of-an-ODE-at-some-condition</link>
      <pubDate>Wed, 27 Feb 2013 14:30:30 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">hyhV9PK86U7VjThj0EO3hskIeog=</guid>
      <description>Stopping the integration of an ODE at some condition</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/02/stopping-the-integration-of-an-ode-at-some-condition/" &gt;Matlab post&lt;/a&gt;

In Post 968 we learned how to get the numerical solution to an ODE, and then to use the deval function to solve the solution for a particular value. The deval function uses interpolation to evaluate the solution at other valuse. An alternative approach would be to stop the ODE integration when the solution has the value you want. That can be done in Matlab by using an &amp;ldquo;event&amp;rdquo; function. You setup an event function and tell the ode solver to use it by setting an option.
&lt;/p&gt;

&lt;p&gt;
Given that the concentration of a species A in a constant volume, batch reactor obeys this differential equation \(\frac{dC_A}{dt}=- k C_A^2\) with the initial condition \(C_A(t=0) = 2.3\) mol/L and \(k = 0.23\) L/mol/s, compute the time it takes for \(C_A\) to be reduced to 1 mol/L.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; pycse &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; *
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np

k = 0.23
Ca0 = 2.3

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;dCadt&lt;/span&gt;(Ca, t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; -k * Ca**2

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;stop&lt;/span&gt;(Ca, t):
    isterminal = &lt;span style="color: #8b0000;"&gt;True&lt;/span&gt;
    direction = 0
    value = 1.0 - Ca
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; value, isterminal, direction

tspan = np.linspace(0.0, 10.0)

t, CA, TE, YE, IE = odelay(dCadt, Ca0, tspan, events=[stop], full_output=1)

&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'At t = {0:1.2f} seconds the concentration of A is {1:1.2f} mol/L.'&lt;/span&gt;.format(t[-1], CA[-1])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
At t = 2.46 seconds the concentration of A is 1.00 mol/L.
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/Stopping-the-integration-of-an-ODE-at-some-condition.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A simple first order ode evaluated at specific points</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/A-simple-first-order-ode-evaluated-at-specific-points</link>
      <pubDate>Wed, 27 Feb 2013 14:30:23 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">pepwkNWmKLn1TT5P2evEryvix2c=</guid>
      <description>A simple first order ode evaluated at specific points</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/08/05/a-simple-first-order-ode-evaluated-at-specific-points/" &gt;Matlab post&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
We have integrated an ODE over a specific time span. Sometimes it is desirable to get the solution at specific points, e.g. at t = [0 0.2 0.4 0.8]; This could be desirable to compare with experimental measurements at those time points. This example demonstrates how to do that.
&lt;/p&gt;

&lt;p&gt;
$$\frac{dy}{dt} = y(t)$$
&lt;/p&gt;

&lt;p&gt;
The initial condition is y(0) = 1.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint

y0 = 1
tspan = [0, 0.2, 0.4, 0.8]

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;dydt&lt;/span&gt;(y, t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; y

Y = odeint(dydt, y0, tspan)
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; Y[:,0]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[ 1.          1.22140275  1.49182469  2.22554103]
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/27/A-simple-first-order-ode-evaluated-at-specific-points.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Numerical solution to a simple ode</title>
      <link>http://jkitchin.github.io/blog/2013/02/26/Numerical-solution-to-a-simple-ode</link>
      <pubDate>Tue, 26 Feb 2013 21:17:44 EST</pubDate>
      <category><![CDATA[interpolation]]></category>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">se4wOj2tNpFT8f6A6HiRkUABg1I=</guid>
      <description>Numerical solution to a simple ode</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/08/03/numerical-solution-to-a-simple-ode/" &gt;Matlab post&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Integrate this ordinary differential equation (ode):
&lt;/p&gt;

&lt;p&gt;
$$\frac{dy}{dt} = y(t)$$
&lt;/p&gt;

&lt;p&gt;
over the time span of 0 to 2. The initial condition is y(0) = 1.
&lt;/p&gt;

&lt;p&gt;
to solve this equation, you need to create a function of the form: dydt = f(y, t) and then use one of the odesolvers, e.g. odeint.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fprime&lt;/span&gt;(y,t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; y

tspan = np.linspace(0, 2)
y0 = 1
ysol = odeint(fprime, y0, tspan)

plt.plot(tspan, ysol, label=&lt;span style="color: #228b22;"&gt;'numerical solution'&lt;/span&gt;)
plt.plot(tspan, np.exp(tspan), &lt;span style="color: #228b22;"&gt;'r--'&lt;/span&gt;, label=&lt;span style="color: #228b22;"&gt;'analytical solution'&lt;/span&gt;)
plt.xlabel(&lt;span style="color: #228b22;"&gt;'time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'y(t)'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #228b22;"&gt;'best'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/simple-ode.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/simple-ode.png"&gt;&lt;p&gt;

&lt;p&gt;
The numerical and analytical solutions agree.
&lt;/p&gt;

&lt;p&gt;
Now, suppose you want to know at what time is the solution equal to 3? There are several approaches to this, including setting up a solver, or using an event like approach to stop integration at y=3. A simple approach is to use reverse interpolation. We simply reverse the x and y vectors so that y is the independent variable, and we interpolate the corresponding x-value.

&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fprime&lt;/span&gt;(y,t):
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; y

tspan = np.linspace(0, 2)
y0 = 1
ysol = odeint(fprime, y0, tspan)

&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.interpolate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; interp1d

ip = interp1d(ysol[:,0], tspan) &lt;span style="color: #ff0000; font-weight: bold;"&gt;# reverse interpolation&lt;/span&gt;
&lt;span style="color: #8b0000;"&gt;print&lt;/span&gt; &lt;span style="color: #228b22;"&gt;'y = 3 at x = {0}'&lt;/span&gt;.format(ip(3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
y = 3 at x = 1.09854780564
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/26/Numerical-solution-to-a-simple-ode.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>ODEs with discontinuous forcing functions</title>
      <link>http://jkitchin.github.io/blog/2013/02/21/ODEs-with-discontinuous-forcing-functions</link>
      <pubDate>Thu, 21 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">BL-UcNEjRlAGAp_J9F3dJ8lFVXY=</guid>
      <description>ODEs with discontinuous forcing functions</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://matlab.cheme.cmu.edu/2011/09/01/odes-with-discontinuous-forcing-functions/" &gt;Matlab post&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
Adapted from &lt;a href="http://archives.math.utk.edu/ICTCM/VOL18/S046/paper.pdf" &gt;http://archives.math.utk.edu/ICTCM/VOL18/S046/paper.pdf&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
A mixing tank initially contains 300 g of salt mixed into 1000 L of water. At t=0 min, a solution of 4 g/L salt enters the tank at 6 L/min. At t=10 min, the solution is changed to 2 g/L salt, still entering at 6 L/min. The tank is well stirred, and the tank solution leaves at a rate of 6 L/min. Plot the concentration of salt (g/L) in the tank as a function of time.
&lt;/p&gt;

&lt;p&gt;
A mass balance on the salt in the tank leads to this differential equation: \(\frac{dM_S}{dt} = \nu C_{S,in}(t) - \nu M_S/V\) with the initial condition that \(M_S(t=0)=300\). The wrinkle is that the inlet conditions are not constant.
&lt;/p&gt;

&lt;p&gt;
$$C_{S,in}(t) = \begin{array}{ll} 0 &amp; t \le 0, \\ 4 &amp; 0 &lt; t \le 10, \\ 2 &amp; t &gt; 10. \end{array}$$
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; np
&lt;span style="color: #8b0000;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #8b0000;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #8b0000;"&gt;as&lt;/span&gt; plt

V = 1000.0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;L&lt;/span&gt;
nu = 6.0  &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;L/min&lt;/span&gt;
    
&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;Cs_in&lt;/span&gt;(t):
    &lt;span style="color: #228b22;"&gt;'inlet concentration'&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; t &amp;lt; 0:
        Cs = 0.0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;g/L&lt;/span&gt;
    &lt;span style="color: #8b0000;"&gt;elif&lt;/span&gt; (t &amp;gt; 0) &lt;span style="color: #8b0000;"&gt;and&lt;/span&gt; (t &amp;lt;= 10):
        Cs = 4.0
    &lt;span style="color: #8b0000;"&gt;else:&lt;/span&gt;
        Cs = 2.0
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; Cs

&lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;mass_balance&lt;/span&gt;(Ms, t):
    &lt;span style="color: #228b22;"&gt;'$\frac{dM_S}{dt} = \nu C_{S,in}(t) - \nu M_S/V$'&lt;/span&gt;
    dMsdt = nu * Cs_in(t) - nu * Ms / V
    &lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; dMsdt

tspan = np.linspace(0.0, 15.0, 50)

M0 = 300.0 &lt;span style="color: #ff0000; font-weight: bold;"&gt;# &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;gm salt&lt;/span&gt;
Ms = odeint(mass_balance, M0, tspan)

plt.plot(tspan, Ms/V, &lt;span style="color: #228b22;"&gt;'b.-'&lt;/span&gt;)
plt.xlabel(&lt;span style="color: #228b22;"&gt;'Time (min)'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #228b22;"&gt;'Salt concentration (g/L)'&lt;/span&gt;)
plt.savefig(&lt;span style="color: #228b22;"&gt;'images/ode-discont.png'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src="/img/./images/ode-discont.png"&gt;&lt;p&gt;

&lt;p&gt;
You can see the discontinuity in the salt concentration at 10 minutes due to the discontinous change in the entering salt concentration.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/02/21/ODEs-with-discontinuous-forcing-functions.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
