

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: ode</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-ODEs-with-a-neural-network-and-autograd"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd/" rel="bookmark" title="Permanent Link to Solving ODEs with a neural network and autograd">Solving ODEs with a neural network and autograd</a></h2>
      <p><small><span class="blog_post_date">Posted November 28, 2017 at 07:23 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated November 28, 2017 at 07:23 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In the last <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/11/27/Solving-BVPs-with-a-neural-network-and-autograd/">post</a> I explored using a neural network to solve a BVP. Here, I expand the idea to solving an initial value ordinary differential equation. The idea is basically the same, we just have a slightly different objective function.
</p>

<p>
\(dCa/dt = -k Ca(t)\) where \(Ca(t=0) = 2.0\).
</p>

<p>
Here is the code that solves this equation, along with a comparison to the analytical solution: \(Ca(t) = Ca0 \exp -kt\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad, elementwise_grad
<span style="color: #0000FF;">import</span> autograd.numpy.random <span style="color: #0000FF;">as</span> npr
<span style="color: #0000FF;">from</span> autograd.misc.optimizers <span style="color: #0000FF;">import</span> adam

<span style="color: #0000FF;">def</span> <span style="color: #006699;">init_random_params</span>(scale, layer_sizes, rs=npr.RandomState(0)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"""Build a list of (weights, biases) tuples, one for each layer."""</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [(rs.randn(insize, outsize) * scale,   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">weight matrix</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>rs.randn(outsize) * scale)           <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">bias vector</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> insize, outsize <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">zip</span>(layer_sizes[:-1], layer_sizes[1:])]


<span style="color: #0000FF;">def</span> <span style="color: #006699;">swish</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"see https://arxiv.org/pdf/1710.05941.pdf"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x / (1.0 + np.exp(-x))


<span style="color: #0000FF;">def</span> <span style="color: #006699;">Ca</span>(params, inputs):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"Neural network functions"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> W, b <span style="color: #0000FF;">in</span> params:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">outputs</span> = np.dot(inputs, W) + b
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">inputs</span> = swish(outputs)    
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> outputs

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Here is our initial guess of params:</span>
<span style="color: #BA36A5;">params</span> = init_random_params(0.1, layer_sizes=[1, 8, 1])

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Derivatives</span>
<span style="color: #BA36A5;">dCadt</span> = elementwise_grad(Ca, 1)

<span style="color: #BA36A5;">k</span> = 0.23
<span style="color: #BA36A5;">Ca0</span> = 2.0
<span style="color: #BA36A5;">t</span> = np.linspace(0, 10).reshape((-1, 1))

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">This is the function we seek to minimize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(params, step):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">These should all be zero at the solution</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">dCadt = -k * Ca(t)</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">zeq</span> = dCadt(params, t) - (-k * Ca(params, t))
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">ic</span> = Ca(params, 0) - Ca0
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.mean(zeq**2) + ic**2

<span style="color: #0000FF;">def</span> <span style="color: #006699;">callback</span>(params, step, g):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> step % 1000 == 0:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">"Iteration {0:3d} objective {1}"</span>.<span style="color: #006FE0;">format</span>(step,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> objective(params, step)))

<span style="color: #BA36A5;">params</span> = adam(grad(objective), params,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> step_size=0.001, num_iters=5001, callback=callback) 


<span style="color: #BA36A5;">tfit</span> = np.linspace(0, 20).reshape(-1, 1)
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(tfit, Ca(params, tfit), label=<span style="color: #008000;">'soln'</span>)
plt.plot(tfit, Ca0 * np.exp(-k * tfit), <span style="color: #008000;">'r--'</span>, label=<span style="color: #008000;">'analytical soln'</span>)
plt.legend()
plt.xlabel(<span style="color: #008000;">'time'</span>)
plt.ylabel(<span style="color: #008000;">'$C_A$'</span>)
plt.xlim([0, 20])
plt.savefig(<span style="color: #008000;">'nn-ode.png'</span>)
</pre>
</div>

<pre class="example">
Iteration   0 objective [[ 3.20374053]]
Iteration 1000 objective [[  3.13906829e-05]]
Iteration 2000 objective [[  1.95894699e-05]]
Iteration 3000 objective [[  1.60381564e-05]]
Iteration 4000 objective [[  1.39930673e-05]]
Iteration 5000 objective [[  1.03554970e-05]]

</pre>


<p>
<img src="/media/nn-ode.png"> 
</p>

<p>
Huh. Those two solutions are nearly indistinguishable. Since we used a neural network, let's hype it up and say we learned the solution to a differential equation! But seriously, note that although we got an "analytical" solution, we should only rely on it in the region we trained the solution on. You can see the solution above is not that good past t=10, even perhaps going negative (which is not even physically correct). That is a reminder that the function we have for the solution <i>is not the same as the analytical solution</i>, it just approximates it really well over the region we solved over. Of course, you can expand that region to the region you care about, but the main point is don't rely on the solution outside where you know it is good.
</p>

<p>
This idea isn't new. There are several papers in the literature on using neural networks to solve differential equations, e.g. <a href="http://www.sciencedirect.com/science/article/pii/S0255270102002076">http://www.sciencedirect.com/science/article/pii/S0255270102002076</a> and <a href="https://arxiv.org/pdf/physics/9705023.pdf">https://arxiv.org/pdf/physics/9705023.pdf</a>, and other blog posts that are similar (<a href="https://becominghuman.ai/neural-networks-for-solving-differential-equations-fa230ac5e04c">https://becominghuman.ai/neural-networks-for-solving-differential-equations-fa230ac5e04c</a>, even using autograd). That means to me that there is some merit to continuing to investigate this approach to solving differential equations.
</p>

<p>
There are some interesting challenges for engineers to consider with this approach though. When is the solution accurate enough? How reliable are derivatives of the solution? What network architecture is appropriate or best? How do you know how good the solution is? Is it possible to build in solution features, e.g. asymptotes, or constraints on derivatives, or that the solution should be monotonic, etc. These would help us trust the solutions not to do weird things, and to extrapolate more reliably.
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.1.2</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Uncertainty-in-the-solution-of-an-ODE"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE/" rel="bookmark" title="Permanent Link to Uncertainty in the solution of an ODE">Uncertainty in the solution of an ODE</a></h2>
      <p><small><span class="blog_post_date">Posted July 14, 2013 at 01:36 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/uncertainty/'>uncertainty</a>, <a href='/blog/category/ode/'>ode</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated October 18, 2013 at 03:55 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
Our objective in this post is to examine the effects of uncertainty in parameters that define an ODE on the integrated solution of the ODE. My favorite method for numerical uncertainty analysis is Monte Carlo simulation because it is easy to code and usually easy to understand. We take that approach first.
</p>

<p>
The problem to solve is to estimate the conversion in a constant volume batch reactor with a second order reaction \(A \rightarrow B\), and the rate law: \(-r_A = k C_A^2\), after one hour of reaction. There is 5% uncertainty in the rate constant \(k=0.001\) and in the initial concentration \(C_{A0}=1\). 
</p>

<p>
The relevant differential equation is:
</p>

<p>
\(\frac{dX}{dt} = -r_A /C_{A0}\).
</p>

<p>
We have to assume that 5% uncertainty refers to a normal distribution of error that has a standard deviation of 5% of the mean value. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b008b;">N</span> = 1000

<span style="color: #8b008b;">K</span> = np.random.normal(0.001, 0.05*0.001, N)
<span style="color: #8b008b;">CA0</span> = np.random.normal(1, 0.05*1, N)

<span style="color: #8b008b;">X</span> = [] <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">to store answer in</span>
<span style="color: #8b0000;">for</span> k, Ca0 <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">zip</span>(K, CA0):
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">define ODE</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ode</span>(X, t):
        <span style="color: #8b008b;">ra</span> = -k * (Ca0 * (1 - X))**2
        <span style="color: #8b0000;">return</span> -ra / Ca0
    
    <span style="color: #8b008b;">X0</span> = 0
    <span style="color: #8b008b;">tspan</span> = np.linspace(0,3600)

    <span style="color: #8b008b;">sol</span> = odeint(ode, X0, tspan)

    <span style="color: #8b008b;">X</span> += [sol[-1][0]]

<span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'Final conversion at one hour is {0:1.3f} +- {1:1.3f} (1 sigma)'</span>
<span style="color: #8b0000;">print</span> s.<span style="color: #cd0000;">format</span>(np.average(X),
               np.std(X))
</pre>
</div>

<pre class="example">
Final conversion at one hour is 0.782 +- 0.013 (1 sigma)
</pre>

<p>
See, it is not too difficulty to write. It is however, a little on the expensive side to run, since we typically need 1e3-1e6 samples to get the statistics reasonable. Let us try the uncertainties package too. For this we have to wrap a function that takes uncertainties and returns a single float number. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> uncertainties <span style="color: #8b0000;">as</span> u

<span style="color: #8b008b;">k</span> = u.ufloat(0.001, 0.05*0.001)
<span style="color: #8b008b;">Ca0</span> = u.ufloat(1.0, 0.05)

<span style="color: #4682b4;">@u.wrap</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(k, Ca0):
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">define the ODE</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ode</span>(X, t):
        <span style="color: #8b008b;">ra</span> = -k * (Ca0 * (1 - X))**2
        <span style="color: #8b0000;">return</span> -ra / Ca0
    
    <span style="color: #8b008b;">X0</span> = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial condition</span>
    <span style="color: #8b008b;">tspan</span> = np.linspace(0, 3600)
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">integrate it</span>
    <span style="color: #8b008b;">sol</span> = odeint(ode, X0, tspan)
    <span style="color: #8b0000;">return</span> sol[-1][0]

<span style="color: #8b008b;">result</span> = func(k, Ca0)
<span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'Final conversion at one hour is {0}(1 sigma)'</span>
<span style="color: #8b0000;">print</span> s.<span style="color: #cd0000;">format</span>(result)
</pre>
</div>

<pre class="example">
Final conversion at one hour is 0.783+/-0.012(1 sigma)
</pre>

<p>
This is about the same amount of code as the Monte Carlo approach, but it runs much faster, and gets approximately the same results. You have to remember the wrapping technique, since the uncertainties package does not run natively with the odeint function. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/07/14/Uncertainty-in-the-solution-of-an-ODE.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/07/14/Uncertainty-in-the-solution-of-an-ODE#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs/" rel="bookmark" title="Permanent Link to Linear algebra approaches to solving systems of constant coefficient ODEs">Linear algebra approaches to solving systems of constant coefficient ODEs</a></h2>
      <p><small><span class="blog_post_date">Posted February 27, 2013 at 02:33 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/20/linear-algebra-approaches-to-solving-systems-of-constant-coefficient-odes" >Matlab post</a>

Today we consider how to solve a system of first order, constant coefficient ordinary differential equations using linear algebra. These equations could be solved numerically, but in this case there are analytical solutions that can be derived. The equations we will solve are:
</p>

<p>
\(y'_1 = -0.02 y_1 + 0.02 y_2\)
</p>

<p>
\(y'_2 = 0.02 y_1 - 0.02 y_2\)
</p>

<p>
We can express this set of equations in matrix form as: \(\left[\begin{array}{c}y'_1\\y'_2\end{array}\right] = \left[\begin{array}{cc} -0.02 & 0.02 \\ 0.02 & -0.02\end{array}\right] \left[\begin{array}{c}y_1\\y_2\end{array}\right]\)
</p>

<p>
The general solution to this set of equations is
</p>

<p>
\(\left[\begin{array}{c}y_1\\y_2\end{array}\right] = \left[\begin{array}{cc}v_1 & v_2\end{array}\right] \left[\begin{array}{cc} c_1 & 0 \\ 0 & c_2\end{array}\right] \exp\left(\left[\begin{array}{cc} \lambda_1 & 0 \\ 0 & \lambda_2\end{array}\right] \left[\begin{array}{c}t\\t\end{array}\right]\right)\)
</p>

<p>
where \(\left[\begin{array}{cc} \lambda_1 & 0 \\ 0 & \lambda_2\end{array}\right]\) is a diagonal matrix of the eigenvalues of the constant coefficient matrix, \(\left[\begin{array}{cc}v_1 & v_2\end{array}\right]\) is a matrix of eigenvectors where the \(i^{th}\) column corresponds to the eigenvector of the \(i^{th}\) eigenvalue, and \(\left[\begin{array}{cc} c_1 & 0 \\ 0 & c_2\end{array}\right]\) is a matrix determined by the initial conditions.
</p>

<p>
In this example, we evaluate the solution using linear algebra. The initial conditions we will consider are \(y_1(0)=0\) and \(y_2(0)=150\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

A = np.array([[-0.02,  0.02],
              [ 0.02, -0.02]])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.</span>
evals, evecs = np.linalg.eigh(A)
<span style="color: #8b0000;">print</span> evals
<span style="color: #8b0000;">print</span> evecs
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; ... &gt;&gt;&gt; &gt;&gt;&gt; ... &gt;&gt;&gt; [-0.04  0.  ]
[[ 0.70710678  0.70710678]
 [-0.70710678  0.70710678]]
</pre>

<p>
The eigenvectors are the <i>columns</i> of evecs.
</p>

<p>
Compute the \(c\) matrix
</p>

<p>
V*c = Y0
</p>

<div class="org-src-container">

<pre class="src src-python">Y0 = [0, 150]

c = np.diag(np.linalg.solve(evecs, Y0))
<span style="color: #8b0000;">print</span> c
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; [[-106.06601718    0.        ]
 [   0.          106.06601718]]
</pre>

<p>
Constructing the solution
</p>

<p>
We will create a vector of time values, and stack them for each solution, \(y_1(t)\) and \(Y_2(t)\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

t = np.linspace(0, 100)
T = np.row_stack([t, t])

D = np.diag(evals)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">y = V*c*exp(D*T);</span>
y = np.dot(np.dot(evecs, c), np.exp(np.dot(D, T)))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">y has a shape of (2, 50) so we have to transpose it</span>
plt.plot(t, y.T)
plt.xlabel(<span style="color: #228b22;">'t'</span>)
plt.ylabel(<span style="color: #228b22;">'y'</span>)
plt.legend([<span style="color: #228b22;">'$y_1$'</span>, <span style="color: #228b22;">'$y_2$'</span>])
plt.savefig(<span style="color: #228b22;">'images/ode-la.png'</span>)
plt.show()
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... &gt;&gt;&gt; &gt;&gt;&gt; ... [&lt;matplotlib.lines.Line2D object at 0x1d4db950&gt;, &lt;matplotlib.lines.Line2D object at 0x1d4db4d0&gt;]
&lt;matplotlib.text.Text object at 0x1d35fbd0&gt;
&lt;matplotlib.text.Text object at 0x1c222390&gt;
&lt;matplotlib.legend.Legend object at 0x1d34ee90&gt;
</pre>

<p><img src="/img/./images/ode-la.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/27/Linear-algebra-approaches-to-solving-systems-of-constant-coefficient-ODEs#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Another-way-to-parameterize-an-ODE-nested-function"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function/" rel="bookmark" title="Permanent Link to Another way to parameterize an ODE - nested function">Another way to parameterize an ODE - nested function</a></h2>
      <p><small><span class="blog_post_date">Posted February 27, 2013 at 02:31 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated February 27, 2013 at 02:32 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/18/another-way-to-parameterize-an-ode-nested-function/" >Matlab post</a>

We saw one method to parameterize an ODE, by creating an ode function that takes an extra parameter argument, and then making a function handle that has the syntax required for the solver, and passes the parameter the ode function. 
</p>

<p>
Here we define the ODE function in a loop. Since the nested function is in the namespace of the main function, it can &ldquo;see&rdquo; the values of the variables in the main function. We will use this method to look at the solution to the van der Pol equation for several different values of mu.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

MU = [0.1, 1, 2, 5]
tspan = np.linspace(0, 100, 5000)
Y0 = [0, 3]

<span style="color: #8b0000;">for</span> mu <span style="color: #8b0000;">in</span> MU:
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">define the ODE</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">vdpol</span>(Y, t):
        x,y = Y
        dxdt = y
        dydt = -x + mu * (1 - x**2) * y
        <span style="color: #8b0000;">return</span>  [dxdt, dydt]
    
    Y = odeint(vdpol, Y0, tspan)
    
    x = Y[:,0]; y = Y[:,1]
    plt.plot(x, y, label=<span style="color: #228b22;">'mu={0:1.2f}'</span>.format(mu))

plt.axis(<span style="color: #228b22;">'equal'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/ode-nested-parameterization.png'</span>)
plt.show()
</pre>
</div>

<p><img src="/img/./images/ode-nested-parameterization.png"><p>

<p>
You can see the solution changes dramatically for different values of mu. The point here is not to understand why, but to show an easy way to study a parameterize ode with a nested function. Nested functions can be a great way to &ldquo;share&rdquo; variables between functions especially for ODE solving, and nonlinear algebra solving, or any other application where you need a lot of parameters defined in one function in another function.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Another-way-to-parameterize-an-ODE---nested-function.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/27/Another-way-to-parameterize-an-ODE-nested-function#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Yet-another-way-to-parameterize-an-ODE"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE/" rel="bookmark" title="Permanent Link to Yet another way to parameterize an ODE">Yet another way to parameterize an ODE</a></h2>
      <p><small><span class="blog_post_date">Posted February 27, 2013 at 02:31 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/06/yet-another-way-to-parameterize-an-ode/" >Matlab post</a>

We previously examined a way to parameterize an ODE. In those methods, we either used an anonymous function to parameterize an ode function, or we used a nested function that used variables from the shared workspace.
</p>

<p>
We want a convenient way to solve \(dCa/dt = -k Ca\) for multiple values of \(k\). Here we use a trick to pass a parameter to an ODE through the initial conditions. We expand the ode function definition to include this parameter, and set its derivative to zero, effectively making it a constant.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ode</span>(F, t):
    Ca, k = F
    dCadt = -k * Ca
    dkdt = 0.0
    <span style="color: #8b0000;">return</span> [dCadt, dkdt]

tspan = np.linspace(0, 4)

Ca0 = 1;
K = [2.0, 3.0]
<span style="color: #8b0000;">for</span> k <span style="color: #8b0000;">in</span> K:
    F = odeint(ode, [Ca0, k], tspan)
    Ca = F[:,0]
    plt.plot(tspan, Ca, label=<span style="color: #228b22;">'k={0}'</span>.format(k))
plt.xlabel(<span style="color: #228b22;">'time'</span>)
plt.ylabel(<span style="color: #228b22;">'$C_A$'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/ode-parameterized-1.png'</span>)
plt.show()
</pre>
</div>

<p><img src="/img/./images/ode-parameterized-1.png"><p>

<p>
I do not think this is a very elegant way to pass parameters around compared to the previous methods, but it nicely illustrates that there is more than one way to do it. And who knows, maybe it will be useful in some other context one day!
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Yet-another-way-to-parameterize-an-ODE.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/02/27/Yet-another-way-to-parameterize-an-ODE#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/ode/2">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/01/27/New-publication-in-Topics-in-Catalysis/">New publication in Topics in Catalysis</a></li>
      <li><a href="/blog/2018/01/03/New-publication-in-Molecular-Simulation/">New publication in Molecular Simulation</a></li>
      <li><a href="/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group/">2017 in a nutshell for the Kitchin Research group</a></li>
      <li><a href="/blog/2017/11/29/Solving-an-eigenvalue-differential-equation-with-a-neural-network/">Solving an eigenvalue differential equation with a neural network</a></li>
      <li><a href="/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd/">Solving ODEs with a neural network and autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



