

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: autograd</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Using-autograd-to-plot-implicit-functions"></div>
      <h2 class="blog_post_title"><a href="/blog/2019/10/02/Using-autograd-to-plot-implicit-functions/" rel="bookmark" title="Permanent Link to Using autograd to plot implicit functions">Using autograd to plot implicit functions</a></h2>
      <p><small><span class="blog_post_date">Posted October 02, 2019 at 09:30 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/implicit-function/'>implicit-function</a>, <a href='/blog/category/nonlinear-algebra/'>nonlinear-algebra</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Consider the solution to these equations (adapted from <a href="https://www.mathworks.com/help/optim/ug/fsolve.html">https://www.mathworks.com/help/optim/ug/fsolve.html</a>):
</p>

<p>
\(e^{-e^{-(x_1 + x_2)}} = x_2 (1 + x_1^2)\)
</p>

<p>
and
</p>

<p>
\(x_1 \cos(x_2) + x_2 \sin(x_1) = 1/2\)
</p>

<p>
It is not clear how many solutions there are to this set of equations, or what you should guess for the initial guess. Usually, the best way to see where a solution might be is to plot the equations and see where they intersect. These equations are implicit though, and it is not easy to plot them because we cannot solve for \(x_2\) in terms of \(x_1\) in either case. Here we explore a strategy to get plots so we can see where solutions could be.
</p>

<p>
The idea is that we find one solution to each equation independently. Then, we derive a differential equation for each equation so we can integrate it to find the curve that is defined by the implicit function.  First, we find a solution for each equation. We guess a value for \(x_2\) and then find the value of \(x_1\) that solves each equation independently.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f1</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(-np.exp(-(x1 + x2))) - x2 * (1 + x1**2)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f2</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x1 * np.cos(x2) + x2 * np.sin(x1) - 0.5

<span style="color: #BA36A5;">x2_1</span> = 0.6
x1_1, = fsolve(f1, 0, args=(x2_1,))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'f1: '</span>, x1_1, x2_1)

<span style="color: #BA36A5;">x2_2</span> = 1.0
x1_2, = fsolve(f2, 0 ,args=(x2_2,))
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'f2: '</span>, x1_2, x2_2)
</pre>
</div>

<p>
f1:  0.08638978040861575 0.6
f2:  0.32842406163614396 1.0
</p>

<p>
Next, we need a differential equation that is \(dx_2/dx_1\). If we had that, we could just integrate it from one of the starting points above, and get the curve we want. The functions are implicit, so we have to use the implicit derivative, which for the first equation is \(dx_2/dx_1 = -df1/dx_1 / df1/dx_2\). We will get these gradients from autograd. Then, we just integrate the solution. Here we do this for the first equation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> solve_ivp
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #BA36A5;">df1dx1</span> = grad(f1, 0)
<span style="color: #BA36A5;">df1dx2</span> = grad(f1, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dx2dx1_1</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -df1dx1(x1, x2) / df1dx2(x1, x2)

<span style="color: #BA36A5;">x1_span</span> = (x1_1, 1)
<span style="color: #BA36A5;">x2_0</span> = (x2_1, )
<span style="color: #BA36A5;">sol1</span> = solve_ivp(dx2dx1_1, x1_span, x2_0, max_step=0.1)
</pre>
</div>

<p>
And then, we do it for the second equation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">df2dx1</span> = grad(f2, 0)
<span style="color: #BA36A5;">df2dx2</span> = grad(f2, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dx2dx1_2</span>(x1, x2):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -df2dx1(x1, x2) / df2dx2(x1, x2)

<span style="color: #BA36A5;">x1_span</span> = (x1_2, 1)
<span style="color: #BA36A5;">x2_0</span> = (x2_2, )
<span style="color: #BA36A5;">sol2</span> = solve_ivp(dx2dx1_2, x1_span, x2_0, max_step=0.1)
</pre>
</div>

<p>
Finally, we plot the two solutions.
</p>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt
plt.plot(sol1.t, sol1.y.T)
plt.plot(sol2.t, sol2.y.T)
plt.xlabel(<span style="color: #008000;">'$x_1$'</span>)
plt.ylabel(<span style="color: #008000;">'$x_2$'</span>)
plt.legend([<span style="color: #008000;">'f1'</span>, <span style="color: #008000;">'f2'</span>])
</pre>
</div>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/b770a79094dc5fa34b51ebeed23401d697cc0f01.png"></figure> 
</p>

<p>
You can see now that in this range, there is only one intersection, i.e. one solution, and it is near \(x_1=0.4, x_2=0.6\). We can finally use that as an initial guess to find the only solution in this region, with confidence we are not missing any solutions.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x1</span>, <span style="color: #BA36A5;">x2</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [f1(x1, x2), f2(x1, x2)]

fsolve(objective, [0.4, 0.6])
</pre>
</div>

<pre class="example">
array([0.35324662, 0.60608174])
</pre>

<p>
That is the same solution as reported at the Matlab site. Another use of autograd for the win here.
</p>
<p>Copyright (C) 2019 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2019/10/02/Using-autograd-to-plot-implicit-functions.org">org-mode source</a></p>
<p>Org-mode version = 9.2.3</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2019/10/02/Using-autograd-to-plot-implicit-functions">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-differential-algebraic-equations-with-help-from-autograd"></div>
      <h2 class="blog_post_title"><a href="/blog/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd/" rel="bookmark" title="Permanent Link to Solving differential algebraic equations with help from autograd">Solving differential algebraic equations with help from autograd</a></h2>
      <p><small><span class="blog_post_date">Posted September 22, 2019 at 12:59 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dae/'>dae</a>, <a href='/blog/category/ode/'>ode</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
This problem is adapted from one in "Problem Solving in Chemical Engineering with Numerical Methods, Michael B. Cutlip, Mordechai Shacham".
</p>

<p>
In the binary, batch distillation of benzene (1) and toluene (2), the moles of liquid \(L\) remaining as a function of the mole fraction of toluene (\(x_2\)) is expressed by:
</p>

<p>
\(\frac{dL}{dx_2} = \frac{L}{x_2 (k_2 - 1)}\)
</p>

<p>
where \(k_2\) is the vapor liquid equilibrium ratio for toluene. This can be computed as:
</p>

<p>
\(k_i = P_i / P\) where \(P_i = 10^{A_i + \frac{B_i}{T +C_i}}\) and that pressure is in mmHg, and the temperature is in degrees Celsius.
</p>

<p>
One difficulty in solving this problem is that the temperature is not constant; it changes with the composition. We know that the temperature changes to satisfy this constraint  \(k_1(T) x_1 + k_2(T) x_2 = 1\).
</p>

<p>
Sometimes, one can solve for T directly, and substitute it into the first ODE, but this is not a possibility here. One way you might solve this is to use the constraint to find \(T\) inside an ODE function, but that is tricky; nonlinear algebra solvers need a guess and don't always converge, or may converge to non-physical solutions. They also require iterative solutions, so they will be slower than an approach where we just have to integrate the solution.  A better way is to derive a second ODE \(dT/dx_2\) from the constraint.  The constraint is implicit in \(T\), so We  compute it as \(dT/dx_2 = -df/dx_2 / df/dT\) where \(f(x_2, T) = k_1(T) x_1 + k_2(T) x_2  - 1 = 0\). This equation is used to compute the bubble point temperature. Note, it is possible to derive these analytically, but who wants to?  We can use autograd to get those derivatives for us instead.
</p>

<p>
The following information is given:
</p>

<p>
The total pressure is fixed at 1.2 atm, and the distillation starts at \(x_2=0.4\). There are initially 100 moles in the distillation.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">species</th>
<th scope="col" class="org-right">A</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">C</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">benzene</td>
<td class="org-right">6.90565</td>
<td class="org-right">-1211.033</td>
<td class="org-right">220.79</td>
</tr>

<tr>
<td class="org-left">toluene</td>
<td class="org-right">6.95464</td>
<td class="org-right">-1344.8</td>
<td class="org-right">219.482</td>
</tr>
</tbody>
</table>

<p>
We have to start by finding the initial temperature from the constraint.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> solve_ivp
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">P</span> = 760 * 1.2 <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">mmHg</span>
<span style="color: #BA36A5;">A1</span>, <span style="color: #BA36A5;">B1</span>, <span style="color: #BA36A5;">C1</span> = 6.90565, -1211.033,  220.79
<span style="color: #BA36A5;">A2</span>, <span style="color: #BA36A5;">B2</span>, <span style="color: #BA36A5;">C2</span> = 6.95464, -1344.8, 219.482

<span style="color: #0000FF;">def</span> <span style="color: #006699;">k1</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 10**(A1 + B1 / (C1 + T)) / P

<span style="color: #0000FF;">def</span> <span style="color: #006699;">k2</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 10**(A2 + B2 / (C2 + T)) / P

<span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x2, T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x1</span> = 1 - x2
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> k1(T) * x1 + k2(T) * x2 - 1

T0, = fsolve(<span style="color: #0000FF;">lambda</span> T: f(0.4, T), 96)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The initial temperature is {T0:1.2f} degC.'</span>)
</pre>
</div>

<p>
The initial temperature is 95.59 degC.
</p>

<p>
Next, we compute the derivative we need. This derivative is derived from the constraint, which should ensure that the temperature changes as required to maintain the constraint.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">dfdx2</span> = grad(f, 0)
<span style="color: #BA36A5;">dfdT</span> = grad(f, 1)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dTdx2</span>(x2, T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -dfdx2(x2, T) / dfdT(x2, T)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">ode</span>(x2, X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">L</span>, <span style="color: #BA36A5;">T</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dLdx2</span> = L / (x2 * (k2(T) - 1))
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [dLdx2, dTdx2(x2, T)]
</pre>
</div>

<p>
Next we solve and plot the ODE.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">x2span</span> = (0.4, 0.8)
<span style="color: #BA36A5;">X0</span> = (100, T0)
<span style="color: #BA36A5;">sol</span> = solve_ivp(ode, x2span, X0, max_step=0.01)

plt.plot(sol.t, sol.y.T)
plt.legend([<span style="color: #008000;">'L'</span>, <span style="color: #008000;">'T'</span>]);
plt.xlabel(<span style="color: #008000;">'$x_2$'</span>)
plt.ylabel(<span style="color: #008000;">'L, T'</span>)
<span style="color: #BA36A5;">x2</span> = sol.t
<span style="color: #BA36A5;">L</span>, <span style="color: #BA36A5;">T</span> = sol.y
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'At x2={x2[-1]:1.2f} there are {L[-1]:1.2f} moles of liquid left at {T[-1]:1.2f} degC'</span>)
</pre>
</div>

<p>
At x2=0.80 there are 14.04 moles of liquid left at 108.57 degC
</p>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/a75e63c53e3c2cb02c40c808789084c337e174ff.png"></figure> 
</p>

<p>
You can see that the liquid level drops, and the temperature rises.
</p>

<p>
Let's double check that the constraint is actually met. We do that qualitatively here by plotting it, and quantitatively by showing all values are close to 0.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">constraint</span> = k1(T) * (1 - x2) + k2(T) * x2 - 1
plt.plot(x2, constraint)
plt.ylim([-1, 1])
plt.xlabel(<span style="color: #008000;">'$x_2$'</span>)
plt.ylabel(<span style="color: #008000;">'constraint value'</span>)
<span style="color: #0000FF;">print</span>(np.allclose(constraint, np.zeros_like(constraint)))
constraint
</pre>
</div>

<p>
True
</p>

<pre class="example">
array([ 2.22044605e-16,  4.44089210e-16,  2.22044605e-16,  0.00000000e+00,
        1.11022302e-15,  0.00000000e+00,  6.66133815e-16,  0.00000000e+00,
       -2.22044605e-16,  1.33226763e-15,  8.88178420e-16, -4.44089210e-16,
        4.44089210e-16,  1.11022302e-15, -2.22044605e-16,  0.00000000e+00,
       -2.22044605e-16, -1.11022302e-15,  4.44089210e-16,  0.00000000e+00,
       -4.44089210e-16,  4.44089210e-16, -6.66133815e-16, -4.44089210e-16,
        4.44089210e-16, -1.11022302e-16, -8.88178420e-16, -8.88178420e-16,
       -9.99200722e-16, -3.33066907e-16, -7.77156117e-16, -2.22044605e-16,
       -9.99200722e-16, -1.11022302e-15, -3.33066907e-16, -1.99840144e-15,
       -1.33226763e-15, -2.44249065e-15, -1.55431223e-15, -6.66133815e-16,
       -2.22044605e-16])
</pre>


<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/bb2b32002658b8724d214f2441c9f55a97c565c8.png"></figure> 
</p>


<p>
So indeed, the constraint is met! Once again, autograd comes to the rescue in making a computable derivative from an algebraic constraint so that we can solve a DAE as a set of ODEs using our regular machinery. Nice work autograd!
</p>
<p>Copyright (C) 2019 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.2.3</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2019/09/22/Solving-differential-algebraic-equations-with-help-from-autograd">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Sensitivity-analysis-with-odeint-and-autograd"></div>
      <h2 class="blog_post_title"><a href="/blog/2019/09/13/Sensitivity-analysis-with-odeint-and-autograd/" rel="bookmark" title="Permanent Link to Sensitivity analysis with odeint and autograd">Sensitivity analysis with odeint and autograd</a></h2>
      <p><small><span class="blog_post_date">Posted September 13, 2019 at 09:56 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis/">previous post</a> I showed a way to do sensitivity analysis of the solution of a differential equation to parameters in the equation using autograd. The basic approach was to write a differentiable integrator, and then use it in a function so that autograd could take the derivative.
</p>

<p>
Since that time, autograd has added <a href="https://github.com/HIPS/autograd/blob/master/autograd/scipy/integrate.py">derivative support</a> for <code>scipy.integrate.odeint</code>. In this post we examine that. As usual with autograd, we have to import the autograd version of numpy, and the autograd version of odeint. We will find the derivative of the solution to an ODE (which is an array) so we need to also import the jacobian function. Finally, there is a subtle, and non-obvious requirement that we need to import the autograd tuple. That ensures that the variables are differentiable through the tuple we will use for the arguments.
</p>

<p>
The differential equation we solve returns the concentration of a species as a function of time, and the solution depends on two parameters, i.e. \(C = f(t; k_1, k_{-1})\), and we are interested in the time-dependent sensitivity of \(C\) with respect to those parameters. The approach we use is to define a function that has those parameters as arguments. The function will solve the ODE and return the time-dependent solution. First we make that solution, mostly to see that the autograd version of odeint works.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd.scipy.integrate <span style="color: #0000FF;">import</span> odeint
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> jacobian
<span style="color: #0000FF;">from</span> autograd.builtins <span style="color: #0000FF;">import</span> <span style="color: #006FE0;">tuple</span>

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">Ca0</span> = 1.0
<span style="color: #BA36A5;">k1</span> = <span style="color: #BA36A5;">k_1</span> = 3.0

<span style="color: #BA36A5;">tspan</span> = np.linspace(0, 0.5)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">C</span>(K):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">k1</span>, <span style="color: #BA36A5;">k_1</span> = K
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">dCdt</span>(Ca, t, k1, k_1):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -k1 * Ca + k_1 * (Ca0 - Ca)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">sol</span> = odeint(dCdt, Ca0, tspan, <span style="color: #006FE0;">tuple</span>((k1, k_1)))
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> sol

plt.plot(tspan, C([k1, k_1]))
plt.xlim([tspan.<span style="color: #006FE0;">min</span>(), tspan.<span style="color: #006FE0;">max</span>()])
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.ylabel(<span style="color: #008000;">'C'</span>);
</pre>
</div>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/bca9e95a16f361ce6d92dd6efe90a2e653e014ef.png"></figure> 
</p>


<p>
Now, the solution is an array, and we want the derivative of C with respect to the parameters at each time point. That means we want the jacobian derivative of the output with respect to the input. Here is the autograd approach to doing that. The jacobian function returns a function that we can evaluate to get the derivatives.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> time
<span style="color: #BA36A5;">t0</span> = time.time()
<span style="color: #BA36A5;">dCdk</span> = jacobian(C, 0)


<span style="color: #BA36A5;">k_sensitivity</span> = dCdk(np.array([k1, k_1]))

<span style="color: #BA36A5;">k1_sensitivity</span> = k_sensitivity[:, 0, 0]
<span style="color: #BA36A5;">k_1_sensitivity</span> = k_sensitivity[:, 0, 1]

plt.plot(tspan, np.<span style="color: #006FE0;">abs</span>(k1_sensitivity), label=<span style="color: #008000;">'dC/dk1'</span>)
plt.plot(tspan, np.<span style="color: #006FE0;">abs</span>(k_1_sensitivity), label=<span style="color: #008000;">'dC/dk_1'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>)
plt.xlabel(<span style="color: #008000;">'t'</span>)
plt.ylabel(<span style="color: #008000;">'sensitivity'</span>)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Elapsed time = {time.time() - t0:1.1f} seconds'</span>)
</pre>
</div>

<p>
Elapsed time = 38.2 seconds
</p>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/3a0a58bb6d4b3e1b215c2918d511f3a8a3a2ca3d.png"></figure> 
</p>

<p>
That looks similar to the results from before. It is pretty slow I think, that took more than half a minute to work out. That is still faster and probably more correct than if I had to do it by hand. In contrast, however, the finite difference code below is comparatively very fast! I don't know what is slow in the autograd implementation. I guess it is an implementation detail.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numdifftools <span style="color: #0000FF;">as</span> nd
<span style="color: #BA36A5;">t0</span> = time.time()

<span style="color: #BA36A5;">fdk1</span>, <span style="color: #BA36A5;">fdk_1</span> = nd.Jacobian(C)([k1, k_1]).T
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Elapsed time = {time.time() - t0:1.1f} seconds'</span>)

plt.plot(tspan, np.<span style="color: #006FE0;">abs</span>(fdk1), label=<span style="color: #008000;">'fd dC/dk1'</span>)
plt.plot(tspan, np.<span style="color: #006FE0;">abs</span>(fdk_1), label=<span style="color: #008000;">'fd dC/dk_1'</span>)
plt.plot(tspan, np.<span style="color: #006FE0;">abs</span>(k1_sensitivity), <span style="color: #008000;">'y--'</span>, label=<span style="color: #008000;">'dC/dk1'</span>)
plt.plot(tspan, np.<span style="color: #006FE0;">abs</span>(k_1_sensitivity),<span style="color: #008000;">'m--'</span>, label=<span style="color: #008000;">'dC/dk_1'</span>)
plt.legend(loc=<span style="color: #008000;">'best'</span>);
plt.xlabel(<span style="color: #008000;">'t'</span>);
plt.ylabel(<span style="color: #008000;">'sensitivity'</span>);
</pre>
</div>

<p>
Elapsed time = 0.1 seconds
</p>

<pre class="example">
&lt;Figure size 432x288 with 1 Axes&gt;
</pre>


<p>
<figure><img src="/media/be7bf4798396d6a27938715f6bb0e22b8f3e0b1c.png"></figure> 
</p>

<p>
You can see the two results are visually indistinguishable. Even the code is pretty similar. I would tend to prefer the autograd way since it should be less sensitive to finite difference artifacts, but it is nice to have an independent way to test if it is working.
</p>
<p>Copyright (C) 2019 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2019/09/13/Sensitivity-analysis-with-odeint-and-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.2.3</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2019/09/13/Sensitivity-analysis-with-odeint-and-autograd">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Line-integrals-in-Python-with-autograd"></div>
      <h2 class="blog_post_title"><a href="/blog/2018/11/16/Line-integrals-in-Python-with-autograd/" rel="bookmark" title="Permanent Link to Line integrals in Python with autograd">Line integrals in Python with autograd</a></h2>
      <p><small><span class="blog_post_date">Posted November 16, 2018 at 08:39 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/python/'>python</a>, <a href='/blog/category/integration/'>integration</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org107f13d">1. Summary</a></li>
</ul>
</div>
</div>
<p>
A line integral is an integral of a function along a curve in space. We usually represent the curve by a parametric equation, e.g. \(\mathbf{r}(t) = [x(t), y(t), z(t)] = x(t)\mathbf{i} + y(t)\mathbf{j} + z(t)\mathbf{k}\).  So, in general the curve will be a vector function, and the function we want to integrate will also be a vector function.
</p>

<p>
Then, we can write the line integral definition as:
</p>

<p>
\(\int_C \mathbf{F(r)}\cdot d\mathbf{r} = \int_a^b \mathbf{F}({\mathbf{r}(t)) \cdot \mathbf{r'}(t) dt\) where \(\mathbf{r'}(t) = \frac{d\mathbf{r}}{dt}\). This integrand is a scalar function, because of the dot product.
</p>

<p>
The following examples are adapted from Chapter 10 in Advanced Engineering Mathematics by Kreysig.
</p>

<p>
The first example is the evaluation of  a line integral in the plane. We want to evaluate the integral of \(\mathbf{F(r)}=[-y, -xy]\) on the curve \(\mathbf{r(t)}=[-sin(t), cos(t)]\) from t=0 to t = &pi;/2. The answer in the book is given as 0.4521. Here we evaluate this numerically, using autograd for the relevant derivative. Since the curve has multiple outputs, we have to use the jacobian function to get the derivatives. After that, it is a simple bit of matrix multiplication, and a call to the quad function.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> jacobian
<span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> quad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">F</span>(X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -y, -x * y

<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([-np.sin(t), np.cos(t)])

<span style="color: #BA36A5;">drdt</span> = jacobian(r)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(r(t)) @ drdt(t)

<span style="color: #BA36A5;">I</span>, <span style="color: #BA36A5;">e</span> = quad(integrand, 0.0, np.pi / 2)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The integral is {I:1.4f}.'</span>)
</pre>
</div>

<pre class="example">
The integral is 0.4521.


</pre>

<p>
We get the same result as the analytical solution.
</p>


<p>
The next example is in three dimensions. Find the line integral along \(\mathbf{r}(t)=[cos(t), sin(t), 3t]\) of the function \(\mathbf{F(r)}=[z, x, y]\) from t=0 to t=2 &pi;. The solution is given as 21.99.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> elementwise_grad, grad, jacobian

<span style="color: #0000FF;">def</span> <span style="color: #006699;">F</span>(X):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span>, <span style="color: #BA36A5;">z</span> = X
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> [z, x, y]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">C</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([np.cos(t), np.sin(t), 3 * t])

<span style="color: #BA36A5;">dCdt</span> = jacobian(C, 0)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(C(t)) @ dCdt(t)

<span style="color: #BA36A5;">I</span>, <span style="color: #BA36A5;">e</span> = quad(integrand, 0, 2 * np.pi)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The integral is {I:1.2f}.'</span>)
</pre>
</div>

<pre class="example">
The integral is 21.99.


</pre>

<p>
That is also the same as the analytical solution. Note the real analytical solution was 7 &pi;, which is nearly equivalent to our answer.
</p>

<div class="org-src-container">
<pre class="src src-ipython">7 * np.pi - I
</pre>
</div>

<pre class="example">
3.552713678800501e-15

</pre>


<p>
As a final example, we consider an alternate form of the line integral. In this form we do not use a dot product, so the integral results in a vector. This doesn't require anything from autograd, but does require us to be somewhat clever in how to do the integrals since quad can only integrate scalar functions. We need to integrate each component of the integrand independently. Here is one approach where we use lambda functions for each component. You could also manually separate the components.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">def</span> <span style="color: #006699;">F</span>(r):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">x</span>, <span style="color: #BA36A5;">y</span>, <span style="color: #BA36A5;">z</span> = r
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x * y, y * z, z

<span style="color: #0000FF;">def</span> <span style="color: #006699;">r</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([np.cos(t), np.sin(t), 3 * t])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(r(t))

[quad(<span style="color: #0000FF;">lambda</span> t: integrand(t)[i], 0, 2 * np.pi)[0] <span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> [0, 1, 2]]
</pre>
</div>

<pre class="example">
[-6.9054847581172525e-18, -18.849555921538755, 59.21762640653615]

</pre>

<p>
The analytical solution in this case was given as:
</p>

<div class="org-src-container">
<pre class="src src-ipython">[0, -6 * np.pi, 6 * np.pi**2]
</pre>
</div>

<pre class="example">
[0, -18.84955592153876, 59.21762640653615]

</pre>

<p>
which is evidently the same as our numerical solution.
</p>

<p>
Maybe an alternative, but more verbose is this vectorized integrate function. We still make temporary functions for integrating, and the vectorization is essentially like the list comprehension above, but we avoid the lambda functions.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #6434A3;">@np.vectorize</span>
<span style="color: #0000FF;">def</span> <span style="color: #006699;">integrate</span>(i):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">integrand</span>(t):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> F(r(t))[i]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">I</span>, <span style="color: #BA36A5;">e</span> = quad(integrand, 0, 2 * np.pi)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> I

integrate([0, 1, 2])
</pre>
</div>

<pre class="example">
array([ -6.90548476e-18,  -1.88495559e+01,   5.92176264e+01])

</pre>

<div id="outline-container-org107f13d" class="outline-2">
<h2 id="org107f13d"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
Once again, autograd provides a convenient way to compute function jacobians which make it easy to evaluate line integrals in Python.</p>
</div>
</div>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/11/16/Line-integrals-in-Python-with-autograd.org">org-mode source</a></p>
<p>Org-mode version = 9.1.14</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2018/11/16/Line-integrals-in-Python-with-autograd">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Using-autograd-for-error-propagation"></div>
      <h2 class="blog_post_title"><a href="/blog/2018/11/05/Using-autograd-for-error-propagation/" rel="bookmark" title="Permanent Link to Using autograd for error propagation">Using autograd for error propagation</a></h2>
      <p><small><span class="blog_post_date">Posted November 05, 2018 at 09:04 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/uncertainty/'>uncertainty</a>, <a href='/blog/category/autograd/'>autograd</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Back in <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/03/07/Another-approach-to-error-propagation/">2013</a> I wrote about using the uncertainties package to propagate uncertainties. The problem setup was for finding the uncertainty in the exit concentration from a CSTR when there are uncertainties in the other parameters. In this problem we were given this information about the parameters and their uncertainties.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Parameter</th>
<th scope="col" class="org-right">value</th>
<th scope="col" class="org-right">&sigma;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Fa0</td>
<td class="org-right">5</td>
<td class="org-right">0.05</td>
</tr>

<tr>
<td class="org-left">v0</td>
<td class="org-right">10</td>
<td class="org-right">0.1</td>
</tr>

<tr>
<td class="org-left">V</td>
<td class="org-right">66000</td>
<td class="org-right">100</td>
</tr>

<tr>
<td class="org-left">k</td>
<td class="org-right">3</td>
<td class="org-right">0.2</td>
</tr>
</tbody>
</table>

<p>
The exit concentration is found by solving this equation:
</p>

<p>
\(0 = Fa0 - v0 * Ca - k * Ca**2 * V\)
</p>

<p>
So the question was what is Ca, and what is the uncertainty on it? Finding Ca is easy with fsolve.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">Fa0</span> = 5.0
<span style="color: #BA36A5;">v0</span> = 10.0

<span style="color: #BA36A5;">V</span> = 66000.0
<span style="color: #BA36A5;">k</span> = 3.0

<span style="color: #0000FF;">def</span> <span style="color: #006699;">func</span>(Ca, v0, k, Fa0, V):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #036A07;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">Fa</span> = v0 * Ca     <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">exit molar flow of A</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">ra</span> = -k * Ca**2  <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">rate of reaction of A L/mol/h</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> Fa0 - Fa + V * ra

Ca, = fsolve(func, 0.1 * Fa0 / v0, args=(v0, k, Fa0, V))
Ca
</pre>
</div>

<pre class="example">
0.0050000000000000001

</pre>

<p>
The uncertainty on Ca is a little trickier. A <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty#Simplification">simplified</a> way to estimate it is:
</p>

<p>
\(\sigma_{Ca} = \sqrt{(dCa/dv0)^2 \sigma_{v0}^2 + (dCa/dv0)^2 \sigma_{v0}^2 + (dCa/dFa0)^2 \sigma_{Fa0}^2 + (dCa/dV)^2 \sigma_{V}^2}\)
</p>

<p>
We know the &sigma;_i for each input, we just need those partial derivatives. However, we only have the implicit function we used to solve for Ca, and I do not want to do the algebra to solve for Ca. Luckily, we <a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/08/Getting-derivatives-from-implicit-functions-with-autograd/">previously worked out</a> how to get these derivatives from an implicit function using autograd. We just need to loop through the arguments, get the relevant derivatives, and accumulate the product of the squared derivatives and errors. Finally, take the square root of that sum.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> autograd.numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">these are the uncertainties on the inputs</span>
<span style="color: #BA36A5;">s</span> = [<span style="color: #D0372D;">None</span>, 0.1, 0.2, 0.05, 100]

<span style="color: #BA36A5;">S2</span> = 0.0

<span style="color: #BA36A5;">dfdCa</span> = grad(func, 0)
<span style="color: #0000FF;">for</span> i <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">range</span>(1, 5):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dfdarg2</span> = grad(func, i)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">dCadarg2</span> = -dfdarg2(Ca, v0, k, Fa0, V) / dfdCa(Ca, v0, k, Fa0, V)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">S2</span> += dCadarg2**2 * s[i]**2

<span style="color: #BA36A5;">Ca_s</span> = np.sqrt(S2)
<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'Ca = {Ca:1.5f} +\- {Ca_s}'</span>)
</pre>
</div>

<pre class="example">
Ca = 0.00500 +\- 0.00016776432898276802


</pre>

<p>
That is the same uncertainty estimate the quantities package provided. One benefit here is I did not have to do the somewhat complicated wrapping procedure around fsolve that was required with uncertainties to get this. On the other hand, I did have to derive the formula and implement them. It worked fine here, since we have an implicit function and a way to get the required derivatives. It could take some work to do this with the exit concentration of a PFR, which requires an integrator. Maybe that <a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis/">differentiable integrator</a> will come in handy again!
</p>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/11/05/Using-autograd-for-error-propagation.org">org-mode source</a></p>
<p>Org-mode version = 9.1.14</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2018/11/05/Using-autograd-for-error-propagation">Discuss on Twitter</a>

  <hr class="interblog" />
 <a href="/blog/category/autograd/2">Next Page Â»</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2025/07/31/New-publication-Mapping-uncertainty-using-differentiable-programming/">New publication - Mapping uncertainty using differentiable programming</a></li>
      <li><a href="/blog/2025/07/17/New-publication-Spin-informed-universal-graph-neural-networks-for-simulating-magnetic-ordering/">New publication - Spin-informed universal graph neural networks for simulating magnetic ordering</a></li>
      <li><a href="/blog/2025/07/09/New-publication-Hyperplane-decision-trees-as-piecewise-linear-surrogate-models-for-chemical-process-design/">New publication - Hyperplane decision trees as piecewise linear surrogate models for chemical process design</a></li>
      <li><a href="/blog/2025/06/22/Lies-damn-lies-statistics-and-Bayesian-statistics/">Lies, damn lies, statistics and Bayesian statistics</a></li>
      <li><a href="/blog/2025/06/17/New-Publication-Solving-an-inverse-problem-with-generative-models/">New Publication - Solving an inverse problem with generative models</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2025
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
 
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PH8NF4F0RE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PH8NF4F0RE');
</script>


  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



