<?xml version="1.0" encoding="UTF-8"?>

<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
  >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2024-06-08T17:43:32Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog" />
  <id>https://kitchingroup.cheme.cmu.edu/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="https://kitchingroup.cheme.cmu.edu/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[Indexing text in screenshots so they are searchable]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2015/07/24/Indexing-text-in-screenshots-so-they-are-searchable" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2015/07/24/Indexing-text-in-screenshots-so-they-are-searchable</id>
    <updated>2015-07-24T07:43:08Z</updated>
    <published>2015-07-24T07:43:08Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="image" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="search" />
    <summary type="html"><![CDATA[Indexing text in screenshots so they are searchable]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2015/07/24/Indexing-text-in-screenshots-so-they-are-searchable"><![CDATA[



&lt;p&gt;
I had an interesting conversation with someone yesterday about using screenshots to document a process. This has an appeal of simplicity, since it is agnostic to the process, but I wondered about the long-term utility. If the documentation is valuable, you would like to search it in the future, and we so far have limited capability to search images. But, if there is important text in the image, we might be able to recognize the text, and use it to index the images. Then they would become searchable at least for the text in the image. Don't get me wrong, it would be better if we could store that text directly, but suppose that just isn't possible, maybe because it is all stored in some kind of gui, or it is locked up in proprietary software. Here we explore the potential utility of this. We only explore getting text out of images here, not the actual indexing part. See this &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/07/06/Indexing-headlines-in-org-files-with-swish-e-with-laser-sharp-results/"&gt;post&lt;/a&gt; for how we could integrate this into an actual index and search tool.
&lt;/p&gt;

&lt;p&gt;
First we need an OCR engine. Tesseract&lt;a href="https://github.com/tesseract-ocr/tesseract"&gt; (tesseract-ocr/tesseract)&lt;/a&gt; is supposed to be pretty good, and it easily installs via brew:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;brew install tesseract
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(shell-command-to-string &lt;span style="color: #008000;"&gt;"tesseract -v"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
tesseract 3.02.02
 leptonica-1.72
  libjpeg 8d : libpng 1.6.17 : libtiff 4.0.3 : zlib 1.2.5
&lt;/pre&gt;

&lt;p&gt;
We will test it on some screenshots taken with the default settings on my Mac. Here is an example. This example has text in color boxes, and some shadowing on the left side because another window was near it and that is some OS effect.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2015-07-24-Indexing-text-in-screenshots-so-they-are-searchable/date-23-07-2015-time-19-56-52.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
And here is the simplest text extraction.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;tesseract ./screenshots/date-23-07-2015-time-19-56-52.png test
cat test.txt
rm test.txt
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
M. ~ an an. -.2... nuIunIrv- I.nd=d¢wn, a.....=.-p. u|u.=u_x. van" bar imam-

smm-ry ~ nu... ma, Camilla man Qu-In lui. Sdlwnu u._-. /-x/mu



master node q)l9amesh.chemc.cmn.edn up 9: days, mas, n nsersv

cutﬂmltc nude: men): :1

bpxoc node sum 17 dmln , o.1s,u.:n up
cuxque node state: n17 dawn

tuxqng jobs: 207 max, m2 nmmnq. as queued
aggregate laud: 799.55
&lt;/pre&gt;

&lt;p&gt;
That is not too good. I am skeptical it would be useful for anything. This &lt;a href="http://vbridge.co.uk/2012/11/05/how-we-tuned-tesseract-to-perform-as-well-as-a-commercial-ocr-package/"&gt;page&lt;/a&gt; suggests improvements can be made with image clean up, but that image is pretty clear to me. There is a little shadow on the left side, but otherwise it is very readable to me. Let us try doubling the size of the image. Maybe that will help. Imagemagick lets us resize the image pretty easily.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;convert -resize 200% ./screenshots/date-23-07-2015-time-19-56-52.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
- 2D Node status summary. Rnd=down, Groun=up, BIu¢=boot. Vdlow bur indium --



Summlry - Hnﬂnr Mods, Compuh Nodu, Quuue, Land, Soﬁwan Ric:-as, /dzc/maul

master node gilqnmesh.cheme.cmu.edu up 91 days, 10:45, 11 users, .'

compute nodes total: 31

bproc node state: 17 down , 0-16,18-30 up
torque node state: n17 down

torque jobs: 207 total, 102 running, 88 queued
aggregate load: 799.55
&lt;/pre&gt;


&lt;p&gt;
That is a very remarkable improvement! This looks very useful, and could even be used for indexing. Interestingly, the white text on colored backgrounds does not do as well. That could be important to remember in designing the GUI front end if you have any say in it.  Let's try a few others.
&lt;/p&gt;



&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2015-07-24-Indexing-text-in-screenshots-so-they-are-searchable/date-23-07-2015-time-20-01-43.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;convert -resize 200% ./screenshots/date-23-07-2015-time-20-01-43.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Fllbn V Q I-"Ind a repository...

tesseract
Tesseract Open Source OCR Enghe (main repository)
Updated 43 minutes ago
&lt;/pre&gt;

&lt;p&gt;
That is also pretty good. Again, the text on colored backgrounds is less good than that on a white background. And one more from Twitter.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2015-07-24-Indexing-text-in-screenshots-so-they-are-searchable/date-23-07-2015-time-20-05-59.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;convert -resize 200% ./screenshots/date-23-07-2015-time-20-05-59.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
chEnected AIchE .-.ChEnected - 5h
C h E AlChE Academy: Take AlChE‘s Pneumatic Conveying 0! Bulk Solids Course and
learn practical design principles. r1m.ag/|IJcN
&lt;/pre&gt;

&lt;p&gt;
Overall pretty good. I am pretty convinced that the right screenshots could be an easy way to document some processes conveniently and that they could be searched in the future. Some testing would need to be done on how to do the OCR, and it does not appear that one recipe will work for all images.
&lt;/p&gt;

&lt;p&gt;
Nevertheless, a program could pretty easily be developed to index a directory of screenshots, do the OCR on each image, and index the resulting text so it can be searched. It is even conceivable that several indexes could be made using different OCR methods that might work better for different types of images. Another improvement would be if some metadata could be associated with the screenshot including what instrument it is a shot of, who took it, etc&amp;#x2026; This starts to move in a direction that requires dedicated screenshot tools, and away from the simplicity of the PrintScreen button, but it adds value to the data that makes it easier to find later.
&lt;/p&gt;

&lt;p&gt;
The beauty of the screenshot is that it is what you saw at the time, and it captures things as they were. It doesn't capture anything "behind the scenes" or off-screen of course, so there is certainly room to lose information this way. A careful analysis of what information is captured and what is lost would be important to assess the long-term value of capturing the process this way as opposed to any other way. There certainly is a balance of how much effort it takes to capture it and the value of the information in the future, and cost to rerun it if it isn't found in the future.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/07/24/Indexing-text-in-screenshots-so-they-are-searchable.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[An xml representation of an org document for indexing with swish-e]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2015/07/04/An-xml-representation-of-an-org-document-for-indexing-with-swish-e" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2015/07/04/An-xml-representation-of-an-org-document-for-indexing-with-swish-e</id>
    <updated>2015-07-04T19:34:22Z</updated>
    <published>2015-07-04T11:49:23Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="search" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="emacs" />
    <summary type="html"><![CDATA[An xml representation of an org document for indexing with swish-e]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2015/07/04/An-xml-representation-of-an-org-document-for-indexing-with-swish-e"><![CDATA[



&lt;p&gt;
Swish-e can index xml data, and enable searching by tag. Here we push our org-mode indexing idea a little further. Initially we indexed org files as text. Then, we exported it to html, and indexed the html. That enabled some richer searching. Now, we will create an xml representation of the org file for indexing. This will enable us to use a custom tag system and search for specific text in tables, or src-blocks, or in headlines, or for headlines with certain tags, todo state or properties.
&lt;/p&gt;

&lt;p&gt;
Incidentally, this is a general strategy for indexing arbitrary files. You just make an xml representation of the file containing the data to be indexed, and use swish-e to index that xml.
&lt;/p&gt;

&lt;p&gt;
Let us start with code to generate xml. I adapted this from some code in &lt;a href="http://landoflisp.com"&gt;Land Of Lisp&lt;/a&gt; . First, a function that simply prints a tag with attributes.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;print-tag&lt;/span&gt; (name attrs &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; closingp)
  &lt;span style="color: #036A07;"&gt;"Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;if CLOSINGP print the closing tag instead."&lt;/span&gt;
  (format
   &lt;span style="color: #008000;"&gt;"&amp;lt;%s%s%s&amp;gt;"&lt;/span&gt;
   (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; closingp &lt;span style="color: #008000;"&gt;"/"&lt;/span&gt; &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
   name
   (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; attrs (not closingp))
       (concat
        &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;
        (mapconcat
         (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
           (format &lt;span style="color: #008000;"&gt;"%s=\"%s\""&lt;/span&gt;
                   (car x)
                   (xml-escape-string (cdr x))))
         attrs
         &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;))
     &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)))

(print-tag 'html '((color . &lt;span style="color: #008000;"&gt;"blue"&lt;/span&gt;) (label . &lt;span style="color: #008000;"&gt;"test"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;html color="blue" label="test"&amp;gt;
&lt;/pre&gt;

&lt;p&gt;
XML tags almost always come in pairs. We define a macro to make this happen here. The macro prints the opening tag, evaluates the body, and prints the closing body. Note that the body may contain other tags, or a string. The string should be escaped to avoid illegal xml characters.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;tag&lt;/span&gt; (name attributes &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  `(format &lt;span style="color: #008000;"&gt;"%s%s%s"&lt;/span&gt;
           (print-tag ,name ,attributes nil)
           (concat
           ,@body)
           (print-tag ,name nil t)))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;example usage&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; &lt;span style="color: #008000;"&gt;"xml"&lt;/span&gt; '((test . &lt;span style="color: #008000;"&gt;"id"&lt;/span&gt;))
     (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; &lt;span style="color: #008000;"&gt;"body"&lt;/span&gt; nil
          (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; &lt;span style="color: #008000;"&gt;"p"&lt;/span&gt; nil (xml-escape-string &lt;span style="color: #008000;"&gt;"paragraph &amp;amp; &amp;lt; 1"&lt;/span&gt;))
          (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; &lt;span style="color: #008000;"&gt;"p"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;"paragraph 2"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;xml test="id"&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;paragraph &amp;amp;amp; &amp;amp;lt; 1&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;paragraph 2&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/xml&amp;gt;
&lt;/pre&gt;

&lt;p&gt;
Now, we can use this to get an xml representation of the source blocks, e.g.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(mapconcat 'identity
           (org-element-map
               (org-element-parse-buffer)
               'src-block
             (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (element)
               (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt;
                'src-block
                `((language . ,(org-element-property &lt;span style="color: #006FE0;"&gt;:language&lt;/span&gt; element)))
                (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'contents ()
                     (xml-escape-string
                      (org-element-property &lt;span style="color: #006FE0;"&gt;:value&lt;/span&gt; element))))))
           &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;src-block language="emacs-lisp"&amp;gt;&amp;lt;contents&amp;gt;(defun print-tag (name attrs &amp;amp;amp;optional closingp)
  &amp;amp;quot;Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead.&amp;amp;quot;
  (format
   &amp;amp;quot;&amp;amp;lt;%s%s%s&amp;amp;gt;&amp;amp;quot;
   (if closingp &amp;amp;quot;/&amp;amp;quot; &amp;amp;quot;&amp;amp;quot;)
   name
   (if (and attrs (not closingp))
       (concat
	&amp;amp;quot; &amp;amp;quot;
	(mapconcat
	 (lambda (x)
	   (format &amp;amp;quot;%s=\&amp;amp;quot;%s\&amp;amp;quot;&amp;amp;quot;
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 &amp;amp;quot; &amp;amp;quot;))
     &amp;amp;quot;&amp;amp;quot;)))

(print-tag &amp;amp;apos;html &amp;amp;apos;((color . &amp;amp;quot;blue&amp;amp;quot;) (label . &amp;amp;quot;test&amp;amp;quot;)))
&amp;lt;/contents&amp;gt;&amp;lt;/src-block&amp;gt;&amp;lt;src-block language="emacs-lisp"&amp;gt;&amp;lt;contents&amp;gt;(defmacro tag (name attributes &amp;amp;amp;rest body)
  `(format &amp;amp;quot;%s%s%s&amp;amp;quot;
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

(tag &amp;amp;quot;xml&amp;amp;quot; &amp;amp;apos;((test . &amp;amp;quot;id&amp;amp;quot;))
     (tag &amp;amp;quot;body&amp;amp;quot; nil
	  (tag &amp;amp;quot;p&amp;amp;quot; nil (xml-escape-string &amp;amp;quot;paragraph &amp;amp;amp; &amp;amp;lt; 1&amp;amp;quot;))
	  (tag &amp;amp;quot;p&amp;amp;quot; nil &amp;amp;quot;paragraph 2&amp;amp;quot;)))
&amp;lt;/contents&amp;gt;&amp;lt;/src-block&amp;gt;&amp;lt;src-block language="emacs-lisp"&amp;gt;&amp;lt;contents&amp;gt;(mapconcat &amp;amp;apos;identity
	   (org-element-map
	       (org-element-parse-buffer)
	       &amp;amp;apos;src-block
	     (lambda (element)
	       (tag
		&amp;amp;apos;src-block
		`((language . ,(org-element-property :language element)))
		(tag &amp;amp;apos;contents ()
		     (xml-escape-string
		      (org-element-property :value element))))))
	   &amp;amp;quot;&amp;amp;quot;)
&amp;lt;/contents&amp;gt;&amp;lt;/src-block&amp;gt;&amp;lt;src-block language="emacs-lisp"&amp;gt;&amp;lt;contents&amp;gt;(let ((xml (tag &amp;amp;apos;root `((filename . ,(buffer-file-name))
			(indexed-on . ,(current-time-string)))
		;; map the headlines
		(mapconcat
		 &amp;amp;apos;identity
		 (org-map-entries
		  (lambda ()
		    (let* ((tags (org-get-tags))
			   (heading-components (org-heading-components))
			   (title (nth 4 heading-components))
			   (level (nth 0 heading-components))
			   (properties (org-entry-properties))
			   (elem (org-element-at-point))
			   (bp (org-element-property :contents-begin elem))
			   (ep (org-element-property :contents-end elem))
			   (content (buffer-substring bp ep)))
		      (tag &amp;amp;apos;heading `((level . ,level))
			   (tag &amp;amp;apos;title () (xml-escape-string title))
			   (tag &amp;amp;apos;tags () (mapconcat &amp;amp;apos;identity tags &amp;amp;quot; &amp;amp;quot;))
			   (tag &amp;amp;apos;properties ()
				(mapconcat
				 (lambda (x)
				   (tag &amp;amp;apos;property `((label . (car ,x))) (cdr x)))
				 properties
				 &amp;amp;quot;&amp;amp;quot;))
			   (tag &amp;amp;apos;content ()
				(format &amp;amp;quot;%s&amp;amp;quot; (xml-escape-string content)))))))
		 &amp;amp;quot;&amp;amp;quot;)

		;; map specific element types
		(tag &amp;amp;apos;source-blocks ()
		     (mapconcat
		      &amp;amp;apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &amp;amp;apos;src-block
			(lambda (element)
			  (tag &amp;amp;apos;src-block
			       `((language .
					   ,(org-element-property
					     :language element)))
			       (tag &amp;amp;apos;contents ()
				    (xml-escape-string
				     (org-element-property :value element)))))) &amp;amp;quot;&amp;amp;quot;))

		(tag &amp;amp;apos;tables ()
		     (mapconcat
		      &amp;amp;apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &amp;amp;apos;table
			(lambda (element)
			  (tag &amp;amp;apos;table ()
			       (when (org-element-property :caption element)
				 (tag &amp;amp;apos;caption ()
				(caaar (org-element-property :caption element))))
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &amp;amp;quot;&amp;amp;quot;))

		(tag &amp;amp;apos;paragraphs ()
		     (mapconcat
		      &amp;amp;apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &amp;amp;apos;paragraph
			(lambda (element)
			  (tag &amp;amp;apos;paragraph ()
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &amp;amp;quot;&amp;amp;quot;
		      ))
		)))
  (with-temp-file &amp;amp;quot;org2xml.xml&amp;amp;quot;
    (insert xml)))
&amp;lt;/contents&amp;gt;&amp;lt;/src-block&amp;gt;&amp;lt;src-block language="emacs-lisp"&amp;gt;&amp;lt;contents&amp;gt;(xml-parse-file &amp;amp;quot;org2xml.xml&amp;amp;quot;)
&amp;lt;/contents&amp;gt;&amp;lt;/src-block&amp;gt;
&lt;/pre&gt;

&lt;p&gt;
So, finally we can map the entries to get some information about them, e.g. the tags, properties, todo state, etc&amp;#x2026; Then we create xml representing all that information so we can have a more precise search. Instead of looking for a word, we can specify that the word be in a property for example. Then, we make xml representations of the tables, src-blocks and paragraphs.
&lt;/p&gt;

&lt;p&gt;
I am going to follow the example &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html/"&gt;here&lt;/a&gt; that we worked out before on html and create a filter function that takes an org-file and spits out xml at the command line.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;:&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;exec emacs -batch -l $0 -f main "$@"&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;org&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;xml&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;print-tag&lt;/span&gt; (name attrs &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; closingp)
  &lt;span style="color: #036A07;"&gt;"Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;if CLOSINGP print the closing tag instead.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;You should use `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;xml-escape-string&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' on text going into the attributes to avoid errors."&lt;/span&gt;
  (format
   &lt;span style="color: #008000;"&gt;"&amp;lt;%s%s%s&amp;gt;"&lt;/span&gt;
   (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; closingp &lt;span style="color: #008000;"&gt;"/"&lt;/span&gt; &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
   name
   (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; attrs (not closingp))
       (concat
        &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;
        (mapconcat
         (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
           (format &lt;span style="color: #008000;"&gt;"%s=\"%s\""&lt;/span&gt; (car x) (cdr x)))
           attrs
           &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;))
     &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;tag&lt;/span&gt; (name attributes &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  `(format &lt;span style="color: #008000;"&gt;"%s%s%s"&lt;/span&gt;
           (print-tag ,name ,attributes nil)
           (concat
           ,@body)
           (print-tag ,name nil t)))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;main&lt;/span&gt; ()
  (find-file (car command-line-args-left))
  (princ (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'root `((filename . ,(buffer-file-name))
                      (indexed-on . ,(current-time-string)))
              &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;map the headlines&lt;/span&gt;
              (mapconcat
               'identity
               (org-map-entries
                (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ()
                  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((tags (org-get-tags))
                         (heading-components (org-heading-components))
                         (todo (nth 2 heading-components))
                         (headline (nth 4 heading-components))
                         (thislevel (nth 0 heading-components))
                         (properties (org-entry-properties)))
                    (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'heading `((level . ,thislevel))
                         (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'headline () (xml-escape-string headline))
                         (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'tags () (mapconcat 'identity tags &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;))
                         (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; todo
                           (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'todo () todo))
                         (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'properties ()
                              (mapconcat
                               (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                                 (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'property `((name . ,(xml-escape-string (car x))))
                                      (xml-escape-string (cdr x))))
                               properties
                               &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))))))
               &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)

              &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;get file keywords, TITLE, authors, etc...&lt;/span&gt;
              (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'file-keywords ()
                   (mapconcat 'identity
                              (org-element-map (org-element-parse-buffer 'element) 'keyword
                                (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (keyword)
                                  (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; (xml-escape-string (org-element-property &lt;span style="color: #006FE0;"&gt;:key&lt;/span&gt; keyword)) ()
                                       (xml-escape-string (org-element-property &lt;span style="color: #006FE0;"&gt;:value&lt;/span&gt; keyword)))))
                              &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))

              &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;map specific element types&lt;/span&gt;
              (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'source-blocks ()
                   (mapconcat
                    'identity
                    (org-element-map
                        (org-element-parse-buffer)
                        'src-block
                      (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (element)
                        (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'src-block
                             `((language .
                                         ,(org-element-property
                                           &lt;span style="color: #006FE0;"&gt;:language&lt;/span&gt; element)))
                             (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'contents ()
                                  (xml-escape-string
                                   (org-element-property &lt;span style="color: #006FE0;"&gt;:value&lt;/span&gt; element)))))) &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))

              (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'tables ()
                   (mapconcat
                    'identity
                    (org-element-map
                        (org-element-parse-buffer)
                        'table
                      (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (element)
                        (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'table ()
                             (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (org-element-property &lt;span style="color: #006FE0;"&gt;:caption&lt;/span&gt; element)
                               (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'caption ()
                                    (format
                                     &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt;
                                     (org-element-property
                                      &lt;span style="color: #006FE0;"&gt;:caption&lt;/span&gt; element))))
                             (xml-escape-string
                              (buffer-substring
                               (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-begin&lt;/span&gt; element)
                               (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-end&lt;/span&gt; element))))))
                    &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))

              (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'paragraphs ()
                   (mapconcat
                    'identity
                    (org-element-map
                        (org-element-parse-buffer)
                        'paragraph
                      (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (element)
                        (&lt;span style="color: #0000FF;"&gt;tag&lt;/span&gt; 'paragraph ()
                             (xml-escape-string
                              (buffer-substring
                               (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-begin&lt;/span&gt; element)
                               (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-end&lt;/span&gt; element))))))
                    &lt;span style="color: #008000;"&gt;""&lt;/span&gt;
                    )))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We could do more, e.g. links, or images, but this is pretty good for now. Now, let's configure a swish indexer. We instruct swish-e to use some metanames, and attributes so we can search on them later.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-text"&gt;# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com/_site

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org2xml.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the HTML parser.
IndexContents XML* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/org2xml.el

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And now, run the index command. I did this at the command line. There might be some problems with the script as there were some warnings about non-zero exits, but there was only a few so we ignore them for now.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -c swish-org2xml.conf
&lt;/pre&gt;
&lt;/div&gt;


&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Examples of searching for org-files&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;&lt;div id="outline-container-sec-1-1" class="outline-3"&gt;
&lt;h3 id="sec-1-1"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; Files with words in the filename&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
Here we look for filenames with the word "Extracting" in them.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w root.filename=Extracting
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: root.filename=Extracting
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/19/Extracting-bibtex-file-from-an-org-buffer.org "Extracting-bibtex-file-from-an-org-buffer.org" 6094
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
.
&lt;/pre&gt;

&lt;p&gt;
Or, thanks to the date being in the path, we can find by year, How about July of 2012?
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w root.filename=&lt;span style="color: #008000;"&gt;"(2012/07)"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: root.filename=(2012/07)
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2012/07/15/Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org "Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org" 311
.
&lt;/pre&gt;

&lt;p&gt;
Interesting we have to use the parentheses here.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-2" class="outline-3"&gt;
&lt;h3 id="sec-1-2"&gt;&lt;span class="section-number-3"&gt;1.2&lt;/span&gt; &lt;span class="done DONE"&gt;DONE&lt;/span&gt; Files with headlines containing a word&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
Now, lets find documents with "Compiled" in a heading title with level=2
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w heading.level=2 &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt;=Compiled -m5
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: heading.level=2 title=Compiled
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-3" class="outline-3"&gt;
&lt;h3 id="sec-1-3"&gt;&lt;span class="section-number-3"&gt;1.3&lt;/span&gt; Headlines marked TODO&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
We can find documents with headlines marked TODO:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e  -w &lt;span style="color: #008000;"&gt;"todo=TODO"&lt;/span&gt; -m 5
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: todo=TODO
# Removed stopwords:
# Number of hits: 12
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-01-27-Clocking-your-time-in-org-mode/blog.org "blog.org" 134160
624 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/A-dynamic-snippet-for-a-task-due-7-days-from-now.org "A-dynamic-snippet-for-a-task-due-7-days-from-now.org" 2587
425 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/END.org "END.org" 1531
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/02/01/Handling-multiple-selections-in-helm.org "Handling-multiple-selections-in-helm.org" 3290
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/01/30/More-adventures-in-helm---more-than-one-action.org "More-adventures-in-helm---more-than-one-action.org" 3236
.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-4" class="outline-3"&gt;
&lt;h3 id="sec-1-4"&gt;&lt;span class="section-number-3"&gt;1.4&lt;/span&gt; For a table&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;p&gt;
so2-capacity-1
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w &lt;span style="color: #BA36A5;"&gt;table&lt;/span&gt;=&lt;span style="color: #008000;"&gt;"energy"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: table=energy
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
633 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/07/04/Estimating-uncertainties-in-equations-of-state.org "Estimating-uncertainties-in-equations-of-state.org" 3117
.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-5" class="outline-3"&gt;
&lt;h3 id="sec-1-5"&gt;&lt;span class="section-number-3"&gt;1.5&lt;/span&gt; Tagged headlines&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-5"&gt;
&lt;p&gt;
Find entries with a "slide" tag.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w &lt;span style="color: #008000;"&gt;"tags=slide"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: tags=slide
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
.
&lt;/pre&gt;

&lt;p&gt;
Evidently there is one file where I talk about slides in org-show.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-6" class="outline-3"&gt;
&lt;h3 id="sec-1-6"&gt;&lt;span class="section-number-3"&gt;1.6&lt;/span&gt; Headlines with a property&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-6"&gt;
&lt;p&gt;
Here I find documents with headlines that have thermodynamics in the property "categories".
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w &lt;span style="color: #008000;"&gt;"property.label=categories property=thermodynamics"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: property.label=categories property=thermodynamics
# Removed stopwords:
# Number of hits: 10
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/01/Water-gas-shift-equilibria-via-the-NIST-Webbook.org "Water-gas-shift-equilibria-via-the-NIST-Webbook.org" 10789
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook.org "Gibbs-energy-minimization-and-the-NIST-webbook.org" 5441
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org "Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org" 6155
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/27/Reading-parameter-database-text-files-in-python.org "Reading-parameter-database-text-files-in-python.org" 3947
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org "The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org" 8230
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture.org "Calculating-a-bubble-point-pressure-of-a-mixture.org" 3203
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/15/The-equal-area-method-for-the-van-der-Waals-equation.org "The-equal-area-method-for-the-van-der-Waals-equation.org" 5737
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org "Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org" 5210
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions.org "Constrained-minimization-to-find-equilibrium-compositions.org" 5666
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/09/23/Generating-an-atomic-stoichiometric-matrix.org "Generating-an-atomic-stoichiometric-matrix.org" 3487
.
&lt;/pre&gt;

&lt;p&gt;
That seems about right, according to &lt;a href="http://kitchingroup.cheme.cmu.edu/categories.html"&gt;http://kitchingroup.cheme.cmu.edu/categories.html&lt;/a&gt; there are 9 documents. I am not sure why they don't totally agree, but I can live with it.
&lt;/p&gt;

&lt;p&gt;
Here are documents containing headlines with the property "TOTAL_ENERGY"
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w property.label=TOTAL_ENERGY
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: property.label=TOTAL_ENERGY
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-7" class="outline-3"&gt;
&lt;h3 id="sec-1-7"&gt;&lt;span class="section-number-3"&gt;1.7&lt;/span&gt; Documents with a Python source block containing a word&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-7"&gt;
&lt;p&gt;
Find org files with diffusion in a python source block.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w src-block.language=python -w src-block=diffusion
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: src-block.language=python src-block=diffusion
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.011 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/04/02/Transient-diffusion---partial-differential-equations.org "Transient-diffusion---partial-differential-equations.org" 3660
.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-1-8" class="outline-3"&gt;
&lt;h3 id="sec-1-8"&gt;&lt;span class="section-number-3"&gt;1.8&lt;/span&gt; An org-file with a UUID&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-8"&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w  &lt;span style="color: #BA36A5;"&gt;property&lt;/span&gt;=&lt;span style="color: #008000;"&gt;"(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: property=(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/11/23/Machine-gradable-quizzes-in-emacs+org-modex.org "Machine-gradable-quizzes-in-emacs+org-modex.org" 5743
.
&lt;/pre&gt;

&lt;p&gt;
Interesting, again the parentheses are necessary to find a match. I think because of the dashes. The next example is similar, but finds an entry with that bibtex key in a CUSTOM_ID property.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index-org2xml.swish-e -w  &lt;span style="color: #BA36A5;"&gt;property&lt;/span&gt;=&lt;span style="color: #008000;"&gt;"(mantina-2008-first-princ)"&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: property=(mantina-2008-first-princ)
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.010 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
.
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
This is pretty cool. There are still some bugs to work out in the indexing filter I think, but this demonstrates you can index org-files, and have pretty refined searches to find your files. There is still some thinking to do on how to schedule an incremental indexing, and whether we need more or better metanames. The indexing is not fast, but that is probably because I am running this through a FileFilter, rather than the -s prog option in swish-e. This is super promising to me though. Imagine building an agenda from files found with TODO headlines in them; a global todo list! Or, grabbing contacts from wherever they are.  No more losing files you have not used in a while. Find all documents containing a citation. With some extra work, you could index links, citations, &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/07/02/Pyparsing-meets-Emacs-to-find-chemical-formulas/"&gt;chemical formulas&lt;/a&gt; , or other types of identifiable content.
&lt;/p&gt;

&lt;p&gt;
The logical conclusion of this work might be an ox-swish-e-xml export engine to render the org-file into xml, rather than the script I used here. It would be really great to get some refined output, e.g. rather than just get matching documents, get location information so you could open the document to the matching element. That might be out of reach for swish-e, but could be in reach for other programs like Sphinx that are more integrated with a database. There is a very interesting project here: &lt;a href="https://github.com/wvxvw/sphinx-mode"&gt;https://github.com/wvxvw/sphinx-mode&lt;/a&gt; to integrate org-mode with the Sphinx search (&lt;a href="http://sphinxsearch.com"&gt;http://sphinxsearch.com&lt;/a&gt; ) engine.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/07/04/An-xml-representation-of-an-org-document-for-indexing-with-swish-e.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[Using swish-e to index org files as html]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html</id>
    <updated>2015-07-03T10:13:11Z</updated>
    <published>2015-07-03T10:13:11Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="search" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="emacs" />
    <summary type="html"><![CDATA[Using swish-e to index org files as html]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html"><![CDATA[



&lt;p&gt;
When we wrote about using swish-e &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/25/Integrating-swish-e-and-Emacs/"&gt;before&lt;/a&gt; , we just indexed the org files as text. This worked pretty well, but we lost some resolution, e.g. being able to search for text in a headline. that is more possible if we index html or xml. So, here we try indexing the org files as html. It will be slower to index because we will filter each org file through a command that exports it to html, but hopefully it will be worth it for the enhanced search capability.
&lt;/p&gt;

&lt;p&gt;
We will need a filter shell command that takes an org-file and spits out html. This command is shown as an &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2014/08/06/Writing-scripts-in-Emacs-lisp/"&gt;emacs-lisp script&lt;/a&gt; here. This is a pretty bare bones export, and would lack the export of all my custom links from org-ref. I tried this, but org-ref outputs a lot of stuff to stdout when it loads, and unless I can figure out how to suppress that I don't want it here for now.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;:&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;exec emacs -batch -l $0 -f main "$@"&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;org&lt;/span&gt;)
&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(add-to-list 'load-path "/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa")&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(add-to-list 'load-path "/Users/jkitchin/Dropbox/kitchingroup/jmax/org-ref")&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(setq package-user-dir "/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa")&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(package-initialize)&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(require 'org-ref)&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;main&lt;/span&gt; ()
  (find-file (car command-line-args-left))
  (org-html-export-as-html nil nil nil t)
  (switch-to-buffer &lt;span style="color: #008000;"&gt;"*Org HTML Export*"&lt;/span&gt;)
  (print (buffer-string)))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Local Variables&amp;#58;&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;mode: emacs-lisp&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;End:&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We try it out here:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;./org2html.el index-org-as-html.org
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
"&amp;lt;div id=\"table-of-contents\"&amp;gt;
&amp;lt;h2&amp;gt;Table of Contents&amp;lt;/h2&amp;gt;
&amp;lt;div id=\"text-table-of-contents\"&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;a href=\"#sec-1\"&amp;gt;1. Using swish-e to index org files as html&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=\"outline-container-sec-1\" class=\"outline-2\"&amp;gt;
&amp;lt;h2 id=\"sec-1\"&amp;gt;&amp;lt;span class=\"section-number-2\"&amp;gt;1&amp;lt;/span&amp;gt; Using swish-e to index org files as html&amp;lt;/h2&amp;gt;
&amp;lt;div class=\"outline-text-2\" id=\"text-1\"&amp;gt;
&amp;lt;p&amp;gt;
When we wrote about using swish-e &amp;lt;a href=\"http://kitchingroup.cheme.cmu.edu/blog/2015/06/25/Integrating-swish-e-and-Emacs/\"&amp;gt;before&amp;lt;/a&amp;gt;, we just indexed the org files as text. This worked pretty well, but we lost some resolution, e.g. being able to search for text in a headline. that is more possible if we index html or xml. So, here we try indexing the org files as html. It will be slower to index because we will filter each org file through a command that exports it to html, but hopefully it will be worth it for the enhanced search capability.
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
We will need a filter shell command that takes an org-file and spits out html. This command is shown as an emacs-lisp script here. This is a pretty bare bones export, and would lack the export of all my custom links
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
cite:dauenhauer-2006-renew
&amp;lt;/p&amp;gt;

&amp;lt;div class=\"org-src-container\"&amp;gt;

&amp;lt;pre class=\"src src-emacs-lisp\"&amp;gt;:;exec emacs -batch -l $0 -f main \"$@\"
(require 'org)
;(add-to-list 'load-path \"/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa\")
;(add-to-list 'load-path \"/Users/jkitchin/Dropbox/kitchingroup/jmax/org-ref\")
;(setq package-user-dir \"/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa\")
;(package-initialize)
;(require 'org-ref)
(defun main ()
  (find-file (car command-line-args-left))
  (org-html-export-as-html nil nil nil t)
  (switch-to-buffer \"*Org HTML Export*\")
  (print (buffer-string)))

;; Local Variables:
;; mode: emacs-lisp
;; End:
&amp;lt;/pre&amp;gt;
&amp;lt;/div&amp;gt;


&amp;lt;div class=\"org-src-container\"&amp;gt;

&amp;lt;pre class=\"src src-sh\"&amp;gt;./org2html.el index-org-as-html.org
&amp;lt;/pre&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;div class=\"org-src-container\"&amp;gt;

&amp;lt;pre class=\"src src-text\"&amp;gt;# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/org2html.el

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
&amp;lt;/pre&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
"
&lt;/pre&gt;


&lt;p&gt;
I think that looks good. Now, let's configure a swish indexer.
&lt;/p&gt;


&lt;div class="org-src-container"&gt;

&lt;pre class="src src-text"&gt;# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the HTML parser.
IndexContents HTML* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/org2html.el

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9

MetaNames class swishtitle
HTMLLinksMetaName links

PropertyNames author subjects

StoreDescription HTML &amp;lt;body&amp;gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And now, run the index command. I did this at the command line. A lot of output! mostly not being able to fontify source blocks because htmlize was not on the path, and a bunch of attribute parsing errors, and a few utf-8 errors.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -c swish-org-html.conf
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And a test search for files with "selector" in a headline.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index.swish-e -x &lt;span style="color: #008000;"&gt;'%r\t%p\n'&lt;/span&gt; -w selector -t h
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: selector
# Removed stopwords:
# Number of hits: 4
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000	/Users/jkitchin/blogofile-jkitchin.github.com/org/2015/03/14/A-helm-mu4e-contact-selector.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/03/14/A-helm-mu4e-contact-selector.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_deploy/org/2015/03/14/A-helm-mu4e-contact-selector.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org
.
&lt;/pre&gt;


&lt;p&gt;
A phrase in a headline.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index.swish-e -x &lt;span style="color: #008000;"&gt;'%r\t%p\n'&lt;/span&gt; -w &lt;span style="color: #008000;"&gt;"information for all documents"&lt;/span&gt; -t h
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: information for all documents
# Removed stopwords:
# Number of hits: 5
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org
921	/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org
794	/Users/jkitchin/blogofile-jkitchin.github.com/org/2015/04/03/Getting-data-from-the-Scopus-API.org
794	/Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/04/03/Getting-data-from-the-Scopus-API.org
794	/Users/jkitchin/blogofile-jkitchin.github.com/_deploy/org/2015/04/03/Getting-data-from-the-Scopus-API.org
.
&lt;/pre&gt;

&lt;p&gt;
Sweet. How about all documents containing this citation:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;swish-e -f index.swish-e -x &lt;span style="color: #008000;"&gt;'%r\t%p\n'&lt;/span&gt; -w cite:kitchin-2004-modif-pt
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
# SWISH format: 2.4.7
# Search words: cite:kitchin-2004-modif-pt
# Removed stopwords:
# Number of hits: 3
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	/Users/jkitchin/blogofile-jkitchin.github.com/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_deploy/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org
.
&lt;/pre&gt;

&lt;p&gt;
Super nice.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2015 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2015/07/03/Using-swish-e-to-index-org-files-as-html.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content>
  </entry>
</feed>
