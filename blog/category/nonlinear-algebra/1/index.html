

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: nonlinear algebra</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches"></div>
      <h2 class="blog_post_title"><a href="/blog/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches/" rel="bookmark" title="Permanent Link to Compressibility factor variation from the van der Waals equation by three different approaches">Compressibility factor variation from the van der Waals equation by three different approaches</a></h2>
      <p><small><span class="blog_post_date">Posted October 07, 2018 at 01:08 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a>, <a href='/blog/category/python/'>python</a>, <a href='/blog/category/autograd/'>autograd</a>, <a href='/blog/category/ode/'>ode</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated October 07, 2018 at 01:15 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org2fd7cfa">1. Method 1 - fsolve</a></li>
<li><a href="#org7ade82a">2. Method 2 - solve_ivp</a></li>
<li><a href="#orge63b16e">3. Method 3 - autograd + solve_ivp</a></li>
</ul>
</div>
</div>
<p>
In the book <span class="underline">Problem solving in chemical and biochemical engineering with POLYMATH, Excel and Matlab</span> by Cutlip and Shacham there is a problem (7.1) where you want to plot the compressibility factor for CO<sub>2</sub> over a range of \(0.1 \le P_r <= 10\) for a constant \(T_r=1.1\) using the van der Waal equation of state. There are a two standard ways to do this:
</p>

<ol class="org-ol">
<li>Solve a nonlinear equation for different values of \(P_r\).</li>
<li>Solve a nonlinear equation for one value of \(P_r\), then derive an ODE for how the compressibility varies with \(P_r\) and integrate it over the relevant range.</li>
</ol>

<p>
In this post, we compare and contrast the two methods, and consider a variation of the second method that uses automatic differentiation.
</p>

<div id="outline-container-org2fd7cfa" class="outline-2">
<h2 id="org2fd7cfa"><span class="section-number-2">1</span> Method 1 - fsolve</h2>
<div class="outline-text-2" id="text-1">
<p>
The van der Waal equation of state is:
</p>

<p>
\(P = \frac{R T}{V - b} - \frac{a}{V^2}\).
</p>

<p>
We define the reduced pressure as \(P_r = P / P_c\), and the reduced temperature as \(T_r = T / T_c\).
</p>

<p>
So, we simply solve for V at a given \(P_r\), and then compute \(Z\). There is a subtle trick needed to make this easy to solve, and that is to multiply each side of the equation by \((V - b)\) to avoid a singularity when \(V = b\), which happens in this case near \(P_r \approx 7.5\).
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
%matplotlib inline
<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #BA36A5;">R</span> = 0.08206
<span style="color: #BA36A5;">Pc</span> = 72.9
<span style="color: #BA36A5;">Tc</span> = 304.2

<span style="color: #BA36A5;">a</span> = 27 * R**2 * Tc**2 / (Pc * 64)
<span style="color: #BA36A5;">b</span> = R * Tc / (8 * Pc)

<span style="color: #BA36A5;">Tr</span> = 1.1

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(V, Pr):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">P</span> = Pr * Pc
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">T</span> = Tr * Tc
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> P * (V - b) - (R * T)  +  a / V**2 * (V - b)


<span style="color: #BA36A5;">Pr_range</span> = np.linspace(0.1, 10)
<span style="color: #BA36A5;">V</span> = [fsolve(objective, 3, args=(Pr,))[0] <span style="color: #0000FF;">for</span> Pr <span style="color: #0000FF;">in</span> Pr_range]

<span style="color: #BA36A5;">T</span> = Tr * Tc
<span style="color: #BA36A5;">P_range</span> = Pr_range * Pc
<span style="color: #BA36A5;">Z</span> = P_range * V / (R * T)

plt.plot(Pr_range, Z)
plt.xlabel(<span style="color: #008000;">'$P_r$'</span>)
plt.ylabel(<span style="color: #008000;">'Z'</span>)
plt.xlim([0, 10])
plt.ylim([0, 2])
</pre>
</div>

<pre class="example">
(0, 2)

</pre>



<p>
<img src="/media/13bc1d996aa4bd032faad00425793120-90490byl.png"> 
</p>

<p>
That looks like Figure 7-1 in the book. This approach is fine, but the equation did require a little algebraic finesse to solve, and you have to use some iteration to get the solution.
</p>
</div>
</div>

<div id="outline-container-org7ade82a" class="outline-2">
<h2 id="org7ade82a"><span class="section-number-2">2</span> Method 2 - solve_ivp</h2>
<div class="outline-text-2" id="text-2">
<p>
In this method, you have to derive an expression for \(\frac{dV}{dP_r}\). That derivation goes like this:
</p>

<p>
\(\frac{dV}{dP_r} = \frac{dV}{dP} \frac{dP}{dP_r}\)
</p>

<p>
The first term \(\frac{dV}{dP}\) is \((\frac{dP}{dV})^{-1}\), which we can derive directly from the van der Waal equation, and the second term is just a constant: \(P_c\) from the definition of \(P_r\).
</p>

<p>
They derived:
</p>

<p>
\(\frac{dP}{dV} = -\frac{R T}{(V - b)^2} + \frac{2 a}{V^3}\)
</p>

<p>
We need to solve for one V, at the beginning of the range of \(P_r\) we are interested in.
</p>

<div class="org-src-container">
<pre class="src src-ipython">V0, = fsolve(objective, 3, args=(0.1,))
V0
</pre>
</div>

<pre class="example">
3.6764763125625461

</pre>

<p>
Now, we can define the functions, and integrate them to get the same solution. I defined these pretty verbosely, just for readability.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> scipy.integrate <span style="color: #0000FF;">import</span> solve_ivp

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dPdV</span>(V):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> -R * T / (V - b)**2 + 2 * a / V**3

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dVdP</span>(V):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 1 / dPdV(V)

<span style="color: #BA36A5;">dPdPr</span> = Pc

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dVdPr</span>(Pr, V):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> dVdP(V) * dPdPr

<span style="color: #BA36A5;">Pr_span</span> = (0.1, 10)
<span style="color: #BA36A5;">Pr_eval</span>, <span style="color: #BA36A5;">h</span> = np.linspace(*Pr_span, retstep=<span style="color: #D0372D;">True</span>)

<span style="color: #BA36A5;">sol</span> = solve_ivp(dVdPr, Pr_span, (V0,), dense_output=<span style="color: #D0372D;">True</span>, max_step=h)

<span style="color: #BA36A5;">V</span> = sol.y[0]
<span style="color: #BA36A5;">P</span> = sol.t * Pc
<span style="color: #BA36A5;">Z</span> = P * V / (R * T)
plt.plot(sol.t, Z)
plt.xlabel(<span style="color: #008000;">'$P_r$'</span>)
plt.ylabel(<span style="color: #008000;">'Z'</span>)
plt.xlim([0, 10])
plt.ylim([0, 2])
</pre>
</div>

<pre class="example">
(0, 2)

</pre>



<p>
<img src="/media/13bc1d996aa4bd032faad00425793120-90490o8r.png"> 
</p>

<p>
This also looks like Figure 7-1. It is arguably a better approach since we only need an initial condition, and after that have a reliable integration (rather than many iterative solutions from an initial guess of the solution in fsolve).
</p>

<p>
The only downside to this approach (in my opinion) is the need to derive and implement derivatives. As equations of state get more complex, this gets more tedious and complicated.
</p>
</div>
</div>

<div id="outline-container-orge63b16e" class="outline-2">
<h2 id="orge63b16e"><span class="section-number-2">3</span> Method 3 - autograd + solve_ivp</h2>
<div class="outline-text-2" id="text-3">
<p>
The whole point of automatic differentiation is to get derivatives of functions that are written as programs. We explore here the possibility of using this to solve this problem. The idea is to use autograd to define the derivative \(dP/dV\), and then solve the ODE like we did before.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> autograd <span style="color: #0000FF;">import</span> grad

<span style="color: #0000FF;">def</span> <span style="color: #006699;">P</span>(V):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> R * T / (V - b) - a / V**2

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">autograd.grad returns a callable that acts like a function</span>
<span style="color: #BA36A5;">dPdV</span> = grad(P, 0)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">dVdPr</span>(Pr, V):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 1 / dPdV(V) * Pc

<span style="color: #BA36A5;">sol</span> = solve_ivp(dVdPr,  Pr_span, (V0,), dense_output=<span style="color: #D0372D;">True</span>, max_step=h)

V, = sol.y
<span style="color: #BA36A5;">P</span> = sol.t * Pc
<span style="color: #BA36A5;">Z</span> = P * V / (R * T)
plt.plot(sol.t, Z)
plt.xlabel(<span style="color: #008000;">'$P_r$'</span>)
plt.ylabel(<span style="color: #008000;">'Z'</span>)
plt.xlim([0, 10])
plt.ylim([0, 2])
</pre>
</div>

<pre class="example">
(0, 2)

</pre>



<p>
<img src="/media/13bc1d996aa4bd032faad00425793120-90490O2H.png"> 
</p>

<p>
Not surprisingly, this answer looks the same as the previous ones. I think this solution is pretty awesome. We only had to implement the van der Waal equation, and then let autograd do its job to get the relevant derivative. We don't get a free pass on calculus here; we still have to know which derivatives are important. We also need some knowledge about how to use autograd, but with that, this problem becomes pretty easy to solve.
</p>
</div>
</div>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches.org">org-mode source</a></p>
<p>Org-mode version = 9.1.13</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-nonlinear-algebra-problems-with-internal-state-information"></div>
      <h2 class="blog_post_title"><a href="/blog/2018/09/24/Solving-nonlinear-algebra-problems-with-internal-state-information/" rel="bookmark" title="Permanent Link to Solving nonlinear algebra problems with internal state information">Solving nonlinear algebra problems with internal state information</a></h2>
      <p><small><span class="blog_post_date">Posted September 24, 2018 at 03:25 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a>, <a href='/blog/category/python/'>python</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org532d5ce">1. First approach</a></li>
<li><a href="#orga01a4af">2. Second approach - use a state dictionary as an arg in the objective function</a></li>
<li><a href="#orgc590864">3. third approach - a callable object</a></li>
<li><a href="#orgaef298d">4. Summary</a></li>
</ul>
</div>
</div>
<p>
In engineering, we often need to solve an equation in one variable, and then use the solution to compute other variables. For example, we might want the bubble point temperature of a mixture, and then to determine the composition of the vapor phase that has formed. In other words, we compute the temperature, and then have to use it in a subsequent step to get the composition. Here is a bubble point computation adapted from example 10.2 in Smith and van Ness, Introduction to Chemical Engineering Thermodynamics.
</p>

<p>
Given a solution of acetone (x<sub>1</sub>=0.3), acetonitrile (x<sub>2</sub>=0.45) and nitromethane (x<sub>3</sub>=0.25) at a total pressure of 80 kPa, compute the bubble point temperature and gas phase composition.
</p>

<p>
The key here is to find a temperature where the gas-phase mole fractions sum to one. The gas phase mole fractions are defined by:
</p>

<p>
\(y_i = x_i Pvap_i(T) / P\)
</p>

<p>
The typical way I would teach students how solve this looks like this. It uses the Antoine equation coded below to estimate the vapor pressure of each component as a function of temperature, and then uses fsolve to find a temperature where the gas-phase mole fractions sum to one.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">acetone</span> = (14.5463, 2940.46, 237.22)
<span style="color: #BA36A5;">acetonitrile</span> = (14.2724, 2945.47,224)
<span style="color: #BA36A5;">nitromethane</span> = (14.2043, 2972.64, 209)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">antoine</span>(T, A, B, C):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">T</span> = <span style="color: #006FE0;">float</span>(T) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">there is some subtle issue that comes up when T is an array,</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">as passed in from fsolve. It needs to be a float, or you get</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the wrong answer.</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(A - B / (T + C))

<span style="color: #BA36A5;">x</span> = np.array([0.3, 0.45, 0.25])
<span style="color: #BA36A5;">P</span> = 80

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">Pvap</span> = np.array([antoine(T, *pars) <span style="color: #0000FF;">for</span> pars <span style="color: #0000FF;">in</span> [acetone, acetonitrile, nitromethane]])
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">y</span> = x * Pvap / P
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 1 - y.<span style="color: #006FE0;">sum</span>()

Tans, = fsolve(objective, 70)

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">This is where we end up repeating code</span>
<span style="color: #BA36A5;">Pvap</span> = np.array([antoine(Tans, *pars) <span style="color: #0000FF;">for</span> pars <span style="color: #0000FF;">in</span> [acetone, acetonitrile, nitromethane]])
<span style="color: #BA36A5;">y</span> = x * Pvap / P

<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The bubble point temperature is {Tans:1.2f} degC, and the gas phase compositions are {np.round(y, 4)}.'</span>)
</pre>
</div>

<pre class="example">
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].


</pre>

<p>
This solution works fine, but there is in my opinion, an issue with the small amount of repeated code at the end that is required to get the composition of the gas-phase. This is a small problem here, but as the problems get bigger it is more and more tedious to correctly repeat all the code to see what the state of a system is at the solution, and it seems wasteful to have to repeat the computations; they were known in the objective function. In the following subsections, I explore some alternative approaches to reduce the repetition.
</p>

<div id="outline-container-org532d5ce" class="outline-2">
<h2 id="org532d5ce"><span class="section-number-2">1</span> First approach</h2>
<div class="outline-text-2" id="text-1">
<p>
There are two small chunks of repeated code in the example above. One way to minimize the amount of repeated code is to pull these out into reusable functions. Here, we do that, and only have to repeat one function call at the end to get the system composition out.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">acetone</span> = (14.5463, 2940.46, 237.22)
<span style="color: #BA36A5;">acetonitrile</span> = (14.2724, 2945.47,224)
<span style="color: #BA36A5;">nitromethane</span> = (14.2043, 2972.64, 209)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">antoine</span>(T, A, B, C):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">T</span> = <span style="color: #006FE0;">float</span>(T) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">there is some subtle issue that comes up when T is an array,</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">as passed in from fsolve. It needs to be a float, or you get</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">the wrong answer.</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(A - B / (T + C))

<span style="color: #BA36A5;">x</span> = np.array([0.3, 0.45, 0.25])
<span style="color: #BA36A5;">P</span> = 80

<span style="color: #0000FF;">def</span> <span style="color: #006699;">Pvap</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.array([antoine(T, *pars) <span style="color: #0000FF;">for</span> pars <span style="color: #0000FF;">in</span> [acetone, acetonitrile, nitromethane]])

<span style="color: #0000FF;">def</span> <span style="color: #006699;">y</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> x * Pvap(T) / P

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 1 - y(T).<span style="color: #006FE0;">sum</span>()

Tans, = fsolve(objective, 70)

<span style="color: #BA36A5;">yans</span> = y(Tans) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">minimal repetition of a calculation to get the composition state.</span>

<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The bubble point temperature is {Tans:1.2f} degC, and the gas phase compositions are {np.round(yans, 4)}.'</span>)
</pre>
</div>

<pre class="example">
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].


</pre>

<p>
That is a small improvement. The code is not much shorter, just reorganized for easier reuse. It would be easy in this case to also get the vapor pressures of each species at this temperature, just by calling the <code>Pvap</code> function. Still, it feels annoying we have to recalculate the answer to something you know must have already been known when the objective function was evaluated.
</p>
</div>
</div>

<div id="outline-container-orga01a4af" class="outline-2">
<h2 id="orga01a4af"><span class="section-number-2">2</span> Second approach - use a state dictionary as an arg in the objective function</h2>
<div class="outline-text-2" id="text-2">
<p>
In this approach, we will use a dictionary to store the state of the objective function. The dictionary will be in the global namespace, and we will just update it each time the objective function is called.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #BA36A5;">acetone</span> = (14.5463, 2940.46, 237.22)
<span style="color: #BA36A5;">acetonitrile</span> = (14.2724, 2945.47,224)
<span style="color: #BA36A5;">nitromethane</span> = (14.2043, 2972.64, 209)

<span style="color: #0000FF;">def</span> <span style="color: #006699;">antoine</span>(T, A, B, C):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(A - B / (T + C))

<span style="color: #BA36A5;">x</span> = np.array([0.3, 0.45, 0.25])

<span style="color: #BA36A5;">state</span> = {}

<span style="color: #BA36A5;">P</span> = 80


<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(T, state):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">T</span> = <span style="color: #006FE0;">float</span>(T)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">Pvap</span> = np.array([antoine(T, *pars) <span style="color: #0000FF;">for</span> pars <span style="color: #0000FF;">in</span> [acetone, acetonitrile, nitromethane]])
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">y</span> = x * Pvap / P
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   state.update({<span style="color: #008000;">'y'</span>: y,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> <span style="color: #008000;">'T'</span>:  T,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> <span style="color: #008000;">'Pvap'</span>: Pvap,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span> <span style="color: #008000;">'z'</span>: 1 - y.<span style="color: #006FE0;">sum</span>()})
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> state[<span style="color: #008000;">'z'</span>]

Tans, = fsolve(objective, 70, args=(state,))

<span style="color: #0000FF;">print</span>(f<span style="color: #008000;">'The bubble point temperature is {Tans:1.2f} degC, and the gas phase compositions are {np.round(state["y"], 4)}.'</span>)
<span style="color: #0000FF;">print</span>(Tans- state[<span style="color: #008000;">'T'</span>]) <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">check to make sure last value from objective is the same as the solution</span>
state
</pre>
</div>

<pre class="example">
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].
0.0


</pre>

<pre class="example">
{'Pvap': array([ 138.5620209 ,   67.07966082,   32.98218545]),
 'T': 68.60064626680659,
 'y': array([ 0.51960758,  0.37732309,  0.10306933]),
 'z': -3.4194869158454821e-14}

</pre>

<p>
What we see in the <code>state</code> dictionary is the result from the last time that the objective function was called. It appears that the list time it was called is also where the solution comes from, so the other variables stored here should be consistent. Now you can see we have access to both the Pvap and y composition data from the solution without needing any further computations. This approach could be easily extended to store any derived quantities that represent internal states you want. We don't store any history in this, but you could by appending to lists in the dictionary.
</p>

<p>
One <i>feature</i> of this is the state dictionary is updated by side effect, and you have to use the state dictionary as an argument parameter to the function.
</p>
</div>
</div>


<div id="outline-container-orgc590864" class="outline-2">
<h2 id="orgc590864"><span class="section-number-2">3</span> third approach - a callable object</h2>
<div class="outline-text-2" id="text-3">
<p>
A standard approach to tracking state data is to encapsulate it in a class. fsolve requires a callable function that returns zero at the solution. It is possible to make an object <i>act like a callable function</i> if we define a <code>__call__</code> method on it. Then, in this method, we can set attributes on the object to keep track of the state, similar to what we did with the dictionary. Since we have a class, we can define some other special dunder methods, e.g. to print the solution. Here is one implementation.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve

<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Objective</span>(<span style="color: #006FE0;">object</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">acetone</span> = (14.5463, 2940.46, 237.22)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">acetonitrile</span> = (14.2724, 2945.47,224)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">nitromethane</span> = (14.2043, 2972.64, 209)

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, x, P):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.x = np.array(x)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.P = P

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">antoine</span>(<span style="color: #0000FF;">self</span>, T, A, B, C):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(A - B / (T + C))

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__str__</span>(<span style="color: #0000FF;">self</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = f<span style="color: #008000;">'The bubble point temperature is {self.T:1.2f} degC, and the gas phase compositions are {np.round(self.y, 4)}.'</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> s

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__call__</span>(<span style="color: #0000FF;">self</span>, T):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">T</span> = <span style="color: #006FE0;">float</span>(T)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.T = T
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.Pvap = np.array([<span style="color: #0000FF;">self</span>.antoine(T, *pars) <span style="color: #0000FF;">for</span> pars <span style="color: #0000FF;">in</span> [<span style="color: #0000FF;">self</span>.acetone, <span style="color: #0000FF;">self</span>.acetonitrile, <span style="color: #0000FF;">self</span>.nitromethane]])
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.y = <span style="color: #0000FF;">self</span>.x * <span style="color: #0000FF;">self</span>.Pvap / <span style="color: #0000FF;">self</span>.P
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> 1 - <span style="color: #0000FF;">self</span>.y.<span style="color: #006FE0;">sum</span>()

<span style="color: #BA36A5;">obj</span> = Objective(x=np.array([0.3, 0.45, 0.25]), P=80)
ans, = fsolve(obj, 60)

<span style="color: #0000FF;">print</span>(obj)
</pre>
</div>

<pre class="example">
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].


</pre>


<p>
Similar to the state dictionary approach, there is no repeated code here, and no repeated evaluations to get to the state after the solution. This is a bit more advanced Python than the state dictionary. Note, this implementation doesn't have any checking in it, so if you try to print the object before calling fsolve, you will get an error because the attributes don't exist until <i>after</i> the object has been called. That is also an issue with the state dictionary above.
</p>

<p>
There are many choices you could make in constructing this example. Maybe this one has gone too far in encapsulating the antoine function as a method. That limits its reusability for another problem. On the other hand, you can reuse it for any other pressure or liquid composition of acetone, acetonitrile and nitromethane very readily.
</p>
</div>
</div>

<div id="outline-container-orgaef298d" class="outline-2">
<h2 id="orgaef298d"><span class="section-number-2">4</span> Summary</h2>
<div class="outline-text-2" id="text-4">
<p>
We looked at three ways to reduce having redundant code in the solution to problems involving nonlinear algebra. The first approach is conceptually simple; you break out as much as you can into reusable functions, and then at most have repeated function calls. These computations are usually not expensive, so repeating them is mostly tedious and provides opportunities for mistakes. This is probably what I will stick to for teaching students that are just seeing this for the first time.
</p>

<p>
The second approach used a dictionary (other data structures could work too) as an argument to the objective function, and internal states were kept in the dictionary so that after the problem was solved, you have immediate access to them. This is more advanced than the first approach because it requires understanding that the dictionary is modified as a side effect of solving the problem.
</p>

<p>
Finally,  we considered an object-oriented class encapsulation of the information we wanted. I consider this the most advanced Python solution, since it requires some understanding of classes, dunder methods and attributes, and how to make an instance of a class.
</p>

<p>
The last two methods seem like candidates for an advanced class in problem solving. Thoughts?
</p>
</div>
</div>
<p>Copyright (C) 2018 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2018/09/24/Solving-nonlinear-algebra-problems-with-internal-state-information.org">org-mode source</a></p>
<p>Org-mode version = 9.1.13</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2018/09/24/Solving-nonlinear-algebra-problems-with-internal-state-information">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Coupled-nonlinear-equations"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/09/02/Coupled-nonlinear-equations/" rel="bookmark" title="Permanent Link to Coupled nonlinear equations">Coupled nonlinear equations</a></h2>
      <p><small><span class="blog_post_date">Posted September 02, 2013 at 03:21 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Suppose we seek the solution to this set of equations:
</p>

\begin{align}
y &=& x^2 \\
y &=& 8 - x^2
\end{align}

<p>
To solve this we need to setup a function that is equal to zero at the solution. We have two equations, so our function must return two values. There are two variables, so the argument to our function will be an array of values. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(X):
    <span style="color: #8b008b;">x</span>, <span style="color: #8b008b;">y</span> = X            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">unpack the array in the argument</span>
    <span style="color: #8b008b;">z1</span> = y - x**2       <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">first equation</span>
    <span style="color: #8b008b;">z2</span> = y - 8 + x**2   <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">second equation</span>
    <span style="color: #8b0000;">return</span> [z1, z2]     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">list of zeros</span>

<span style="color: #8b008b;">x0</span>, <span style="color: #8b008b;">y0</span> = 1, 1           <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guesses</span>
<span style="color: #8b008b;">guess</span> = [x0, y0]
<span style="color: #8b008b;">sol</span> = fsolve(objective, guess)
<span style="color: #8b0000;">print</span> sol

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">of course there may be more than one solution</span>
<span style="color: #8b008b;">x0</span>, <span style="color: #8b008b;">y0</span> = -1, -1           <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guesses</span>
<span style="color: #8b008b;">guess</span> = [x0, y0]
<span style="color: #8b008b;">sol</span> = fsolve(objective, guess)
<span style="color: #8b0000;">print</span> sol
</pre>
</div>

<pre class="example">
[ 2.  4.]
[-2.  4.]
</pre>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/09/02/Coupled-nonlinear-equations.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/09/02/Coupled-nonlinear-equations">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Finding-the-nth-root-of-a-periodic-function"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/05/Finding-the-nth-root-of-a-periodic-function/" rel="bookmark" title="Permanent Link to Finding the nth root of a periodic function">Finding the nth root of a periodic function</a></h2>
      <p><small><span class="blog_post_date">Posted March 05, 2013 at 02:06 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a></span> | tags: <a href='/blog/tag/heat-transfer/'>heat transfer</a>
      <p><small><span class="blog_post_date">Updated March 05, 2013 at 03:12 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
There is a heat transfer problem where one needs to find the n^th root of the following equation: \(x J_1(x) - Bi J_0(x)=0\) where \(J_0\) and \(J_1\) are the Bessel functions of zero and first order, and \(Bi\) is the Biot number. We examine an approach to finding these roots. 
</p>

<p>
First,  we plot the function.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> jn, jn_zeros
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

Bi = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):
    <span style="color: #8b0000;">return</span> x * jn(1, x) - Bi * jn(0, x)

X = np.linspace(0, 30, 200)
plt.plot(X, f(X))
plt.savefig(<span style="color: #228b22;">'images/heat-transfer-roots-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/heat-transfer-roots-1.png"><p>

<p>
You can see there are many roots to this equation, and we want to be sure we get the n^{th} root. This function is pretty well behaved, so if you make a good guess about the solution you will get an answer, but if you make a bad guess, you may get the wrong root. We examine next a way to do it without guessing the solution. What we want is the solution to \(f(x) = 0\), but we want all the solutions in a given interval. We derive a new equation, \(f'(x) = 0\), with initial condition \(f(0) = f0\), and integrate the ODE with an event function that identifies all zeros of \(f\) for us. The derivative of our function is \(df/dx = d/dx(x J_1(x)) - Bi J'_0(x)\). It is known (<a href="http://www.markrobrien.com/besselfunct.pdf" >http://www.markrobrien.com/besselfunct.pdf</a>) that \(d/dx(x J_1(x)) = x J_0(x)\), and \(J'_0(x) = -J_1(x)\). All we have to do now is set up the problem and run it.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> *  <span style="color: #ff0000; font-weight: bold;"># contains the ode integrator with events</span>

<span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> jn, jn_zeros
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

Bi = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):
    <span style="color: #228b22;">"function we want roots for"</span>
    <span style="color: #8b0000;">return</span> x * jn(1, x) - Bi * jn(0, x)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fprime</span>(f, x):
    <span style="color: #228b22;">"df/dx"</span>
    <span style="color: #8b0000;">return</span> x * jn(0, x) - Bi * (-jn(1, x))

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">e1</span>(f, x):
    <span style="color: #228b22;">"event function to find zeros of f"</span>
    isterminal = <span style="color: #8b0000;">False</span>
    value = f
    direction = 0
    <span style="color: #8b0000;">return</span> value, isterminal, direction

f0 = f(0)
xspan = np.linspace(0, 30, 200)

x, fsol, XE, FE, IE = odelay(fprime, f0, xspan, events=[e1])

plt.plot(x, fsol, <span style="color: #228b22;">'.-'</span>, label=<span style="color: #228b22;">'Numerical solution'</span>)
plt.plot(xspan, f(xspan), <span style="color: #228b22;">'--'</span>, label=<span style="color: #228b22;">'Analytical function'</span>)
plt.plot(XE, FE, <span style="color: #228b22;">'ro'</span>, label=<span style="color: #228b22;">'roots'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/heat-transfer-roots-2.png'</span>)

<span style="color: #8b0000;">for</span> i, root <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(XE):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'root {0} is at {1}'</span>.format(i, root)

plt.show()
</pre>
</div>

<pre class="example">
root 0 is at 1.25578377377
root 1 is at 4.07947743741
root 2 is at 7.15579904465
root 3 is at 10.2709851256
root 4 is at 13.3983973869
root 5 is at 16.5311587137
root 6 is at 19.6667276775
root 7 is at 22.8039503455
root 8 is at 25.9422288192
root 9 is at 29.081221492
</pre>

<p><img src="/img/./images/heat-transfer-roots-2.png"><p>

<p>
You can work this out once, and then you have all the roots in the interval and you can select the one you want.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/05/Finding-the-nth-root-of-a-periodic-function.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/03/05/Finding-the-nth-root-of-a-periodic-function">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Method-of-continuity-for-solving-nonlinear-equations-Part-II"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/01/Method-of-continuity-for-solving-nonlinear-equations-Part-II/" rel="bookmark" title="Permanent Link to Method of continuity for solving nonlinear equations - Part II">Method of continuity for solving nonlinear equations - Part II</a></h2>
      <p><small><span class="blog_post_date">Posted March 01, 2013 at 06:17 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated March 03, 2013 at 12:22 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/02/method-of-continuity-for-solving-nonlinear-equations-part-ii-2/" >Matlab post</a>
Yesterday in Post 1324 we looked at a way to solve nonlinear equations that takes away some of the burden of initial guess generation. The idea was to reformulate the equations with a new variable \(\lambda\), so that at \(\lambda=0\) we have a simpler problem we know how to solve, and at \(\lambda=1\) we have the original set of equations. Then, we derive a set of ODEs on how the solution changes with \(\lambda\), and solve them.
</p>

<p>
Today we look at a simpler example and explain a little more about what is going on. Consider the equation: \(f(x) = x^2 - 5x + 6 = 0\), which has two roots, \(x=2\) and \(x=3\). We will use the method of continuity to solve this equation to illustrate a few ideas. First, we introduce a new variable \(\lambda\) as: \(f(x; \lambda) = 0\). For example, we could write \(f(x;\lambda) = \lambda x^2 - 5x + 6 = 0\). Now, when \(\lambda=0\), we hve the simpler equation \(- 5x + 6 = 0\), with the solution \(x=6/5\). The question now is, how does \(x\) change as \(\lambda\) changes? We get that from the total derivative of how \(f(x,\lambda)\) changes with \(\lambda\). The total derivative is:
</p>

<p>
$$\frac{df}{d\lambda} = \frac{\partial f}{\partial \lambda} + \frac{\partial f}{\partial x}\frac{\partial x}{\partial \lambda}=0$$
</p>

<p>
We can calculate two of those quantities: \(\frac{\partial f}{\partial \lambda}\) and \(\frac{\partial f}{\partial x}\) analytically from our equation and solve for \(\frac{\partial x}{\partial \lambda}\) as
</p>

<p>
$$ \frac{\partial x}{\partial \lambda} = -\frac{\partial f}{\partial \lambda}/\frac{\partial f}{\partial x}$$
</p>

<p>
That defines an ordinary differential equation that we can solve by integrating from \(\lambda=0\) where we know the solution to \(\lambda=1\) which is the solution to the real problem. For this problem: \(\frac{\partial f}{\partial \lambda}=x^2\) and \(\frac{\partial f}{\partial x}=-5 + 2\lambda x\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dxdL</span>(x, Lambda):
    <span style="color: #8b0000;">return</span> -x**2 / (-5.0 + 2 * Lambda * x)

x0 = 6.0/5.0
Lspan = np.linspace(0, 1)
x = odeint(dxdL, x0, Lspan)

plt.plot(Lspan, x)
plt.xlabel(<span style="color: #228b22;">'$\lambda$'</span>)
plt.ylabel(<span style="color: #228b22;">'x'</span>)
plt.savefig(<span style="color: #228b22;">'images/nonlin-contin-II-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/nonlin-contin-II-1.png"><p>

<p>
We found one solution at x=2. What about the other solution? To get that we have to introduce \(\lambda\) into the equations in another way. We could try: \(f(x;\lambda) = x^2 + \lambda(-5x + 6)\), but this leads to an ODE that is singular at the initial starting point. Another approach is \(f(x;\lambda) = x^2 + 6 + \lambda(-5x)\), but now the solution at \(\lambda=0\) is imaginary, and we do not have a way to integrate that! What we can do instead is add and subtract a number like this: \(f(x;\lambda) = x^2 - 4 + \lambda(-5x + 6 + 4)\). Now at \(\lambda=0\), we have a simple equation with roots at \(\pm 2\), and we already know that \(x=2\) is a solution. So, we create our ODE on \(dx/d\lambda\) with initial condition \(x(0) = -2\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dxdL</span>(x, Lambda):
    <span style="color: #8b0000;">return</span> (5 * x - 10) / (2 * x - 5 * Lambda)

x0 = -2
Lspan = np.linspace(0, 1)
x = odeint(dxdL, x0, Lspan)

plt.plot(Lspan, x)
plt.xlabel(<span style="color: #228b22;">'$\lambda$'</span>)
plt.ylabel(<span style="color: #228b22;">'x'</span>)
plt.savefig(<span style="color: #228b22;">'images/nonlin-contin-II-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/nonlin-contin-II-2.png"><p>

<p>
Now we have the other solution. Note if you choose the other root, \(x=2\), you find that 2 is a root, and learn nothing new. You could choose other values to add, e.g., if you chose to add and subtract 16, then you would find that one starting point leads to one root, and the other starting point leads to the other root. This method does not solve all problems associated with nonlinear root solving, namely, how many roots are there, and which one is &ldquo;best&rdquo; or physically reasonable? But it does give a way to solve an equation where you have no idea what an initial guess should be. You can see, however, that just like you can get different answers from different initial guesses, here you can get different answers by setting up the equations differently.</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/01/Method-of-continuity-for-solving-nonlinear-equations---Part-II.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/03/01/Method-of-continuity-for-solving-nonlinear-equations-Part-II">Discuss on Twitter</a>

  <hr class="interblog" />
 <a href="/blog/category/nonlinear-algebra/2">Next Page </a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2021/06/29/Youtube-live-streamed-research-talks/">Youtube live-streamed research talks</a></li>
      <li><a href="/blog/2021/06/21/New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation/">New publication "Machine-learning accelerated geometry optimization in molecular simulation"</a></li>
      <li><a href="/blog/2021/03/07/New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models/">New publication - Semi-grand Canonical Monte Carlo Simulation of the Acrolein induced Surface Segregation and Aggregation of AgPd with Machine Learning Surrogate Models</a></li>
      <li><a href="/blog/2020/07/09/New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability/">New publication SingleNN - Modified BehlerParrinello Neural Network with Shared Weights for Atomistic Simulations with Transferability</a></li>
      <li><a href="/blog/2020/03/10/New-publication-Parallelized-Screening-of-Characterized-and-DFT-Modelled-Bimetallic-Colloidal-Co-Catalysts-for-Photocatalytic-Hydrogen-Evolution/">New publication - Parallelized Screening of Characterized and DFT-Modelled Bimetallic Colloidal Co-Catalysts for Photocatalytic Hydrogen Evolution</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2021
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



