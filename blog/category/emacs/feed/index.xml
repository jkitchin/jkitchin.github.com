<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>https://kitchingroup.cheme.cmu.edu/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Mon, 03 Feb 2025 11:51:03 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Using results from one code block in another org-mode</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2019/02/12/Using-results-from-one-code-block-in-another-org-mode</link>
      <pubDate>Tue, 12 Feb 2019 09:20:58 EST</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[elisp]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">gzZgY5oqeB9thgLDRCfcJu-iwyw=</guid>
      <description>Using results from one code block in another org-mode</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org679863a"&gt;1. :var&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1cd48f8"&gt;2. :cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org744145d"&gt;3. :wrap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org603dd14"&gt;4. :file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org61d9dad"&gt;5. "remote" data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf9c3e0a"&gt;6. Manually saving data in files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org578795b"&gt;7. An appendix for data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org828ee8b"&gt;8. Caveats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
One really great feature in org-mode is you have many options to pass data between code-blocks. In this post we look at some of these options using emacs-lisp as the language. This runs in a &lt;i&gt;session&lt;/i&gt; where you can keep variables in memory between blocks, and use them in subsequent blocks.
&lt;/p&gt;

&lt;p&gt;
Here we set a variable to a value.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; some-variable 42)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
42
&lt;/pre&gt;


&lt;p&gt;
Then later in another block we can use that variable:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(+ some-variable 1)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
43
&lt;/pre&gt;


&lt;p&gt;
While you are in the session, &lt;code&gt;some-variable&lt;/code&gt; can be used. If you want some mind-bending trouble, the emacs-lisp session is global, and you can access &lt;code&gt;some-variable&lt;/code&gt; even in another buffer! Don't do that. When you close emacs this variable will disappear, and all that is left are the results from above.
&lt;/p&gt;

&lt;p&gt;
There is another way to pass information from one block to another using named src blocks and variables in the block header. This allows you to pass data between blocks by name, and you will see later you can even access the results by name from other files.
&lt;/p&gt;

&lt;div id="outline-container-org679863a" class="outline-2"&gt;
&lt;h2 id="org679863a"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; :var&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
First, we give our src block a name like this:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+name: block-1
#+BEGIN_SRC emacs-lisp
(current-time-string)
#+END_SRC
&lt;/pre&gt;

&lt;p&gt;
When we run this, the results will have a name too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org0eee06d"&gt;(current-time-string)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Tue Feb 12 08:19:23 2019
&lt;/pre&gt;


&lt;p&gt;
Now, we can use the named result as &lt;i&gt;input&lt;/i&gt; to a new block using the :var header.
&lt;/p&gt;

&lt;pre class="example"&gt;
#+BEGIN_SRC emacs-lisp :var input=block-1
(format "We got %S in block-1" input)
#+END_SRC
&lt;/pre&gt;

&lt;p&gt;
When we run this block, emacs will run block-1 and put the output in to the variable &lt;code&gt;input&lt;/code&gt; which we use inside the code block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(format &lt;span style="color: #008000;"&gt;"We got %S in block-1"&lt;/span&gt; input)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "Tue Feb 12 08:20:44 2019" in block-1
&lt;/pre&gt;


&lt;p&gt;
Some things to note:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Every time you run this, block-1 gets rerun.&lt;/li&gt;
&lt;li&gt;The results in this block are not the same as in block-1&lt;/li&gt;
&lt;li&gt;The results in block-1 are not changed when you run the second block.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
You may not want to rerun block-1 each time; maybe it is an expensive calculation, or maybe it should not be changed. You can prevent this behavior by using the :cache header.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1cd48f8" class="outline-2"&gt;
&lt;h2 id="org1cd48f8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; :cache&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
If you specify &lt;code&gt;:cache yes&lt;/code&gt; then org-mode &lt;i&gt;should&lt;/i&gt; store a hash of the code block with the results, and if the code block hasn't changed then it should not run again.
&lt;/p&gt;

&lt;pre class="example"&gt;
#+name: block-2
#+BEGIN_SRC emacs-lisp :cache yes
(current-time-string)
#+END_SRC
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="orgb1aedb8"&gt;(current-time-string)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Tue Feb 12 08:06:22 2019
&lt;/pre&gt;


&lt;p&gt;
Now, we use block-2 as input to a block, we see the output is the same as the output from block-2.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(format &lt;span style="color: #008000;"&gt;"We got %S in block-2"&lt;/span&gt; input)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "Tue Feb 12 08:06:22 2019" in block-2
&lt;/pre&gt;


&lt;p&gt;
Ok, but what if my results are too large to put in the buffer, or too complex for text? You still have some options.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org744145d" class="outline-2"&gt;
&lt;h2 id="org744145d"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; :wrap&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Suppose we generate some json in one block, and we want to use it in another block. We still want to see the json in the buffer as an intermediate result. We can wrap the output in a json block like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="orgd0725ee"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="json"&gt;
&lt;p&gt;
{"date":"Tue Feb 12 08:30:20 2019"}
&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;
Then, we can simply input that output into a new block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(format &lt;span style="color: #008000;"&gt;"We got %S in json"&lt;/span&gt; input)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "{\"date\":\"Tue Feb 12 08:30:20 2019\"}
" in json
&lt;/pre&gt;


&lt;p&gt;
This admittedly still pretty simple, text-based data. It is probably not a good idea to do this with binary data.
&lt;/p&gt;

&lt;p&gt;
Note you can refer to this result even in another org-file:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+BEGIN_SRC emacs-lisp :var input=./2019-02-12.org:json
input
#+END_SRC

#+RESULTS:
: {"date":"Tue Feb 12 08:30:20 2019"}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org603dd14" class="outline-2"&gt;
&lt;h2 id="org603dd14"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; :file&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
It may be that your data is too large to conveniently put into your org-file, or maybe it is binary data. No problem, just put it into an external file using the :file header. It looks like this:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+name: block-3
#+BEGIN_SRC emacs-lisp :cache yes :file block-3
(require 'json)
(json-encode `(("date" . ,(current-time-string))))
#+END_SRC

#+RESULTS[a14d376653bd8c40a0961ca95f21d8837dddec66]: block-3
[[file:block-3]]
&lt;/pre&gt;


&lt;p&gt;
Note that you have to provide a file name for this. Sometimes that is nice if you want a human recognizable file to send to someone, but it would also be nice if there was an automatic naming scheme, e.g. based on an sha-1 hash of the src block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org5f97d46"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;a href="/media/block-3"&gt;block-3&lt;/a&gt; 
&lt;/p&gt;

&lt;p&gt;
Now you can use other tools to check out the file. Here we can still use simple shell tools.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;cat block-3
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
The output of block-3 is a file name:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;input
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
/Users/jkitchin/Box Sync/kitchingroup/jkitchin/journal/2019/02/12/block-3
&lt;/pre&gt;


&lt;p&gt;
So you can use it in a new block to read the data in, and then do something new with it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
  (insert-file-contents input)
  (format &lt;span style="color: #008000;"&gt;"We got %S in block-3"&lt;/span&gt; (json-read-from-string (buffer-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got ((date . "Tue Feb 12 08:46:55 2019")) in block-3
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org61d9dad" class="outline-2"&gt;
&lt;h2 id="org61d9dad"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; "remote" data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
The blocks do not have to be in order. If you want, you can put your blocks in an &lt;a href="#org578795b"&gt;appendix&lt;/a&gt;, and then just have analysis blocks here that use them. That way, you can have short blocks here that are more readable, but longer, more complex blocks elsewhere that do not clutter your document.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
  (insert-file-contents input)
  (format &lt;span style="color: #008000;"&gt;"We got %S in the appendix data"&lt;/span&gt; (json-read-from-string (buffer-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "{\"date\":\"Tue Feb 12 09:11:12 2019\"}" in the appendix data
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgf9c3e0a" class="outline-2"&gt;
&lt;h2 id="orgf9c3e0a"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; Manually saving data in files&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
Note you can also manually save data in a file, for example:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org99c8008"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((f &lt;span style="color: #008000;"&gt;"block-4.json"&lt;/span&gt;))
  (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; f
    (prin1
     (json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
     (current-buffer)))
  f)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
block-4.json
&lt;/pre&gt;


&lt;p&gt;
We put the filename as the last variable which is returned by the block, so that we don't have to manually type it later in the next block. You know, try not to repeat yourself&amp;#x2026;
&lt;/p&gt;

&lt;p&gt;
This just shows we did write out to our file:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;cat block-4.json
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And we read the file in here, using the filename from block-4 as an input variable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
  (insert-file-contents input)
  (format &lt;span style="color: #008000;"&gt;"We got %S in block-4"&lt;/span&gt; (json-read-from-string (buffer-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "{\"date\":\"Tue Feb 12 08:51:25 2019\"}" in block-4
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org578795b" class="outline-2"&gt;
&lt;h2 id="org578795b"&gt;&lt;span class="section-number-2"&gt;7&lt;/span&gt; An appendix for data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="orgfc06cf8"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((f &lt;span style="color: #008000;"&gt;"appendix.json"&lt;/span&gt;))
  (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; f
    (prin1
     (json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
     (current-buffer)))
  f)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
appendix.json
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org828ee8b" class="outline-2"&gt;
&lt;h2 id="org828ee8b"&gt;&lt;span class="section-number-2"&gt;8&lt;/span&gt; Caveats&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;p&gt;
Using org-mode like this is almost always finding the right tradeoffs in what is persistent, and where is it stored. Not all of the intermediate data/calculations are stored; if they are really cheap you can just run the code blocks again. If they are really small, i.e. easy for your to read in a few lines, you can store them in the document. If they are really large, you can store them in a file.
&lt;/p&gt;

&lt;p&gt;
The beauty of having everything in an org-file is you have a single file that is easy to transport. When the files get too large though, it can become impractical, e.g. emacs may slow down if you try to put thousands of lines of xml data into the buffer. Then, you have to make some decisions about what to keep, where to keep it, and in what form to keep it.
&lt;/p&gt;

&lt;p&gt;
For short projects where you only need a single compute session, having everything in memory may be fine. For longer projects, say one that is long enough you will close all the buffers, and possibly restart emacs in between working on it, then you have to make some decisions about what to save from each block so you can continue the work in the next session. Again, you have to decide what to save, where to save, and in what form.
&lt;/p&gt;

&lt;p&gt;
Once you start saving data outside the org-file, it becomes less portable, or more tricky to move the file because you need to also move all the data files to keep it intact. I have explored a concept of making an org-archive in the past, where you get a list of all files linked in the org-file, but this so far has just been worked out for some small proof of concept ideas.
&lt;/p&gt;

&lt;p&gt;
Not all languages are the same in org-mode. They do not all support sessions for example, and they may not all work like the examples here. The scimax iPython modifications do not behave like the examples above. That is probably due to bugs I have inadvertently introduced, and in the future I will try to make it work like emacs-lisp does above.
&lt;/p&gt;

&lt;p&gt;
Overall, org-mode has one of the most flexible and powerful systems for passing and reusing data in documents I have ever seen. It is not perfect, and in such a powerful system there are many unexplored or lightly traveled corners that may have hazards in them. It still seems pretty promising though.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2019 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2019/02/12/Using-results-from-one-code-block-in-another-org-mode.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.2.1&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Getting geo-tagged information from photos for blogging</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2018/07/01/Getting-geo-tagged-information-from-photos-for-blogging</link>
      <pubDate>Sun, 01 Jul 2018 19:17:18 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <category><![CDATA[geotag]]></category>
      <guid isPermaLink="false">To7Oj9cQgVbpXvdso0vW9uTFc2o=</guid>
      <description>Getting geo-tagged information from photos for blogging</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am kind of late to this game, but recently I turned on location services for the camera on my phone. That means the location of the photo is stored in the photo, and we can use that to create urls to the photo location in a map for example. While traveling, I thought this would be a good application for org-mode to add functionality to documents with photos in them, e.g. to be able to click on them to see where they are from, or to automate creation of html pages with links to maps, etc. In this post I explore some ways to achieve those ideas. What I would like is a custom org link that shows me a thumbnail of the image, and which exports to show the image in an html file with a link to a pin on Google maps.
&lt;/p&gt;

&lt;p&gt;
So, let's dig in. Imagemagick provides an identify command that can extract the information stored in the images. Here we consider just the GPS information. I some pictures on a recent vacation, and one is unimaginatively named IMG_1759.JPG. Let's see where it was taken.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;identify -verbose IMG_1759.JPG | grep GPS
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSAltitude:&lt;/td&gt;
&lt;td class="org-left"&gt;14426/387&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSAltitudeRef:&lt;/td&gt;
&lt;td class="org-left"&gt;0&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSDateStamp:&lt;/td&gt;
&lt;td class="org-left"&gt;2018:06:30&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSDestBearing:&lt;/td&gt;
&lt;td class="org-left"&gt;11767/80&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSDestBearingRef:&lt;/td&gt;
&lt;td class="org-left"&gt;T&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSImgDirection:&lt;/td&gt;
&lt;td class="org-left"&gt;11767/80&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSImgDirectionRef:&lt;/td&gt;
&lt;td class="org-left"&gt;T&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSInfo:&lt;/td&gt;
&lt;td class="org-left"&gt;1632&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLatitude:&lt;/td&gt;
&lt;td class="org-left"&gt;22/1,&lt;/td&gt;
&lt;td class="org-left"&gt;11/1,&lt;/td&gt;
&lt;td class="org-left"&gt;614/100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLatitudeRef:&lt;/td&gt;
&lt;td class="org-left"&gt;N&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLongitude:&lt;/td&gt;
&lt;td class="org-left"&gt;159/1,&lt;/td&gt;
&lt;td class="org-left"&gt;40/1,&lt;/td&gt;
&lt;td class="org-left"&gt;4512/100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLongitudeRef:&lt;/td&gt;
&lt;td class="org-left"&gt;W&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSSpeed:&lt;/td&gt;
&lt;td class="org-left"&gt;401/100&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSSpeedRef:&lt;/td&gt;
&lt;td class="org-left"&gt;K&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSTimeStamp:&lt;/td&gt;
&lt;td class="org-left"&gt;3/1,&lt;/td&gt;
&lt;td class="org-left"&gt;44/1,&lt;/td&gt;
&lt;td class="org-left"&gt;3900/100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
The interpretation here is that I took that photo at latitude 22° 11' 6.14" N, and longitude 159° 40' 45.12" W. Evidently I was moving at 4.01 in some unit; I can confirm that I was at least moving, I was on a ship when I took that picture, and it was moving.
&lt;/p&gt;

&lt;p&gt;
According to &lt;a href="http://alvarestech.com/temp/routeconverter/RouteConverter/navigation-formats/src/main/doc/googlemaps/Google_Map_Parameters.htm"&gt;this&lt;/a&gt; you can make a url to a Google maps pin in satellite picture mode that looks like this: &lt;a href="http://maps.google.com/maps?q=22%2011%206.14N,159%2040%2045.12W&amp;amp;t=k"&gt;http://maps.google.com/maps?q=22 11 6.14N,159 40 45.12W&amp;amp;t=k&lt;/a&gt;. It doesn't seem possible to set the zoom in this url (at least setting the zoom doesn't do anything, and I didn't feel like trying all the other variations that are reported to sometimes work). I guess that is ok for now, it adds some suspense that you have to zoom out to see where the image is in some cases.
&lt;/p&gt;

&lt;p&gt;
We need a little function to take an image file and generate that link. We have to do some algebra on the latitude and longitude which are stored as integers with a division operator. I am going to pipe this through an old unix utility called bc mostly because it is simple, and I won't have to parse it much. bc is a little archaic, you have to set the scale first, which tells it how many decimal places to output. The degrees and minutes are integers, so we will have to deal with that later.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;&lt;span style="color: #006FE0;"&gt;echo&lt;/span&gt; &lt;span style="color: #008000;"&gt;"scale=2; 614/100"&lt;/span&gt; | bc
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6.14

&lt;/pre&gt;

&lt;p&gt;
Here is our function. I filter out the lines with GPS in them into an a-list. Then, I grab out the specific quantities I want and construct the url. There is a little hackery since it appears the degrees and minutes should be integers in the url formulation used here, so I convert them to numbers and then take the floor. The function is a little longer than I thought, but it isn't too bad I guess. It is a little repetitious, but not enough to justify refactoring.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-map-url&lt;/span&gt; (fname)
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((gps-lines (-keep (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (line)
                             (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (s-contains? &lt;span style="color: #008000;"&gt;"GPS"&lt;/span&gt; line) (s-trim line)))
                           (process-lines &lt;span style="color: #008000;"&gt;"identify"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"-verbose"&lt;/span&gt; fname)))
         (gps-alist (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s) (s-split &lt;span style="color: #008000;"&gt;": "&lt;/span&gt; s t))  gps-lines))
         (latitude (mapcar
                    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                      (s-trim (shell-command-to-string
                               (format &lt;span style="color: #008000;"&gt;"echo \"scale=2;%s\" | bc"&lt;/span&gt; s))))
                    (s-split &lt;span style="color: #008000;"&gt;","&lt;/span&gt; (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLatitude"&lt;/span&gt; gps-alist)))))
         (latitude-ref (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLatitudeRef"&lt;/span&gt; gps-alist)))
         (longitude (mapcar
                     (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                       (s-trim
                        (shell-command-to-string
                         (format &lt;span style="color: #008000;"&gt;"echo \"scale=2;%s\" | bc"&lt;/span&gt; s))))
                     (s-split &lt;span style="color: #008000;"&gt;","&lt;/span&gt; (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLongitude"&lt;/span&gt; gps-alist)))))
         (longitude-ref (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLongitudeRef"&lt;/span&gt; gps-alist))))
    (s-format &lt;span style="color: #008000;"&gt;"http://maps.google.com/maps?q=$0 $1 $2$3,$4 $5 $6$7&amp;amp;t=k"&lt;/span&gt;
              'elt
              (list
               (floor (string-to-number (nth 0 latitude)))
               (floor (string-to-number (nth 1 latitude)))
               (nth 2 latitude)
               latitude-ref
               (floor (string-to-number (nth 0 longitude)))
               (floor (string-to-number (nth 1 longitude)))
               (nth 2 longitude)
               longitude-ref))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
iphoto-map-url

&lt;/pre&gt;

&lt;p&gt;
Here is the function in action, making the url.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(iphoto-map-url &lt;span style="color: #008000;"&gt;"IMG_1759.JPG"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
http://maps.google.com/maps?q=22 11 6.14N,159 40 45.12W&amp;amp;t=k

&lt;/pre&gt;

&lt;p&gt;
It is kind of slow, but that is because the identify shell command is kind of slow when you run it with the -verbose tag. Now, I would like the following things to happen when I publish it to html:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;I want the image wrapped in an img tag inside a figure environment.&lt;/li&gt;
&lt;li&gt;I want the image to by hyperlinked to its location in Google maps.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
In the org file, I want a thumbnail overlay on it, so I can see the image while writing, and I want it to toggle like other images. I use an iPhone to take the photos, so we will call it an iphoto link.
&lt;/p&gt;

&lt;p&gt;
Here is the html export function I will use. It is a little hacky that I hard code the width in at 300 pixels, but I didn't feel like figuring out how to get it from an #+attr_html line right now. It probably requires a filter function where you have access to the actual org-elements. I put the url to the image location in a figure caption here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-export&lt;/span&gt; (path desc backend)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq 'html backend)
    (format &lt;span style="color: #008000;"&gt;"&amp;lt;figure&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000;"&gt;&amp;lt;img src=\"%s\" width=\"300\"&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000;"&gt;%s&lt;/span&gt;
&lt;span style="color: #008000;"&gt;&amp;lt;/figure&amp;gt;"&lt;/span&gt;
            path
            (format &lt;span style="color: #008000;"&gt;"&amp;lt;figcaption&amp;gt;%s &amp;lt;a href=\"%s\"&amp;gt;map&amp;lt;/a&amp;gt;&amp;lt;/figcaption&amp;gt;"&lt;/span&gt;
                    (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; desc &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                    (iphoto-map-url path))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
iphoto-export

&lt;/pre&gt;

&lt;p&gt;
Ok, the last detail I want is to put an image overlay on my new link so I can see it. I want this to work with org-toggle-inline-images so I can turn the images on and off like regular image links with C-c C-x C-v. This function creates overlays as needed, and ties into the org-inline-image-overlays so they get deleted on toggling. We have to advise the display function to redraw these, which we clumsily do by restarting the org font-lock machinery which will redraw the thumbnails from the activate-func property of the links. I also hard code the thumbnail width in this function, when it could be moved out to a variable or attribute.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-thumbnails&lt;/span&gt; (start end imgfile bracketp)
  (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; bracketp
    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt;
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;it is an image&lt;/span&gt;
           (org-string-match-p (image-file-name-regexp) imgfile)
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and it exists&lt;/span&gt;
           (f-exists? imgfile)
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and there is no overlay here.&lt;/span&gt;
           (not (ov-at start)))
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; img (create-image (expand-file-name imgfile)
                              'imagemagick nil &lt;span style="color: #006FE0;"&gt;:width&lt;/span&gt; 300
                              &lt;span style="color: #006FE0;"&gt;:background&lt;/span&gt; &lt;span style="color: #008000;"&gt;"lightgray"&lt;/span&gt;))
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ov (make-overlay start end))
      (overlay-put ov 'display img)
      (overlay-put ov 'face 'default)
      (overlay-put ov 'org-image-overlay t)
      (overlay-put ov 'modification-hooks
                   (list
                    `(&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
                       (org-display-inline-remove-overlay ,ov t ,start ,end))))
      (&lt;span style="color: #0000FF;"&gt;push&lt;/span&gt; ov org-inline-image-overlays))))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-redraw-thumbnails&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  (org-restart-font-lock))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this redisplays these thumbnails on image toggling&lt;/span&gt;
(advice-add 'org-display-inline-images &lt;span style="color: #006FE0;"&gt;:after&lt;/span&gt; 'iphoto-redraw-thumbnails)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next, we define the link with a follow, export, tooltip and activate-func (which puts the overlay on).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-link-set-parameters
 &lt;span style="color: #008000;"&gt;"iphoto"&lt;/span&gt;
 &lt;span style="color: #006FE0;"&gt;:follow&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (path) (browse-url (iphoto-map-url path)))
 &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'iphoto-export
 &lt;span style="color: #006FE0;"&gt;:help-echo&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Click me to see where this photo is on a map."&lt;/span&gt;
 &lt;span style="color: #006FE0;"&gt;:activate-func&lt;/span&gt; 'iphoto-thumbnails)
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
So finally, here is the mysterious image.
&lt;/p&gt;


&lt;p&gt;
&lt;figure&gt;
&lt;img src="/media/IMG_1759.JPG" width="300"&gt;
&lt;figcaption&gt; &lt;a href="http://maps.google.com/maps?q=22 11 6.14N,159 40 45.12W&amp;t=k"&gt;map&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;


&lt;p&gt;
Now, in org-mode, I see the image in an overlay, and I can toggle it on and off. If I click on the image, it opens a browser to Google maps with a pin at the spot I took it. When I export it, it wraps the image in a &amp;lt;figure&amp;gt; tag, and puts a url in the caption to the map. If you click on it, and zoom out, you will see this is a picture of the Nāpali Coast on Kauai in Hawaii, and I was in fact out at sea when I took the picture. It was spectacular. Here is another one. This one is a little more obvious with the zoom. Here, I was on land. Since this link is bracketed, it does not show the overlay however in the org-file.
&lt;/p&gt;

&lt;p&gt;
&lt;figure&gt;
&lt;img src="/media/IMG_1749.JPG" width="300"&gt;
&lt;figcaption&gt;Another vacation picture, this time with a caption. &lt;a href="http://maps.google.com/maps?q=21 57 37.01N,159 21 6.72W&amp;t=k"&gt;map&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
Overall, this was easier than I expected. It might be faster to outsource reading the exif data to some dedicate library, perhaps in python that would return everything you want in an easy to parse json data structure. The speed of computing the url is only annoying when you export or click on the links though.
&lt;/p&gt;

&lt;p&gt;
I didn't build in any error handling, e.g. if you do this on a photo with no GPS data it will probably not handle it gracefully. I also haven't tested this on any other images, e.g. south of the equator, from other cameras, etc. I assume this exif data is pretty standard, but it is a wild world out there&amp;#x2026; It would still be nice to find a way to get a string representing the nearest known location somehow, that would help the caption be more useful.
&lt;/p&gt;

&lt;p&gt;
There is one little footnote to speak of, and that is I had to do a little hackery to get this to work with my blog machinery. You can see what it is in the org-source, I buried it in a noexport subheading, because it isn't that interesting in the grand scheme of things. It was just necessary because I export these org-files to blogofile, which then builds the html pages, instead of just exporting them. The images have to be copied to a source directory, and paths changed in the html to point to them. See, boring stuff. Otherwise, the code above should be fine for regular org and html files! Now, my vacation is over so it is time to get back to work.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/07/01/Getting-geo-tagged-information-from-photos-for-blogging.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>f-strings in emacs-lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2018/05/14/f-strings-in-emacs-lisp</link>
      <pubDate>Mon, 14 May 2018 17:27:42 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[elisp]]></category>
      <guid isPermaLink="false">fy7uCq1luP3IH-u2u_WegS14a4Q=</guid>
      <description>f-strings in emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am a big fan of f-strings in Python 3. They let you put variable names and expressions in a string template that get expanded to create new strings. Here is a simple example of using those:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;username&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'John Kitchin'&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;somevar&lt;/span&gt; = 5**0.5
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{username:30s}{somevar:1.2f}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24


&lt;/pre&gt;

&lt;p&gt;
String formatting in emacs-lisp is by comparison not as fun and easy. Out of the box we have:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (format &lt;span style="color: #008000;"&gt;"%-30s%1.2f"&lt;/span&gt; username somevar))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24

&lt;/pre&gt;

&lt;p&gt;
That is still three lines of code, but it is ugly and hard to read like the old python code:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'%-30s%1.2f'&lt;/span&gt; % (username, somevar))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24


&lt;/pre&gt;


&lt;p&gt;
My experience has shown that this gets harder to figure out as the strings get larger, and f-strings are easier to read.
&lt;/p&gt;

&lt;p&gt;
The wonderful &lt;a href="https://github.com/magnars/s.el"&gt;'s&lt;/a&gt; library provides some salvation for emacs-lisp, if you don't want the format fields. You can refer to variables in a lexical environment like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (&lt;span style="color: #0000FF;"&gt;s-lex-format&lt;/span&gt; &lt;span style="color: #008000;"&gt;"${username}${somevar}"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin2.23606797749979

&lt;/pre&gt;

&lt;p&gt;
Today, I decided to do something about this, and wrote this little macro. It is a variation on s-lex-format that introduces a slightly new syntax. You can now add an optional format field separated from the variable name by a space.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;f-string&lt;/span&gt; (fmt)
  &lt;span style="color: #036A07;"&gt;"Like `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;s-format&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' but with format fields in it.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;FMT is a string to be expanded against the current lexical&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;environment. It is like what is used in `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;s-lex-format&lt;/span&gt;&lt;span style="color: #036A07;"&gt;', but has&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;an expanded syntax to allow format-strings. For example:&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;${user-full-name 20s} will be expanded to the current value of&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;the variable `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;user-full-name&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' in a field 20 characters wide.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  (let ((f (sqrt 5)))  (f-string \"${f 1.2f}\"))&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  will render as: 2.24&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;This function is inspired by the f-strings in Python 3.6, which I&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;enjoy using a lot.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;"&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((matches (s-match-strings-all&lt;span style="color: #008000;"&gt;"${&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?3:&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?1:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt;} ]+&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt; *&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?2:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt;}]*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;}"&lt;/span&gt; fmt))
         (agetter (&lt;span style="color: #0000FF;"&gt;cl-loop&lt;/span&gt; for (m0 m1 m2 m3) in matches
                        collect `(cons ,m3  (format (format &lt;span style="color: #008000;"&gt;"%%%s"&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (string= ,m2 &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                                                      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; s-lex-value-as-lisp &lt;span style="color: #008000;"&gt;"S"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"s"&lt;/span&gt;)
                                                                   ,m2))
                                                  (symbol-value (intern ,m1)))))))

    `&lt;span style="color: #D0372D;"&gt;(s-format ,fmt &lt;/span&gt;'aget (list ,@agetter))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
f-string

&lt;/pre&gt;

&lt;p&gt;
Here it is in action.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (&lt;span style="color: #0000FF;"&gt;f-string&lt;/span&gt; &lt;span style="color: #008000;"&gt;"${username -30s}${somevar 1.2f}"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24

&lt;/pre&gt;

&lt;p&gt;
It still lacks some of the capability of f-strings in python, e.g. in Python, arguments inside the template to be expanded get evaluated. The solution used above is too simple for that, since it just used a regexp and is limited to the value of variables in the lexical environment.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{5**0.5:1.3f}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2.236


&lt;/pre&gt;

&lt;p&gt;
Nevertheless, this simple solution matches what I do most of the time anyway, so I still consider it an improvement!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/14/f-strings-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Making it easier to extend the export of org-mode links with generic functions</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions</link>
      <pubDate>Wed, 09 May 2018 19:49:14 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">6zitH1v5O3fSqcDJ8SfMByrxF7Q=</guid>
      <description>Making it easier to extend the export of org-mode links with generic functions</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am a big fan of org-mode links. Lately, I have had a need to modify how some links are exported, e.g. defining new exports for different backends, or fine-tuning a particular backend. This can be difficult, depending on how the link was set up. Here is a typical setup I am used to using, where the different options for the backends are handled in a conditional statement in a single function. I will just use a link that just serves to illustrate the issues here. These links are just sytactic sugar for markup, they don't do anything else. We start with an example that just converts text to italic text for different backends like html or latex.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-export&lt;/span&gt; (path desc backend)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq 'html backend)
    (format &lt;span style="color: #008000;"&gt;"&amp;lt;em&amp;gt;%s&amp;lt;/em&amp;gt;"&lt;/span&gt; path))
   ((eq 'latex backend)
    (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;fall-through case for everything else&lt;/span&gt;
   (t
    path)))

(org-link-set-parameters &lt;span style="color: #008000;"&gt;"italic"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'italic-link-export)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;:export&lt;/td&gt;
&lt;td class="org-left"&gt;italic-link-export&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'html t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;p&amp;gt;
&amp;lt;em&amp;gt;text&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'latex t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
\textit{text}

&lt;/pre&gt;

&lt;p&gt;
This falls through though to the default case.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ox-md&lt;/span&gt;)
(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'md t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

# Table of Contents



text


&lt;/pre&gt;

&lt;p&gt;
The point I want to make here is that this is not easy to extend as a user. You have to either modify the italic-link-export function, advise it, or monkey-patch it. None of these are especially nice.
&lt;/p&gt;

&lt;p&gt;
I could define italic-link-export in a way that it retrieves the function to use from an alist or hash-table using the backend, but then you have to do two things to modify the behavior: define a backend specific function &lt;i&gt;and&lt;/i&gt; register it in the lookup variable. It is also possible to just look up a function by a derived symbol, e.g. using fboundp, and then using funcall to execute it. This looks something like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;a user definable function for exporting to latex&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-export-latex&lt;/span&gt; (path desc backend)
  (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;generic export function that looks up functions or defaults to&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-exporter&lt;/span&gt; (path desc backend)
  &lt;span style="color: #036A07;"&gt;"Run `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;italic-link-export-BACKEND&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' if it exists, or return path."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((func (intern-soft (format &lt;span style="color: #008000;"&gt;"italic-link-export-%s"&lt;/span&gt; backend))))
    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (fboundp func)
        (funcall func path desc backend)
      path)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This has some indirection, but allows you to just define new functions to add new export backends, or replace single backend exports. It isn't bad, but there is room for improvement.
&lt;/p&gt;

&lt;p&gt;
In this &lt;a href="https://github.com/jkitchin/org-ref/issues/492#issuecomment-387806180"&gt;comment&lt;/a&gt; in org-ref, I saw a new opportunity to address this issue using generic functions in elisp! The idea is to define a generic function that handles the general export case, and then define additional functions for each specific backend based on the signature of the export function. I will switch to bold markup for this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defgeneric&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; (path desc backend)
 &lt;span style="color: #036A07;"&gt;"Generic function to export a bold link."&lt;/span&gt;
 path)

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this one runs when the backend is equal to html&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; ((path t) (desc t) (backend (eql html)))
 (format &lt;span style="color: #008000;"&gt;"&amp;lt;b&amp;gt;%s&amp;lt;/b&amp;gt;"&lt;/span&gt; path))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this one runs when the backend is equal to latex&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; ((path t) (desc t) (backend (eql latex)))
 (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))

(org-link-set-parameters &lt;span style="color: #008000;"&gt;"bold"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'bold-link-export)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;:export&lt;/td&gt;
&lt;td class="org-left"&gt;bold-link-export&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here it is in action:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'html t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;p&amp;gt;
some &amp;lt;b&amp;gt;text&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'latex t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This uses the generic function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ox-md&lt;/span&gt;)
(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'md t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

# Table of Contents



some text


&lt;/pre&gt;

&lt;p&gt;
The syntax for defining the generic function is pretty similar to a regular function. The specific methods are a little different since they have to provide the specific "signature" that triggers each method. Here we only differentiate on the type of the backend. It is nice these are all separate functions though. It makes it trivial to add new ones, and less intrusive to replace in my opinion.
&lt;/p&gt;

&lt;p&gt;
Generic functions have many other potential applications to replace functions that use lots of conditions to control flow, with a fall-through option at the end. You can learn more about them here: &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html"&gt;https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html&lt;/a&gt;. There is a lot more to them than I have illustrated here.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Overloading mathematical operators in elisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/07/23/Overloading-mathematical-operators-in-elisp</link>
      <pubDate>Sun, 23 Jul 2017 14:13:41 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[elisp]]></category>
      <guid isPermaLink="false">6wjMw9DC1Qi0d1qlZyaOfJiHcbA=</guid>
      <description>Overloading mathematical operators in elisp</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgccfe3c4"&gt;1. Addendum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In Python I am used to some simple idioms like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;([1, 2, 3] * 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;"ab"&lt;/span&gt; * 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
[1, 2, 3, 1, 2, 3]
ababab
&lt;/p&gt;

&lt;p&gt;
There is even such fanciness as defining operators for objects, as long as they have the appropriate dunder methods defined:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Point&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x = x
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y = y

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__str__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Point ({}, {})"&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__mul__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Point(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * a, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y * a)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__rmul__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Point(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * a, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y * a)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   
&lt;span style="color: #BA36A5;"&gt;p&lt;/span&gt; = Point(1, 1)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(p * 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(3 * p)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Point (2, 2)
Point (3, 3)
&lt;/p&gt;

&lt;p&gt;
Out of the box, these things are not possible in elisp. Operators like  * in elisp only take numbers or markers. We have a few options to change this. The worst option is to simply redefine these functions. That is bad because it is not reversible. We could define new functions that have the behavior we want, but then we lose the semantic meaning of "*" that we were aiming for. A better option is to &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html"&gt;advise&lt;/a&gt; these functions. This is reversible, because you can later unadvise them. Today we look at some strategies to do this.
&lt;/p&gt;

&lt;p&gt;
We will use "around" advise because it will let us bypass the original intent of the function when we want to, or use it when we do. First, we create a function that will be the advice and add it to the * function. This first draft won't actually change the behavior of *; if all the args are numbers or markers it will simply use the original function as before.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;dash&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))))

(advice-add '* &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; #'*--*-around)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Let's just confirm
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(* 1 2 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6

&lt;/pre&gt;

&lt;p&gt;
Now, we can start modifying our function to handle some other cases. Let's do the list and string first. The * function is variadic, but in these cases it makes sense to limit to two arguments. We need two cases for each type since we can write (* 2 list) or (* list 2). We also should create a fall-through case that raises an error to alert us we can't multiply things.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The original behavior&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create repeated copies of list&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) append (copy-list (first args))))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) append (copy-list (second args))))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make repeated string&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) concat (first args)))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) concat (second args)))

   (t
    (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"You cannot * %s"&lt;/span&gt; args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
*--*-around

&lt;/pre&gt;

&lt;p&gt;
Here is the new advice in action. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(list
 (* '(a b) 2)
 (* 2 '(c d))
 (* 2 &lt;span style="color: #008000;"&gt;"ab"&lt;/span&gt;)
 (* &lt;span style="color: #008000;"&gt;"cd"&lt;/span&gt; 2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;(a b a b)&lt;/td&gt;
&lt;td class="org-left"&gt;(c d c d)&lt;/td&gt;
&lt;td class="org-left"&gt;abab&lt;/td&gt;
&lt;td class="org-left"&gt;cdcd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That captures the spirit of overloading * for lists and strings. What about that object example? We have to make some assumptions here. Python looks for an uses a dunder &lt;span class="underline"&gt;&lt;span class="underline"&gt;mul&lt;/span&gt;&lt;/span&gt; method. We will assume a double dash method (&amp;#x2013;mul&amp;#x2013;) in a similar spirit. We have to modify the advice one final time. We just add a condition to check if one of the arguments is an eieio-object, and then call the &amp;#x2013;mul&amp;#x2013; function on the arguments.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"if every arg is a number do *, else do something else."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The original behavior&lt;/span&gt;
   ((-every? (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (numberp x) (markerp x))) args)
    (apply orig-fun args))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create repeated copies of list&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) append (copy-list (first args))))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) append (copy-list (second args))))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Make repeated string&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (second args) concat (first args)))

   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below (first args) concat (second args)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Handle object&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (eieio-object-p (first args))
             (numberp (second args)))
        (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (numberp (first args))
             (eieio-object-p (second args))))
    (apply '--mul-- args))

   (t
    (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"You cannot * %s"&lt;/span&gt; args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
*--*-around

&lt;/pre&gt;

&lt;p&gt;
Now, we can define a class and the &amp;#x2013;mul&amp;#x2013; function and show that our overloaded * function works. Note we can define two signatures of &amp;#x2013;mul&amp;#x2013; so it is not necessary to define an &amp;#x2013;rmul&amp;#x2013; in this case as it was with Python (although we still create two functions in the end).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;eieio&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defclass&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Point&lt;/span&gt; ()
  ((x &lt;span style="color: #006FE0;"&gt;:initarg&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;)
   (y &lt;span style="color: #006FE0;"&gt;:initarg&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--mul--&lt;/span&gt; ((p Point) a)
  (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) a) &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;) a)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--mul--&lt;/span&gt; (a (p Point))
  (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) a) &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; (* (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;) a)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;--str--&lt;/span&gt; ((p Point))
  (format &lt;span style="color: #008000;"&gt;"Point (%s, %s)"&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt;) (&lt;span style="color: #0000FF;"&gt;oref&lt;/span&gt; p &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt;)))

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((P (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Point (2, 2)&lt;/td&gt;
&lt;td class="org-left"&gt;Point (3, 3)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That is pretty awesome. Before going on, here is how you remove the advice:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(advice-remove '* '*--*-around)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This example has been pretty instructive. You have to handle overloading for all the intrinsic types. We did lists and strings here; you might also consider vectors. For objects, it looks like we can at least try using a generic method like &amp;#x2013;mul&amp;#x2013;. One detail I neglected to consider here is that * is natively variadic. For these special cases, we did not implement variadic versions. This isn't a feature of Python which uses infix notation, so every call is with two arguments. In some cases it might make sense to support variadic args, but that seems like a generally challenging thing to do. While (* "a" 2 3) might be expected to create a string of "aaaaaa", (* "a" 2 '(3)) doesn't make sense at all.
&lt;/p&gt;

&lt;p&gt;
It would be straightforward to extend this to other operators like '+ to concatenate strings, lists and vectors, or '- to remove chars or elements, including extensions to objects using double-dash functions like &amp;#x2013;add&amp;#x2013;, &amp;#x2013;subtract&amp;#x2013;, etc. Another nice idea might be to advise print to use &amp;#x2013;str&amp;#x2013; on objects.
&lt;/p&gt;

&lt;p&gt;
On the surface this looks useful so far. Python defines &lt;i&gt;a lot&lt;/i&gt; of dunder methods that cover all kinds of scenarios including logical comparisons, bit shifting, mod, incrementing operators, casting, comparisons, right/left operations, indexing and assignment, length and others. That would be a lot of advices. This approach is moderately tedious to expand though; you have to keep adding conditional cases. 
&lt;/p&gt;

&lt;p&gt;
An alternative to the big conditional statement used in the advice might be the use of a &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html"&gt;generic function&lt;/a&gt;. With this approach we define a generic function that just does multiplication by default. Then we define specific cases with specific signatures that are used for lists, strings, objects, etc. That is basically all our conditional above was doing, matching signatures and executing a chunk of code accordingly.
&lt;/p&gt;

&lt;p&gt;
Here is our default case that does the original behavior. We still use advice to apply the function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defgeneric&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"Generic multiply for when no specific case exists."&lt;/span&gt;
  (apply orig-fun args))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;*--*-around-generic&lt;/span&gt; (orig-fun &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  (apply 'generic-multiply orig-fun args))

(advice-add '* &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; #'*--*-around-generic)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That should just work as usual for regular multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(* 1 2 3 4)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
24

&lt;/pre&gt;

&lt;p&gt;
Sure enough it does. Now, we can define a specific method for a string. We need a specialized method for each signature, e.g. pre and post multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (s string) (n integer))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n concat s))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (s string))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n concat s))

(list
 (* &lt;span style="color: #008000;"&gt;"Ac"&lt;/span&gt; 2)
 (* 2 &lt;span style="color: #008000;"&gt;"Ad"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;AcAc&lt;/td&gt;
&lt;td class="org-left"&gt;AdAd&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That works fine, and we did not have to modify our original advice function at all! Next the  list:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (L list) (n integer))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n append (copy-list L)))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (L list))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i from 0 below n append (copy-list L)))

(list (* '(1 2) 2)
      (* 2 '(3 4)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That also works fine. Last, our class example. This should work on all objects I think (unless there is some way to make classes that do not inherit the default superclass).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (n integer) (obj eieio-default-superclass))
  (--mul-- n obj))

(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;generic-multiply&lt;/span&gt; ((orig-fun subr) (obj eieio-default-superclass) (n integer))
  (--mul-- n obj))

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((P (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Point (2, 2)&lt;/td&gt;
&lt;td class="org-left"&gt;Point (3, 3)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
This is a much better approach to extending the multiplication operator! If I continue this path in the future I would probably take this one.  This could be useful to make elisp more like some more popular contemporary languages like Python, as well as to add linear algebra like notation or mathematical operations on objects in elisp. It kind of feels like these operations ought to be generic functions to start with to make this kind of overloading easier from the beginning.  Functions like "*" are currently defined in the C source code though, maybe for performance reasons. It is not obvious what the consequences of making them generic might be.
&lt;/p&gt;

&lt;div id="outline-container-orgccfe3c4" class="outline-2"&gt;
&lt;h2 id="orgccfe3c4"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Addendum&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Christopher Wellons &lt;a href="http://disq.us/p/1kr76r9"&gt;pointed out&lt;/a&gt; an important limitation of advice: they don't work on byte-compiled functions. Let's see what he means. Here is a simple function that will just multiply a Point object by an integer:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;to-be-bytten&lt;/span&gt; (p1 n)
  (* p1 n))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
to-be-bytten

&lt;/pre&gt;

&lt;p&gt;
Here it is in action, and here it works fine.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(to-be-bytten (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1) 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[eieio-class-tag--Point 2 2]

&lt;/pre&gt;

&lt;p&gt;
Now, let's byte-compile that function and try it again:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(byte-compile 'to-be-bytten)

(&lt;span style="color: #0000FF;"&gt;condition-case&lt;/span&gt; err
    (to-be-bytten (Point &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:y&lt;/span&gt; 1) 2)
  ((&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; r)
   (message &lt;span style="color: #008000;"&gt;"Doh! Christopher was right. It did not work...\n%s"&lt;/span&gt; err)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Doh! Christopher was right. It did not work...
(wrong-type-argument number-or-marker-p [eieio-class-tag--Point 1 1])

&lt;/pre&gt;

&lt;p&gt;
So the advice is pretty limited since most of the functions in Emacs core are likely to be byte-compiled, and it might mean you have to redefine * completely, or define some new function that looks like it. Too bad, the advice was pretty easy! 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/23/Overloading-mathematical-operators-in-elisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Linear algebra in Emacs using MKL and dynamic modules</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules</link>
      <pubDate>Fri, 21 Jul 2017 15:48:05 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[dynamic-module]]></category>
      <guid isPermaLink="false">X4G6viEo2YxLzJFxbdbE-5aShLg=</guid>
      <description>Linear algebra in Emacs using MKL and dynamic modules</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbfb8d4e"&gt;1. Convenience functions to get array properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga1c9a60"&gt;2. Matrix multiplication&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf536480"&gt;2.1. 1d * 1d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org76f193d"&gt;2.2. 2d * 1d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org82cc641"&gt;2.3. 1d * 2d&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org0849c80"&gt;2.4. 2d * 2d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4a14b46"&gt;3. Summary thoughts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgba66efb"&gt;4. The module code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4be1bce"&gt;5. Elisp helper functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In a &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules/"&gt;previous post&lt;/a&gt; I integrated some linear algebra into Emacs using the GNU Scientific library and a dynamic module. In this post, I use a similar approach that uses the Intel MKL library in conjunction with some helper elisp functions to mimic the array broadcasting features in Numpy. I thought this might be easier and lead to at least a complementary set of functionalities.
&lt;/p&gt;

&lt;p&gt;
Note: I had to follow the directions &lt;a href="http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x"&gt;here&lt;/a&gt; to disable some security feature on my Mac so that it would use the MKL libraries. Thanks Apple.
&lt;/p&gt;

&lt;p&gt;
It is convenient to use vectors for the representation of arrays in Emacs because there are nice functions in the emacs-module.h for accessing vector properties. Also vectors sound closer to an array than a list. So what about array broadcasting, e.g. the way numpy lets you multiply a 2d array with a 1d array? If you multiply two arrays with size (m1, n1) * (m2, n2), it is required that the number of columns in the first array (n1) be equal to the number of rows in the second one (m2), and the resulting size of the array product will be (m1, n2). What should happen though when we have 1d array? This is neither a row or column vector itself, but we can treat as either one if we choose too. For example the vector [1 2 3] can be thought of as an array with the shape (1, 3), e.g. a single row with three columns, or (3, 1), i.e. three rows in a single column. We will build this capability into the module for convenience.
&lt;/p&gt;

&lt;p&gt;
I still find it moderately tedious to write c functions that take emacs arguments, transform them to c arguments, do some c computations, and convert the results back to emacs values. So, we only implement one c function for this that multiplies two 2d arrays together using the cblas_dgemm routine in the MKL library. Then, we will create a complementary elisp library that will provide some additional functionality to get the shapes of vector arrays, dimensions, and allow us to multiply 1d and 2d vectors together the same way Numpy does array broadcasting.
&lt;/p&gt;

&lt;p&gt;
The dynamic module code is listed in &lt;a href="#orgba66efb"&gt;The module code&lt;/a&gt;. The elisp code is listed in &lt;a href="#org4be1bce"&gt;Elisp helper functions&lt;/a&gt;.  In the following sections we just demonstrate how to use the results.
&lt;/p&gt;

&lt;div id="outline-container-orgbfb8d4e" class="outline-2"&gt;
&lt;h2 id="orgbfb8d4e"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Convenience functions to get array properties&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
I found it convenient to do array shape and dimension analysis in elisp before sending arrays to the dynamic module. The shape of an array is just the number of elements in each dimension. Here we look at a 2&amp;times; 3 array.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(vector-shape [[1 2 3]
               [3 4 5]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[2 3]

&lt;/pre&gt;

&lt;p&gt;
You see it returns a vector showing two rows and three columns. There are two convenience commands to get the number of rows (vector-nrows) and columns (vector-ncols). Here is one of them.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(vector-ncols [[1 2 3]
               [3 4 5]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orga1c9a60" class="outline-2"&gt;
&lt;h2 id="orga1c9a60"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Matrix multiplication&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The main problem we want to calculate is the matrix multiplication \(A\cdotB\) where \(A\) and \(B\) are either 1d vectors or 2d arrays. Here we examine several representative cases of matrix multiplication.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf536480" class="outline-3"&gt;
&lt;h3 id="orgf536480"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; 1d * 1d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;p&gt;
This is a simple dot-product that is actually calculated in elisp.
&lt;/p&gt;

&lt;p&gt;
\([1 1 1] \cdot [2 2 2] = 6\)
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(matrix-multiply [1 1 1] [2 2 2])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6.0

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
Note we get a float. That is because we initialize the sum with 0.0 to be consistent with all the other cases which are done with floats. dgemm is a double routine in MKL, which means it should return floats. Internally in the module, we cast all numbers as doubles for the multiplication.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org76f193d" class="outline-3"&gt;
&lt;h3 id="org76f193d"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; 2d * 1d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
This is a matrix multiplication that is typically like \(A b\) where \(b\) is a column vector. We return a 1d array as a result, rather than a 2d array of nrows and 1 column.
&lt;/p&gt;

&lt;p&gt;
\[ \left[\begin{array}{cc}
1 &amp; 2 \\
3 &amp; 4 \end{array}\right] 
\left [ \begin{array}{c}
1 \\ 1 \end{array}\right] = \left[\begin{array}{c}3\\7\end{array}\right]\]
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((A [[1 2]
          [3 4]])
      (b [1 1]))
  (matrix-multiply  A b))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[3.0 7.0]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org82cc641" class="outline-3"&gt;
&lt;h3 id="org82cc641"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; 1d * 2d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
This case is \(b A\) where \(b\) is a row vector. For example:
&lt;/p&gt;

&lt;p&gt;
\[\left[\begin{array}{cc}1 &amp; 1\end{array}\right]
\left[\begin{array}{cc} 1 &amp; 2\\ 3 &amp; 4\end{array}\right] = \left[\begin{array}{cc} 4 &amp; 6 \end{array}\right ]\]
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(matrix-multiply [1 1]
                 [[1 2]
                  [3 4]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[4.0 6.0]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
As with the previous case, we return a 1d vector result rather than a 2d array with 1 row and ncolumns.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org0849c80" class="outline-3"&gt;
&lt;h3 id="org0849c80"&gt;&lt;span class="section-number-3"&gt;2.4&lt;/span&gt; 2d * 2d&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
Finally we have the case of \(A B\). The number of columns in A must be the same as the number of rows in B, and the result has a size that is the number of rows in A and the number of columns in B. Here is one &lt;a href="http://www.sosmath.com/matrix/matrix1/matrix1.html"&gt;example&lt;/a&gt;:
&lt;/p&gt;

&lt;p&gt;
\[\left[\begin{array}{cc} 0 &amp; 1\\ 0 &amp; 0\end{array}\right]  
\left[\begin{array}{cc} 0 &amp; 0\\ 1 &amp; 0\end{array}\right]  
= \left[\begin{array}{cc} 1 &amp; 0\\ 0 &amp; 0\end{array}\right]  \]
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(matrix-multiply [[0 1]
                  [0 0]]
                 [[0 0]
                  [1 0]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[1.0 0.0] [0.0 0.0]]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
This example is adapted from &lt;a href="https://stackoverflow.com/questions/21547462/how-to-multiply-2-dimensional-arrays-matrix-multiplication"&gt;here&lt;/a&gt;. The correct answer is at the bottom of that page, and shown here.
&lt;/p&gt;

&lt;p&gt;
\[\left[\begin{array}{cccc} 1 &amp; 2 &amp; -2 &amp; 0 \\ -3 &amp; 4 &amp; 7 &amp; 2 \\ 6 &amp; 0 &amp; 3 &amp; 1\end{array}\right]  
\left[\begin{array}{cc} -1 &amp; 3 \\ 0 &amp; 9 \\ 1 &amp; -11 \\ 4 &amp; -5 \end{array}\right]
= \left[\begin{array}{cc} -3 &amp; 43 \\ 18 &amp; -60 \\ 4 &amp; -5\end{array}\right]    \]
&lt;/p&gt;

&lt;p&gt;
For readability we use temporary variables here, and pretty-print the result.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((A [[1 2 -2 0]
          [-3 4 7 2]
          [6 0 3 1]])
      (B [[-1 3]
          [0  9]
          [1 -11]
          [4 -5]]))
  (pp (matrix-multiply A B)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[-3.0 43.0]
 [18.0 -60.0]
 [1.0 -20.0]]

&lt;/pre&gt;

&lt;p&gt;
✓
&lt;/p&gt;

&lt;p&gt;
So, all these example work as we expect. The elisp function for matrix-multiply does a lot of work for you to make these cases work, including error checking for dimensional consistency.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4a14b46" class="outline-2"&gt;
&lt;h2 id="org4a14b46"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Summary thoughts&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
It was not any easier to write this dynamic module than the previous one I used with the Gnu Scientific Library. The approach and code are remarkably similar. In one way the GSL was easier to use; it worked out of the box, whereas I had to fiddle with a security option in my OS to get it to run MKL! My  Anaconda Python distribution must get around that somehow since it ships with an MKL compiled Numpy and scipy.
&lt;/p&gt;

&lt;p&gt;
The idea of using elisp for analysis of the inputs and making sure they are correct is a good one and helps prevent segfaults. Of course it is a good idea to write defensive c-code to avoid that too. Overall, this is another good example of expanding the capabilities of Emacs with a dynamic module.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgba66efb" class="outline-2"&gt;
&lt;h2 id="orgba66efb"&gt;&lt;a id="ID-45D04B39-1927-44ED-9402-E89D166AE8C8"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; The module code&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
The c-code is loosely adapted from &lt;a href="https://software.intel.com/en-us/node/529735"&gt;https://software.intel.com/en-us/node/529735&lt;/a&gt;. We do not implement the full dgemm behavior which is able to calculate \(C = \alpha A * B + \beta*C\). We set &amp;alpha;=1, and &amp;beta;=0 in this example. We should do some dimension checking here, but it is easier to do it in emacs in a helper function. As long as you use the helper function there should not be an issue, but it is possible to segfault Emacs if you use the module function incorrectly.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-c"&gt;&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;"emacs-module.h"&lt;/span&gt;
&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;"emacs-module-helpers.h"&lt;/span&gt;
&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;&amp;lt;mkl.h&amp;gt;&lt;/span&gt;

&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;plugin_is_GPL_compatible&lt;/span&gt;;

&lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #006699;"&gt;Fmkl_dgemm&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt;, &lt;span style="color: #6434A3;"&gt;ptrdiff_t&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;nargs&lt;/span&gt;, &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;args&lt;/span&gt;[], &lt;span style="color: #6434A3;"&gt;void&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;data&lt;/span&gt;)
{
  &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;A&lt;/span&gt;, *&lt;span style="color: #BA36A5;"&gt;B&lt;/span&gt;, *&lt;span style="color: #BA36A5;"&gt;C&lt;/span&gt;;
  &lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;m&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;n&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;k&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt;;
  &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;alpha&lt;/span&gt; = 1.0;
  &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;beta&lt;/span&gt; = 0.0;
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;These will be 2d vectors&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;M0&lt;/span&gt; = args[0]; &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;array 1 - A (m x k)&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;M1&lt;/span&gt; = args[1]; &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;array 2 - B (k x n)&lt;/span&gt;

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;I need to get the number of rows and columns of each one.&lt;/span&gt;
  m = env-&amp;gt;vec_size(env, M0);
  k  = 0;
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;We assume that we have a 2d array.&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;el1&lt;/span&gt; = env-&amp;gt;vec_get (env, M0, 0);
  k = env-&amp;gt;vec_size(env, el1);
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now we know A has dimensions (m, k)&lt;/span&gt;
 
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;el2&lt;/span&gt; = env-&amp;gt;vec_get (env, M1, 0);
  n = env-&amp;gt;vec_size(env, el2);
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now we know M1 had dimensions (k, n)&lt;/span&gt;
  
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now we have to build up arrays.&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;We are looking at a * b = c&lt;/span&gt;
  A = (&lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *)mkl_malloc( m*k*&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;( &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; ), 64 );
  B = (&lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *)mkl_malloc( k*n*&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;( &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; ), 64 );
  C = (&lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; *)mkl_malloc( m*n*&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;( &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; ), 64 );
  &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (A == &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt; || B == &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt; || C == &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt;) {
    printf( &lt;span style="color: #008000;"&gt;"\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"&lt;/span&gt;);
    mkl_free(A);
    mkl_free(B);
    mkl_free(C);
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1;
  }

  &lt;span style="color: #8D8D84;"&gt;//&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;populate A&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;row&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;ij&lt;/span&gt;;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; m; i++)
    {
      row = env-&amp;gt;vec_get(env, M0, i);
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; k; j++)
        {
          &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;get M0[i, j]&lt;/span&gt;
          ij = env-&amp;gt;vec_get(env, row, j);
          A[k * i + j] = extract_double(env, ij);
        }
    }

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;populate B&lt;/span&gt;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; k; i++)
    {
      row = env-&amp;gt;vec_get(env, M1, i);
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; n; j++)
        {         
          &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;get M0[i, j]&lt;/span&gt;
          ij = env-&amp;gt;vec_get(env, row, j);
          B[n * i + j] = extract_double(env, ij);
        }
    }

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;initialize C.  The solution will have dimensions of (rows1, cols2).&lt;/span&gt;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; m; i++)
    {
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; n; j++)
        {
          C[n * i + j] = 0.0;
        }
    }

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the multiplication is done here.&lt;/span&gt;
  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 
                m, n, k, alpha, A, k, B, n, beta, C, n);

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now we build up the vector to return&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;vector&lt;/span&gt; = env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"vector"&lt;/span&gt;);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;array&lt;/span&gt; = malloc(&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;(emacs_value) * m);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;row1&lt;/span&gt;;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;vec&lt;/span&gt;;
  &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0; i &amp;lt; m; i++)
    {
      row1 = malloc(&lt;span style="color: #0000FF;"&gt;sizeof&lt;/span&gt;(emacs_value) * n);
      &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;j&lt;/span&gt; = 0; j &amp;lt; n; j++)
        {
          row1[j] = env-&amp;gt;make_float(env, C[j + i * n]);
        }
      vec = env-&amp;gt;funcall(env, vector, n, row1);
      array[i] = vec;
      free(row1);
    }

  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;result&lt;/span&gt; = env-&amp;gt;funcall(env, vector, m, array);
  free(array);
  &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; result;
}


&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #006699;"&gt;emacs_module_init&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;struct&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;emacs_runtime&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;ert&lt;/span&gt;)
{
  &lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt; = ert-&amp;gt;get_environment(ert);
  
  DEFUN(&lt;span style="color: #008000;"&gt;"mkl-dgemm"&lt;/span&gt;, Fmkl_dgemm, 2, 2,
        &lt;span style="color: #008000;"&gt;"(mkl-dgemm A B)\n"&lt;/span&gt;\
        &lt;span style="color: #008000;"&gt;"Multiply the matrices A and B. A and B must both be 2d vectors.\n"&lt;/span&gt; \
        &lt;span style="color: #008000;"&gt;"Returns the product as a vector."&lt;/span&gt;,
        &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt;);
  provide(env, &lt;span style="color: #008000;"&gt;"mkl"&lt;/span&gt;);
  
  &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0;
}

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
To build this we have to run &lt;a href="org-babel-tangle"&gt;org-babel-tangle&lt;/a&gt; to generate the mkl.c file, and then run this shell block to compile it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;sh /opt/intel/mkl/bin/mklvars.sh intel64
gcc -Wall -m64 -I${&lt;span style="color: #BA36A5;"&gt;MKLROOT&lt;/span&gt;}/include -fPIC -c mkl.c
gcc -shared -L${&lt;span style="color: #BA36A5;"&gt;MKLROOT&lt;/span&gt;}/lib -Wl,-rpath,${&lt;span style="color: #BA36A5;"&gt;MKLROOT&lt;/span&gt;}/lib -lmkl_rt -lpthread -lm -ldl -L. -lemacs-module-helpers -o mkl.so mkl.o
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4be1bce" class="outline-2"&gt;
&lt;h2 id="org4be1bce"&gt;&lt;a id="ID-F5AEAF4E-317F-48D4-9815-8EB0331AF0E5"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; Elisp helper functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
We will often want to know the shape of our arrays. The shape is how many elements there are in each dimension. Here we define a recursive function that gets the shape of arbitrarily nested vectors and returns a vector of the shape. We define some helper functions to get the number of dimensions, elements, rows and columns.
&lt;/p&gt;

&lt;p&gt;
The main function is a helper elisp function that multiplies two arrays. The function analyzes the shapes and transforms 1d vectors into the right 2d shape to multiply them together, and then returns the shape that makes sense. The c-code is not very robust to mistakes in the array dimensions. It tends to make emacs segfault if you get it wrong. So we try to avoid that if possible.
&lt;/p&gt;

&lt;p&gt;
We have four cases to consider for multiplication:
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;2d * 2d&lt;/dt&gt;&lt;dd&gt;(assert (= m1 n2)) return (n1, m2)&lt;/dd&gt;
&lt;dt&gt;1d * 2d&lt;/dt&gt;&lt;dd&gt;1d is a row vector (1, n1) (assert (= n1 m2)) return vector with n2 elements&lt;/dd&gt;
&lt;dt&gt;2d * 1d&lt;/dt&gt;&lt;dd&gt;1d is a column vector (m2, 1) (assert (= n1 m2)) return vector with m2 elements&lt;/dd&gt;
&lt;dt&gt;1d * 1d&lt;/dt&gt;&lt;dd&gt;(assert (= (length m1) (length m2)) return a scalar&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;
Here is the 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;mkl&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;cl&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;seq&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-shape&lt;/span&gt; (vec)
  &lt;span style="color: #036A07;"&gt;"Return a vector of the shape of VEC."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((shape (vector (length vec))))
    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (vectorp (aref vec 0))
        (vconcat shape (vector-shape (aref vec 0)))
      shape)))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-ndims&lt;/span&gt; (vec)
  &lt;span style="color: #036A07;"&gt;"Returns the number of dimensions in VEC."&lt;/span&gt;
  (length (vector-shape vec)))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-numel&lt;/span&gt; (vec)
  &lt;span style="color: #036A07;"&gt;"Returns the number of elements in VEC."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&amp;gt; (length vec) 0)
      (seq-reduce '* (vector-shape vec) 1)
    0))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-nrows&lt;/span&gt; (vec)
 &lt;span style="color: #036A07;"&gt;"Return the number of rows in VEC."&lt;/span&gt;
 (aref (vector-shape vec) 0))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;vector-ncols&lt;/span&gt; (vec)
 &lt;span style="color: #036A07;"&gt;"Return the number of columns in VEC."&lt;/span&gt;
 (aref (vector-shape vec) 1))


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;matrix-multiply&lt;/span&gt; (A B)
  &lt;span style="color: #036A07;"&gt;"Return A * B in the matrix multiply sense."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;1d * 1d i.e. a dot-product&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 1 (vector-ndims A))
         (= 1 (vector-ndims B))
         (= (length A) (length B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this is easy to compute so we don't use dgemm.&lt;/span&gt;
    (seq-reduce '+ (mapcar* (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (a b) (* a b)) A B) 0.0))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;2d * 1d (m1, n1) * (n2, 1)&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 2 (vector-ndims A))
         (= 1 (vector-ndims B))
         &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;ncols-A = len-B&lt;/span&gt;
         (= (vector-ncols A) (length B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;transform B into a 2d column vector&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((B2d (apply 'vector (mapcar 'vector B)))
           (result  (mkl-dgemm A B2d)))
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Now call (dgemm A B2d) -&amp;gt; (m2, 1) column vector&lt;/span&gt;
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and convert it back to a 1d result&lt;/span&gt;
      (cl-map 'vector (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (v) (aref v 0)) result)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;1d * 2d (1, n1) * (m2, n2) len-A = nrows-B&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 1 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (length A) (vector-nrows B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;transform B into a 2d row vector&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((A2d (vector A))
           (result  (mkl-dgemm A2d B)))
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;should be a 2d row vector&lt;/span&gt;
      (aref result 0)))

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;2d * 2d (m1, n1) * (m2, n2) rows-A = ncols-B&lt;/span&gt;
   ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 2 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (vector-ncols A)
            (vector-nrows B)))
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;call (dgemm A B) and return result&lt;/span&gt;
    (mkl-dgemm A B))
   (t
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Error checking, getting here means none of the cases above were caught.&lt;/span&gt;
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;something is probably wrong.&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
     ((&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (&amp;gt; (vector-ndims A) 2)
          (&amp;gt; (vector-ndims B) 2))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"One of your arrays has more than 2 dimensions. Only 1 or 2d arrays are supported"&lt;/span&gt;))
     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (= 1 (vector-ndims A))
           (= 1 (vector-ndims B))
           (not (= (length A) (length B))))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"A and B must be the same length.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;len(A) = %d&lt;/span&gt;
&lt;span style="color: #008000;"&gt;len(B) = %d"&lt;/span&gt; (length A) (length B)))
     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt;
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 2)
       (not (= (vector-nrows A) (vector-ncols B))))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Your array shapes are not correct.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;The number of rows in array A must equal the number of columns in array B.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;There are %d rows in A and %d columns in B"&lt;/span&gt; (vector-nrows A) (vector-ncols B)))
     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt;
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 1)
       (not (= (vector-nrows A) (length B))))
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Your array shapes are not correct.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;The number of rows in array A must equal the number of columns in array B.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;There are %d rows in A and %d columns in B"&lt;/span&gt; (vector-nrows A) (length B)))
     (t
      (&lt;span style="color: #ff0000; font-weight: bold;"&gt;error&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Unknown error"&lt;/span&gt;))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
matrix-multiply

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>An Emacs zeromq library using an ffi</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi</link>
      <pubDate>Thu, 13 Jul 2017 06:44:23 EDT</pubDate>
      <category><![CDATA[zeromq]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[dynamic-module]]></category>
      <category><![CDATA[ffi]]></category>
      <guid isPermaLink="false">tsnBCsXNOCTT8zGYAUIAudNdiZg=</guid>
      <description>An Emacs zeromq library using an ffi</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org9367268"&gt;1. Summary thoughts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4003ff3"&gt;2. Modified ffi-define-function macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org77956c2"&gt;3. The zeromq bindings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
An alternative approach to writing your own dynamic module (which requires some proficiency in c) is to use a foreign function interface (ffi). There is one for emacs at &lt;a href="https://github.com/tromey/emacs-ffi"&gt;https://github.com/tromey/emacs-ffi&lt;/a&gt;, and it is also a dynamic module itself that uses &lt;a href="https://github.com/libffi/libffi"&gt;libffi&lt;/a&gt;. This lets you use elisp to create functions in Emacs that actually call functions in some other library installed on your system. Here, we use this module to recreate our zeromq bindings that I previously &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules/"&gt;posted&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The emacs-ffi module works fine as it is, but I found it useful to redefine one of the main macros (define-ffi-function) with the following goals in mind:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Allow me to specify the argument names and docstrings for each arg that contain its type and a description of the arg.&lt;/li&gt;
&lt;li&gt;Document what each function returns (type and description).&lt;/li&gt;
&lt;li&gt;Combine those two things into an overall docstring on the function.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
These are important to me because it allows Emacs to work at its fullest potential while writing elisp code, including having the right function signatures in eldoc, and easy access to documentation of each function. You can see the new definition &lt;a href="#org4003ff3"&gt;here&lt;/a&gt;. For example, here is a docstring for zmq-send using that new macro:
&lt;/p&gt;

&lt;pre class="example"&gt;
zmq-send is a Lisp function.

(zmq-send *SOCKET *MSG LEN FLAGS)

For more information check the manuals.

send a message part on a socket.
http://api.zeromq.org/4-2:zmq-send

*SOCKET (:pointer) Pointer to a socket.
*MSG (:pointer) Pointer to a C-string to send
LEN (:size_t) Number of bytes to send
FLAGS (:int) 

Returns: Number of bytes sent or -1 on failure. (:int)
&lt;/pre&gt;

&lt;p&gt;
That has everything you need to know
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-send-ori &lt;span style="color: #008000;"&gt;"zmq_send"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:size_t&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt;) zmq)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
zmq-send-ori

&lt;/pre&gt;

&lt;p&gt;
Compare that to this docstring from the original macro. 
&lt;/p&gt;

&lt;pre class="example"&gt;
zmq-send-ori is a Lisp function.

(zmq-send-ori G251 G252 G253 G254)

For more information check the manuals.
&lt;/pre&gt;

&lt;p&gt;
You can see the zeromq function definitions in elisp &lt;a href="#org77956c2"&gt;here&lt;/a&gt;. Here is a list of the functions we have created:
&lt;/p&gt;

&lt;pre class="example"&gt;
Type RET on a type label to view its full documentation.

zmq
  Function: Returns a pointer to the libzmq library.
zmq-close
  Function: close ØMQ socket.
zmq-connect
  Function: create outgoing connection from socket.
zmq-ctx-destroy
  Function: terminate a ØMQ context.
zmq-ctx-new
  Function: create new ØMQ context.
zmq-recv
  Function: receive a message part from a socket.
zmq-send
  Function: send a message part on a socket.
zmq-socket
  Function: create ØMQ socket.
&lt;/pre&gt;

&lt;p&gt;
Now we can use these to create the client, this time in elisp. Just as in the last post, you need to run the hwserver in a terminal for this to work. Here is the client code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ)))

  (&lt;span style="color: #0000FF;"&gt;with-ffi-string&lt;/span&gt; (endpoint &lt;span style="color: #008000;"&gt;"tcp://localhost:5555"&lt;/span&gt;)
    (zmq-connect socket endpoint))

  (&lt;span style="color: #0000FF;"&gt;with-ffi-string&lt;/span&gt; (msg &lt;span style="color: #008000;"&gt;"Hi there"&lt;/span&gt;)
    (zmq-send socket msg 5 0))

  (&lt;span style="color: #0000FF;"&gt;with-ffi-string&lt;/span&gt; (recv (make-string 10 &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))
    (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((status -1))
      (&lt;span style="color: #0000FF;"&gt;cl-loop&lt;/span&gt; do (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; status (zmq-recv socket recv 10 0)) until (not (= -1 status)))) 
    (print (ffi-get-c-string recv)))

  (zmq-close socket)
  (zmq-ctx-destroy context))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

"World     "

&lt;/pre&gt;

&lt;p&gt;
This client basically performs the same as the previously one we built. You can see we are mixing some programming styles here. For example, we have to create pointers to string variables in advance that the ffi will be writing to later like we would do in c. We use the with-ffi-string macro which frees the pointer when we are done with it. It basically just avoids me having to create, use, and destroy the pointers myself. So, there it is, a working elisp zeromq client!
&lt;/p&gt;


&lt;div id="outline-container-org9367268" class="outline-2"&gt;
&lt;h2 id="org9367268"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Summary thoughts&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
For this example, I feel like the ffi approach here (with my modified function making macro) was much easier than what I previously did with a compiled c-library (although it benefited a lot from my recent work on the c-library). I really like working in elisp, which is a much greater strength of mine than programming in c. It is pretty clear, however, that you have to know how c works to use this, otherwise it isn't so obvious that some functions will return a status, and do something by side effect, e.g. put results in one of the arguments. The signatures of the ffi functions are basically limited by the signatures of the c-functions. If you want to change the signature in Emacs, you have to write wrapper functions to do that.
&lt;/p&gt;

&lt;p&gt;
The macro I used here to create the functions creates really good (the kind I like anyway) docstrings when you use it fully. That isn't a totally new idea, I tried it out &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/"&gt;here&lt;/a&gt; before.  In contrast, the original version not only didn't have a docstring, but every arg had a gensym (i.e. practically random) name! I think it would be very difficult to get the same level of documentation when writing c-code to make a module. In the c-code, there is a decoupling of the definition of a c-function (which always has the same signature) that gets data from the Emacs env, e.g. arguments, does stuff with them, and creates data to put back into the env, and the emacs_module_init function where you declare these functions to Emacs and tell it what to call the function in emacs, about how many arguments it takes, etc&amp;#x2026; The benefit of this is you define what the Emacs signature will look like, and then write the c-function that does the required work. The downside of this is the c-function and Emacs declarations are often far apart in the editor, and there is no easy way to auto-generate docstrings like I can with lisp macros. You would have to manually build them up yourself, and keep them synchronized. Also, I still have not figured out how to get emacs to show the right signature for c-generated functions.
&lt;/p&gt;

&lt;p&gt;
The ffi approach still uses a dynamic module approach, so it still requires a modern Emacs with the module compiled and working. It still requires (in this case) the zeromq library to be installed on the system too. Once you have those, however, the elisp zeromq bindings by this approach is done &lt;i&gt;completely in elisp&lt;/i&gt;!
&lt;/p&gt;

&lt;p&gt;
It will be interesting in the coming weeks to see how this approach works with the GNU Scientific Library, particularly with arrays. Preliminary work shows that while the elisp ffi code is &lt;i&gt;much&lt;/i&gt; shorter and easier to write than the corresponding c-code for some examples (e.g. a simple mathematical function), it is not as fast. So if performance is crucial, it may still pay off to write the c-code.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4003ff3" class="outline-2"&gt;
&lt;h2 id="org4003ff3"&gt;&lt;a id="ID-A2B7F051-EA53-4882-A978-05FAD211BB81"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Modified ffi-define-function macro&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Here are two macros I modified to add docstrings and named arguments too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;define-ffi-library&lt;/span&gt; (symbol name)
  &lt;span style="color: #036A07;"&gt;"Create a pointer named to the c library."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((library (cl-gensym))
        (docstring (format &lt;span style="color: #008000;"&gt;"Returns a pointer to the %s library."&lt;/span&gt; name)))
    (set library nil)
    `(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; ,symbol ()
       ,docstring
       (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; ,library
           (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ,library (ffi--dlopen ,name))))))

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;define-ffi-function&lt;/span&gt; (name c-name return args library &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; docstring)
  &lt;span style="color: #036A07;"&gt;"Create an Emacs function from a c-function.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;NAME is a symbol for  the emacs function to create.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;C-NAME is a string of the c-function to use.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;RETURN is a type-keyword or (type-keyword docstring)&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;ARGS is a list of type-keyword or (type-keyword name &amp;amp;optional arg-docstring)&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;LIBRARY is a symbol usually defined by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;define-ffi-library&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;DOCSTRING is a string for the function to be created.&lt;/span&gt;

&lt;span style="color: #036A07;"&gt;An overall docstring is created for the function from the arg and return docstrings.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;"&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Turn variable references into actual types; while keeping&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;keywords the same.&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((return-type (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (keywordp return)
                          return
                        (car return)))
         (return-docstring (format &lt;span style="color: #008000;"&gt;"Returns: %s (%s)"&lt;/span&gt;
                                   (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (listp return)
                                       (second return)
                                     &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                   return-type))
         (arg-types (vconcat (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (arg)
                                       (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (keywordp arg)
                                           (symbol-value arg)
                                         &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;assume list (type-keyword name &amp;amp;optional doc)&lt;/span&gt;
                                         (symbol-value (car arg))))
                                     args)))
         (arg-names (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (arg)
                              (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (keywordp arg)
                                  (cl-gensym)
                                &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;assume list (type-keyword name &amp;amp;optional doc)&lt;/span&gt;
                                (second arg)))
                            args))
         (arg-docstrings (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (arg)
                                   (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
                                    ((keywordp arg)
                                     &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                    ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp arg) (= 3 (length arg)))
                                     (third arg))
                                    (t &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)))
                                 args))
         &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Combine all the arg docstrings into one string&lt;/span&gt;
         (arg-docstring (mapconcat 'identity
                                   (mapcar* (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (name type arg-doc)
                                              (format &lt;span style="color: #008000;"&gt;"%s (%s) %s"&lt;/span&gt;
                                                      (upcase (symbol-name name))
                                                      type
                                                      arg-doc))
                                            arg-names arg-types arg-docstrings)
                                   &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;))
         (&lt;span style="color: #0000FF;"&gt;function&lt;/span&gt; (cl-gensym))
         (cif (ffi--prep-cif (symbol-value return-type) arg-types)))
    (set function nil)
    `(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; ,name (,@arg-names)
       ,(concat docstring &lt;span style="color: #008000;"&gt;"\n\n"&lt;/span&gt; arg-docstring &lt;span style="color: #008000;"&gt;"\n\n"&lt;/span&gt; return-docstring)
       (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; ,function
         (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ,function (ffi--dlsym ,c-name (,library))))
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;FIXME do we even need a separate prep?&lt;/span&gt;
       (ffi--call ,cif ,function ,@arg-names))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
define-ffi-function

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org77956c2" class="outline-2"&gt;
&lt;h2 id="org77956c2"&gt;&lt;a id="ID-29C81B62-C0DF-44D4-AFE2-6EE239C70500"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; The zeromq bindings&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
These define the ffi functions we use in this post. I use a convention that pointer args start with a * so they look more like the c arguments. I also replace all _ with - so it looks more lispy, and the function names are easier to type.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ffi&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;define-ffi-library&lt;/span&gt; zmq &lt;span style="color: #008000;"&gt;"libzmq"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-ctx-new &lt;span style="color: #008000;"&gt;"zmq_ctx_new"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pointer to a context"&lt;/span&gt;)
  nil zmq
  &lt;span style="color: #008000;"&gt;"create new &amp;#216;MQ context.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-ctx-new"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-ctx-destroy &lt;span style="color: #008000;"&gt;"zmq_ctx_destroy"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"status"&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *context)) zmq
  &lt;span style="color: #008000;"&gt;"terminate a &amp;#216;MQ context.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-ctx-destroy"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-socket &lt;span style="color: #008000;"&gt;"zmq_socket"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pointer to a socket."&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *context &lt;span style="color: #008000;"&gt;"Created by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;zmq-ctx-new &lt;/span&gt;&lt;span style="color: #008000;"&gt;'."&lt;/span&gt;) (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; type)) zmq
  &lt;span style="color: #008000;"&gt;"create &amp;#216;MQ socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-socket"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-close &lt;span style="color: #008000;"&gt;"zmq_close"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Status"&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket &lt;span style="color: #008000;"&gt;"Socket pointer created by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;zmq-socket&lt;/span&gt;&lt;span style="color: #008000;"&gt;'"&lt;/span&gt;)) zmq
  &lt;span style="color: #008000;"&gt;"close &amp;#216;MQ socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-close"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-connect &lt;span style="color: #008000;"&gt;"zmq_connect"&lt;/span&gt; 
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Status"&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket &lt;span style="color: #008000;"&gt;"Socket pointer created by `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;zmq-socket&lt;/span&gt;&lt;span style="color: #008000;"&gt;'"&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *endpoint &lt;span style="color: #008000;"&gt;"Char pointer, e.g. (ffi-make-c-string \"tcp://localhost:5555\")"&lt;/span&gt;))
  zmq
  &lt;span style="color: #008000;"&gt;"create outgoing connection from socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-connect"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-send &lt;span style="color: #008000;"&gt;"zmq_send"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Number of bytes sent or -1 on failure."&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket &lt;span style="color: #008000;"&gt;"Pointer to a socket."&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *msg &lt;span style="color: #008000;"&gt;"Pointer to a C-string to send"&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:size_t&lt;/span&gt; len &lt;span style="color: #008000;"&gt;"Number of bytes to send"&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; flags)) 
  zmq
   &lt;span style="color: #008000;"&gt;"send a message part on a socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-send"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;define-ffi-function&lt;/span&gt; zmq-recv &lt;span style="color: #008000;"&gt;"zmq_recv"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Number of bytes received or -1 on failure."&lt;/span&gt;)
  ((&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *socket)
   (&lt;span style="color: #006FE0;"&gt;:pointer&lt;/span&gt; *buf &lt;span style="color: #008000;"&gt;"Pointer to c-string to put result in."&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:size_t&lt;/span&gt; len &lt;span style="color: #008000;"&gt;"Length to truncate message at."&lt;/span&gt;)
   (&lt;span style="color: #006FE0;"&gt;:int&lt;/span&gt; flags)) 
  zmq
   &lt;span style="color: #008000;"&gt;"receive a message part from a socket.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;http://api.zeromq.org/4-2:zmq-recv"&lt;/span&gt;)


&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;We cannot get these through a ffi because the are #define'd for the CPP and&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;invisible in the library. They only exist in the zmq.h file.&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defconst&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;ZMQ-REQ&lt;/span&gt; 3
  &lt;span style="color: #036A07;"&gt;"A socket of type ZMQ_REQ is used by a client to send requests&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  to and receive replies from a service. This socket type allows&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  only an alternating sequence of zmq_send(request) and&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  subsequent zmq_recv(reply) calls. Each request sent is&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  round-robined among all services, and each reply received is&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  matched with the last issued request."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/13/An-Emacs-zeromq-library-using-an-ffi.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Zeromq bindings for Emacs via dynamic modules</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules</link>
      <pubDate>Wed, 12 Jul 2017 07:38:28 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[dynamic-module]]></category>
      <guid isPermaLink="false">m-tZJML1FxAOUxMB7M7yJH946wc=</guid>
      <description>Zeromq bindings for Emacs via dynamic modules</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I do a lot of scientific programming, and it is one of the reasons I have been learning to extend Emacs with dynamic modules. They have allowed me to add physical constants, numerical integration, root finding and linear algebra from established c-libraries to Emacs. Today I am taking a break from that and finally getting to another one of the reasons I started playing around with dynamic modules: &lt;a href="http://zguide.zeromq.org/"&gt;zeromq&lt;/a&gt;. Zeromq is a messaging library that &lt;a href="http://jupyter-client.readthedocs.io/en/latest/messaging.html"&gt;Jupyter&lt;/a&gt; uses to communicate with kernels. I thought we might get a smoother integration with Emacs and Jupyter if we could use zeromq directly to communicate between org-mode and the kernel. Currently we have to run a web server that does the communication for us via http requests. We won't solve the Jupyter problem today, but we will look at communicating with a Zeromq server from Emacs.
&lt;/p&gt;

&lt;p&gt;
This might have lots of other useful applications. Suppose Emacs could communicate directly with other zeromq servers to retrieve data from, perhaps scientific data. It might even be possible for Emacs to run its own zeromq server, and other instances of Emacs could then communicate with it. Collaborative editing anyone? 
&lt;/p&gt;

&lt;p&gt;
Here we just implement the "Hello world" client example in the &lt;a href="http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive"&gt;zeromq guide&lt;/a&gt;. The code for the server, a c-client, the mod-zmq library, a makefile and tests can be found at &lt;a href="https://github.com/jkitchin/emacs-modules/tree/master/zeromq"&gt;https://github.com/jkitchin/emacs-modules/tree/master/zeromq&lt;/a&gt;. All the server does is receive a string, and then send a response (in this case just the string "World") back to the client. 
&lt;/p&gt;

&lt;p&gt;
To run this, make sure to run the hwserver executable in a terminal. I wrapped the  zeromq commands required to implement the client into a dynamic module. Since this example focuses on strings, the module returns strings to Emacs. I am not sure if that is always the right thing to do, as zeromq more generically uses bytes, but I will have to wait until I know more about zeromq to know if this is an issue. 
&lt;/p&gt;

&lt;p&gt;
This dynamic module uses a new feature that none of the previous posts used, and that is the user_ptr. These allow you to essentially return a reference pointer back to emacs that you can pass back to another function. That way they stay alive between function calls. For example, here we have to create a context and socket and pass these items to functions like zmq_send and zmq_recv.
&lt;/p&gt;

&lt;p&gt;
The directory this library is in is not on my path, so we load it like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;mod-zmq&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are the functions and their signatures that have been implemented so far. I only implemented the ones I needed for the client. The signatures may change in the future; this is just a proof of concept for now for the purpose of building the client.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(apropos-command &lt;span style="color: #008000;"&gt;"zmq*"&lt;/span&gt; t)
(&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"*Apropos*"&lt;/span&gt; (buffer-string))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Type RET on a type label to view its full documentation.

zmq-close
  Function: (zmq-close SOCKET)
zmq-connect
  Function: (zmq-connect SOCKET ENDPOINT)
zmq-ctx-destroy
  Function: (zmq-ctx-destroy CONTEXT)
zmq-ctx-new
  Function: (zmq-ctx-new)
zmq-recv
  Function: (zmq-recv SOCKET LEN FLAGS)
zmq-send
  Function: (zmq-send SOCKET BUF FLAGS)
zmq-socket
  Function: (zmq-socket CONTEXT TYPE)
&lt;/pre&gt;

&lt;p&gt;
You can see the c code for the client here: &lt;a href="/media/hwclient.c"&gt;hwclient.c&lt;/a&gt; . Here is a simple elisp version of the hwclient that basically does the same thing! The main difference is I added a while loop around the zmq-recv because sometimes it returns -1 and no result. So, here we loop until the return result is not -1. That seems to do the right thing.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ))
       (recv-ret -1)
       (result))

  (zmq-connect socket &lt;span style="color: #008000;"&gt;"tcp://localhost:5555"&lt;/span&gt;)
  (zmq-send socket &lt;span style="color: #008000;"&gt;"Hello"&lt;/span&gt; 0)

  (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (= recv-ret -1)
    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; result (zmq-recv socket 10 0)
          recv-ret (second result)))

  (print result)

  (zmq-close socket)
  (zmq-ctx-destroy context))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

("World" 5)

&lt;/pre&gt;

&lt;p&gt;
Basically this creates the context, then the socket, and connects to it on port 5555 of the localhost where the server is running. Then we send the string "Hello". The server returns the string "World" and tells us it sent 5 bytes. Then we close the socket and destroy the context. There is a lot of code in the module to make this happen. A lot of it is converting args in emacs functions to things we can use in c, running a few lines of zmq commands, and then code to convert those results back to emacs values. Finally, there is code to register each function and define docstrings for them. I am not totally convinced this is the best way to do this, but it does work! An alternative might be &lt;a href="https://github.com/tromey/emacs-ffi"&gt;emacs-ffi&lt;/a&gt;, which might enable most of this to be developed in just elisp. 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Adding linear algebra to Emacs with the GSL and dynamic modules</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules</link>
      <pubDate>Tue, 11 Jul 2017 10:27:13 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[dynamic-module]]></category>
      <guid isPermaLink="false">IJ-sF1scUy-uFWWiq6ST3-cuY6A=</guid>
      <description>Adding linear algebra to Emacs with the GSL and dynamic modules</description>
      <content:encoded><![CDATA[


&lt;p&gt;
The goal of this post is to be able to solve equations like this one:
&lt;/p&gt;

&lt;p&gt;
\[\left(\begin{array}{cccc}
 0.18&amp; 0.60&amp; 0.57&amp; 0.96 \\
 0.41&amp; 0.24&amp; 0.99&amp; 0.58 \\
 0.14&amp; 0.30&amp; 0.97&amp; 0.66 \\
 0.51&amp; 0.13&amp; 0.19&amp; 0.85 \end{array} \right ) 
\left ( \begin{array}{c} x_0 \\ x_1 \\ x_2 \\ x_3 \end{array} \right )
= \left ( \begin{array}{c} 1.0 \\ 2.0 \\ 3.0 \\ 4.0 \end{array} \right ) \]
&lt;/p&gt;

&lt;p&gt;
The answer is &lt;a href="https://www.gnu.org/software/gsl/doc/html/linalg.html#examples:"&gt;given&lt;/a&gt; as
&lt;/p&gt;

&lt;p&gt;
\[x = \left ( \begin{array}{c} -4.05205 \\ -12.6056 \\ 1.66091 \\ 8.69377 \end{array} \right ) \]
&lt;/p&gt;

&lt;p&gt;
The syntax we want to use is shown below, and we want it to return a vector containing the solution:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((A [[0.18 0.60 0.57 0.96]
          [0.41 0.24 0.99 0.58]
          [0.14 0.30 0.97 0.66]
          [0.51 0.13 0.19 0.85]])
      (b [1.0 2.0 3.0 4.0]))
  (gsl-linalg-LU-solve A b))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Rather than put all the code in here like I have for the past several posts, I started a git repo at &lt;a href="https://github.com/jkitchin/emacs-modules"&gt;https://github.com/jkitchin/emacs-modules&lt;/a&gt; that contains this code. 
&lt;/p&gt;


&lt;p&gt;
The module for this post can be found here: &lt;a href="https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c"&gt;https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c&lt;/a&gt;. There are a few notable features in it. First, I started writing/collecting &lt;a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c"&gt;some helper functions&lt;/a&gt; to make these modules simpler to write. For example, look how nice this looks to declare the functions and provide the feature.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-c"&gt;&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #006699;"&gt;emacs_module_init&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;struct&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;emacs_runtime&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;ert&lt;/span&gt;)
{
  &lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt; = ert-&amp;gt;get_environment(ert);
  
  DEFUN(&lt;span style="color: #008000;"&gt;"gsl-linalg-LU-solve"&lt;/span&gt;, Fgsl_linalg_LU_solve, 2, 2,
        &lt;span style="color: #008000;"&gt;"(gsl-linalg-LU-solve A b).\n"&lt;/span&gt; \
        &lt;span style="color: #008000;"&gt;"Solve A x = b for x.\n"&lt;/span&gt; \
        &lt;span style="color: #008000;"&gt;"Returns a vector containing the solution x."&lt;/span&gt;,
        &lt;span style="color: #D0372D;"&gt;NULL&lt;/span&gt;);
  provide(env, &lt;span style="color: #008000;"&gt;"gsl-linalg"&lt;/span&gt;);
  
  &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The DEFUN and provide function are defined in &lt;a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c"&gt;https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Within the module itself, we have to loop over the inputs to create the arrays that GSL wants to solve this problem. Second, after the solution is obtained, we have to build up a vector to return. The solution is in a gsl_vector, and we need to create an array of emacs_value elements containing each element of the gsl_vector as a float, and then create a vector to return to emacs. I use vectors here because it was easy to get the size of the b vector, which is also related to the size of the A matrix.
&lt;/p&gt;

&lt;p&gt;
The repo has a Makefile in it, so we can build this module with:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;make gsl-linalg.so
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Once it is compiled, we load it like this. In this post we are in the emacs-modules directory where the gsl-linalg.so library is, and it is not on my load-path, so I add it here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path (expand-file-name &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;))
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;gsl-linalg&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
gsl-linalg

&lt;/pre&gt;

&lt;p&gt;
Here is one function in the module:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(describe-function 'gsl-linalg-LU-solve)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
gsl-linalg-LU-solve is a Lisp function.

(gsl-linalg-LU-solve &amp;amp;rest ARGS)

For more information check the manuals.

(gsl-linalg-LU-solve A b).
Solve A x = b for x.
Returns a vector containing the solution x.

&lt;/pre&gt;

&lt;p&gt;
Now, we can solve linear equations like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(gsl-linalg-LU-solve
 [[0.18 0.60 0.57 0.96]
  [0.41 0.24 0.99 0.58]
  [0.14 0.30 0.97 0.66]
  [0.51 0.13 0.19 0.85]]
 [1.0 2.0 3.0 4.0])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[-4.052050229573973 -12.605611395906903 1.6609116267088417 8.693766928795227]

&lt;/pre&gt;


&lt;p&gt;
We have a limited ability to confirm this answer. I have written a function that uses blas for multiplication of 2d vectors. You can see from this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(gsl-blas-dgemm [[0.18 0.60 0.57 0.96]
                 [0.41 0.24 0.99 0.58]
                 [0.14 0.30 0.97 0.66]
                 [0.51 0.13 0.19 0.85]]
                [[-4.052050229573973]
                 [-12.605611395906903]
                 [1.6609116267088417]
                 [8.693766928795227]])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[[1.0] [1.9999999999999991] [2.9999999999999996] [4.0]]

&lt;/pre&gt;

&lt;p&gt;
That within float that indeed \(A x = b\).
&lt;/p&gt;

&lt;p&gt;
The main limitation of this module at the moment is that you have to use vectors; you cannot put in a list of numbers. It is possible to make it take lists and vectors, but for now I am leaving it at vectors. Also, it only produces solutions of float numbers (not integers).
&lt;/p&gt;

&lt;p&gt;
The module does not handle 1d vectors well,, e.g. in gsl-linalg-LU-solve example, the right hand side is implied to be a column vector, and we don't have the array broadcasting features of Python yet. Those are doable things for some future day perhaps. For now I am happy to have figured out how to handle arrays!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Adding GSL constants to Emacs in a dynamic module</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module</link>
      <pubDate>Mon, 10 Jul 2017 09:38:21 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[dynamic-module]]></category>
      <guid isPermaLink="false">42JNpUsNaZHMcgDxTF0Aq9-eEGU=</guid>
      <description>Adding GSL constants to Emacs in a dynamic module</description>
      <content:encoded><![CDATA[


&lt;p&gt;
The GNU Scientific Library defines a lot of &lt;a href="https://www.gnu.org/software/gsl/doc/html/const.html"&gt;physical constants&lt;/a&gt;. Since we are exploring how to make Emacs a more scientific environment to work in, it would be nice to import these constants to elisp. We do that through a dynamic module. This turned out to be tricky. I thought we could just use a funcall to defconst or defvar, but these are special forms and you cannot funcall them. @polizta on Stackoverflow &lt;a href="https://emacs.stackexchange.com/questions/34049/how-do-you-define-constants-in-an-emacs-dynamic-module/34063#34063"&gt;pointed me to the path&lt;/a&gt; that led to success: You make a list like '(defconst sym val doc) and then eval it. That can be funcall'd, and it works nicely in the module below. It is a growing theme that it takes much hacking around to figure out how to do things like this.
&lt;/p&gt;

&lt;p&gt;
The only other notable feature of this module is that I created a defconst function to make adding multiple constants less verbose. Here I only add two constants. There are about 408 constants defined in gsl_const_*.h, so brevity might be a good idea! Here is the module.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-c"&gt;&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;&amp;lt;gsl/gsl_const_mksa.h&amp;gt;&lt;/span&gt;
&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span style="color: #808080;"&gt;#include&lt;/span&gt; &lt;span style="color: #008000;"&gt;"emacs-module.h"&lt;/span&gt;

&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;plugin_is_GPL_compatible&lt;/span&gt;;

&lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;I assume here that all values will be double. I can't think of any that would&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;be ints&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;static&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;void&lt;/span&gt; &lt;span style="color: #006699;"&gt;defconst&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt;, &lt;span style="color: #0000FF;"&gt;const&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;char&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;name&lt;/span&gt;, &lt;span style="color: #6434A3;"&gt;double&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;value&lt;/span&gt;, &lt;span style="color: #0000FF;"&gt;const&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;char&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;doc&lt;/span&gt;)
{
  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;These are functions we will call&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;eval&lt;/span&gt; = env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"eval"&lt;/span&gt;);  
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;list&lt;/span&gt; = env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"list"&lt;/span&gt;);

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;These will make up the list we will eventally eval&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;fdefconst&lt;/span&gt; = env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"defconst"&lt;/span&gt;);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;sym&lt;/span&gt; = env-&amp;gt;intern(env, name);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;val&lt;/span&gt; = env-&amp;gt;make_float(env, value);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;sdoc&lt;/span&gt; = env-&amp;gt;make_string(env, doc, strlen(doc));

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;make a list of (defconst sym val doc)&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;largs&lt;/span&gt;[] = {fdefconst, sym, val, sdoc};
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;qlist&lt;/span&gt; = env-&amp;gt;funcall(env, list, 4, &amp;amp;largs);   

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now eval the list of symbols&lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;args&lt;/span&gt;[] = { qlist };  
  env-&amp;gt;funcall(env, eval, 1, &amp;amp;args);
}

&lt;span style="color: #6434A3;"&gt;int&lt;/span&gt; &lt;span style="color: #006699;"&gt;emacs_module_init&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;struct&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;emacs_runtime&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;ert&lt;/span&gt;)
{
  &lt;span style="color: #6434A3;"&gt;emacs_env&lt;/span&gt; *&lt;span style="color: #BA36A5;"&gt;env&lt;/span&gt; = ert-&amp;gt;get_environment(ert);

  defconst(env, &lt;span style="color: #008000;"&gt;"GSL-CONST-MKSA-SPEED-OF-LIGHT"&lt;/span&gt;,
           GSL_CONST_MKSA_SPEED_OF_LIGHT,
           &lt;span style="color: #008000;"&gt;"Speed of light in vacuum (m/s)."&lt;/span&gt;);
  
  defconst(env, &lt;span style="color: #008000;"&gt;"GSL-CONST-MKSA-PLANCKS-CONSTANT-H"&lt;/span&gt;,
           GSL_CONST_MKSA_PLANCKS_CONSTANT_H,
           &lt;span style="color: #008000;"&gt;"Plank's constant, h"&lt;/span&gt;);

  &lt;span style="color: #8D8D84;"&gt;// &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;This is what allows the shared library to provide a feature &lt;/span&gt;
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;provide&lt;/span&gt; = env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"provide"&lt;/span&gt;);
  &lt;span style="color: #6434A3;"&gt;emacs_value&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;provide_args&lt;/span&gt;[] = { env-&amp;gt;intern(env, &lt;span style="color: #008000;"&gt;"gsl-constants"&lt;/span&gt;) };
  env-&amp;gt;funcall(env, provide, 1, provide_args);
  
  &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 0;
}
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
Regular gcc will work to compile this module. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;rm -f gsl-constants.so gsl-constants.o
gcc -Wall -I/usr/local/include -fPIC -c gsl-constants.c
gcc -shared -L/usr/local/include -lgsl -o gsl-constants.so gsl-constants.o
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is in action. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(add-to-list 'load-path &lt;span style="color: #008000;"&gt;"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;gsl-constants&lt;/span&gt;)
GSL-CONST-MKSA-SPEED-OF-LIGHT
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
299792458.0

&lt;/pre&gt;

&lt;p&gt;
We can see there is a docstring on that constant:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(describe-variable 'GSL-CONST-MKSA-SPEED-OF-LIGHT)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
GSL-CONST-MKSA-SPEED-OF-LIGHT's value is 299792458.0


  This variable can be risky when used as a file-local variable.

Documentation:
Speed of light in vacuum (m/s).

For more information check the manuals.

&lt;/pre&gt;


&lt;p&gt;
It is worth thinking about what we accomplished here. The value of each constant in GSL is stored in a header file. The units are stored in a comment next to the value, and the documentation is in an html page somewhere. It is not easy to introspect that! Getting it all into an Emacs variable makes that more introspectable, and findable. That means while typing elisp code you will get completion on these variables. Check this out:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(apropos-variable &lt;span style="color: #008000;"&gt;"GSL-*"&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; &lt;span style="color: #008000;"&gt;"*Apropos*"&lt;/span&gt; (buffer-string))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Type RET on a type label to view its full documentation.

GSL-CONST-MKSA-PLANCKS-CONSTANT-H
  Variable: Plank's constant, h
GSL-CONST-MKSA-SPEED-OF-LIGHT
  Variable: Speed of light in vacuum (m/s).

&lt;/pre&gt;

&lt;p&gt;
It seems like it might be possible to partially automate creation of this module by parsing the gsl_const*.h files. There is no automating adding the doc strings though, I am pretty sure that will have to be done by hand ;(
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
