<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Thu, 09 Jul 2015 12:06:04 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Acronym minor mode for Emacs</title>
      <link>http://jkitchin.github.io/blog/2015/07/09/Acronym-minor-mode-for-Emacs</link>
      <pubDate>Thu, 09 Jul 2015 08:04:40 EDT</pubDate>
      <category><![CDATA[video]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[tooltip]]></category>
      <guid isPermaLink="false">vt7mEa2on8CD1Tjm4o_qa0Q0LKY=</guid>
      <description>Acronym minor mode for Emacs</description>
      <content:encoded><![CDATA[



<p>
Three letter acronyms (TLA) are pretty common, as are other kinds of acronyms, e.g. ferromagnetic (FM), anti-ferromagnetic (AFM), National Security Agency (NSA), even <a href="https://www.gnu.org/fun/jokes/gnuemacs.acro.exp.html">Escape-Meta-Alt-Control-Shift</a> (EMACS) etc&#x2026; in technical documents. As you get away from the definition, it can get hard to remember what they are, so here we develop a minor mode that will put a tooltip over acronyms that hopefully shows what they mean.
</p>

<p>
You can see this in action here: <a href="https://www.youtube.com/watch?v=2G2isMO6E2c">https://www.youtube.com/watch?v=2G2isMO6E2c</a> 
</p>

<p>
When we turn the mode on, it will scan the buffer looking for an acronym pattern, deduce its likely meaning, and put tooltips on every subsequent use of the acronym. The pattern we will look for is a sequence of uppercase letters surrounded by parentheses. We will assume that if we find N uppercase letters, that the previous N words contain the definition of the acronym. This is pretty approximate, but it is not likely to be that wrong. Then, we will use button-lock to put the tooltips on all subsequent instances of acronyms. We don't want flyspell interfering with the tooltips, so we remove the overlays if they are there.
</p>

<p>
Unlike previous examples where we just use button-lock, here we wrap the feature into a minor mode that you can turn on and off. Note, you cannot add new acronyms and have them have tooltips. You have to refresh the buttons.
</p>

<p>
Here is the minor mode code. We use the interesting rx package to build the regular expression. It is more verbose, but a little easier to read than a straight regexp like (concat "\\&lt;" (match-string 1) "\\&gt;") in my opinion.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(make-variable-buffer-local
  (<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*acronym-buttons*</span> '() <span style="color: #036A07;">"list of acronym buttons"</span>))

(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">rx</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">highlight-acronyms</span> ()
  (<span style="color: #0000FF;">save-excursion</span>
    (<span style="color: #0000FF;">let</span> ((case-fold-search nil))
      (goto-char (point-min))
      (<span style="color: #0000FF;">while</span> (re-search-forward <span style="color: #008000;">"(</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(</span><span style="color: #008000;">[A-Z]+</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">)"</span> nil t)
        (<span style="color: #0000FF;">when</span> flyspell-mode
          (flyspell-delete-region-overlays (match-beginning 1)
                                           (match-end 1)))
        (<span style="color: #0000FF;">let*</span> ((acronym (match-string 1))
               (p (point))
               (definition (<span style="color: #0000FF;">save-excursion</span>
                             (goto-char (match-beginning 1))
                             (backward-word (length acronym))
                             (buffer-substring (point) p))))
          (add-to-list '*acronym-buttons*
                       (button-lock-set-button
                        (<span style="color: #0000FF;">rx</span> word-start (eval (match-string 1)) word-end)
                        nil
                        <span style="color: #006FE0;">:help-echo</span> definition)))))))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">remove-acronym-buttons</span> ()
  (<span style="color: #0000FF;">dolist</span> (button *acronym-buttons*)
      (button-lock-unset-button button))
  (<span style="color: #0000FF;">setq</span> *acronym-buttons* '()))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">refresh-acronyms</span> ()
  <span style="color: #036A07;">"Refresh acronym tooltips in buffer."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (remove-acronym-buttons)
  (highlight-acronyms))


<span style="color: #8D8D84;">;;;</span><span style="color: #8D8D84; font-style: italic;">###</span><span style="color: #ff0000; font-weight: bold; font-style: italic;">autoload</span>
(<span style="color: #0000FF;">define-minor-mode</span> <span style="color: #006699;">acronym-mode</span>
  <span style="color: #036A07;">"Put definitions on acronyms."</span>
  <span style="color: #006FE0;">:lighter</span> <span style="color: #008000;">" AM"</span>
  (<span style="color: #0000FF;">if</span> acronym-mode
      (highlight-acronyms)
    (remove-acronym-buttons)))


(<span style="color: #0000FF;">provide</span> '<span style="color: #D0372D;">acronym-mode</span>)
</pre>
</div>

<pre class="example">
acronym-mode
</pre>

<p>
There it is. Now any time we have an acronym like EMACS we can mouse over it, or type C-h . on the acronym to see how it was previously defined. If you don't like it, you can turn it off!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/07/09/Acronym-minor-mode-for-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Indexing headlines in org files with swish-e with laser-sharp results</title>
      <link>http://jkitchin.github.io/blog/2015/07/06/Indexing-headlines-in-org-files-with-swish-e-with-laser-sharp-results</link>
      <pubDate>Mon, 06 Jul 2015 11:04:43 EDT</pubDate>
      <category><![CDATA[orgmode]]></category>
      <category><![CDATA[swishe]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">beCd3vQYB3XyqfQ8isHCXKvkCJk=</guid>
      <description>Indexing headlines in org files with swish-e with laser-sharp results</description>
      <content:encoded><![CDATA[



<p>
So far, it looks like swish-e is able to do some pretty focused searches on specific content types. However, the return results are not actually that sharp; in the way we have been using swish-e, it can only tell us the document path that matches, not where in the document the match is. To fix that, we need a new approach to what a "document" is, and a new approach to indexing. We will finally use the "-s prog" option in swish-e which runs an external program that prints stuff to stdout for swish-e to index. We will treat each headline in an org file as a "document" but rather than have the path to the file, we will put an org-mode link there that will take us right to the point of interest.
</p>

<p>
You can see this in action here: <a href="https://www.youtube.com/watch?v=bTwXtEb5Ng8">https://www.youtube.com/watch?v=bTwXtEb5Ng8</a> 
</p>

<p>
Basically, we need a program to output chunks like this for each headline in an org-file:
</p>
<pre class="example">
Path-Name: [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/ase-db.org") (goto-char 1))]]
Content-Length: 247
Document-Type: XML*

&lt;headline&gt;&lt;title&gt;Using the ase database module&lt;/title&gt;&lt;properties&gt;&lt;FILE&gt;/Users/jkitchin/blogofile-jkitchin.github.com/_blog/ase-db.org&lt;/FILE&gt;&lt;BLOCKED&gt;&lt;/BLOCKED&gt;&lt;categories&gt;python, ase&lt;/categories&gt;&lt;CATEGORY&gt;ase-db&lt;/CATEGORY&gt;&lt;/properties&gt;&lt;/headline&gt;
</pre>

<p>
Then we need to tell swish-e to run the program and index its output. Here is the program to do that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">:<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">exec emacs -batch -l $0 "$@"</span>
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">org</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">xml</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">cl</span>)

(add-to-list 'load-path <span style="color: #008000;">"~/Dropbox/kitchingroup/jmax/elpa/f-20140828.716"</span>)
(add-to-list 'load-path <span style="color: #008000;">"~/Dropbox/kitchingroup/jmax/elpa/s-20140910.334"</span>)
(add-to-list 'load-path <span style="color: #008000;">"~/Dropbox/kitchingroup/jmax/elpa/dash-20141201.2206"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">f</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">print-tag</span> (name attrs <span style="color: #6434A3;">&amp;optional</span> closingp)
  <span style="color: #036A07;">"Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).</span>
<span style="color: #036A07;">if CLOSINGP print the closing tag instead."</span>
  (format
   <span style="color: #008000;">"&lt;%s%s%s&gt;"</span>
   (<span style="color: #0000FF;">if</span> closingp <span style="color: #008000;">"/"</span> <span style="color: #008000;">""</span>)
   name
   (<span style="color: #0000FF;">if</span> (<span style="color: #0000FF;">and</span> attrs (not closingp))
       (concat
        <span style="color: #008000;">" "</span>
        (mapconcat
         (<span style="color: #0000FF;">lambda</span> (x)
           (format <span style="color: #008000;">"%s=\"%s\""</span>
                   (car x)
                   (xml-escape-string (cdr x))))
         attrs
         <span style="color: #008000;">" "</span>))
     <span style="color: #008000;">""</span>)))

(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">tag</span> (name attributes <span style="color: #6434A3;">&amp;rest</span> body)
  <span style="color: #036A07;">"macro to create an xml tag with NAME, ATTRIBUTES. BODY is executed in the tag."</span>
  `(format <span style="color: #008000;">"%s%s%s"</span>
           (print-tag ,name ,attributes nil)
           (concat
            ,@body)
           (print-tag ,name nil t)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">headline-xml</span> (headline)
  <span style="color: #036A07;">"Return xml representation of an element HEADLINE."</span>
  (<span style="color: #0000FF;">let</span> ((title (org-element-property <span style="color: #006FE0;">:title</span> headline))
        (properties (<span style="color: #0000FF;">save-excursion</span>
                      (goto-char
                       (org-element-property <span style="color: #006FE0;">:begin</span> headline))
                      (org-entry-properties))))
    (tag 'headline ()
         (tag 'title () (xml-escape-string (mapconcat 'identity title <span style="color: #008000;">" "</span>)))
         (<span style="color: #0000FF;">when</span> properties
           (tag 'properties ()
                (mapconcat
                 'identity
                 (<span style="color: #0000FF;">loop</span> for (p . v) in properties
                       collect (tag p () (xml-escape-string v)))
                 <span style="color: #008000;">""</span>))))))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">headline-document</span> (headline)
  <span style="color: #036A07;">"Return the headline \"document\" for swish-e to index."</span>
  (<span style="color: #0000FF;">let</span> ((xml (replace-regexp-in-string
              <span style="color: #008000;">"[</span><span style="color: #008000;">^</span><span style="color: #008000;">[:ascii:]]"</span> <span style="color: #008000;">""</span>
              (headline-xml headline))))
    (format <span style="color: #008000;">"Path-Name: [[elisp:(progn (find-file \"%s\") (goto-char %s) (show-children))][link]]</span>
<span style="color: #008000;">Content-Length: %s</span>
<span style="color: #008000;">Document-Type: XML*</span>

<span style="color: #008000;">%s"</span> (buffer-file-name)
(org-element-property <span style="color: #006FE0;">:begin</span> headline)
(length xml)
xml)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">process-file</span> (fname)
  <span style="color: #036A07;">"Print the `</span><span style="color: #D0372D;">headline-document</span><span style="color: #036A07;">' for each headline in FNAME."</span>
  (<span style="color: #0000FF;">with-current-buffer</span> (find-file-noselect fname)
    (mapconcat 'identity
               (org-element-map (org-element-parse-buffer)
                   'headline
                 (<span style="color: #0000FF;">lambda</span> (headline)
                   (princ (headline-document headline))))
               <span style="color: #008000;">""</span>)))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Here is the main work in the script.</span>
(<span style="color: #0000FF;">loop</span> for dir in '(<span style="color: #008000;">"/Users/jkitchin/blogofile-jkitchin.github.com/_blog"</span>)
      do
      (<span style="color: #0000FF;">loop</span> for fname in (f-entries
                          dir
                          (<span style="color: #0000FF;">lambda</span> (x)
                            (string=  <span style="color: #008000;">"org"</span>  (file-name-extension x)))
                          t)
            do (<span style="color: #0000FF;">ignore-errors</span>
                 (princ (process-file fname)))))
</pre>
</div>

<p>
Now we need a configuration file:
</p>

<div class="org-src-container">

<pre class="src src-text"># Example configuration file

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org-headlines.swish-e

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
</pre>
</div>


<p>
And we run the indexer, I did this in an actual shell. For some reason, it was not possible to run here. The output is pretty useful though, as it tells you what MetaNames are searchable.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -c swish-org-headlines.conf -S prog -i ./swish-org-headlines.el
</pre>
</div>

<pre class="example">
10:17 $ swish-e -c swish-org-headlines.conf -S prog -i ./swish-org-headlines.el
Indexing Data Source: "External-Program"
Indexing "./swish-org-headlines.el"
External Program found: ./swish-org-headlines.el
**Adding automatic MetaName 'headline' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'title' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'properties' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'file' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'blocked' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'categories' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'date' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'updated' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'category' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'points' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 1391) (show-children))][link]]'
**Adding automatic MetaName 'tags' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 25) (show-children))][link]]'
**Adding automatic MetaName 'alltags' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 25) (show-children))][link]]'
**Adding automatic MetaName 'todo' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 1733) (show-children))][link]]'
**Adding automatic MetaName 'closed' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 1733) (show-children))][link]]'
**Adding automatic MetaName 'timestamp_ia' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/pdfsync.org") (goto-char 28) (show-children))][link]]'
**Adding automatic MetaName 'id' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-to-docx-pandoc.org") (goto-char 5056) (show-children))][link]]'
**Adding automatic MetaName 'custom_id' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'calculation' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'volume' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'total_energy' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'stress' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'priority' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 15327) (show-children))][link]]'
**Adding automatic MetaName 'export_title' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'export_author' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'export_file_name' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'export_date' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'scheduled' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 516502) (show-children))][link]]'
**Adding automatic MetaName 'deadline' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 516502) (show-children))][link]]'
**Adding automatic MetaName 'votes' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 532031) (show-children))][link]]'
**Adding automatic MetaName 'timestamp' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 571125) (show-children))][link]]'
**Adding automatic MetaName 'clock' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 21059) (show-children))][link]]'
**Adding automatic MetaName 'level' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 46582) (show-children))][link]]'
**Adding automatic MetaName 'correct' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 46582) (show-children))][link]]'
**Adding automatic MetaName 'permalink' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61814) (show-children))][link]]'
**Adding automatic MetaName 'hint' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 340534) (show-children))][link]]'
**Adding automatic MetaName 'answer' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 355206) (show-children))][link]]'
**Adding automatic MetaName 'correct-answer' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 377210) (show-children))][link]]'
**Adding automatic MetaName 'post_filename' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 415454) (show-children))][link]]'
**Adding automatic MetaName 'ordered' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 423900) (show-children))][link]]'
**Adding automatic MetaName 'grade' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/add-subheadings-to-headings.org") (goto-char 2822) (show-children))][link]]'
**Adding automatic MetaName ':export_file_name:' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/add-properties-to-headings.org") (goto-char 2) (show-children))][link]]'
**Adding automatic MetaName 'firstname' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'lastname' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'email' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'affiliation' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'lettergrade' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-report/Slim-Shady-HW1.org") (goto-char 29) (show-children))][link]]'
**Adding automatic MetaName 'difficulty' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/problem-selection/problem-selection.org") (goto-char 1) (show-children))][link]]'
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 6,044 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: Complete
  Writing word hash: Complete
  Writing word data: Complete
6,044 unique words indexed.
4 properties sorted.
5,084 files indexed.  1,760,249 total bytes.  368,569 total words.
Elapsed time: 00:00:37 CPU time: 00:00:01
Indexing done!
</pre>


<p>
Ok, now for the proof in the approach!
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org-headlines.swish-e -w <span style="color: #BA36A5;">headline</span>=generating
</pre>
</div>

<p>
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/separate-bib.org") (goto-char 1) (show-children))">link</a> "separate-bib.org") (goto-char 1) (show-children))][link]]" 393
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 158456) (show-children))">link</a> "blog-2014.org") (goto-char 158456) (show-children))][link]]" 229
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 272383) (show-children))">link</a> "blog-2014.org") (goto-char 272383) (show-children))][link]]" 400
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 158456) (show-children))">link</a> "blog-2014.org") (goto-char 158456) (show-children))][link]]" 229
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 448965) (show-children))">link</a> "blog.org") (goto-char 448965) (show-children))][link]]" 389
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 575) (show-children))">link</a> "org-db.org") (goto-char 575) (show-children))][link]]" 204
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 575) (show-children))">link</a> "org-db.org") (goto-char 575) (show-children))][link]]" 204
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/separate-bib.org") (goto-char 1) (show-children))">link</a> "separate-bib.org") (goto-char 1) (show-children))][link]]" 393
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 272383) (show-children))">link</a> "blog-2014.org") (goto-char 272383) (show-children))][link]]" 400
.
</p>


<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org-headlines.swish-e -w <span style="color: #BA36A5;">todo</span>=TODO
</pre>
</div>

<p>
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 16933) (show-children))">link</a> "blog.org") (goto-char 16933) (show-children))][link]]" 342
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-children))">link</a> "blog-2014.org") (goto-char 61231) (show-children))][link]]" 207
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-children))">link</a> "blog-2014.org") (goto-char 60802) (show-children))][link]]" 274
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-children))">link</a> "blog-2014.org") (goto-char 60289) (show-children))][link]]" 207
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-children))">link</a> "blog-2014.org") (goto-char 61568) (show-children))][link]]" 246
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-children))">link</a> "blog-2014.org") (goto-char 61231) (show-children))][link]]" 207
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-children))">link</a> "blog-2014.org") (goto-char 60802) (show-children))][link]]" 274
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-children))">link</a> "blog-2014.org") (goto-char 60289) (show-children))][link]]" 207
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 632875) (show-children))">link</a> "blog.org") (goto-char 632875) (show-children))][link]]" 266
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 529123) (show-children))">link</a> "blog.org") (goto-char 529123) (show-children))][link]]" 202
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 529087) (show-children))">link</a> "blog.org") (goto-char 529087) (show-children))][link]]" 206
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 518108) (show-children))">link</a> "blog.org") (goto-char 518108) (show-children))][link]]" 280
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 30559) (show-children))">link</a> "blog.org") (goto-char 30559) (show-children))][link]]" 337
1000 <a href="(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-children))">link</a> "blog-2014.org") (goto-char 61568) (show-children))][link]]" 246
.
</p>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-1">
<p>
This could be super useful for a lot of different elements: headlines, src-blocks, links, tables, paragraphs are the main ones that come to mind. You could have pretty focused searches that go straight to the matches!</p>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/07/06/Indexing-headlines-in-org-files-with-swish-e-with-laser-sharp-results.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>An xml representation of an org document for indexing with swish-e</title>
      <link>http://jkitchin.github.io/blog/2015/07/04/An-xml-representation-of-an-org-document-for-indexing-with-swish-e</link>
      <pubDate>Sat, 04 Jul 2015 11:49:23 EDT</pubDate>
      <category><![CDATA[search]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">BoIIRNA4GbxSDyRrbkIUTNyhZ6A=</guid>
      <description>An xml representation of an org document for indexing with swish-e</description>
      <content:encoded><![CDATA[



<p>
Swish-e can index xml data, and enable searching by tag. Here we push our org-mode indexing idea a little further. Initially we indexed org files as text. Then, we exported it to html, and indexed the html. That enabled some richer searching. Now, we will create an xml representation of the org file for indexing. This will enable us to use a custom tag system and search for specific text in tables, or src-blocks, or in headlines, or for headlines with certain tags, todo state or properties.
</p>

<p>
Incidentally, this is a general strategy for indexing arbitrary files. You just make an xml representation of the file containing the data to be indexed, and use swish-e to index that xml.
</p>

<p>
Let us start with code to generate xml. I adapted this from some code in <a href="http://landoflisp.com">Land Of Lisp</a> . First, a function that simply prints a tag with attributes.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">print-tag</span> (name attrs <span style="color: #6434A3;">&amp;optional</span> closingp)
  <span style="color: #036A07;">"Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).</span>
<span style="color: #036A07;">if CLOSINGP print the closing tag instead."</span>
  (format
   <span style="color: #008000;">"&lt;%s%s%s&gt;"</span>
   (<span style="color: #0000FF;">if</span> closingp <span style="color: #008000;">"/"</span> <span style="color: #008000;">""</span>)
   name
   (<span style="color: #0000FF;">if</span> (<span style="color: #0000FF;">and</span> attrs (not closingp))
       (concat
        <span style="color: #008000;">" "</span>
        (mapconcat
         (<span style="color: #0000FF;">lambda</span> (x)
           (format <span style="color: #008000;">"%s=\"%s\""</span>
                   (car x)
                   (xml-escape-string (cdr x))))
         attrs
         <span style="color: #008000;">" "</span>))
     <span style="color: #008000;">""</span>)))

(print-tag 'html '((color . <span style="color: #008000;">"blue"</span>) (label . <span style="color: #008000;">"test"</span>)))
</pre>
</div>

<pre class="example">
&lt;html color="blue" label="test"&gt;
</pre>

<p>
XML tags almost always come in pairs. We define a macro to make this happen here. The macro prints the opening tag, evaluates the body, and prints the closing body. Note that the body may contain other tags, or a string. The string should be escaped to avoid illegal xml characters.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">tag</span> (name attributes <span style="color: #6434A3;">&amp;rest</span> body)
  `(format <span style="color: #008000;">"%s%s%s"</span>
           (print-tag ,name ,attributes nil)
           (concat
           ,@body)
           (print-tag ,name nil t)))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">example usage</span>
(<span style="color: #0000FF;">tag</span> <span style="color: #008000;">"xml"</span> '((test . <span style="color: #008000;">"id"</span>))
     (<span style="color: #0000FF;">tag</span> <span style="color: #008000;">"body"</span> nil
          (<span style="color: #0000FF;">tag</span> <span style="color: #008000;">"p"</span> nil (xml-escape-string <span style="color: #008000;">"paragraph &amp; &lt; 1"</span>))
          (<span style="color: #0000FF;">tag</span> <span style="color: #008000;">"p"</span> nil <span style="color: #008000;">"paragraph 2"</span>)))
</pre>
</div>

<pre class="example">
&lt;xml test="id"&gt;&lt;body&gt;&lt;p&gt;paragraph &amp;amp; &amp;lt; 1&lt;/p&gt;&lt;p&gt;paragraph 2&lt;/p&gt;&lt;/body&gt;&lt;/xml&gt;
</pre>

<p>
Now, we can use this to get an xml representation of the source blocks, e.g.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(mapconcat 'identity
           (org-element-map
               (org-element-parse-buffer)
               'src-block
             (<span style="color: #0000FF;">lambda</span> (element)
               (<span style="color: #0000FF;">tag</span>
                'src-block
                `((language . ,(org-element-property <span style="color: #006FE0;">:language</span> element)))
                (<span style="color: #0000FF;">tag</span> 'contents ()
                     (xml-escape-string
                      (org-element-property <span style="color: #006FE0;">:value</span> element))))))
           <span style="color: #008000;">""</span>)
</pre>
</div>

<pre class="example">
&lt;src-block language="emacs-lisp"&gt;&lt;contents&gt;(defun print-tag (name attrs &amp;amp;optional closingp)
  &amp;quot;Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead.&amp;quot;
  (format
   &amp;quot;&amp;lt;%s%s%s&amp;gt;&amp;quot;
   (if closingp &amp;quot;/&amp;quot; &amp;quot;&amp;quot;)
   name
   (if (and attrs (not closingp))
       (concat
	&amp;quot; &amp;quot;
	(mapconcat
	 (lambda (x)
	   (format &amp;quot;%s=\&amp;quot;%s\&amp;quot;&amp;quot;
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 &amp;quot; &amp;quot;))
     &amp;quot;&amp;quot;)))

(print-tag &amp;apos;html &amp;apos;((color . &amp;quot;blue&amp;quot;) (label . &amp;quot;test&amp;quot;)))
&lt;/contents&gt;&lt;/src-block&gt;&lt;src-block language="emacs-lisp"&gt;&lt;contents&gt;(defmacro tag (name attributes &amp;amp;rest body)
  `(format &amp;quot;%s%s%s&amp;quot;
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

(tag &amp;quot;xml&amp;quot; &amp;apos;((test . &amp;quot;id&amp;quot;))
     (tag &amp;quot;body&amp;quot; nil
	  (tag &amp;quot;p&amp;quot; nil (xml-escape-string &amp;quot;paragraph &amp;amp; &amp;lt; 1&amp;quot;))
	  (tag &amp;quot;p&amp;quot; nil &amp;quot;paragraph 2&amp;quot;)))
&lt;/contents&gt;&lt;/src-block&gt;&lt;src-block language="emacs-lisp"&gt;&lt;contents&gt;(mapconcat &amp;apos;identity
	   (org-element-map
	       (org-element-parse-buffer)
	       &amp;apos;src-block
	     (lambda (element)
	       (tag
		&amp;apos;src-block
		`((language . ,(org-element-property :language element)))
		(tag &amp;apos;contents ()
		     (xml-escape-string
		      (org-element-property :value element))))))
	   &amp;quot;&amp;quot;)
&lt;/contents&gt;&lt;/src-block&gt;&lt;src-block language="emacs-lisp"&gt;&lt;contents&gt;(let ((xml (tag &amp;apos;root `((filename . ,(buffer-file-name))
			(indexed-on . ,(current-time-string)))
		;; map the headlines
		(mapconcat
		 &amp;apos;identity
		 (org-map-entries
		  (lambda ()
		    (let* ((tags (org-get-tags))
			   (heading-components (org-heading-components))
			   (title (nth 4 heading-components))
			   (level (nth 0 heading-components))
			   (properties (org-entry-properties))
			   (elem (org-element-at-point))
			   (bp (org-element-property :contents-begin elem))
			   (ep (org-element-property :contents-end elem))
			   (content (buffer-substring bp ep)))
		      (tag &amp;apos;heading `((level . ,level))
			   (tag &amp;apos;title () (xml-escape-string title))
			   (tag &amp;apos;tags () (mapconcat &amp;apos;identity tags &amp;quot; &amp;quot;))
			   (tag &amp;apos;properties ()
				(mapconcat
				 (lambda (x)
				   (tag &amp;apos;property `((label . (car ,x))) (cdr x)))
				 properties
				 &amp;quot;&amp;quot;))
			   (tag &amp;apos;content ()
				(format &amp;quot;%s&amp;quot; (xml-escape-string content)))))))
		 &amp;quot;&amp;quot;)

		;; map specific element types
		(tag &amp;apos;source-blocks ()
		     (mapconcat
		      &amp;apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &amp;apos;src-block
			(lambda (element)
			  (tag &amp;apos;src-block
			       `((language .
					   ,(org-element-property
					     :language element)))
			       (tag &amp;apos;contents ()
				    (xml-escape-string
				     (org-element-property :value element)))))) &amp;quot;&amp;quot;))

		(tag &amp;apos;tables ()
		     (mapconcat
		      &amp;apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &amp;apos;table
			(lambda (element)
			  (tag &amp;apos;table ()
			       (when (org-element-property :caption element)
				 (tag &amp;apos;caption ()
				(caaar (org-element-property :caption element))))
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &amp;quot;&amp;quot;))

		(tag &amp;apos;paragraphs ()
		     (mapconcat
		      &amp;apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &amp;apos;paragraph
			(lambda (element)
			  (tag &amp;apos;paragraph ()
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &amp;quot;&amp;quot;
		      ))
		)))
  (with-temp-file &amp;quot;org2xml.xml&amp;quot;
    (insert xml)))
&lt;/contents&gt;&lt;/src-block&gt;&lt;src-block language="emacs-lisp"&gt;&lt;contents&gt;(xml-parse-file &amp;quot;org2xml.xml&amp;quot;)
&lt;/contents&gt;&lt;/src-block&gt;
</pre>

<p>
So, finally we can map the entries to get some information about them, e.g. the tags, properties, todo state, etc&#x2026; Then we create xml representing all that information so we can have a more precise search. Instead of looking for a word, we can specify that the word be in a property for example. Then, we make xml representations of the tables, src-blocks and paragraphs.
</p>

<p>
I am going to follow the example <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html/">here</a> that we worked out before on html and create a filter function that takes an org-file and spits out xml at the command line.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">:<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">exec emacs -batch -l $0 -f main "$@"</span>
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">org</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">xml</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">print-tag</span> (name attrs <span style="color: #6434A3;">&amp;optional</span> closingp)
  <span style="color: #036A07;">"Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).</span>
<span style="color: #036A07;">if CLOSINGP print the closing tag instead.</span>
<span style="color: #036A07;">You should use `</span><span style="color: #D0372D;">xml-escape-string</span><span style="color: #036A07;">' on text going into the attributes to avoid errors."</span>
  (format
   <span style="color: #008000;">"&lt;%s%s%s&gt;"</span>
   (<span style="color: #0000FF;">if</span> closingp <span style="color: #008000;">"/"</span> <span style="color: #008000;">""</span>)
   name
   (<span style="color: #0000FF;">if</span> (<span style="color: #0000FF;">and</span> attrs (not closingp))
       (concat
        <span style="color: #008000;">" "</span>
        (mapconcat
         (<span style="color: #0000FF;">lambda</span> (x)
           (format <span style="color: #008000;">"%s=\"%s\""</span> (car x) (cdr x)))
           attrs
           <span style="color: #008000;">" "</span>))
     <span style="color: #008000;">""</span>)))

(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">tag</span> (name attributes <span style="color: #6434A3;">&amp;rest</span> body)
  `(format <span style="color: #008000;">"%s%s%s"</span>
           (print-tag ,name ,attributes nil)
           (concat
           ,@body)
           (print-tag ,name nil t)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">main</span> ()
  (find-file (car command-line-args-left))
  (princ (<span style="color: #0000FF;">tag</span> 'root `((filename . ,(buffer-file-name))
                      (indexed-on . ,(current-time-string)))
              <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">map the headlines</span>
              (mapconcat
               'identity
               (org-map-entries
                (<span style="color: #0000FF;">lambda</span> ()
                  (<span style="color: #0000FF;">let*</span> ((tags (org-get-tags))
                         (heading-components (org-heading-components))
                         (todo (nth 2 heading-components))
                         (headline (nth 4 heading-components))
                         (thislevel (nth 0 heading-components))
                         (properties (org-entry-properties)))
                    (<span style="color: #0000FF;">tag</span> 'heading `((level . ,thislevel))
                         (<span style="color: #0000FF;">tag</span> 'headline () (xml-escape-string headline))
                         (<span style="color: #0000FF;">tag</span> 'tags () (mapconcat 'identity tags <span style="color: #008000;">" "</span>))
                         (<span style="color: #0000FF;">when</span> todo
                           (<span style="color: #0000FF;">tag</span> 'todo () todo))
                         (<span style="color: #0000FF;">tag</span> 'properties ()
                              (mapconcat
                               (<span style="color: #0000FF;">lambda</span> (x)
                                 (<span style="color: #0000FF;">tag</span> 'property `((name . ,(xml-escape-string (car x))))
                                      (xml-escape-string (cdr x))))
                               properties
                               <span style="color: #008000;">""</span>))))))
               <span style="color: #008000;">""</span>)

              <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">get file keywords, TITLE, authors, etc...</span>
              (<span style="color: #0000FF;">tag</span> 'file-keywords ()
                   (mapconcat 'identity
                              (org-element-map (org-element-parse-buffer 'element) 'keyword
                                (<span style="color: #0000FF;">lambda</span> (keyword)
                                  (<span style="color: #0000FF;">tag</span> (xml-escape-string (org-element-property <span style="color: #006FE0;">:key</span> keyword)) ()
                                       (xml-escape-string (org-element-property <span style="color: #006FE0;">:value</span> keyword)))))
                              <span style="color: #008000;">""</span>))

              <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">map specific element types</span>
              (<span style="color: #0000FF;">tag</span> 'source-blocks ()
                   (mapconcat
                    'identity
                    (org-element-map
                        (org-element-parse-buffer)
                        'src-block
                      (<span style="color: #0000FF;">lambda</span> (element)
                        (<span style="color: #0000FF;">tag</span> 'src-block
                             `((language .
                                         ,(org-element-property
                                           <span style="color: #006FE0;">:language</span> element)))
                             (<span style="color: #0000FF;">tag</span> 'contents ()
                                  (xml-escape-string
                                   (org-element-property <span style="color: #006FE0;">:value</span> element)))))) <span style="color: #008000;">""</span>))

              (<span style="color: #0000FF;">tag</span> 'tables ()
                   (mapconcat
                    'identity
                    (org-element-map
                        (org-element-parse-buffer)
                        'table
                      (<span style="color: #0000FF;">lambda</span> (element)
                        (<span style="color: #0000FF;">tag</span> 'table ()
                             (<span style="color: #0000FF;">when</span> (org-element-property <span style="color: #006FE0;">:caption</span> element)
                               (<span style="color: #0000FF;">tag</span> 'caption ()
                                    (format
                                     <span style="color: #008000;">"%s"</span>
                                     (org-element-property
                                      <span style="color: #006FE0;">:caption</span> element))))
                             (xml-escape-string
                              (buffer-substring
                               (org-element-property <span style="color: #006FE0;">:contents-begin</span> element)
                               (org-element-property <span style="color: #006FE0;">:contents-end</span> element))))))
                    <span style="color: #008000;">""</span>))

              (<span style="color: #0000FF;">tag</span> 'paragraphs ()
                   (mapconcat
                    'identity
                    (org-element-map
                        (org-element-parse-buffer)
                        'paragraph
                      (<span style="color: #0000FF;">lambda</span> (element)
                        (<span style="color: #0000FF;">tag</span> 'paragraph ()
                             (xml-escape-string
                              (buffer-substring
                               (org-element-property <span style="color: #006FE0;">:contents-begin</span> element)
                               (org-element-property <span style="color: #006FE0;">:contents-end</span> element))))))
                    <span style="color: #008000;">""</span>
                    )))))
</pre>
</div>

<p>
We could do more, e.g. links, or images, but this is pretty good for now. Now, let's configure a swish indexer. We instruct swish-e to use some metanames, and attributes so we can search on them later.
</p>

<div class="org-src-container">

<pre class="src src-text"># Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com/_site

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org2xml.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the HTML parser.
IndexContents XML* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/org2xml.el

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
</pre>
</div>

<p>
And now, run the index command. I did this at the command line. There might be some problems with the script as there were some warnings about non-zero exits, but there was only a few so we ignore them for now.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -c swish-org2xml.conf
</pre>
</div>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Examples of searching for org-files</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Files with words in the filename</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Here we look for filenames with the word "Extracting" in them.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w root.filename=Extracting
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: root.filename=Extracting
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/19/Extracting-bibtex-file-from-an-org-buffer.org "Extracting-bibtex-file-from-an-org-buffer.org" 6094
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
.
</pre>

<p>
Or, thanks to the date being in the path, we can find by year, How about July of 2012?
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w root.filename=<span style="color: #008000;">"(2012/07)"</span>
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: root.filename=(2012/07)
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2012/07/15/Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org "Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org" 311
.
</pre>

<p>
Interesting we have to use the parentheses here.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> <span class="done DONE">DONE</span> Files with headlines containing a word</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Now, lets find documents with "Compiled" in a heading title with level=2
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w heading.level=2 <span style="color: #BA36A5;">title</span>=Compiled -m5
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: heading.level=2 title=Compiled
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
.
</pre>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Headlines marked TODO</h3>
<div class="outline-text-3" id="text-1-3">
<p>
We can find documents with headlines marked TODO:
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e  -w <span style="color: #008000;">"todo=TODO"</span> -m 5
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: todo=TODO
# Removed stopwords:
# Number of hits: 12
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-01-27-Clocking-your-time-in-org-mode/blog.org "blog.org" 134160
624 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/A-dynamic-snippet-for-a-task-due-7-days-from-now.org "A-dynamic-snippet-for-a-task-due-7-days-from-now.org" 2587
425 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/END.org "END.org" 1531
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/02/01/Handling-multiple-selections-in-helm.org "Handling-multiple-selections-in-helm.org" 3290
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/01/30/More-adventures-in-helm---more-than-one-action.org "More-adventures-in-helm---more-than-one-action.org" 3236
.
</pre>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> For a table</h3>
<div class="outline-text-3" id="text-1-4">
<p>
so2-capacity-1
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w <span style="color: #BA36A5;">table</span>=<span style="color: #008000;">"energy"</span>
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: table=energy
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
633 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/07/04/Estimating-uncertainties-in-equations-of-state.org "Estimating-uncertainties-in-equations-of-state.org" 3117
.
</pre>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Tagged headlines</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Find entries with a "slide" tag.
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w <span style="color: #008000;">"tags=slide"</span>
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: tags=slide
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
.
</pre>

<p>
Evidently there is one file where I talk about slides in org-show.
</p>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Headlines with a property</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Here I find documents with headlines that have thermodynamics in the property "categories".
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w <span style="color: #008000;">"property.label=categories property=thermodynamics"</span>
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: property.label=categories property=thermodynamics
# Removed stopwords:
# Number of hits: 10
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/01/Water-gas-shift-equilibria-via-the-NIST-Webbook.org "Water-gas-shift-equilibria-via-the-NIST-Webbook.org" 10789
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook.org "Gibbs-energy-minimization-and-the-NIST-webbook.org" 5441
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org "Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org" 6155
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/27/Reading-parameter-database-text-files-in-python.org "Reading-parameter-database-text-files-in-python.org" 3947
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org "The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org" 8230
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture.org "Calculating-a-bubble-point-pressure-of-a-mixture.org" 3203
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/15/The-equal-area-method-for-the-van-der-Waals-equation.org "The-equal-area-method-for-the-van-der-Waals-equation.org" 5737
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org "Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org" 5210
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions.org "Constrained-minimization-to-find-equilibrium-compositions.org" 5666
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/09/23/Generating-an-atomic-stoichiometric-matrix.org "Generating-an-atomic-stoichiometric-matrix.org" 3487
.
</pre>

<p>
That seems about right, according to <a href="http://kitchingroup.cheme.cmu.edu/categories.html">http://kitchingroup.cheme.cmu.edu/categories.html</a> there are 9 documents. I am not sure why they don't totally agree, but I can live with it.
</p>

<p>
Here are documents containing headlines with the property "TOTAL_ENERGY"
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w property.label=TOTAL_ENERGY
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: property.label=TOTAL_ENERGY
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
.
</pre>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Documents with a Python source block containing a word</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Find org files with diffusion in a python source block.
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w src-block.language=python -w src-block=diffusion
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: src-block.language=python src-block=diffusion
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.011 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/04/02/Transient-diffusion---partial-differential-equations.org "Transient-diffusion---partial-differential-equations.org" 3660
.
</pre>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> An org-file with a UUID</h3>
<div class="outline-text-3" id="text-1-8">
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w  <span style="color: #BA36A5;">property</span>=<span style="color: #008000;">"(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)"</span>
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: property=(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/11/23/Machine-gradable-quizzes-in-emacs+org-modex.org "Machine-gradable-quizzes-in-emacs+org-modex.org" 5743
.
</pre>

<p>
Interesting, again the parentheses are necessary to find a match. I think because of the dashes. The next example is similar, but finds an entry with that bibtex key in a CUSTOM_ID property.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f index-org2xml.swish-e -w  <span style="color: #BA36A5;">property</span>=<span style="color: #008000;">"(mantina-2008-first-princ)"</span>
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: property=(mantina-2008-first-princ)
# Removed stopwords:
# Number of hits: 1
# Search time: 0.000 seconds
# Run time: 0.010 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
.
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Summary</h2>
<div class="outline-text-2" id="text-2">
<p>
This is pretty cool. There are still some bugs to work out in the indexing filter I think, but this demonstrates you can index org-files, and have pretty refined searches to find your files. There is still some thinking to do on how to schedule an incremental indexing, and whether we need more or better metanames. The indexing is not fast, but that is probably because I am running this through a FileFilter, rather than the -s prog option in swish-e. This is super promising to me though. Imagine building an agenda from files found with TODO headlines in them; a global todo list! Or, grabbing contacts from wherever they are.  No more losing files you have not used in a while. Find all documents containing a citation. With some extra work, you could index links, citations, <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/07/02/Pyparsing-meets-Emacs-to-find-chemical-formulas/">chemical formulas</a> , or other types of identifiable content.
</p>

<p>
The logical conclusion of this work might be an ox-swish-e-xml export engine to render the org-file into xml, rather than the script I used here. It would be really great to get some refined output, e.g. rather than just get matching documents, get location information so you could open the document to the matching element. That might be out of reach for swish-e, but could be in reach for other programs like Sphinx that are more integrated with a database. There is a very interesting project here: <a href="https://github.com/wvxvw/sphinx-mode">https://github.com/wvxvw/sphinx-mode</a> to integrate org-mode with the Sphinx search (<a href="http://sphinxsearch.com">http://sphinxsearch.com</a> ) engine.
</p>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/07/04/An-xml-representation-of-an-org-document-for-indexing-with-swish-e.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Using swish-e to index org files as html</title>
      <link>http://jkitchin.github.io/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html</link>
      <pubDate>Fri, 03 Jul 2015 10:13:11 EDT</pubDate>
      <category><![CDATA[search]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">U7jBXWYU4qwe_jQjwLSQbUjMZ44=</guid>
      <description>Using swish-e to index org files as html</description>
      <content:encoded><![CDATA[



<p>
When we wrote about using swish-e <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/25/Integrating-swish-e-and-Emacs/">before</a> , we just indexed the org files as text. This worked pretty well, but we lost some resolution, e.g. being able to search for text in a headline. that is more possible if we index html or xml. So, here we try indexing the org files as html. It will be slower to index because we will filter each org file through a command that exports it to html, but hopefully it will be worth it for the enhanced search capability.
</p>

<p>
We will need a filter shell command that takes an org-file and spits out html. This command is shown as an <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/08/06/Writing-scripts-in-Emacs-lisp/">emacs-lisp script</a> here. This is a pretty bare bones export, and would lack the export of all my custom links from org-ref. I tried this, but org-ref outputs a lot of stuff to stdout when it loads, and unless I can figure out how to suppress that I don't want it here for now.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">:<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">exec emacs -batch -l $0 -f main "$@"</span>
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">org</span>)
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(add-to-list 'load-path "/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa")</span>
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(add-to-list 'load-path "/Users/jkitchin/Dropbox/kitchingroup/jmax/org-ref")</span>
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(setq package-user-dir "/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa")</span>
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(package-initialize)</span>
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(require 'org-ref)</span>
(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">main</span> ()
  (find-file (car command-line-args-left))
  (org-html-export-as-html nil nil nil t)
  (switch-to-buffer <span style="color: #008000;">"*Org HTML Export*"</span>)
  (print (buffer-string)))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Local Variables&#58;</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">mode: emacs-lisp</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">End:</span>
</pre>
</div>

<p>
We try it out here:
</p>

<div class="org-src-container">

<pre class="src src-sh">./org2html.el index-org-as-html.org
</pre>
</div>

<pre class="example">
"&lt;div id=\"table-of-contents\"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id=\"text-table-of-contents\"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=\"#sec-1\"&gt;1. Using swish-e to index org files as html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=\"outline-container-sec-1\" class=\"outline-2\"&gt;
&lt;h2 id=\"sec-1\"&gt;&lt;span class=\"section-number-2\"&gt;1&lt;/span&gt; Using swish-e to index org files as html&lt;/h2&gt;
&lt;div class=\"outline-text-2\" id=\"text-1\"&gt;
&lt;p&gt;
When we wrote about using swish-e &lt;a href=\"http://kitchingroup.cheme.cmu.edu/blog/2015/06/25/Integrating-swish-e-and-Emacs/\"&gt;before&lt;/a&gt;, we just indexed the org files as text. This worked pretty well, but we lost some resolution, e.g. being able to search for text in a headline. that is more possible if we index html or xml. So, here we try indexing the org files as html. It will be slower to index because we will filter each org file through a command that exports it to html, but hopefully it will be worth it for the enhanced search capability.
&lt;/p&gt;

&lt;p&gt;
We will need a filter shell command that takes an org-file and spits out html. This command is shown as an emacs-lisp script here. This is a pretty bare bones export, and would lack the export of all my custom links
&lt;/p&gt;

&lt;p&gt;
cite:dauenhauer-2006-renew
&lt;/p&gt;

&lt;div class=\"org-src-container\"&gt;

&lt;pre class=\"src src-emacs-lisp\"&gt;:;exec emacs -batch -l $0 -f main \"$@\"
(require 'org)
;(add-to-list 'load-path \"/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa\")
;(add-to-list 'load-path \"/Users/jkitchin/Dropbox/kitchingroup/jmax/org-ref\")
;(setq package-user-dir \"/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa\")
;(package-initialize)
;(require 'org-ref)
(defun main ()
  (find-file (car command-line-args-left))
  (org-html-export-as-html nil nil nil t)
  (switch-to-buffer \"*Org HTML Export*\")
  (print (buffer-string)))

;; Local Variables:
;; mode: emacs-lisp
;; End:
&lt;/pre&gt;
&lt;/div&gt;


&lt;div class=\"org-src-container\"&gt;

&lt;pre class=\"src src-sh\"&gt;./org2html.el index-org-as-html.org
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=\"org-src-container\"&gt;

&lt;pre class=\"src src-text\"&gt;# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/org2html.el

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
"
</pre>


<p>
I think that looks good. Now, let's configure a swish indexer.
</p>


<div class="org-src-container">

<pre class="src src-text"># Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the HTML parser.
IndexContents HTML* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/swish-org/org2html.el

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9

MetaNames class swishtitle
HTMLLinksMetaName links

PropertyNames author subjects

StoreDescription HTML &lt;body&gt;
</pre>
</div>

<p>
And now, run the index command. I did this at the command line. A lot of output! mostly not being able to fontify source blocks because htmlize was not on the path, and a bunch of attribute parsing errors, and a few utf-8 errors.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -c swish-org-html.conf
</pre>
</div>

<p>
And a test search for files with "selector" in a headline.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f index.swish-e -x <span style="color: #008000;">'%r\t%p\n'</span> -w selector -t h
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: selector
# Removed stopwords:
# Number of hits: 4
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000	/Users/jkitchin/blogofile-jkitchin.github.com/org/2015/03/14/A-helm-mu4e-contact-selector.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/03/14/A-helm-mu4e-contact-selector.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_deploy/org/2015/03/14/A-helm-mu4e-contact-selector.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org
.
</pre>


<p>
A phrase in a headline.
</p>
<div class="org-src-container">

<pre class="src src-sh">swish-e -f index.swish-e -x <span style="color: #008000;">'%r\t%p\n'</span> -w <span style="color: #008000;">"information for all documents"</span> -t h
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: information for all documents
# Removed stopwords:
# Number of hits: 5
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org
921	/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org
794	/Users/jkitchin/blogofile-jkitchin.github.com/org/2015/04/03/Getting-data-from-the-Scopus-API.org
794	/Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/04/03/Getting-data-from-the-Scopus-API.org
794	/Users/jkitchin/blogofile-jkitchin.github.com/_deploy/org/2015/04/03/Getting-data-from-the-Scopus-API.org
.
</pre>

<p>
Sweet. How about all documents containing this citation:
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f index.swish-e -x <span style="color: #008000;">'%r\t%p\n'</span> -w cite:kitchin-2004-modif-pt
</pre>
</div>

<pre class="example">
# SWISH format: 2.4.7
# Search words: cite:kitchin-2004-modif-pt
# Removed stopwords:
# Number of hits: 3
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	/Users/jkitchin/blogofile-jkitchin.github.com/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org
1000	/Users/jkitchin/blogofile-jkitchin.github.com/_deploy/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org
.
</pre>

<p>
Super nice.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/07/03/Using-swish-e-to-index-org-files-as-html.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Pyparsing meets Emacs to find chemical formulas</title>
      <link>http://jkitchin.github.io/blog/2015/07/02/Pyparsing-meets-Emacs-to-find-chemical-formulas</link>
      <pubDate>Thu, 02 Jul 2015 12:22:57 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">MmU-3J8XFG8NYK-iMnTKSYLmbjs=</guid>
      <description>Pyparsing meets Emacs to find chemical formulas</description>
      <content:encoded><![CDATA[



<p>
see the video: <a href="https://www.youtube.com/watch?v=sjxS9m8QCoo">https://www.youtube.com/watch?v=sjxS9m8QCoo</a> 
</p>

<p>
Today we expand the concepts of clickable text and merge an idea from Python with Emacs. Here we will use Python to find chemical formulas in the buffer, and then highlight them with Emacs.  We will use pyparsing to find the chemical formulas and then use them to create a pattern for button-lock. I chose this approach because regular expressions are hard to use on the most general kinds of chemical formulas, and a (possibly recursive) parser should be better equipped to handle this. I adapted an <a href="https://pyparsing.wikispaces.com/file/view/chemicalFormulas.py/31041705/chemicalFormulas.py">example</a> grammar to match simple chemical formulas, i.e. ones that do not have any parentheses, or charges different than + or -. I think something like this could be done in Emacs, but I am not as familiar with this kind of parsing in Emacs.
</p>

<p>
Basically, we treat a formula as a group of one or more Elements that have an optional number following them. Spoiler alert: This mostly works, but in the end I conclude there is a clear benefit to a markup language for chemical formulas. Here is an example usage of a parser:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">adapted from [[https://pyparsing.wikispaces.com/file/view/chemicalFormulas.py/31041705/chemicalFormulas.py]]</span>

<span style="color: #0000FF;">from</span> pyparsing <span style="color: #0000FF;">import</span> *

<span style="color: #BA36A5;">element</span> = oneOf( <span style="color: #008000;">"""H He Li Be B C N O F Ne Na Mg Al Si P S Cl</span>
<span style="color: #008000;">            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge</span>
<span style="color: #008000;">            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag</span>
<span style="color: #008000;">            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os</span>
<span style="color: #008000;">            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf</span>
<span style="color: #008000;">            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus</span>
<span style="color: #008000;">            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm</span>
<span style="color: #008000;">            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No"""</span> )

<span style="color: #BA36A5;">integer</span> = Word(nums)
<span style="color: #BA36A5;">elementRef</span> = Group(element + Optional(integer))
<span style="color: #BA36A5;">chemicalFormula</span> = (WordStart(alphas.upper())
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>      + OneOrMore(elementRef).leaveWhitespace()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>      + Optional(Or([Literal(<span style="color: #008000;">"-"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     Literal(<span style="color: #008000;">"+"</span>)]))
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>      + WordEnd(alphas + nums + <span style="color: #008000;">"-+"</span>))


<span style="color: #BA36A5;">s</span> = <span style="color: #008000;">'''Water is  H2O or OH2  not h2O, methane is CH4 and of course there is PtCl4.</span>
<span style="color: #008000;">What about H+ and OH-? and carbon or Carbon or H2SO4?</span>

<span style="color: #008000;">Is this C6H6? or C2H5OH?</span>

<span style="color: #008000;">and a lot of elements:</span>
<span style="color: #008000;">H He Li Be B C N O F Ne Na Mg Al Si P S Cl</span>
<span style="color: #008000;">            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge</span>
<span style="color: #008000;">            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag</span>
<span style="color: #008000;">            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os</span>
<span style="color: #008000;">            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf</span>
<span style="color: #008000;">            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus</span>
<span style="color: #008000;">            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm</span>
<span style="color: #008000;">            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No'''</span>

<span style="color: #BA36A5;">matches</span> = []
<span style="color: #0000FF;">for</span> match, start, stop <span style="color: #0000FF;">in</span> chemicalFormula.scanString(s):
   matches.append(s[start:stop])

<span style="color: #0000FF;">print</span> <span style="color: #006FE0;">sorted</span>(matches, key=<span style="color: #0000FF;">lambda</span> x: <span style="color: #006FE0;">len</span>(x), reverse=<span style="color: #D0372D;">True</span>)
</pre>
</div>
<pre class="example">
['C2H5OH', 'PtCl4', 'H2SO4', 'C6H6', 'H2O', 'OH2', 'CH4', 'OH-', 'Uub', 'Uut', 'Uuq', 'Uup', 'Uuh', 'Uus', 'Uuo', 'H+', 'He', 'Li', 'Be', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'Cl', 'Ar', 'Ca', 'Sc', 'Ti', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'Xe', 'Cs', 'Ba', 'Lu', 'Hf', 'Ta', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Ac', 'Th', 'Pa', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'O', 'H', 'B', 'C', 'N', 'O', 'F', 'P', 'S', 'K', 'V', 'Y', 'I', 'W', 'U']
</pre>

<p>
That is pretty good. If the string was actually our buffer, we could use those to create a regexp to put text-properties on them. The trick is how to get the buffer string to the Python function, and then get back usable information in lisp. We actually explored this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/05/16/Python-data-structures-to-lisp/">before</a> ! Rather than use that, we will just create the lisp output manually since this is a simple list of strings.
</p>

<p>
The first thing we should do is work out a Python script that will output the lisp results we want, which are the found formulas (I tried getting the start and stop positions, but I don't think they map onto the buffer positions very well). Here it is. We set it up as a command line tool that takes a string. We use set to get a unique list, then sort the list by length so we try matching the longest patterns first. There are a few subtle differences in this script and the example above because of some odd false hits I unsuccessfully tried to get rid of.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> sys
<span style="color: #0000FF;">from</span> pyparsing <span style="color: #0000FF;">import</span> *

<span style="color: #BA36A5;">element_string</span> =  <span style="color: #008000;">"""H He Li Be B C N O F Ne Na Mg Al Si P S Cl</span>
<span style="color: #008000;">            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge</span>
<span style="color: #008000;">            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag</span>
<span style="color: #008000;">            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os</span>
<span style="color: #008000;">            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf</span>
<span style="color: #008000;">            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus</span>
<span style="color: #008000;">            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm</span>
<span style="color: #008000;">            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No"""</span>
<span style="color: #BA36A5;">element</span> = oneOf([x <span style="color: #0000FF;">for</span> x <span style="color: #0000FF;">in</span> element_string.split()])

<span style="color: #BA36A5;">integer</span> = Word(nums)
<span style="color: #BA36A5;">elementRef</span> = Group(element + Optional(integer))
<span style="color: #BA36A5;">chemicalFormula</span> = (WordStart(alphas.upper()).leaveWhitespace()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>      + OneOrMore(elementRef).leaveWhitespace()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>      + Optional(Or([Literal(<span style="color: #008000;">"-"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     Literal(<span style="color: #008000;">"+"</span>)])).leaveWhitespace()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>      + WordEnd(alphas + alphas.lower() + nums + <span style="color: #008000;">"-+"</span>).leaveWhitespace())

<span style="color: #BA36A5;">s</span> = sys.stdin.read().strip()

<span style="color: #BA36A5;">matches</span> = []
<span style="color: #0000FF;">for</span> match, start, stop <span style="color: #0000FF;">in</span> chemicalFormula.scanString(s):
   matches.append(s[start:stop])
<span style="color: #BA36A5;">matches</span> = <span style="color: #006FE0;">list</span>(<span style="color: #006FE0;">set</span>(matches))
matches.sort(key=<span style="color: #0000FF;">lambda</span> x: <span style="color: #006FE0;">len</span>(x), reverse=<span style="color: #D0372D;">True</span>)

<span style="color: #0000FF;">print</span> <span style="color: #008000;">"'("</span> + <span style="color: #008000;">' '</span>.join([<span style="color: #008000;">"\"{}\""</span>.<span style="color: #006FE0;">format</span>(m) <span style="color: #0000FF;">for</span> m <span style="color: #0000FF;">in</span> matches]) + <span style="color: #008000;">')'</span>
</pre>
</div>

<p>
Now we can test this:
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #006FE0;">echo</span> <span style="color: #008000;">"Water is H2O, methane is CH4 and of course PtCl4, what about H+ and OH-? and carbon or Carbon. Water is H2O not h2o or mH2o, methane is CH4 and of course PtCl4, what about H+ and OH-? carbon, Carbon and SRC, or H2SO4? Is this C6H6? Ethanol is C2H5OH in a sentence.</span>

<span style="color: #008000;"> C2H5OH firs con</span>

<span style="color: #008000;">This is CH3OH</span>

<span style="color: #008000;">H He Li Be B C N O F Ne Na Mg Al Si P S Cl</span>
<span style="color: #008000;">            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge</span>
<span style="color: #008000;">            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag</span>
<span style="color: #008000;">            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os</span>
<span style="color: #008000;">            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf</span>
<span style="color: #008000;">            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus</span>
<span style="color: #008000;">            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm</span>
<span style="color: #008000;">            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No</span>
<span style="color: #008000;">"</span> | ./parse_chemical_formulas.py
</pre>
</div>
<pre class="example">
'("C2H5OH" "CH3OH" "PtCl4" "H2SO4" "C6H6" "CH4" "OH-" "Uub" "Uuq" "Uup" "Uus" "Uuo" "Uuh" "H2O" "Uut" "Ru" "Re" "Rf" "Rg" "Ra" "Rb" "Rn" "Rh" "Be" "Ba" "Bh" "Bi" "Bk" "Br" "Ho" "Os" "Es" "Hg" "Ge" "Gd" "Ga" "Pr" "Pt" "Pu" "Pb" "Pa" "Pd" "Cd" "Po" "Pm" "Hs" "Hf" "He" "Md" "Mg" "Mo" "Mn" "Mt" "Zn" "H+" "Eu" "Zr" "Er" "Ni" "No" "Na" "Nb" "Nd" "Ne" "Np" "Fr" "Fe" "Fm" "Sr" "Kr" "Si" "Sn" "Sm" "Sc" "Sb" "Sg" "Se" "Co" "Cm" "Cl" "Ca" "Cf" "Ce" "Xe" "Tm" "Cs" "Cr" "Cu" "La" "Li" "Tl" "Lu" "Lr" "Th" "Ti" "Te" "Tb" "Tc" "Ta" "Yb" "Db" "Dy" "Ds" "Ac" "Ag" "Ir" "Am" "Al" "As" "Ar" "Au" "At" "In" "H" "P" "C" "K" "O" "S" "W" "B" "F" "N" "V" "I" "U" "Y")
</pre>

<p>
That seems to work great. Now, we have a list of chemical formulas. Now, the Emacs side to call that function. We do not use regexp-opt here because I found it optimizes too much, and doesn't always match the formulas. We want explicit matches on each formula.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">shell-command-on-region-to-string</span> (start end command)
  (<span style="color: #0000FF;">with-output-to-string</span>
    (shell-command-on-region start end command standard-output)))

(read (shell-command-on-region-to-string
        (point-min) (point-max)
        <span style="color: #008000;">"./parse_chemical_formulas.py"</span>))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">quote</td>
<td class="left">(C2H5OH ext; t CH3OH PtCl4 H2SO4 the   fir C6H6 CH4 OH- OH2 Uub  co Uuq Uup Uus Uuo Uuh ord H2O Uut Ru Re Rf Rg Ra Rb Rn Rh Be Ba Bh Bi Bk Br Ho Os Es Hg Ge Gd Ga Pr  t Pt Pu Pb Pa Pd Cd Po Pm Hs Hf He Md Mg Mo Mn Mt Zn H+ Eu Zr Er Ni No Na Nb Nd Ne Np Fr Fe Fm Sr Kr Si Sn Sm Sc Sb Sg Se Co Cm Cl Ca Cf Ce Xe Tm Cs Cr Cu La Li Tl Lu Lr Th Ti Te Tb Tc as Ta Yb Db Dy Ds In Ac Ag Ir Am Al As Ar Au At n H P l t C r K O S W w B F N V   I U Y e i)</td>
</tr>
</tbody>
</table>


<p>
That is certainly less than perfect, you can see a few false hits that are not too easy to understand, e.g. why is "fir" or "the " or "as"  in the list? They don't even start with an uppercase letter. One day maybe I will figure it out. I assume it is a logic flaw in my parser. Until then, let's go ahead and make the text functional, so it looks up the formula in the NIST webbook. The regexp is a little funny, we have to add word-boundaries to each formula to avoid some funny, bad matches.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">chemical-formula-button</span> nil <span style="color: #036A07;">"store button for removal later."</span>)

(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">nist-webbook</span>)
(<span style="color: #0000FF;">setq</span> chemical-formula-button
      (button-lock-set-button
       (mapconcat
        (<span style="color: #0000FF;">lambda</span> (formula)
          (concat <span style="color: #008000;">"\\&lt;"</span> (regexp-quote formula) <span style="color: #008000;">"\\&gt;"</span>))
        (eval (read (shell-command-on-region-to-string
                     (point-min) (point-max)
                     <span style="color: #008000;">"./parse_chemical_formulas.py"</span>)))
        <span style="color: #008000;">"</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">"</span>)
       (<span style="color: #0000FF;">lambda</span> () (<span style="color: #0000FF;">interactive</span>)
         (nist-webbook-formula
          (get-surrounding-text-with-property
           'chemical-formula)))
       <span style="color: #006FE0;">:face</span> '((<span style="color: #006FE0;">:underline</span> t) (<span style="color: #006FE0;">:background</span> <span style="color: #008000;">"gray80"</span>))
       <span style="color: #006FE0;">:help-echo</span> <span style="color: #008000;">"A chemical formula"</span>
       <span style="color: #006FE0;">:additional-property</span> 'chemical-formula))
</pre>
</div>

<p>
Here are a few tests: CH4, C2H5OH, C6H6. C(CH3)4. C6H6 is benzene. As you can see our pattern lacks context; the first word of the sentence is "as" not the symbol for arsenic. Also, our parser does not consider formulas with parentheses in them. Whenever I refer to myself, I mean myself, and not the element iodine. There are a few weird matchs I just don't understand, like firs d t x rn lac? These do not seem to match anything, and I wonder how they are getting in the list. I think this really shows that it would be useful to use some light markup for chemical formulas which would a) provide context, and b) enhance parsing accuracy. In LaTeX you would use \ce{I} to indicate that is iodine, and not a reference to myself. That is more clear than saying I use I in chemical reactions ;) And it also clarifies sentences like the letter W is used to represent tungsten as the symbol \ce{W}.
</p>

<p>
Nevertheless, we can click on the formulas, and get something to happen that is potentially useful. Is this actually useful? Conceptually yes, I think it could be, but clearly the parsing is not recognizing formulas perfectly. Sending the buffer to a dedicated program that can return a list of matches to highlight in Emacs is a good idea, especially if it is not easy to build in Emacs, or if a proven solution already exists.
</p>


<p>
Finally, we can remove the highlighted text like this. That was the reason for saving the button earlier!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">when</span> chemical-formula-button
  (button-lock-unset-button chemical-formula-button)
  (<span style="color: #0000FF;">setq</span> chemical-formula-button nil))
</pre>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/07/02/Pyparsing-meets-Emacs-to-find-chemical-formulas.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Spoken translations in Emacs</title>
      <link>http://jkitchin.github.io/blog/2015/07/01/Spoken-translations-in-Emacs</link>
      <pubDate>Wed, 01 Jul 2015 11:42:28 EDT</pubDate>
      <category><![CDATA[speech]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">Zp8xiJg6ES3-rUVGYiL6AXNY724=</guid>
      <description>Spoken translations in Emacs</description>
      <content:encoded><![CDATA[



<p>
Finally, continuing our experiments with computer speech for fun, let us try a translation of text to another language that is then spoken. Here is a free translator that has the courtesy to reply with json with the translated text in it. <a href="http://mymemory.translated.net/api/get?q=Hello%20World!&langpair=en|de">http://mymemory.translated.net/api/get?q=Hello%20World!&langpair=en|de</a> I had to download a German voice called Anna, then get some translated text.
</p>

<p>
As with previous posts, there is a video: <a href="https://www.youtube.com/watch?v=8CBKnahE0ak">https://www.youtube.com/watch?v=8CBKnahE0ak</a> . I am trying ScreenFlow for these (instead of Camtasia), and I still have not quite mastered the aspect ratio, so the videos still look a little odd.
</p>

<p>
As a reminder, we have this easy way to speak text in applescript. If you are on Linux, check out <a href="https://wiki.archlinux.org/index.php/Festival">Festival</a> and on windows you may find some inspiration <a href="http://stackoverflow.com/questions/1040655/ms-speech-from-command-line">here</a> .
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(do-applescript <span style="color: #008000;">"say \"Hello. My name is John. I am glad to meet you.\""</span>)
</pre>
</div>

<p>
You can retrieve json data of the translated text, and then we can use it in our <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/29/Getting-Emacs-to-read-to-me/">word-speak</a> function we previously developed. Here is an example in in German.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((words-voice <span style="color: #008000;">"Anna"</span>)
       (text <span style="color: #008000;">"Hello. My name is John. I am glad to meet you."</span>)
       (url (format <span style="color: #008000;">"http://mymemory.translated.net/api/get?q=%s!&amp;langpair=en|de"</span>
                    text))
       (json (<span style="color: #0000FF;">with-current-buffer</span>
                 (url-retrieve-synchronously url)
               (json-read-from-string
                (buffer-substring url-http-end-of-headers (point-max)))))
       (translated-text (cdr (assoc 'translatedText (cdr (assoc 'responseData json))))))
  (words-speak translated-text)
  translated-text)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #008000;">"Hallo. Mein Name ist John. Ich freue mich, Sie kennen zu lernen.!"</span>
</pre>
</div>


<p>
How about Chinese? Again, I downloaded a Chinese voice called "Ting-Ting".
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((words-voice <span style="color: #008000;">"Ting-Ting"</span>)
       (text <span style="color: #008000;">"Hello. My name is John. I am glad to meet you."</span>)
       (url (format <span style="color: #008000;">"http://mymemory.translated.net/api/get?q=%s!&amp;langpair=en|zh"</span>
                    text))
       (json (<span style="color: #0000FF;">with-current-buffer</span>
                 (url-retrieve-synchronously url)
               (json-read-from-string
                (buffer-substring url-http-end-of-headers (point-max)))))
       (translated-text (cdr (assoc 'translatedText (cdr (assoc 'responseData json))))))
  (words-speak translated-text)
  translated-text)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #008000;">"&#20320;&#22909;&#12290;&#25105;&#30340;&#21517;&#23383;&#26159;&#32422;&#32752;&#12290;&#25105;&#24456;&#39640;&#20852;&#35265;&#21040;&#20320;&#12290;!"</span>
</pre>
</div>

<p>
So, can any Chinese readers and listeners confirm if the text translates correctly, and if Ting-Ting said it correctly? Hopefully it is good enough to make some sense and be useful!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/07/01/Spoken-translations-in-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Get spoken definitions from the Meriam dictionary</title>
      <link>http://jkitchin.github.io/blog/2015/06/30/Get-spoken-definitions-from-the-Meriam-dictionary</link>
      <pubDate>Tue, 30 Jun 2015 11:26:41 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">7NMCEbkQYHE8R_G3lZIClQbLX1g=</guid>
      <description>Get spoken definitions from the Meriam dictionary</description>
      <content:encoded><![CDATA[


<p>
Now that I can get <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/29/Getting-Emacs-to-read-to-me/">Emacs to speak words</a> , here is a new application of the idea. We use it to speak the definition of the word at point. We look up the definition here:
<a href="http://www.dictionaryapi.com/account/index.htm">http://www.dictionaryapi.com/account/index.htm</a> 
</p>

<p>
You may want to head straight to the video to see how this works here: <a href="https://www.youtube.com/watch?v=m529gXMrXZA">https://www.youtube.com/watch?v=m529gXMrXZA</a> 
</p>


<p>
I had to get an API key for this. I suppose this key should be secret, but it could only be secure by obscurity in any kind of webapp and I don't anticipate using this much so here are the keys I got for the dictionary and thesaurus.
</p>

<p>
Key (Dictionary): 64f0950a-03b9-4315-9ba5-a73a964251ed
Key (Thesaurus): ff0e39e2-b31f-4f17-833c-24e2875aad5d
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">with-current-buffer</span>
    (url-retrieve-synchronously
     (format
      <span style="color: #008000;">"http://www.dictionaryapi.com/api/v1/references/collegiate/xml/%s?key=%s"</span>
      <span style="color: #008000;">"synchronous"</span>
      <span style="color: #008000;">"64f0950a-03b9-4315-9ba5-a73a964251ed"</span>))
  (buffer-substring url-http-end-of-headers (point-max)))
</pre>
</div>

<pre class="example">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;entry_list version="1.0"&gt;
</pre>
<p>
:        &lt;entry id="synchronous"&gt;&lt;ew&gt;synchronous&lt;/ew&gt;&lt;subj&gt;AE-4b#CP-5#TL-5&lt;/subj&gt;&lt;hw&gt;syn*chro*nous&lt;/hw&gt;&lt;sound&gt;&lt;wav&gt;synchr14.wav&lt;/wav&gt;&lt;wpr&gt;!siN-kru-nus&lt;/wpr&gt;&lt;/sound&gt;&lt;pr&gt;si-kr-ns, sin-&lt;/pr&gt;&lt;fl&gt;adjective&lt;/fl&gt;&lt;et&gt;Late Latin &lt;it&gt;synchronos,&lt;/it&gt; from Greek, from &lt;it&gt;syn-&lt;/it&gt; + &lt;it&gt;chronos&lt;/it&gt; time&lt;/et&gt;&lt;def&gt;&lt;date&gt;1669&lt;/date&gt; &lt;sn&gt;1&lt;/sn&gt; &lt;dt&gt;:happening, existing, or arising at precisely the same time&lt;/dt&gt; &lt;sn&gt;2&lt;/sn&gt; &lt;dt&gt;:recurring or operating at exactly the same periods&lt;/dt&gt; &lt;sn&gt;3&lt;/sn&gt; &lt;dt&gt;:involving or indicating &lt;fw&gt;synchronism&lt;/fw&gt;&lt;/dt&gt; &lt;sn&gt;4 a&lt;/sn&gt; &lt;dt&gt;:having the same period&lt;/dt&gt; &lt;sd&gt;also&lt;/sd&gt; &lt;dt&gt;:having the same period and phase&lt;/dt&gt;  &lt;sn&gt;b&lt;/sn&gt; &lt;dt&gt;:&lt;sx&gt;geostationary&lt;/sx&gt;&lt;/dt&gt; &lt;sn&gt;5&lt;/sn&gt; &lt;dt&gt;:of, used in, or being digital communication (as between computers) in which a common timing signal is established that dictates when individual bits can be transmitted and which allows for very high rates of data transfer&lt;/dt&gt;&lt;ss&gt;contemporary&lt;/ss&gt;&lt;/def&gt;&lt;uro&gt;&lt;ure&gt;syn*chro*nous*ly&lt;/ure&gt; &lt;fl&gt;adverb&lt;/fl&gt;&lt;/uro&gt;&lt;uro&gt;&lt;ure&gt;syn*chro*nous*ness&lt;/ure&gt; &lt;fl&gt;noun&lt;/fl&gt;&lt;/uro&gt;&lt;/entry&gt;
:        &lt;entry id="synchronous motor"&gt;&lt;ew&gt;synchronous motor&lt;/ew&gt;&lt;subj&gt;ME#EE&lt;/subj&gt;&lt;hw&gt;synchronous motor&lt;/hw&gt;&lt;fl&gt;noun&lt;/fl&gt;&lt;def&gt;&lt;date&gt;1897&lt;/date&gt;&lt;dt&gt;:an electric motor having a speed strictly proportional to the frequency of the operating current&lt;/dt&gt;&lt;/def&gt;&lt;/entry&gt;
</p>
<pre class="example">
&lt;/entry_list&gt;
</pre>

<p>
The idea is to query the url, get some xml back, and collect the definitions from it. Then, construct a string of the word, the number of definitions, then the definitions, and say it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">speak-definition</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let*</span> ((keyword (thing-at-point 'word))
         (api-key <span style="color: #008000;">"64f0950a-03b9-4315-9ba5-a73a964251ed"</span>)
         (xml (<span style="color: #0000FF;">with-current-buffer</span>
                  (url-retrieve-synchronously
                   (format
                    <span style="color: #008000;">"http://www.dictionaryapi.com/api/v1/references/collegiate/xml/%s?key=%s"</span>
                    keyword
                    api-key))
                (xml-parse-region url-http-end-of-headers (point-max))))
         (entries (xml-get-children (car xml) 'entry))
         (nentries (length entries))
         (defs (<span style="color: #0000FF;">loop</span> for entry in entries
                     collect (car (xml-get-children entry 'def))))
         (definition (format
                      <span style="color: #008000;">"%s"</span>
                      (concat
                       (format <span style="color: #008000;">"%s has %s definition%s. "</span>
                               keyword
                               nentries
                               (<span style="color: #0000FF;">if</span> (<span style="color: #0000FF;">or</span> (= 0 nentries)
                                       (&gt; nentries 1))
                                   <span style="color: #008000;">"s"</span>
                                 <span style="color: #008000;">""</span>))
                       (mapconcat
                        'identity
                        (<span style="color: #0000FF;">loop</span> for element in
                              (<span style="color: #0000FF;">loop</span> for def in defs
                                    collect (car (xml-get-children def 'dt)))
                              for i from 1
                              collect (format <span style="color: #008000;">"%s %s"</span> i (car (xml-node-children element))))
                        <span style="color: #008000;">" "</span>)))))
    (message definition)
    (do-applescript
     (format
      <span style="color: #008000;">"say \"%s\""</span> definition))))
</pre>
</div>

<pre class="example">
speak-definition
</pre>

<p>
Let us try this out on a few words: asynchronous  synchronous  flibbity
</p>

<p>
I guess this would be helpful sometimes ;)
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/30/Get-spoken-definitions-from-the-Meriam-dictionary.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Getting Emacs to read to me</title>
      <link>http://jkitchin.github.io/blog/2015/06/29/Getting-Emacs-to-read-to-me</link>
      <pubDate>Mon, 29 Jun 2015 14:56:16 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">DwYJChCDl8rIpuU18s40lLB6IzQ=</guid>
      <description>Getting Emacs to read to me</description>
      <content:encoded><![CDATA[



<p>
I thought it would be interesting to have Emacs read text on the screen. Why? Sometimes I get tired of reading ;) Seriously though, this has applications in accessibility, learning to read, translation, taking a break from looking at the screen, reading emails out loud, fun and games, etc&#x2026; Seems like a worthwhile endeavor!
</p>

<p>
You may want to see this video: <a href="https://www.youtube.com/watch?v=8bgS8yDSkXw">https://www.youtube.com/watch?v=8bgS8yDSkXw</a> to hear how it works.
</p>

<p>
On a Mac, it turns out to be easy to get a voice with a little applescript:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(do-applescript <span style="color: #008000;">"say \"Hello John\" using \"Victoria\""</span>)
</pre>
</div>

<p>
Interesting idea to integrate some feedback into Emacs-lisp functions! at least if you are on a Mac. All we need are some interactive functions that grab text, and pass them to the applescript with an appropriate amount of escaping any quotes and backslashes.
</p>

<p>
Here is a function to speak the word at point, or selected region, or the text passed to the function:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">words-voice</span> <span style="color: #008000;">"Vicki"</span>
  <span style="color: #036A07;">"Mac voice to use for speaking."</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">words-speak</span> (<span style="color: #6434A3;">&amp;optional</span> text)
  <span style="color: #036A07;">"Speak word at point or region. Mac only."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">unless</span> text
    (<span style="color: #0000FF;">setq</span> text (<span style="color: #0000FF;">if</span> (use-region-p)
                   (buffer-substring
                    (region-beginning) (region-end))
                 (thing-at-point 'word))))
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">escape some special applescript chars</span>
  (<span style="color: #0000FF;">setq</span> text (replace-regexp-in-string <span style="color: #008000;">"\\\\"</span> <span style="color: #008000;">"\\\\\\\\"</span> text))
  (<span style="color: #0000FF;">setq</span> text (replace-regexp-in-string <span style="color: #008000;">"\""</span> <span style="color: #008000;">"\\\\\""</span> text))
  (do-applescript
   (format
    <span style="color: #008000;">"say \"%s\" using \"%s\""</span>
    text
    words-voice)))
</pre>
</div>

<pre class="example">
words-speak
</pre>

<p>
Now we can write:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(words-speak <span style="color: #008000;">"Hello John"</span>)
</pre>
</div>

<p>
One reason I wrote this is to read org-files to me. So, now we write some functions to read words, sentences and paragraphs. These are all syntactic units in Emacs. We write code to enable us to read the next or previous units with the prefix args. Finally,  we bind the commands to some keys and a hydra for fun.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> sentence-end-double-space nil)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">mac-say-word</span> (<span style="color: #6434A3;">&amp;optional</span> arg)
  <span style="color: #036A07;">"Speak word at point. With ARG, go forward ARG words."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"P"</span>)
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">arg can be (4), 4, "-", or -1. we handle these like this.</span>
  (<span style="color: #0000FF;">let</span> ((newarg))
    (<span style="color: #0000FF;">when</span> arg
      (<span style="color: #0000FF;">setq</span> newarg (<span style="color: #0000FF;">cond</span>
                    ((listp arg)
                     (round (log (car arg) 4)))
                    ((<span style="color: #0000FF;">and</span> (stringp arg) (string= <span style="color: #008000;">"-"</span> arg))
                     ((&lt; 0 arg) arg)
                     -1)
                    (t arg)))
      (forward-word newarg))
    (<span style="color: #0000FF;">when</span> (thing-at-point 'word)
      (words-speak (thing-at-point 'word)))))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">mac-say-sentence</span> (<span style="color: #6434A3;">&amp;optional</span> arg)
  <span style="color: #036A07;">"Speak sentence at point. With ARG, go forward ARG sentences."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"P"</span>)
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">arg can be (4), 4, "-", or -1. we handle these like this.</span>
  (<span style="color: #0000FF;">let</span> ((newarg))
    (<span style="color: #0000FF;">when</span> arg
      (<span style="color: #0000FF;">setq</span> newarg (<span style="color: #0000FF;">cond</span>
                    ((listp arg)
                     (round (log (car arg) 4)))
                    ((<span style="color: #0000FF;">and</span> (stringp arg) (string= <span style="color: #008000;">"-"</span> arg))
                     ((&lt; 0 arg) arg)
                     -1)
                    (t arg)))
      (forward-sentence newarg)
      (<span style="color: #0000FF;">when</span> (&lt; 0 newarg) (forward-word)))
    (<span style="color: #0000FF;">when</span> (thing-at-point 'sentence)
      (words-speak (thing-at-point 'sentence)))))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">mac-say-paragraph</span> (<span style="color: #6434A3;">&amp;optional</span> arg)
  <span style="color: #036A07;">"Speak paragraph at point. With ARG, go forward ARG paragraphs."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"P"</span>)
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">arg can be (4), 4, "-", or -1. we handle these like this.</span>
  (<span style="color: #0000FF;">let</span> ((newarg))
    (<span style="color: #0000FF;">when</span> arg
      (<span style="color: #0000FF;">setq</span> newarg (<span style="color: #0000FF;">cond</span>
                    ((listp arg)
                     (round (log (car arg) 4)))
                    ((<span style="color: #0000FF;">and</span> (stringp arg) (string= <span style="color: #008000;">"-"</span> arg))
                     ((&lt; 0 arg) arg)
                     -1)
                    (t arg)))
      (forward-paragraph newarg)
      (<span style="color: #0000FF;">when</span> (&lt; 0 newarg) (forward-word)))
    (<span style="color: #0000FF;">when</span> (thing-at-point 'paragraph)
      (words-speak (thing-at-point 'paragraph)))))
</pre>
</div>

<pre class="example">
mac-say-paragraph
</pre>

<p>
Now for some key-bindings. I will make a hydra that allows repeating commands, and a keymap for more direct function calls.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defhydra</span> mac-speak (<span style="color: #006FE0;">:color</span> red)
  <span style="color: #008000;">"word speak"</span>
  (<span style="color: #008000;">"w"</span> (<span style="color: #0000FF;">progn</span> (mac-say-word) (forward-word)) <span style="color: #008000;">"Next word"</span>)
  (<span style="color: #008000;">"W"</span> (mac-say-word -1) <span style="color: #008000;">"Previous word"</span>)
  (<span style="color: #008000;">"s"</span> (<span style="color: #0000FF;">progn</span> (mac-say-sentence) (forward-sentence)(forward-word)) <span style="color: #008000;">"Next sentence"</span>)
  (<span style="color: #008000;">"S"</span> (mac-say-sentence -1) <span style="color: #008000;">"Previous sentence"</span>)
  (<span style="color: #008000;">"p"</span> (<span style="color: #0000FF;">progn</span> (mac-say-paragraph) (forward-paragraph)) <span style="color: #008000;">"Next paragraph"</span>)
  (<span style="color: #008000;">"P"</span> (mac-say-paragraph -1) <span style="color: #008000;">"Previous paragraph"</span>))

(define-prefix-command 'mac-speak-keymap)
(define-key mac-speak-keymap (vector ?w) 'mac-say-word)
(define-key mac-speak-keymap (vector ?s) 'mac-say-sentence)
(define-key mac-speak-keymap (vector ?p) 'mac-say-paragraph)
(define-key mac-speak-keymap (vector ?h) 'mac-speak/body)
(global-set-key (kbd <span style="color: #008000;">"\C-xr"</span>) 'mac-speak-keymap)
</pre>
</div>

<pre class="example">
mac-speak-keymap
</pre>

<p>
Now, I can navigate text and have my Mac read it to me. It isn't quite like hearing a real person read it, but it is not too bad either. When you need a break from reading, this might be a nice tool!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/29/Getting-Emacs-to-read-to-me.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Clickable text for learning environments</title>
      <link>http://jkitchin.github.io/blog/2015/06/26/Clickable-text-for-learning-environments</link>
      <pubDate>Fri, 26 Jun 2015 11:22:17 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">AuTFwtHFhvSKaLfZ4vHeEAsj_zo=</guid>
      <description>Clickable text for learning environments</description>
      <content:encoded><![CDATA[



<p>
One use for clickable text is in educational texts, or technical documents where you want easy access to glossaries for jargon or new words, or other context specific information. Here we consider some approaches to highlight words in an Emacs buffer that are defined in a glossary, to give them tooltips and make them clickable.
</p>

<p>
You may want to see the video of this in action, the blog post does not do it justice: <a href="http://www.youtube.com/watch?v=Ogavyl_QXiU">http://www.youtube.com/watch?v=Ogavyl_QXiU</a> 
</p>

<p>
We assume we have a <a href="#sec-1">1</a> in the current document that has the words we want to highlight as headlines.  Here is a somewhat hacky way to get the list of keywords (hacky because we use cdr to get rid of the Glossary in the list). Our glossary only has two terms: INCAR and KPOINTS.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">save-excursion</span>
    (org-open-link-from-string <span style="color: #008000;">"[[*Glossary]]"</span>)
    (cdr  (org-map-entries (<span style="color: #0000FF;">lambda</span> ()
                             (nth 4 (org-heading-components)))
                           nil 'tree)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">INCAR</td>
<td class="left">KPOINTS</td>
</tr>
</tbody>
</table>

<p>
We can use that list to make the regexp for button lock with regexp-opt like we did before. We illustrate two ideas here for the highlighted text. One is a dynamic tooltip, which we calculate on the fly and use to display the contents of the glossary heading when you mouse over the word or call local help from the keyboard (C-h .). Second, when you click on the word, you jump to the section in the glossary, and you can readily jump back with C-c &amp; (Thanks org-mode!).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">highlight-glossary-words</span> ()
  (button-lock-set-button
   (regexp-opt (<span style="color: #0000FF;">save-excursion</span>
                 (org-open-link-from-string <span style="color: #008000;">"[[*Glossary]]"</span>)
                 (cdr  (org-map-entries
                        (<span style="color: #0000FF;">lambda</span> ()
                          (nth 4 (org-heading-components)))
                        nil 'tree))))
   (<span style="color: #0000FF;">lambda</span> ()
     <span style="color: #036A07;">"Jump to definition."</span>
     (<span style="color: #0000FF;">interactive</span>)
     (<span style="color: #0000FF;">let</span> ((keyword (get-surrounding-text-with-property 'glossary)))
       (org-open-link-from-string (format <span style="color: #008000;">"[[*%s]]"</span> keyword))))
   <span style="color: #006FE0;">:additional-property</span> 'glossary
   <span style="color: #006FE0;">:face</span> '((<span style="color: #006FE0;">:background</span> <span style="color: #008000;">"gray80"</span>) (<span style="color: #006FE0;">:underline</span> t))
   <span style="color: #006FE0;">:help-echo</span> (<span style="color: #0000FF;">lambda</span> (window object position)
                (<span style="color: #0000FF;">save-excursion</span>
                  (goto-char position)
                  (<span style="color: #0000FF;">save-restriction</span>
                    (org-open-link-from-string
                     (format <span style="color: #008000;">"[[*%s]]"</span> (get-surrounding-text-with-property 'glossary)))
                    (org-narrow-to-subtree)
                    (buffer-string))))))

(highlight-glossary-words)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">\(?:INCAR\</td>
<td class="left">KPOINTS\)</td>
<td class="left">(0 (quote (face ((:background gray80) (:underline t)) keymap (keymap (mouse-1 lambda nil Jump to definition. (interactive) (let ((keyword (get-surrounding-text-with-property (quote glossary)))) (org-open-link-from-string (format <i>*%s</i> keyword))))) button-lock t glossary t mouse-face button-lock-mouse-face help-echo (lambda (window object position) (save-excursion (goto-char position) (save-restriction (org-open-link-from-string (format <i>*%s</i> (get-surrounding-text-with-property (quote glossary)))) (org-narrow-to-subtree) (buffer-string)))) rear-nonsticky t)) append)</td>
</tr>
</tbody>
</table>

<p>
That is pretty cool. You might want something a little smarter for the tooltip, e.g. just the first line of the headline, but this works fine for this little example. I noticed that flyspell seems to get the tooltip in KPOINTS, sometimes, when it thinks it is misspelled.
</p>

<p>
It might take some local variables to make this work only in this just a file, rather than in every file. Alternatively, you could define a function that opens the file and then applies this.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Glossary</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> INCAR</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The file containing all the input parameters for VASP.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> KPOINTS</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The file containing the definitions of the kpoint grid.
</p>

<p>
See <a href="http://cms.mpi.univie.ac.at/vasp/vasp/KPOINTS_file.html">http://cms.mpi.univie.ac.at/vasp/vasp/KPOINTS_file.html</a> 
</p>
</div>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/26/Clickable-text-for-learning-environments.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
    <item>
      <title>Integrating swish-e and Emacs</title>
      <link>http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs</link>
      <pubDate>Thu, 25 Jun 2015 10:37:05 EDT</pubDate>
      <category><![CDATA[orgmode]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">6niCJ0luIGwpPDINzVyYVCw0RB8=</guid>
      <description>Integrating swish-e and Emacs</description>
      <content:encoded><![CDATA[



<p>
<a href="http://swish-e.org">swish-e</a> is a software package that indexes files on your computer, and then allows you to search the index. Spotlight on my Mac is not working too well (sometimes not at all), and I want some more flexibility so today we try getting swish-e up and running and integrated with Emacs. I don't know that swish-e is the best tool for this available, but it has been on my radar a <i>long</i> time (probably since 2003 from this <a href="http://joshr.com/src/docs/HowToIndexAnything.pdf">article</a> ), and it was easy to setup and use.
</p>

<p>
I use homebrew, so installation was this simple:
</p>

<div class="org-src-container">

<pre class="src src-sh">brew install swish-e
</pre>
</div>

<p>
To test things out, I will only index org-files. I have these all over the place, and they are not all in my org-mode agenda. So, finding them quickly would be awesome.
</p>

<div class="org-src-container">

<pre class="src src-text"># Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox
IndexDir "/Users/jkitchin/Box Sync"
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/.swish-e/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

# Otherwise, use the HTML parser
DefaultContents HTML*

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
</pre>
</div>

<p>
Now, we create our index.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -c ~/.swish-e/swish.conf
</pre>
</div>

<pre class="example">
Indexing Data Source: "File-System"
Indexing "/Users/jkitchin/Dropbox"
Indexing "/Users/jkitchin/Box Sync"
Indexing "/Users/jkitchin/blogofile-jkitchin.github.com"
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 130,109 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: ...  Writing word text:  10%  Writing word text:  20%  Writing word text:  30%  Writing word text:  40%  Writing word text:  50%  Writing word text:  60%  Writing word text:  70%  Writing word text:  80%  Writing word text:  90%  Writing word text: 100%  Writing word text: Complete
  Writing word hash: ...  Writing word hash:  10%  Writing word hash:  20%  Writing word hash:  30%  Writing word hash:  40%  Writing word hash:  50%  Writing word hash:  60%  Writing word hash:  70%  Writing word hash:  80%  Writing word hash:  90%  Writing word hash: 100%  Writing word hash: Complete
  Writing word data: ...  Writing word data:   9%  Writing word data:  19%  Writing word data:  29%  Writing word data:  39%  Writing word data:  49%  Writing word data:  59%  Writing word data:  69%  Writing word data:  79%  Writing word data:  89%  Writing word data:  99%  Writing word data: Complete
130,109 unique words indexed.
Sorting property: swishdocpath                            Sorting property: swishtitle                              Sorting property: swishdocsize                            Sorting property: swishlastmodified                       4 properties sorted.
3,208 files indexed.  54,104,974 total bytes.  8,038,594 total words.
Elapsed time: 00:00:16 CPU time: 00:00:13
Indexing done!
</pre>


<p>
Now an example search. I have been looking into the Energy frontier research centers, and I want to find my notes on it. Here is a little query. I use a special output format to keep things simple for the parsing later, just the rank and path, separated by a tab.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f ~/.swish-e/index.swish-e -x <span style="color: #008000;">'%r\t%p\n'</span> -w efrc
</pre>
</div>
<pre class="example">
# SWISH format: 2.4.7
# Search words: efrc
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	/Users/jkitchin/Dropbox/org-mode/journal.org
471	/Users/jkitchin/Dropbox/org-mode/proposals.org
.
</pre>

<p>
Now, for the integration with Emacs. We just get that output in a string, split it, and get the parts we want.  I think I will use helm to provide a selection buffer to these results. We need a list of cons cells (string . candidate). Then we write an interactive helm function. We provide two sources. One for the initial query, and another to start a new search, in case you don't find what you want.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">helm-swish-e-candidates</span> (query)
  <span style="color: #036A07;">"Generate a list of cons cells (swish-e result . path)."</span>
  (<span style="color: #0000FF;">let*</span> ((result (shell-command-to-string
                  (format <span style="color: #008000;">"swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"</span>
                          (shell-quote-argument query))))
         (lines (s-split <span style="color: #008000;">"\n"</span> result t))
         (candidates '()))
    (<span style="color: #0000FF;">loop</span> for line in lines
          unless (<span style="color: #0000FF;">or</span>  (s-starts-with? <span style="color: #008000;">"#"</span> line)
                      (s-starts-with? <span style="color: #008000;">"."</span> line))
          collect (cons line (cdr (s-split <span style="color: #008000;">"\t"</span> line))))))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">helm-swish-e</span> (query)
  <span style="color: #036A07;">"Run a swish-e query and provide helm selection buffer of the results."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sQuery: "</span>)
  (helm <span style="color: #006FE0;">:sources</span> `(((name . ,(format <span style="color: #008000;">"swish-e: %s"</span> query))
                    (candidates . ,(helm-swish-e-candidates query))
                    (action . ((<span style="color: #008000;">"open"</span> . (<span style="color: #0000FF;">lambda</span> (f)
                                           (find-file (car f)))))))
                   ((name . <span style="color: #008000;">"New search"</span>)
                    (dummy)
                    (action . ((<span style="color: #008000;">"search"</span> . (<span style="color: #0000FF;">lambda</span> (f)
                                             (helm-swish-e helm-pattern)))))))))
</pre>
</div>

<pre class="example">
helm-swish-e
</pre>

<p>
Now I can run M-x helm-swish-e and enter "efrc AND computing infrastructure" to find org files containing those words, then press enter to find the file. Nice and easy. I have not tested the query syntax very fully, but so far it is working fine!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/25/Integrating-swish-e-and-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content:encoded>
    </item>
  </channel>
</rss>
