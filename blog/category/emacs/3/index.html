

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: emacs</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module/" rel="bookmark" title="Permanent Link to Adding a GSL integration function to Emacs with a dynamic module">Adding a GSL integration function to Emacs with a dynamic module</a></h2>
      <p><small><span class="blog_post_date">Posted July 09, 2017 at 07:22 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/integration/'>integration</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated July 11, 2017 at 07:37 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Here we work out how to run this program: <a href="https://www.gnu.org/software/gsl/doc/html/integration.html#adaptive-integration-example">https://www.gnu.org/software/gsl/doc/html/integration.html#adaptive-integration-example</a> in a dynamic module in emacs. The goal is to be able to evaluate \(\int_0^1 x^{-1/2} \log(x) dx\). According to the example page the answer is -4. We will define an integration function that takes at least a function and integration bounds as arguments, and several optional arguments to specify tolerances and limits. In other words we want to evaluate integrals of the form:
</p>

<p>
\(\int_a^b f(x; params) dx\)
</p>

<p>
I want that to happen in an elisp function with a signature like:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) body) a b <span style="color: #6434A3;">&amp;optional</span> params epsabs epsrel limit)
</pre>
</div>

<p>
And that function will return a list containing (result error-estimate). Here is the C-code that makes this happen. It is more complex that the <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/">last example</a>, and only compiles with gcc that allows nested functions. I don't know how to write this without that feature. This is more complex also because you have to create a workspace to do the integration inside the function that does the integration. The C-module also has extra code in it to allow for optional arguments.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_integration.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #0000FF;">static</span> <span style="color: #6434A3;">emacs_value</span> <span style="color: #006699;">F_gsl_integrate</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #6434A3;">ptrdiff_t</span> <span style="color: #BA36A5;">nargs</span>, <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[], <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">data</span>)
{
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">nested function - only supported as an extension in gcc</span>
  <span style="color: #6434A3;">double</span> <span style="color: #006699;">f</span> (<span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span>, <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">params</span>) 
  {
    <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fn</span> = args[0];  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">function we will integrate</span>
    <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">x2</span>[] = { env-&gt;make_float(env, x), params };
    <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">y</span> = env-&gt;funcall(env, fn, 2, &amp;x2);   
    
    <span style="color: #0000FF;">return</span> env-&gt;extract_float (env, y);
  }

  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">a</span> = env-&gt;extract_float (env, args[1]);
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">b</span> = env-&gt;extract_float (env, args[2]);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">default values for optional arguments</span>
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">epsabs</span> = 0.0;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">epsrel</span> = 1e-7;
  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">limit</span> = 1000;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">result</span>, <span style="color: #BA36A5;">error</span>; 

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Here is how I handle the optional arguments</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">(gsl-integrate func a b params epsabs epsrel limit)</span>
  <span style="color: #6434A3;">gsl_function</span> <span style="color: #BA36A5;">F</span>;
  F.function = &amp;f;
  <span style="color: #0000FF;">if</span> (nargs &gt;= 4) {F.params = args[3];}
  <span style="color: #0000FF;">if</span> (nargs &gt;= 5 &amp;&amp; env-&gt;is_not_nil(env, args[4])) {epsabs = env-&gt;extract_float(env, args[4]);}
  <span style="color: #0000FF;">if</span> (nargs &gt;= 6 &amp;&amp; env-&gt;is_not_nil(env, args[5])) {epsrel = env-&gt;extract_float(env, args[5]);}
  <span style="color: #0000FF;">if</span> (nargs &gt;= 7 &amp;&amp; env-&gt;is_not_nil(env, args[6])) {limit = env-&gt;extract_integer(env, args[6]);}

  <span style="color: #6434A3;">gsl_integration_workspace</span> * <span style="color: #BA36A5;">w</span> = gsl_integration_workspace_alloc (limit);

  gsl_integration_qags (&amp;F, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">gsl_function pointer</span>
                        a, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">lower integration bound</span>
                        b, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">upper integration bound</span>
                        epsabs, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">absolute error tolerance</span>
                        epsrel, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">relative error tolerance</span>
                        limit, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">max number of subintervals for integration</span>
                        w, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">the workspace</span>
                        <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">pointers to put results and error in</span>
                        &amp;result, &amp;error);

  gsl_integration_workspace_free (w);
    
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">make a list of (result error) to return</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qlist</span> = env-&gt;intern(env, <span style="color: #008000;">"list"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qresult</span> = env-&gt;make_float (env, result);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qerror</span> = env-&gt;make_float (env, error);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">list_args</span>[] = { Qresult, Qerror };
  <span style="color: #0000FF;">return</span> env-&gt;funcall(env, Qlist, 2, list_args);
}

<span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Here we create the function.</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fset</span> = env-&gt;intern(env, <span style="color: #008000;">"fset"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[2];
  args[0] = env-&gt;intern(env, <span style="color: #008000;">"gsl-integration-qags"</span>); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">symbol to create for function</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">The function we set that symbol to.</span>
  args[1] = env-&gt;make_function(env,
                               3, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">min nargs</span>
                               7, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">max nargs</span>
                               F_gsl_integrate,
                               <span style="color: #008000;">"(gsl-integration-qags F A B &amp;optional PARAMS EPSABS EPSREL LIMIT)\n"</span> \
                               <span style="color: #008000;">"Integrate F(x; params) from A to B.\n"</span> \
                               <span style="color: #008000;">"F is a function of a single variable and parameters.\n"</span> \
                               <span style="color: #008000;">"A is the lower bound of integration\n"</span>  \
                               <span style="color: #008000;">"B is the upper bound of integration.\n"</span> \
                               <span style="color: #008000;">"Optional parameters:\n"</span>\
                               <span style="color: #008000;">"PARAMS is a list of params to pass to F.\n"</span> \
                               <span style="color: #008000;">"EPSABS is a float (default 0.0) and is the absolute error tolerance.\n"</span> \
                               <span style="color: #008000;">"EPSREL is a float (default 1e-7) and is the relative error tolerance.\n"</span> \
                               <span style="color: #008000;">"LIMIT is the maximum number of subintervals for the integration (default 1000).\n"</span> \
                               <span style="color: #008000;">"Returns (list result error-estimate).\n"</span> \
                               <span style="color: #008000;">"See https://www.gnu.org/software/gsl/manual/html_node/QAGS-adaptive-integration-with-singularities.html."</span>,
                               0);
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">This is basically (fset 'gsl-integration-qags (lambda func))</span>
  env-&gt;funcall(env, fset, 2, args);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">This is what allows the shared library to provide a feature </span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide</span> = env-&gt;intern(env, <span style="color: #008000;">"provide"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide_args</span>[] = { env-&gt;intern(env, <span style="color: #008000;">"gsl-integration"</span>) };
  env-&gt;funcall(env, provide, 1, provide_args);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
Building this was moderately tricky. It appears the first gcc on my path uses clang which does not support nested functions in C. I don't know enough C to figure out how to do this without a nested function though, since the function has to be defined at run-time based on the emacs env and args. gcc does support inline functions, so the code below uses a gcc that does compile it.
</p>

<div class="org-src-container">
<pre class="src src-sh">rm -f gsl-integration.so gsl-integration.o
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6 -Wall -I/usr/local/include -fPIC -c gsl-integration.c
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6  -shared -L/usr/local/include -lgsl -o gsl-integration.so gsl-integration.o
</pre>
</div>

<p>
Now we add this directory to our path since it is not on it and require our new module.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #008000;">"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-integration</span>)
</pre>
</div>

<pre class="example">
gsl-integration

</pre>

<p>
Let us see our new function in action. We evaluate \(\int_0^1 x^{-1/2} \log(x) dx\). According to the example page the answer is -4. Here is an example where we ignore the parameters. You have to be careful; Emacs sometimes segfaults and crashes if you use an integer or float argument when it expects the other type.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (/ (log x) (sqrt x))) 0.0 1.0)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">-4.000000000000085</td>
<td class="org-right">1.354472090042691e-13</td>
</tr>
</tbody>
</table>

<p>
Here are some optional arguments. 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (/ (log x) (sqrt x))) 0.0 1.0 nil nil 0.01)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">-4.000000000000075</td>
<td class="org-right">0.019526557540360034</td>
</tr>
</tbody>
</table>

<p>
Nice, with a larger epsrel argument we get a larger error. Note the arguments are positional, so we have to include them all just to set the epsrel argument. How about an easier example with parameters that we actually use. Here we integrate a constant, and set the value of the constant from the params arg. The integral should be the area of a rectangle of length 1 and width of the param we use.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(list
 (gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (first params)) 0.0 1.0 '(1.0))
 (gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (first params)) 0.0 1.0 '(0.5)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1.0</td>
<td class="org-right">1.1102230246251565e-14</td>
</tr>

<tr>
<td class="org-right">0.5</td>
<td class="org-right">5.551115123125783e-15</td>
</tr>
</tbody>
</table>

<p>
Wow! It actually works!!! That was harder won success than usual for me. I am claiming victory for now and leaving the following notes to future me:
</p>

<ol class="org-ol">
<li>It would be nice to have optional keyword arguments. This would take some handling of the arguments beyond what I know how to do for now, unless it is possible to pull in something like plist-get the way we pull in fset, provide and list in this example.</li>
<li>Error checking on types would be helpful. It is not good for Emacs to crash because 0 is not 0.0!</li>
<li>In numpy there is often a feature to get full_output. Here, the workspace created in the function has more information available in a struct that might be helpful to have access to at times. It seems like it might be possible to get that here too.</li>
</ol>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-numerical-methods-to-emacs-with-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/" rel="bookmark" title="Permanent Link to Adding numerical methods to emacs with dynamic modules">Adding numerical methods to emacs with dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 08, 2017 at 10:12 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated July 09, 2017 at 07:31 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org35cb5dc">1. Using the GSL to calculate a Bessel function value</a></li>
<li><a href="#orgfee9627">2. A GSL dynamic module for a Bessel function</a></li>
<li><a href="#orgfedab6e">3. Summary</a></li>
</ul>
</div>
</div>
<p>
There is a relatively new feature in Emacs 25 that allows you to extend Emacs using compiled libraries (<a href="http://diobla.info/blog-archive/modules-tut.html">http://diobla.info/blog-archive/modules-tut.html</a>). This could be very helpful in a few ways:
</p>

<ol class="org-ol">
<li>To add functionality that exists in other libraries, e.g.
<ol class="org-ol">
<li><a href="https://github.com/syohex/emacs-libyaml">libyaml</a></li>
<li><a href="https://github.com/syohex/emacs-memcached">libmemcached</a></li>
<li><a href="https://github.com/syohex/emacs-mruby-test">Embedding Ruby in Emacs</a></li>
</ol></li>
<li>Interface Emacs with hardware, e.g. <a href="http://nullprogram.com/blog/2016/11/05/">a joystick</a>, or <a href="https://github.com/syohex/emacs-eject">ejecting a CD</a>.</li>
<li>To speed up slow elisp functions
<ol class="org-ol">
<li>A c implementation of a fibonacci function is 150 times faster than an elisp version <a href="https://coldnew.github.io/2d16cc25/">here</a>.</li>
<li>This <a href="https://github.com/syohex/emacs-parson">json parser</a> is up to 4 times faster than the json.el library for some operations.</li>
</ol></li>
</ol>

<p>
I am interested in this in particular to bring numerical methods into Emacs. It is fair to ask why. Even I think the numpy/scipy/matplotlib Python stack is currently unparalleled in functionality for scientific programming. But I like writing elisp code so much more! So, we will take a look today at a simple example of integrating a function from the GNU Scientific Library into Emacs.
</p>

<div id="outline-container-org35cb5dc" class="outline-2">
<h2 id="org35cb5dc"><span class="section-number-2">1</span> Using the GSL to calculate a Bessel function value</h2>
<div class="outline-text-2" id="text-1">
<p>
A canonical example of using the GSL is given at <a href="https://www.gnu.org/software/gsl/manual/html_node/An-Example-Program.html">https://www.gnu.org/software/gsl/manual/html_node/An-Example-Program.html</a>. Here it is for reference. It just calculates a value for a Bessel function. We save this program in a file called example.c.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;stdio.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_sf_bessel.h&gt;</span>

<span style="color: #6434A3;">int</span>
<span style="color: #006699;">main</span> (<span style="color: #6434A3;">void</span>)
{
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span> = 5.0;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">y</span> = gsl_sf_bessel_J0 (x);
  printf (<span style="color: #008000;">"J0(%g) = %.18e\n"</span>, x, y);
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
We have to compile and run this program. Here are the commands to do that.
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -Wall -I/usr/local/include/ -c example.c
gcc -L/usr/local/include -lgsl example.o 
./a.out
</pre>
</div>

<p>
That is a lot of code and steps to get one number. 
</p>

<p>
What I would like to do instead is this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-sf-bessel</span>)
(gsl-sf-bessel-J0 5)
</pre>
</div>

<p>
So, enter the dynamic module!
</p>
</div>
</div>

<div id="outline-container-orgfee9627" class="outline-2">
<h2 id="orgfee9627"><span class="section-number-2">2</span> A GSL dynamic module for a Bessel function</h2>
<div class="outline-text-2" id="text-2">
<p>
To create the dynamic module we need a small c file that wraps the GSL function and adds it to the Emacs environment. Here is the smallest example I could come up with for this one function.  Basically, we create a function that takes the emacs environment and arguments, extract what we want from them, and use that to calculate what we need and return it to the environment. Then we register that function  and define what the module provides in emacs_module_init.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;assert.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_sf_bessel.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #0000FF;">static</span> <span style="color: #6434A3;">emacs_value</span>
<span style="color: #006699;">F_gsl_sf_bessel_J0</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #6434A3;">ptrdiff_t</span> <span style="color: #BA36A5;">nargs</span>, <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[], <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">data</span>)
{
  assert (nargs == 1);
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span> = env-&gt;extract_float (env, args[0]);
  <span style="color: #0000FF;">return</span> env-&gt;make_float (env, gsl_sf_bessel_J0 (x));
}

<span style="color: #6434A3;">int</span>
<span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
        <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);

        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">gsl_sf_bessel_J0_fn</span> = env-&gt;make_function(env, 1, 1, F_gsl_sf_bessel_J0, <span style="color: #008000;">"Regular cylindrical Bessel function of zeroth order, J_0(x)"</span>, <span style="color: #D0372D;">NULL</span>);

        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qfset</span> = env-&gt;intern(env, <span style="color: #008000;">"fset"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Q_gsl_sf_bessel_J0</span> = env-&gt;intern(env, <span style="color: #008000;">"gsl-sf-bessel-J0"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fset_args</span>[] = { Q_gsl_sf_bessel_J0, gsl_sf_bessel_J0_fn };
        env-&gt;funcall(env, Qfset, 2, fset_args);

        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qprovide</span> = env-&gt;intern(env, <span style="color: #008000;">"provide"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Q_gsl_sf_bessel</span> = env-&gt;intern(env, <span style="color: #008000;">"gsl-sf-bessel"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide_args</span>[] = { Q_gsl_sf_bessel };
        env-&gt;funcall(env, Qprovide, 1, provide_args);

        <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
Now we compile it into a shared library.
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -Wall -I/usr/local/include -fPIC -c gsl-sf-bessel.c
gcc -shared -L/usr/local/include -lgsl -o gsl-sf-bessel.so gsl-sf-bessel.o
</pre>
</div>

<p>
That creates our shared library in gsl-sf-bessel.so.
</p>

<div class="org-src-container">
<pre class="src src-sh">ls *.so
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #008000;">"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-sf-bessel</span>)
(gsl-sf-bessel-J0 5.0)
</pre>
</div>

<pre class="example">
-0.17759677131433826

</pre>

<p>
That is the same answer as we got before. Here is the documentation we defined. It could use some improvement, e.g. to note that the argument has to be a float, and that only one argument is allowed. I am not sure why the signature doesn't show a single argument.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'gsl-sf-bessel-J0)
</pre>
</div>

<pre class="example">
gsl-sf-bessel-J0 is a Lisp function.

(gsl-sf-bessel-J0 &amp;rest ARGS)

For more information check the manuals.

Regular cylindrical Bessel function of zeroth order, J_0(x)

</pre>

<p>
I am not a very skilled C-programmer yet, so I don't know how hard it would be to make this function accept integers as well, or to vectorize it so you could have an arbitrary number of args to it and return a list.
</p>
</div>
</div>


<div id="outline-container-orgfedab6e" class="outline-2">
<h2 id="orgfedab6e"><span class="section-number-2">3</span> Summary</h2>
<div class="outline-text-2" id="text-3">
<p>
Dynamic modules look promising to extend Emacs with. This example is about the simplest function from the GSL there is. There are many more (<a href="https://www.gnu.org/software/gsl/doc/html/index.html">https://www.gnu.org/software/gsl/doc/html/index.html</a>) functions that do linear algebra on arrays, integration or optimization of functions, interpolation of data, etc. I don't have a sense yet of how easy it will be to integrate these into a module.
</p>

<p>
It looks like you are not limited to writing these in C. There is an example of a plugin written in Rust <a href="https://github.com/lunaryorn/emacs-module.rs/blob/master/src/lib.rs">here</a>, and a framework to write them in <a href="https://github.com/sigma/go-emacs/">Go</a>. Maybe any language that can make a shared library with the required plugin_is_GPL_compatible symbol and emacs_module_init function would work. Those examples do not look significantly easier to write than the C versions though since I am not that fluent in those languages either.
</p>

<p>
There are some challenges to figure out in developing and using dynamic modules. Here are a few:
</p>

<ol class="org-ol">
<li>The documentation on what is possible is not that great yet, so there is a lot of exploring to do. There are a fair number of examples out there though to learn from (<a href="https://github.com/emacs-pe/emacs-modules">https://github.com/emacs-pe/emacs-modules</a>). The <a href="https://github.com/emacs-mirror/emacs/tree/emacs-25/modules/mod-test">official example</a> shows a lot of the functionality.</li>
<li>I guess it will be tricky to distribute these. I don't know how easy it would be to build all the libraries for each platform for distribution on MELPA for example. I don't think there is a standard way to incorporate a compile step in elisp package installation. Also, you need an Emacs version of at least 25 with the dynamic module feature compiled in. It is not yet a default enabled option. The required emacs-module.h should be gotten from the emacs build, so people with binaries might not be able to build it anyway.</li>
<li>Users will need the libraries the dynamic module uses. In this example, they will need libgsl.</li>
<li>Once you require the module, it does not seem possible to modify it, rebuild it, and reload it. It appears you have to close Emacs and reload it. That is tedious.</li>
</ol>

<p>
It would be nice to have a more generic foreign function interface that would allow you to develop more on the elisp side. One effort in that direction is <a href="https://github.com/tromey/emacs-ffi">https://github.com/tromey/emacs-ffi</a>. It looks like it might be a lot simpler to use than creating a dynamic module. Once it is installed, it looks like you can write elisp code to wrap the library functions. I will write about this on another day.
</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-keymaps-to-src-blocks-via-org-font-lock-hook"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook/" rel="bookmark" title="Permanent Link to Adding keymaps to src blocks via org-font-lock-hook">Adding keymaps to src blocks via org-font-lock-hook</a></h2>
      <p><small><span class="blog_post_date">Posted June 10, 2017 at 03:27 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/orgmode/'>orgmode</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated June 12, 2017 at 11:28 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org49daca5">1. Update</a></li>
<li><a href="#org004cb53">2. Update #2</a></li>
</ul>
</div>
</div>
<p>
I had an idea to use custom keymaps in src-blocks. For example, you could then use lispy directly in your org-files without entering org-special-edit, or the elpy key-bindings in python blocks. There are other solutions I have seen, e.g. polymode, that claim to do this. You might guess that if they worked, I would not be writing this! There was some nice discussion about this idea on the org-mode mailing list, and Nicolas Goaziou pointed out this might be accomplished with the org-font-lock-hook.
</p>

<p>
You can check out the video here:
</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/a2jHqB1qWiY" frameborder="0" allowfullscreen></iframe>

<p>
It was relatively easy to figure out how to do this. Keymaps can be added to regions during font-lock, so I just had to hook into the org-mode font lock system with a function to find the src blocks and add the keymap as a text-property. That took three steps:
</p>

<ol class="org-ol">
<li>Define the keymaps to use. I use an a-list of (language . map) for this.</li>
<li>Define the font-lock function. This will add the keymap properties to src-blocks.</li>
<li>Define a minor mode to toggle this feature on and off.</li>
</ol>

<p>
Here is the definition of the keymaps. Generally I just copy the mode-map I want and then add some things to them. For example sometimes it is still a good idea to jump into the org-special-edit mode. For example, if you try to use a command in a Python block to send the buffer to the repl while in org-mode you are sure to get an error! You might also want to add the C-c C-e export command if you use that a lot. An alternative approach, of course, is to copy the org-map and add additional bindings to it. The choice is up to you.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">lispy</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">elpy</span>)

(<span style="color: #0000FF;">setq</span> scimax-src-block-keymaps
      `((<span style="color: #008000;">"ipython"</span> . ,(<span style="color: #0000FF;">let</span> ((map (make-composed-keymap
                                  `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                  org-mode-map)))
                        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">In org-mode I define RET so we f</span>
                        (define-key map (kbd <span style="color: #008000;">"&lt;return&gt;"</span>) 'newline)
                        (define-key map (kbd <span style="color: #008000;">"C-c C-c"</span>) 'org-ctrl-c-ctrl-c)
                        map))
        (<span style="color: #008000;">"python"</span> . ,(<span style="color: #0000FF;">let</span> ((map (make-composed-keymap
                                 `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                 org-mode-map)))
                       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">In org-mode I define RET so we f</span>
                       (define-key map (kbd <span style="color: #008000;">"&lt;return&gt;"</span>) 'newline)
                       (define-key map (kbd <span style="color: #008000;">"C-c C-c"</span>) 'org-ctrl-c-ctrl-c)
                       map))
        (<span style="color: #008000;">"emacs-lisp"</span> . ,(<span style="color: #0000FF;">let</span> ((map (make-composed-keymap `(,lispy-mode-map
                                                            ,emacs-lisp-mode-map
                                                            ,outline-minor-mode-map)
                                                          org-mode-map)))
                           (define-key map (kbd <span style="color: #008000;">"C-c C-c"</span>) 'org-ctrl-c-ctrl-c)
                           map))))
</pre>
</div>

<p>
Next we define the function that will apply the keymap to each src block. The keymaps are only applied when they are defined in the variable above. This function is derived from org-fontify-meta-lines-and-blocks-1.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scimax-add-keymap-to-src-blocks</span> (limit)
  <span style="color: #036A07;">"Add keymaps to src-blocks defined in `</span><span style="color: #D0372D;">scimax-src-block-keymaps</span><span style="color: #036A07;">'."</span>
  (<span style="color: #0000FF;">let</span> ((case-fold-search t)
        lang)
    (<span style="color: #0000FF;">while</span> (re-search-forward org-babel-src-block-regexp limit t)
      (<span style="color: #0000FF;">let</span> ((lang (match-string 2))
            (beg (match-beginning 0))
            (end (match-end 0)))
        (<span style="color: #0000FF;">if</span> (assoc (org-no-properties lang) scimax-src-block-keymaps)
            (<span style="color: #0000FF;">progn</span>
              (add-text-properties
               beg end `(local-map ,(cdr (assoc
                                          (org-no-properties lang)
                                          scimax-src-block-keymaps))))
              (add-text-properties
               beg end `(cursor-sensor-functions
                         ((<span style="color: #0000FF;">lambda</span> (win prev-pos sym)
                            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">This simulates a mouse click and makes a menu change</span>
                            (org-mouse-down-mouse nil)))))))))))
</pre>
</div>

<p>
Here we create an advice to trick any functions that need to know the major mode. We only apply the spoof if we are in org-mode and in a src block though. Otherwise we call the original function. So far lispy&#x2013;eval is the only function I have needed it for. This might be a general strategy though to do other things like narrow to the src-block, or even go into special edit mode temporarily if there are commands that require it.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scimax-spoof-mode</span> (orig-func <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"Advice function to spoof commands in org-mode src blocks.</span>
<span style="color: #036A07;">It is for commands that depend on the major mode. One example is</span>
<span style="color: #036A07;">`</span><span style="color: #D0372D;">lispy--eval</span><span style="color: #036A07;">'."</span>
  (<span style="color: #0000FF;">if</span> (org-in-src-block-p)
      (<span style="color: #0000FF;">let</span> ((major-mode (intern (format <span style="color: #008000;">"%s-mode"</span> (first (org-babel-get-src-block-info))))))
        (apply orig-func args))
    (apply orig-func args)))
</pre>
</div>

<p>
We define a minor mode so we can toggle this on and off. Here we add the function to the org-font-lock-hook and advise the lispy&#x2013;eval function. I had to add the font-lock-function to the end of the org-font-lock hook for some reason, and also add local-map as an extra-managed property so it would be removed when we toggle it off.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">define-minor-mode</span> <span style="color: #006699;">scimax-src-keymap-mode</span>
  <span style="color: #036A07;">"Minor mode to add mode keymaps to src-blocks."</span>
  <span style="color: #006FE0;">:init-value</span> nil
  (<span style="color: #0000FF;">if</span> scimax-src-keymap-mode
      (<span style="color: #0000FF;">progn</span>
        (add-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks t)
        (add-to-list 'font-lock-extra-managed-props 'local-map)
        (add-to-list 'font-lock-extra-managed-props 'cursor-sensor-functions)
        (advice-add 'lispy--eval <span style="color: #006FE0;">:around</span> 'scimax-spoof-mode)
        (cursor-sensor-mode +1))
    (remove-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks)
    (advice-remove 'lispy--eval 'scimax-spoof-mode)
    (cursor-sensor-mode -1))
  (font-lock-fontify-buffer))

(add-hook 'org-mode-hook (<span style="color: #0000FF;">lambda</span> ()
                           (scimax-src-keymap-mode +1)))
</pre>
</div>

<p>
That is it! I am pretty sure this is a good idea. It helps a lot when you are writing a lot of short code blocks and near equal amounts of text (like in this blog post). It also helps write the code since many things like indentation, parentheses, etc. are automatically handled. That is what I used to go into special-edit mode all the time for!
</p>

<p>
I have not used this long enough to know if it causes any other surprises. If you try it and find any, leave a comment!
</p>

<div id="outline-container-org49daca5" class="outline-2">
<h2 id="org49daca5"><span class="section-number-2">1</span> Update</h2>
<div class="outline-text-2" id="text-1">
<p>
It turns out you can have the best of all the worlds by combining keymaps. The make-composed-keymap creates a new keymap that combines a keymaps and falls through to a parent keymap. So here we use that to combine several keymaps, falling through to org-mode. The only subtlety I have come across is that I remapped &lt;return&gt; in orgmode to scimax/org-return, and not all modes define it, so I redefine it in some places to just be newline. Also to keep C-c C-c for executing the block, I add that back too.
</p>

<p>
I use a few maps here, and some of them seem to just add menus that are only active when your cursor is in the block. Pretty handy!
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> scimax-src-block-keymaps
      `((<span style="color: #008000;">"ipython"</span> . ,(<span style="color: #0000FF;">let</span> ((map (make-composed-keymap
                                  `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                  org-mode-map)))
                        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">In org-mode I define RET so we f</span>
                        (define-key map (kbd <span style="color: #008000;">"&lt;return&gt;"</span>) 'newline)
                        (define-key map (kbd <span style="color: #008000;">"C-c C-c"</span>) 'org-ctrl-c-ctrl-c)
                        map))
        (<span style="color: #008000;">"python"</span> . ,(<span style="color: #0000FF;">let</span> ((map (make-composed-keymap
                                 `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                 org-mode-map)))
                       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">In org-mode I define RET so we f</span>
                       (define-key map (kbd <span style="color: #008000;">"&lt;return&gt;"</span>) 'newline)
                       (define-key map (kbd <span style="color: #008000;">"C-c C-c"</span>) 'org-ctrl-c-ctrl-c)
                       map))
        (<span style="color: #008000;">"emacs-lisp"</span> . ,(<span style="color: #0000FF;">let</span> ((map (make-composed-keymap `(,lispy-mode-map
                                                            ,emacs-lisp-mode-map
                                                            ,outline-minor-mode-map)
                                                          org-mode-map)))
                           (define-key map (kbd <span style="color: #008000;">"C-c C-c"</span>) 'org-ctrl-c-ctrl-c)
                           map))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org004cb53" class="outline-2">
<h2 id="org004cb53"><span class="section-number-2">2</span> Update #2</h2>
<div class="outline-text-2" id="text-2">
<p>
The previous version had some issues where it would only add a keymap to the first block. The code in this post now addresses that and uses cursor-sensor-functions to make sure we change key map on entering and leaving blocks. That might mean you need an emacs of at least version 25 to use this. I guess it will work with an earlier version, but the cursor-sensor-functions might get ignored. You might have to comment out the cursor-sensor-mode line
</p>

<p>
Thanks to those brave people alpha-testing this and helping refine the idea!
</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Org-mode-and-ipython-enhancements-in-scimax"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/05/26/Org-mode-and-ipython-enhancements-in-scimax/" rel="bookmark" title="Permanent Link to Org-mode and ipython enhancements in scimax">Org-mode and ipython enhancements in scimax</a></h2>
      <p><small><span class="blog_post_date">Posted May 26, 2017 at 04:54 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/ipython/'>ipython</a>, <a href='/blog/category/orgmode/'>orgmode</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org696d7c2">1. Some convenience functions</a></li>
<li><a href="#orgef414e8">2. ob-ipython-inspect works</a></li>
<li><a href="#orgd62ef75">3. Getting selective output from Ipython</a></li>
<li><a href="#org5cac271">4. Where was that error?</a></li>
<li><a href="#org3ebd0a8">5. Asynchronous Ipython</a></li>
</ul>
</div>
</div>
<p>
We have made some improvements to using Ipython in org-mode in the past including:
</p>

<ol class="org-ol">
<li><a href="http://kitchingroup.cheme.cmu.edu/blog/2017/01/29/ob-ipython-and-inline-figures-in-org-mode/">Inline figures</a></li>
<li><a href="http://kitchingroup.cheme.cmu.edu/blog/2017/01/21/Exporting-org-mode-to-Jupyter-notebooks/">Export to Jupyter notebooks</a></li>
</ol>

<p>
Today I will talk about a few new features and improvements I have introduced to scimax for using org-mode and Ipython together.
</p>

<p>
The video for this post might be more obvious than the post:
</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/dMira3QsUdg" frameborder="0" allowfullscreen></iframe>

<div id="outline-container-org696d7c2" class="outline-2">
<h2 id="org696d7c2"><span class="section-number-2">1</span> Some convenience functions</h2>
<div class="outline-text-2" id="text-1">
<p>
There are a few nice shortcuts in the Jupyter notebook. Now we have some convenient commands in scimax to mimic those. My favorites are adding cells above or below the current cell. You can insert a new src block above the current one with (M-x <code>org-babel-insert-block</code>). You can use a prefix arg to insert it below the current block.
</p>


<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">code</span>
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">below</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">some code</span>
</pre>
</div>

<p>
I am particularly fond of splitting a large block into two smaller blocks. Use (M-x <code>org-babel-split-src-block</code>) to do that and leave the point in the upper block. Use a prefix arg to leave the point in the lower block.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">lots of code in large block</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Even more code</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">The end of the long block</span>
</pre>
</div>

<p>
You can execute all the blocks up to the current point with (M-x <code>org-babel-execute-to-point</code>).
</p>
</div>
</div>

<div id="outline-container-orgef414e8" class="outline-2">
<h2 id="orgef414e8"><span class="section-number-2">2</span> ob-ipython-inspect works</h2>
<div class="outline-text-2" id="text-2">
<p>
In the original ob-ipython I found that ob-ipython-inspect did not work unless you were in special edit mode. That is too inconvenient. I modified a few functions to work directly from the org-buffer. I bind this to M-. in org-mode.
</p>

<div class="org-src-container">
<pre class="src src-ipython">%matplotlib inline
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">import</span> matplotlib.pyplot <span style="color: #0000FF;">as</span> plt

<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Compute areas and colors</span>
<span style="color: #BA36A5;">N</span> = 150
<span style="color: #BA36A5;">r</span> = 2 * np.random.rand(N)
<span style="color: #BA36A5;">theta</span> = 2 * np.pi * np.random.rand(N)
<span style="color: #BA36A5;">area</span> = 200 * r**2
<span style="color: #BA36A5;">colors</span> = theta

<span style="color: #BA36A5;">ax</span> = plt.subplot(111, projection=<span style="color: #008000;">'polar'</span>)
<span style="color: #BA36A5;">c</span> = ax.scatter(theta, r, c=colors, s=area, cmap=<span style="color: #008000;">'hsv'</span>, alpha=0.75)
</pre>
</div>

<p>

</p>

<p>
&lt;matplotlib.figure.Figure at 0x114ded710&gt;
<img src="/media/ob-ipython-1758dfdd7a96829c50791c7cc9a39f3a.png"> 
</p>
</div>
</div>



<div id="outline-container-orgd62ef75" class="outline-2">
<h2 id="orgd62ef75"><span class="section-number-2">3</span> Getting selective output from Ipython</h2>
<div class="outline-text-2" id="text-3">
<p>
Out of the box Ipython returns a lot of results. This block, for example returns a plain text, image and latex result as output.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> sympy <span style="color: #0000FF;">import</span> *
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">commenting out init_printing() results in no output</span>
init_printing()

var(<span style="color: #008000;">'x y'</span>)
x**2 + y
</pre>
</div>

<p>

</p>

<p>
 2
x  + y
<img src="/media/ob-ipython-da6fb3a34919a4f694cfaae45b6f0868.png"> 
</p>


<p>
We can select which one we want with a new header argument :ob-ipython-results. For this block you can give it the value of text/plain, text/latex or image/png.
</p>


<div class="org-src-container">
<pre class="src src-ipython">var(<span style="color: #008000;">'x y'</span>)
x**2 + y
</pre>
</div>

<p>
 2
x  + y
</p>

<p>
Or to get the image:
</p>


<div class="org-src-container">
<pre class="src src-ipython">var(<span style="color: #008000;">'x y'</span>)
x**2 + y
</pre>
</div>

<p>
<img src="/media/ob-ipython-da6fb3a34919a4f694cfaae45b6f0868.png"> 
</p>


<p>
This shows up with <a href="https://emacs.stackexchange.com/questions/33005/python-org-mode-babel-output-column-headers-misaligned/33016#33016">pandas too</a>. This block creates a table of data and then shows the first 5 rows. Ipython returns both plain text and html here.
</p>


<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> pandas <span style="color: #0000FF;">as</span> pd
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> datetime <span style="color: #0000FF;">as</span> dt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">makeSim</span>(nHosps, nPatients):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span> = pd.DataFrame()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'patientid'</span>] = <span style="color: #006FE0;">range</span>(nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'hospid'</span>] = np.random.randint(0, nHosps, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'sex'</span>] = np.random.randint(0, 2, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'age'</span>] = np.random.normal(65,18, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'race'</span>] = np.random.randint(0, 4, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'cptCode'</span>] = np.random.randint(1, 100, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'rdm30d'</span>] = np.random.uniform(0, 1, nPatients) &lt; 0.1
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'mort30d'</span>] = np.random.uniform(0, 1, nPatients) &lt; 0.2
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'los'</span>] = np.random.normal(8, 2, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> df

<span style="color: #BA36A5;">discharges</span> = makeSim(50, 10000)
discharges.head()
</pre>
</div>

<p>

</p>

<p>
   patientid  hospid  sex        age  race  cptCode rdm30d mort30d        los
0          0      10    1  64.311947     0        8  False   False   8.036793
1          1       6    0  82.951484     1       73   True   False   7.996024
2          2      27    1  53.064501     3       95  False   False   9.015144
3          3      37    0  64.799128     0       93  False   False  10.099032
4          4      46    0  99.111394     2       25  False   False  11.711427
</p>
<div>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>patientid</th>
      <th>hospid</th>
      <th>sex</th>
      <th>age</th>
      <th>race</th>
      <th>cptCode</th>
      <th>rdm30d</th>
      <th>mort30d</th>
      <th>los</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>10</td>
      <td>1</td>
      <td>64.311947</td>
      <td>0</td>
      <td>8</td>
      <td>False</td>
      <td>False</td>
      <td>8.036793</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>6</td>
      <td>0</td>
      <td>82.951484</td>
      <td>1</td>
      <td>73</td>
      <td>True</td>
      <td>False</td>
      <td>7.996024</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>27</td>
      <td>1</td>
      <td>53.064501</td>
      <td>3</td>
      <td>95</td>
      <td>False</td>
      <td>False</td>
      <td>9.015144</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3</td>
      <td>37</td>
      <td>0</td>
      <td>64.799128</td>
      <td>0</td>
      <td>93</td>
      <td>False</td>
      <td>False</td>
      <td>10.099032</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4</td>
      <td>46</td>
      <td>0</td>
      <td>99.111394</td>
      <td>2</td>
      <td>25</td>
      <td>False</td>
      <td>False</td>
      <td>11.711427</td>
    </tr>
  </tbody>
</table>
</div>


<p>
We can use the header to select only the plain text output!
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> pandas <span style="color: #0000FF;">as</span> pd
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #0000FF;">import</span> datetime <span style="color: #0000FF;">as</span> dt

<span style="color: #0000FF;">def</span> <span style="color: #006699;">makeSim</span>(nHosps, nPatients):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span> = pd.DataFrame()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'patientid'</span>] = <span style="color: #006FE0;">range</span>(nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'hospid'</span>] = np.random.randint(0, nHosps, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'sex'</span>] = np.random.randint(0, 2, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'age'</span>] = np.random.normal(65,18, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'race'</span>] = np.random.randint(0, 4, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'cptCode'</span>] = np.random.randint(1, 100, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'rdm30d'</span>] = np.random.uniform(0, 1, nPatients) &lt; 0.1
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'mort30d'</span>] = np.random.uniform(0, 1, nPatients) &lt; 0.2
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">df</span>[<span style="color: #008000;">'los'</span>] = np.random.normal(8, 2, nPatients)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> df

<span style="color: #BA36A5;">discharges</span> = makeSim(50, 10000)
discharges.head()
</pre>
</div>

<p>
   patientid  hospid  sex        age  race  cptCode rdm30d mort30d        los
0          0      21    0  73.633836     1       38  False   False   7.144019
1          1      16    1  67.518804     3       23  False   False   3.340534
2          2      15    0  44.139033     0        8  False   False   9.258706
3          3      29    1  45.510276     2        5  False   False  10.590245
4          4       7    0  52.974924     2        4  False    True   5.811064
</p>
</div>
</div>

<div id="outline-container-org5cac271" class="outline-2">
<h2 id="org5cac271"><span class="section-number-2">4</span> Where was that error?</h2>
<div class="outline-text-2" id="text-4">
<p>
A somewhat annoying feature of running cells in org-mode is when there is an exception there has not been a good way to jump to the line that caused the error to edit it. The lines in the src block are not numbered, so in a large block it can be tedious to find the line. In scimax, when you get an exception it will number the lines in the src block, and when you press q in the exception traceback buffer it will jump to the line in the block where the error occurred.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">print</span>(1)
<span style="color: #8D8D84;">#</span><span style="color: #8D8D84; font-style: italic;">raise Exception('Here')</span>
<span style="color: #0000FF;">print</span>(2)
</pre>
</div>

<p>
1
2
</p>



<p>
If you don't like the numbers add this to your init file:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> ob-ipython-number-on-exception nil)
</pre>
</div>
</div>
</div>

<div id="outline-container-org3ebd0a8" class="outline-2">
<h2 id="org3ebd0a8"><span class="section-number-2">5</span> Asynchronous Ipython</h2>
<div class="outline-text-2" id="text-5">
<p>
I have made a few improvements to the asynchronous workflow in Ipython. We now have a calculation queue, so you can use C-c C-c to execute several blocks in a row, and they will run asynchronously in the order you ran them. While they are running you can continue using Emacs, e.g. writing that paper, reading email, checking RSS feeds, tetris, &#x2026; This also lets you run all the blocks up to the current point (M-x <code>org-babel-execute-ipython-buffer-to-point-async</code>) or the whole buffer (of Ipython) blocks asynchronously (M-x <code>org-babel-execute-ipython-buffer-async</code>).
</p>

<p>
To turn this on by default put this in your init file:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> org-babel-async-ipython t)
</pre>
</div>

<p>
This requires all src blocks to have a name, and running the block will give it a name if you have not named the block. By default we use human-readable names. While the block is running, there will be a link indicating it is running. You can click on the link to cancel it. Running subsequent blocks will queue them to be run when the first block is done.
</p>

<p>
Here is an example:
</p>

<div class="org-src-container">
<pre class="src src-ipython" id="orgb3ddac3"><span style="color: #0000FF;">import</span> time
time.sleep(5)
<span style="color: #BA36A5;">a</span> = 5
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'done'</span>)
</pre>
</div>


<div class="org-src-container">
<pre class="src src-ipython" id="org5b7e30b"><span style="color: #0000FF;">print</span>(3 * a)
</pre>
</div>

<p>
15
</p>




<p>
Occasionally you will run into an issue. You can clear the queue with <code>org-babel-async-ipython-clear-queue</code>.</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/05/26/Org-mode-and-ipython-enhancements-in-scimax.org">org-mode source</a></p>
<p>Org-mode version = 9.0.5</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/05/26/Org-mode-and-ipython-enhancements-in-scimax">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="A-partial-symbolic-numeric-solver-in-emacs-lisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp/" rel="bookmark" title="Permanent Link to A partial symbolic numeric solver in emacs-lisp">A partial symbolic numeric solver in emacs-lisp</a></h2>
      <p><small><span class="blog_post_date">Posted May 21, 2017 at 11:33 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/math/'>math</a>, <a href='/blog/category/emacs-lisp/'>emacs-lisp</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org18a4554">1. The Newton solver in emacs-lisp</a></li>
</ul>
</div>
</div>
<p>
I have been exploring  ways to use emacs-lisp to express scientific ideas. In this post, we explore a partial symbolic numeric solver in Emacs-lisp. This involves some syntactic developments to more clearly identify something we want to solve for and to then generate the code required to solve it.
</p>

<p>
In section <a href="#org18a4554">The Newton solver</a> you can find a simple implementation of a Newton solver in emacs-lisp. This function allows you to numerically solve equations that can be written in the form \(f(x) = 0\) for \(x\) given an initial guess. You write a function for \(f(x)\) and pass the function to the solver. This is a standard approach used in Python with fsolve, for example. Here is an example of solving a trivial problem: \(x - 4 = 0\) just to check that it works. We use a lambda function for \(f(x) = x - 4 = 0\). The answer is \(x=4\).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(newton-f (<span style="color: #0000FF;">lambda</span> (x) (- x 4)) 2)
</pre>
</div>

<p>
That syntax is not too bad, but we have the whole lambda expression in there, and some repetition of what we want to solve for as an argument and in the function. It would be interesting if we could just have an expression that gets solved, e.g. <code>(newton-f (- x? 4) 2)</code> where <code>x?</code> indicates the thing to solve for.
</p>

<p>
We can do that! We can take an expression, flatten it and find the variable names that end with ?. We should check that there is only one, but for now we don't. Here is an example that does that. I use a nested expression here just to illustrate that the code finds the <code>x?</code> variable correctly.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">dash</span>)

(<span style="color: #0000FF;">let</span> ((body '((* (- x? 4) 1))))
  (<span style="color: #0000FF;">loop</span> for item in (-flatten body)
        if (<span style="color: #0000FF;">and</span> (symbolp item) (s-ends-with? <span style="color: #008000;">"?"</span> (symbol-name item)))
        collect item))
</pre>
</div>

<p>
So, given an expression we can identify the unknown that should be the argument to a lambda function. So, we create a macro that takes that expression and constructs a function to solve it, then calls newton-f on it. The macro is syntactically useful here because we do not have to quote the expression. Here is that macro.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">solve</span> (expression guess)
  `(newton-f
    (<span style="color: #0000FF;">lambda</span> ,(<span style="color: #0000FF;">loop</span> for item in (-flatten expression)
                   if (<span style="color: #0000FF;">and</span> (symbolp item) (s-ends-with? <span style="color: #008000;">"?"</span> (symbol-name item)))
                   collect item)
      ,expression)
    ,guess))
</pre>
</div>

<p>
I call this a partial symbolic solver because we do some introspection symbolically to identify what to solve for, and then construct the code required to solve it. Here is that trivial example (x? - 4 = 0). It just shows we can have some nesting and it still works. I am not so thrilled with the initial guess, but this is an iterative solver, so you either need an initial guess, or a solution range.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">solve</span> (* (- x? 4) 1) 3)
</pre>
</div>

<p>
Here is what that expands into:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(macroexpand '(solve (* (- x? 4) 1) 3))
</pre>
</div>

<p>
It expands into what we would have written in the first place. The benefit to us is less typing, and a simpler syntax. Both of those reduce the opportunity to make errors!
</p>

<p>
A more realistic problem might be: Reactant A flows into a continuously stirred tank reactor at a rate of  \(F_{A0} = 1\) mol/min with a volumetric flow of \(v_0 = 1\) L/min.. The reactor achieves 50% conversion (\(X\)) of A to products. The reaction rate law is known to be \(-r_A = k C_A\) with \(k = 0.1\) 1/min. Estimate the volume of the reactor. If you have taken my class in reaction engineering, you know the following facts:
</p>

<ul class="org-ul">
<li>The exit molar flow is defined by \(F_A = F_{A0} (1 - X)\)</li>
<li>The exit concentration is \(C_A = F_A / v_0\)</li>
<li>The mole balance is defined by \(0 = F_{A0} - F_A + r_A V\)</li>
</ul>

<p>
That is all we need; we can solve for \(V\) from the last equation. This is simple enough you might do the algebra to get: \(V = \frac{F_{A0} - F_A}{-r_A}\) which can be simply evaluated. We use our solver here and compare it to the evaluation.
</p>

<p>
Here is the solver:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((Fa0 1)
       (X 0.5)
       (Fa (* Fa0 (- 1 X)))
       (k 0.1)
       (v0 1)
       (Ca (/ Fa v0))
       (r (* k Ca))
       (ra (* r -1)))
  (<span style="color: #0000FF;">solve</span> (+ Fa0 (* Fa -1) (* ra V?)) 2))
</pre>
</div>

<p>
It is pretty hard to imagine doing something like this in Python! It would probably involve parsing a string.
</p>

<p>
Here is the evaluation from our algebra:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((Fa0 1)
       (X 0.5)
       (Fa (* Fa0 (- 1 X)))
       (k 0.1)
       (v0 1)
       (Ca (/ Fa v0))
       (r (* k Ca))
       (ra (* r -1)))
  (/ (- Fa0 Fa) (* -1 ra)))
</pre>
</div>

<p>
Within the tolerance specified in <code>newton-f</code>, these are the same.
</p>

<p>
This is just the tip of the iceberg though. You may have noticed that none of the variables in the let* had any descriptions. Sure, you could put some comments after them, but those are not really part of the code.
</p>

<p>
Also, we had to define the variables in advance of the expression. That is a limitation of how computers work, they cannot evaluate undefined variables. It <i>constrains</i> how we can express the idea. What if we could instead specify the equation first, then the data? That way we are clear what we are trying to do at a higher level, and fill in the details later. Suppose we wanted a syntax like the block below instead. Here we emphasize the equation we are solving first, and then define the variables and quantities used in the equation, and finally the guess that we use to find the solution.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">solve1</span>
 (eqn (+ Fa0 (* -1 Fa) (* ra V?)))
 (data ((k 0.1 <span style="color: #008000;">"rate constant 1/min"</span>)
        (Ca0 1.0 <span style="color: #008000;">"feed concentration"</span>)
        (v0 1 <span style="color: #008000;">"volumetric flow L/min"</span>)
        (Fa0 (* v0 Ca0) <span style="color: #008000;">"Inlet molar flow"</span>)
        (X 0.5 <span style="color: #008000;">"Desired conversion"</span>)
        (Fa (* Fa0 (- 1 X)) <span style="color: #008000;">"Exit molar flow"</span>)
        (Ca (/ Fa v0) <span style="color: #008000;">"exit concentration"</span>)
        (ra (* -1 k Ca) <span style="color: #008000;">"rate in the reactor"</span>)))
 (guess 8))
</pre>
</div>

<p>
That is achievable with the solve1 macro below! It too has some limitations, mostly the order of the data block still has to be correct, e.g. you cannot use a variable before it is defined. It would take some serious macro-fu to sort these so that everything is defined in the right order! Still, it allows you to express an <i>executable</i> idea in the order we defined. The strings in this syntax for documenting the variables are ignored, but they could be used in the macro to print useful information or something else you could imagine. You could also make them mandatory to encourage documentation.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">solve1</span> (<span style="color: #6434A3;">&amp;rest</span> body)
  (<span style="color: #0000FF;">let</span> ((expression (second (assoc 'eqn body)))
        (data (<span style="color: #0000FF;">loop</span> for d in (second (assoc 'data body))
                    collect (list (first d) (second d))))
        (guess (second (assoc 'guess body))))
    `(<span style="color: #0000FF;">let*</span> ,data
       (newton-f
        (<span style="color: #0000FF;">lambda</span> ,(<span style="color: #0000FF;">loop</span> for item in (-flatten expression)
                       if (<span style="color: #0000FF;">and</span> (symbolp item) (s-ends-with? <span style="color: #008000;">"?"</span> (symbol-name item)))
                       collect item)
          ,expression)
        ,guess))))
</pre>
</div>

<p>
To summarize, lisp macros allow us to rewrite the syntax of code before it is evaluated. This gives us the opportunity to inspect it, and generate new code, e.g. functions with arguments based on the contents of expressions, to save us typing. It also allows us to define ideas in a near arbitrary order that make sense to us, and then rearrange them so they make sense to the computer. See, for example,  <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/">this post</a> for an example of changing how functions are defined.
</p>

<p>
This seems to be heading in the domain specific language direction. I think it would be very helpful in engineering problem solving to build up tools like this. They could start out simple for new students to use. They never need to see the macro parts of this, just to learn how to use them for problem solving. These beginner tools would be limited in what they could do to minimize how much lisp is required to be learned so students can focus on the problem solving. Eventually they might outgrow them, and in the process transition to having the full lisp language at their disposal for problem solving.
</p>


<div id="outline-container-org18a4554" class="outline-2">
<h2 id="org18a4554"><a id="ID-53A5F60F-F929-43BB-AD9D-167D6EBEB8EB"></a><span class="section-number-2">1</span> The Newton solver in emacs-lisp</h2>
<div class="outline-text-2" id="text-1">
<p>
This is an emacs-lisp implementation of Newton's method. It is a simple implementation for a single variable. The tolerance and step-size are hard-coded for this post because we focus on the partial symbolic solver, not the best solver methods.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">See https://en.wikipedia.org/wiki/Newton%27s_method for the method</span>

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">newton-f</span> (func x0)
  <span style="color: #036A07;">"Solve the equation FUNC(x)=0 using Newton's method.</span>
<span style="color: #036A07;">X0 is an initial guess."</span>
  (<span style="color: #0000FF;">let*</span> ((tolerance 1e-6)
         (x x0)
         (dx 1e-6)
         fx fpx)
    (<span style="color: #0000FF;">while</span> (&gt; (abs (funcall func x)) tolerance)
      (<span style="color: #0000FF;">setq</span> fx (funcall func x)
            fpx (/ (- (funcall func (+ x dx)) (funcall func (- x dx))) (* 2 dx))
            x (- x (/ fx fpx))))
    x))
</pre>
</div>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp.org">org-mode source</a></p>
<p>Org-mode version = 9.0.5</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp">Discuss on Twitter</a>

  <hr class="interblog" />
 <a href="/blog/category/emacs/2">« Previous Page</a>
  --  
 <a href="/blog/category/emacs/4">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2021/12/22/2021-in-a-nutshell/">2021 in a nutshell</a></li>
      <li><a href="/blog/2021/12/18/New-publication-Origin-of-the-Stokes-Einstein-Deviation-in-Liquid-Al-Si/">New publication - Origin of the Stokes-Einstein Deviation in Liquid Al-Si</a></li>
      <li><a href="/blog/2021/12/03/New-publication-Accelerated-Optimization-of-Pure-Metal-and-Ligand-Compositions-for-Light-driven-Hydrogen-Production/">New publication - Accelerated Optimization of Pure Metal and Ligand Compositions for Light-driven Hydrogen Production</a></li>
      <li><a href="/blog/2021/12/02/New-publication-Ligand-Enhanced-Activity-of-in-Situ-Formed-Nanoparticles-for-Photocatalytic-Hydrogen-Evolution/">New publication - Ligand Enhanced Activity of in Situ Formed Nanoparticles for Photocatalytic Hydrogen Evolution</a></li>
      <li><a href="/blog/2021/11/30/New-publication-Uncertainty-quantification-in-machine-learning-and-nonlinear-least-squares-regression-models/">New publication - Uncertainty quantification in machine learning and nonlinear least squares regression models</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2021
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



