<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>https://kitchingroup.cheme.cmu.edu/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Thu, 29 Sep 2022 21:24:39 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>A Hy macro for defining functions with docstrings on each argument</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/03/19/A-Hy-macro-for-defining-functions-with-docstrings-on-each-argument</link>
      <pubDate>Sun, 19 Mar 2017 19:47:22 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">NqXI-d5MIhdrEMrRoS82Q6yAc8U=</guid>
      <description>A Hy macro for defining functions with docstrings on each argument</description>
      <content:encoded><![CDATA[


&lt;p&gt;
For functions with a lot of arguments, python style docstrings leave something to be desired. For one, they are not that close to the arguments, so if you have a function with say 20 arguments, the docstring might take up a whole page! That means they are hard to keep synchronized too. Let's not argue now over the merits of a function with 20+ arguments, it is enough that they exist, and are a problem.
&lt;/p&gt;

&lt;p&gt;
So what are typical documentation standards? Here is a Numpy style doc string:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;func&lt;/span&gt;(arg1, arg2):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"""multiply arg1 and arg2&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   Parameters&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   ----------&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   arg1 : a number&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   arg2 : a number&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   """&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; arg1 * arg2
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It works well for a small number of arguments with limited descriptions. This is a proper docstring that is accessible by introspection and pydoc. With much longer argument lists, this falls apart. I will not pick on any code in particular here, but suffice it to say I was inspired today to think of a better way. There are some other documentation solutions at &lt;a href="http://stackoverflow.com/questions/9195455/how-to-document-a-method-with-parameters"&gt;http://stackoverflow.com/questions/9195455/how-to-document-a-method-with-parameters&lt;/a&gt;, but None of them are better in my opinion. I want accessible docstrings by instrospection, and only if that is unavailable do I want to read the code! Finally, if I have to read the code, I want it to be easy to figure out, which means the documentation is close to the arguments.
&lt;/p&gt;

&lt;p&gt;
There is bad news, I do not have one for vanilla python. Python does not even give you a way to deal with this. But, if we had a lisp, we could make a macro to help us out. In fact, we &lt;i&gt;have&lt;/i&gt; a lisp with &lt;a href="http://docs.hylang.org/en/latest/"&gt;hy&lt;/a&gt;! And we can use a macro to make a  syntax that lets us keep the docstring close to the argument, &lt;i&gt;and&lt;/i&gt; that constructs a real docstring so we get help later!
&lt;/p&gt;

&lt;p&gt;
Here it is:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;mydef&lt;/span&gt; [func args &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; docstring &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body]
  `(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;~func&lt;/span&gt; [~@(&lt;span style="color: #006FE0;"&gt;map&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; [x] (&lt;span style="color: #006FE0;"&gt;nth&lt;/span&gt; x 0)) args)]
     ~(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; docstring (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; docstring &lt;span style="color: #008000;"&gt;"\n\n"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
         &lt;span style="color: #008000;"&gt;"Parameters\n----------\n"&lt;/span&gt;
         (.join &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;map&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; [x]
                            (.format &lt;span style="color: #008000;"&gt;"{} : {}"&lt;/span&gt;
                                     (&lt;span style="color: #006FE0;"&gt;nth&lt;/span&gt; x 0)
                                     (&lt;span style="color: #006FE0;"&gt;nth&lt;/span&gt; x 1))) args)))
     ~@body))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can checkout how it expands like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-hy"&gt;(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;macroexpand&lt;/span&gt; '(mydef f [(a &lt;span style="color: #008000;"&gt;"an int"&lt;/span&gt;)
                               (b &lt;span style="color: #008000;"&gt;"an int"&lt;/span&gt;)]
                            &lt;span style="color: #008000;"&gt;"some doc"&lt;/span&gt;
                            (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; a b))))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
('setv' 'f' ('fn' ['a' 'b'] 'some doc\n\nParameters\n----------\na : an int\nb : an int' ('*' 'a' 'b')))
&lt;/pre&gt;

&lt;p&gt;
That looks ok. Now, for an example of using that. Here is the same function we defined before, but I put the documentation for each argument with the argument.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-hy"&gt;(mydef func ((arg1 &lt;span style="color: #008000;"&gt;"a number"&lt;/span&gt;)
             (arg2 &lt;span style="color: #008000;"&gt;"a number"&lt;/span&gt;))
  &lt;span style="color: #008000;"&gt;"Multiply arg1 by arg2"&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; arg1 arg2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can use the function now like a regular function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-hy"&gt;(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (func 24 3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
72
&lt;/pre&gt;

&lt;p&gt;
And now for the help.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-hy"&gt;(help func)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Help on function func in module __main__:

func(arg1, arg2)
    Multiply arg1 by arg2

    Parameters
    ----------
    arg1 : a number
    arg2 : a number
&lt;/pre&gt;

&lt;p&gt;
Now, that should amaze and astonish you if you are a vanilla Pythonista! We have our cake, and we eat it too. You just can not make up your own syntax that way in Python. Imagine, we could add type information, validation code, etc&amp;#x2026; into that macro. Maybe it could even be possible to store argument dependent documentation on the function, say in the function dictionary. That would require some conventions I guess,  but they could become introspectable then. For example, in this vanilla Python:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt;(x): &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x*x
&lt;span style="color: #BA36A5;"&gt;f.__dict__&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'args'&lt;/span&gt;] = {&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;: &lt;span style="color: #008000;"&gt;'A number'&lt;/span&gt;}
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f.__dict__)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
{'args': {'x': 'A number'}}
&lt;/p&gt;

&lt;p&gt;
In the end, this does not really solve all the problems I have with current docstrings in Python. It does solve a problem with writing and reading the code by keeping documentation close to the arguments, but ultimately the docstring from Python's point of view will basically look the same. It is pretty awesome that it is even possible. Hy lisp for the win here (again!).
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/03/19/A-Hy-macro-for-defining-functions-with-docstrings-on-each-argument.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Enough with the hyperbole - hy does things that are not as easy in Python</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/29/Enough-with-the-hyperbole-hy-does-things-that-are-not-as-easy-in-Python</link>
      <pubDate>Fri, 29 Apr 2016 14:45:54 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">AlLJjsPo6vkQxkw6fZR4YP-NR98=</guid>
      <description>Enough with the hyperbole - hy does things that are not as easy in Python</description>
      <content:encoded><![CDATA[



&lt;p&gt;
We run a lot of molecular simulations using Python. Here is a typical script we would use. It creates an instance of a calculator inside a context manager.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; Atoms, Atom
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; jasp &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; *

&lt;span style="color: #BA36A5;"&gt;co&lt;/span&gt; = Atoms([Atom(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;,[0,   0, 0]),
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   Atom(&lt;span style="color: #008000;"&gt;'O'&lt;/span&gt;,[1.2, 0, 0])],
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   cell=(6., 6., 6.))

&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; jasp(&lt;span style="color: #008000;"&gt;'molecules/simple-co'&lt;/span&gt;, &lt;span style="color: #8D8D84;"&gt;#&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;output dir&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; xc=&lt;span style="color: #008000;"&gt;'PBE'&lt;/span&gt;,  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the exchange-correlation functional&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; nbands=6,  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;number of bands&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; encut=350, &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;planewave cutoff&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; ismear=1,  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Methfessel-Paxton smearing&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; sigma=0.01,&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;very small smearing factor for a molecule&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; atoms=co) &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; calc:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;'energy = {0} eV'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(co.get_potential_energy())
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt; co.get_forces()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This basic approach has served us for more than a decade! Still, there are things about it that bug me. Most significantly is the arbitrary keyword args. We keep a list of legitimate kwargs in the module, but there is no documentation or validation to go with them that is accessible to users (short of reading the code). There are well over 100 kwargs that are possible, so documenting them in the &lt;span class="underline"&gt;&lt;span class="underline"&gt;init&lt;/span&gt;&lt;/span&gt; docstring is not that useful (we did it once, see &lt;a href="https://gitlab.com/ase/ase/blob/master/ase/calculators/jacapo/jacapo.py#L143"&gt;https://gitlab.com/ase/ase/blob/master/ase/calculators/jacapo/jacapo.py#L143&lt;/a&gt; , and it made a really long docstring). Providing validation for these (some can only be integers, floats, specific strings, lists, or dictionaries) is not easy. I did this for another simulation code by providing &lt;a href="https://gitlab.com/ase/ase/blob/master/ase/calculators/jacapo/validate.py"&gt;validation functions&lt;/a&gt; that could be looked up dynamically by name. I never did come up with a way to provide kwarg specific documentation though.
&lt;/p&gt;

&lt;p&gt;
The access to documentation while writing code is becoming increasingly important to me; I don't remember all the kwargs and what values are valid. More importantly, as I teach people how to use these tools, it is not practical to tell them to "read the code". I don't even want to do that while running simulations, I just want to setup the simulation and run it.
&lt;/p&gt;

&lt;p&gt;
Today, I had an idea that a macro in hy would allow me to get documentation and validation of these kwargs.
&lt;/p&gt;

&lt;p&gt;
The pseudocode would look like this. Each "kwarg" will actually be a function that has a docstring, performs validation, and evaluates to its argument. "vaspm" is a macro that will expand to the calculator with the desired kwargs. We will have to be careful that these function names don't conflict with other function names, but that could be addressed in a variety of ways with namespaces and function names.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;pseudocode of the macro&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; calc (vaspm &lt;span style="color: #008000;"&gt;"molecules/simple-co"&lt;/span&gt;
                  (xc &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;)
                  (nbands 6)
                  (encut 350)
                  (ismear 1)
                  (sigma 0.01)
                  (atoms co)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This would expand to the following block, which is equivalent to what we already do today. In the process of expansion though, we gain docstrings and validation!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; calc (Vasp &lt;span style="color: #008000;"&gt;"molecules/simple-co"&lt;/span&gt;
                 &lt;span style="color: #D0372D;"&gt;:xc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;
                 &lt;span style="color: #D0372D;"&gt;:nbands&lt;/span&gt; 6
                 &lt;span style="color: #D0372D;"&gt;:encut&lt;/span&gt; 6
                 &lt;span style="color: #D0372D;"&gt;:ismear&lt;/span&gt; 1
                 &lt;span style="color: #D0372D;"&gt;:sigma&lt;/span&gt; 0.01
                 &lt;span style="color: #D0372D;"&gt;:atoms&lt;/span&gt; co))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is a toy implementation that illustrates what the functions are, and how we build up the code from the macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;encut&lt;/span&gt; [cutoff]
  &lt;span style="color: #008000;"&gt;"The planewave cutoff energy in eV."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;assert&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;integer?&lt;/span&gt; cutoff))
  (&lt;span style="color: #0000FF;"&gt;assert&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;&amp;gt;&lt;/span&gt; cutoff 0))
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"encut validated"&lt;/span&gt;)
  cutoff)

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;xc&lt;/span&gt; [exc]
  &lt;span style="color: #008000;"&gt;"The exchange correlation functional. Should be a string of PBE or LDA."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;assert&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;string?&lt;/span&gt; exc))
  (&lt;span style="color: #0000FF;"&gt;assert&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;in&lt;/span&gt; exc [&lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"LDA"&lt;/span&gt;]))
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"exc validated"&lt;/span&gt;)
  exc)


(&lt;span style="color: #0000FF;"&gt;defclass&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Calculator&lt;/span&gt; []
  &lt;span style="color: #008000;"&gt;"Toy class representing a calculator."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt; [self wd &lt;span style="color: #6434A3;"&gt;&amp;amp;kwargs&lt;/span&gt; kwargs]
    (setattr self &lt;span style="color: #008000;"&gt;"wd"&lt;/span&gt; wd)
    (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [key kwargs]
      (setattr self key (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; kwargs key)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We tangle that block to calculator.hy so we can reuse it. First we show the traditional syntax.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[calculator [*]]&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; calc (Calculator &lt;span style="color: #008000;"&gt;"some-dir"&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;:encut&lt;/span&gt; 400 &lt;span style="color: #D0372D;"&gt;:xc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.wd)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.encut)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.xc)
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
some-dir
400
PBE
&lt;/pre&gt;

&lt;p&gt;
Note, we can also do this, and get the validation too. It is verbose for my taste, but shows what we need the final code to look like, and incidentally how this would be done in Python too. We just need a macro that expands to this code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[calculator [*]]&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; calc (Calculator &lt;span style="color: #008000;"&gt;"some-dir"&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;:encut&lt;/span&gt; (encut 400) &lt;span style="color: #D0372D;"&gt;:xc&lt;/span&gt; (xc &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;)))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.wd)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.encut)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.xc)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
encut validated
exc validated
some-dir
400
PBE
&lt;/pre&gt;

&lt;p&gt;
That is what this macro below does. We build up that code by making a keyword of the function name, and setting it to the value of the form the function is in.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;vaspm&lt;/span&gt; [wd &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body]
  &lt;span style="color: #036A07;"&gt;"Macro to build a Calculator with validation of arguments in BODY"&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [code `(Calculator ~wd)]
    (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [form body]
      (.append code (&lt;span style="color: #006FE0;"&gt;keyword&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;name&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;car&lt;/span&gt; form))))
      (.append code form))
    code))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, lets consider the macro version.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[calculator [*]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;calculator&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; calc (vaspm &lt;span style="color: #008000;"&gt;"some-dir"&lt;/span&gt; (encut 400) (xc &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.wd)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.encut)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.xc)

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;proof we can get to the encut docstring!&lt;/span&gt;
(help encut)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
encut validated
exc validated
some-dir
400
PBE
Help on function encut in module calculator:

encut(cutoff)
    The planewave cutoff energy in eV.
&lt;/pre&gt;

&lt;p&gt;
Sweet. The macro allows us to simplify our notation to be approximately the same as the original function, but with validation and docstring availability. Here is a variation of the macro that even uses keywords and builds the validation in from the keyword. It is not clear we can access the docstrings so easily here (ok, we can build an eldoc function that works either way, but the function method above is "more native").
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[calculator [*]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;calculator&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;vasp2&lt;/span&gt; [wd &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; kwargs]
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [code `(Calculator ~wd)]
    (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [x (&lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;   0 (len kwargs) 2)]
      (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [kw (&lt;span style="color: #006FE0;"&gt;nth&lt;/span&gt; kwargs x)
            val (&lt;span style="color: #006FE0;"&gt;nth&lt;/span&gt; kwargs (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 1 x))]
        (.append code kw)
        (.append code `(~(HySymbol (&lt;span style="color: #006FE0;"&gt;name&lt;/span&gt; kw)) ~val))))
    code))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;macroexpand&lt;/span&gt; '(vasp2 &lt;span style="color: #008000;"&gt;"/tmp"&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;:encut&lt;/span&gt; 1 &lt;span style="color: #D0372D;"&gt;:xc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;)))

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; calc (vasp2 &lt;span style="color: #008000;"&gt;"some-dir"&lt;/span&gt;
                  &lt;span style="color: #D0372D;"&gt;:encut&lt;/span&gt; 400
                  &lt;span style="color: #D0372D;"&gt;:xc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"PBE"&lt;/span&gt;))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.wd)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.encut)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; calc.xc)
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
(u'Calculator' u'/tmp' u'\ufdd0:encut' (u'encut' 1L) u'\ufdd0:xc' (u'xc' u'PBE'))
encut validated
exc validated
some-dir
400
PBE
&lt;/pre&gt;

&lt;p&gt;
To summarize here, we have looked at some ways to incorporate validation and documentation into kwargs. There are certainly ways to do this in Python, using these auxiliary functions. In fact we use them in hy too. We could build the validation into a Python &lt;span class="underline"&gt;&lt;span class="underline"&gt;init&lt;/span&gt;&lt;/span&gt; function too, using dynamic lookup of the function names, and evaluation of the functions. The macro features of hy give different opportunities for this, and different syntactical sugars to work with. The hy approach leads to less duplication (e.g. only a keyword, not a keyword and a function name that are the same), which will lead to fewer mistakes of the type xc=xd(something). Overall, interesting differences to contemplate.
&lt;/p&gt;

&lt;p&gt;
From a developer point of view there is the burden of writing all the validation functions, but the payoff is access to documentation and optionally, validation. Also, no kwargs that are not allowed will work. Right now, with **kwargs, they might silently fail.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/29/Enough-with-the-hyperbole---hy-does-things-that-are-not-as-easy-in-Python.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Managing contexts - Python vs hy</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/28/Managing-contexts-Python-vs-hy</link>
      <pubDate>Thu, 28 Apr 2016 14:32:40 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">p3sWsg64KLQplQeo8vt5xxcHh2A=</guid>
      <description>Managing contexts - Python vs hy</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-1"&gt;1. a try/except/finally approach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-2"&gt;2. A Python context manager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-3"&gt;3. A python decorator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-4"&gt;4. A hy macro approach&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;
A common pattern we have in running molecular simulations is to temporarily change to a new directory, do some stuff, and then change back to the directory, even if something goes wrong and an exception is raised. Here we examine several approaches to handling this in Python.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; a try/except/finally approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
A way to handle this is with a try/except/finally block in Python. Here we illustrate the idea. Nothing fancy happens for the exception here, other than we do get back to the original directory before the program ends. There is nothing wrong with this, but it is not that reusable, and has a lot of places to make sure the right thing happens.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; os
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(os.getcwd())
&lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;cwd&lt;/span&gt; = os.getcwd()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chdir(&lt;span style="color: #008000;"&gt;'/tmp'&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;f&lt;/span&gt; = &lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'some-file'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'w'&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   f.write(&lt;span style="color: #008000;"&gt;'5'&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(os.getcwd())
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   1 / 0
&lt;span style="color: #0000FF;"&gt;except&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;pass&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;finally&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   f.close()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chdir(cwd)

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(os.getcwd())

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'/tmp/some-file'&lt;/span&gt;).read())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
/Users/jkitchin/Dropbox/python/hyve
/private/tmp
/Users/jkitchin/Dropbox/python/hyve
5
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; A Python context manager&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
A more sophisticated way to handle this in Python is a context manager. We create a context manager here called cd that does the same thing. The context manager is longer, but we would presumably put this in module and import it. This allows us to to the same thing in a lot less code afterwards, and to reuse this pattern. We also use the built in context manager for opening a file. This is for the most part a syntactical sugar for the code above.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; contextlib

&lt;span style="color: #6434A3;"&gt;@contextlib.contextmanager&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;cd&lt;/span&gt;(wd):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; os
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;cwd&lt;/span&gt; = os.getcwd()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'Started in {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(os.getcwd()))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chdir(wd)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'Entered {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(os.getcwd()))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;yield&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;except&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;pass&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;finally&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chdir(cwd)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'Entered {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(os.getcwd()))

&lt;span style="color: #8D8D84;"&gt;##################################################################&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; cd(&lt;span style="color: #008000;"&gt;'/tmp'&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'some-other-file'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'w'&lt;/span&gt;) &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; f:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   f.write(&lt;span style="color: #008000;"&gt;'5'&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   1 / 0

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'/tmp/some-other-file'&lt;/span&gt;).read())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Started in /Users/jkitchin/Dropbox/python/hyve
Entered /private/tmp
Entered /Users/jkitchin/Dropbox/python/hyve
5
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; A python decorator&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Here is an example of doing something like this with a decorator. I don't do this too often, but this does more or less the same thing. It does eliminate a with statement and provide some context to do work in. The overall indentation is identical to the context manager we looked at previously because we have to wrap our code in a function to delay its execution, which we have to ask for with f(). A downside of this is f is always decorated now. I am not sure you can undecorate it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; os

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;cd&lt;/span&gt;(wd):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;outer&lt;/span&gt;(func):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;inner&lt;/span&gt;(*args):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;cwd&lt;/span&gt; = os.getcwd()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'Started in {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(os.getcwd()))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chdir(wd)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'entered {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(os.getcwd()))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; func(*args)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;except&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;pass&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;finally&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chdir(cwd)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'entered {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(os.getcwd()))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; inner
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; outer
&lt;span style="color: #8D8D84;"&gt;##################################################################&lt;/span&gt;

&lt;span style="color: #6434A3;"&gt;@cd&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'/tmp'&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt;():
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'decorated-file'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'w'&lt;/span&gt;) &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; f:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   f.write(&lt;span style="color: #008000;"&gt;"5"&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   1 / 0

f()
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(&lt;span style="color: #008000;"&gt;"/tmp/decorated-file"&lt;/span&gt;).read())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Started in /Users/jkitchin/Dropbox/python/hyve
entered /private/tmp
entered /Users/jkitchin/Dropbox/python/hyve
5
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-4" class="outline-2"&gt;
&lt;h2 id="sec-4"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; A hy macro approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
hy gives us yet another option: a macro. We can use a macro to construct the context for us by building up the try/except/finally code we used above. The indentation used here is just for readability.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;cd&lt;/span&gt; [wd &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body]
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;os&lt;/span&gt;)
    (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"started in "&lt;/span&gt; (os.getcwd))
    (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [cwd (os.getcwd)]
      (&lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;
       (&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt; (os.chdir ~wd)
           (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"entered "&lt;/span&gt; (os.getcwd))
           ~@body)
       (&lt;span style="color: #0000FF;"&gt;except&lt;/span&gt; [e Exception] &lt;span style="color: #D0372D;"&gt;nil&lt;/span&gt;)
       (&lt;span style="color: #0000FF;"&gt;finally&lt;/span&gt;
        (os.chdir cwd)
        (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"entered "&lt;/span&gt; (os.getcwd)))))))


&lt;span style="color: #8D8D84;"&gt;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;&lt;/span&gt;
(cd &lt;span style="color: #008000;"&gt;"/tmp"&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; [f (open &lt;span style="color: #008000;"&gt;"some-hy-file"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"w"&lt;/span&gt;)]
          (.write f &lt;span style="color: #008000;"&gt;"5"&lt;/span&gt;)
          (&lt;span style="color: #006FE0;"&gt;/&lt;/span&gt; 1 0)))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.read (open &lt;span style="color: #008000;"&gt;"/tmp/some-hy-file"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
started in  /Users/jkitchin/Dropbox/python/hyve
entered  /private/tmp
entered  /Users/jkitchin/Dropbox/python/hyve
5
&lt;/pre&gt;


&lt;p&gt;
The results are the same, even down to the reduced number of lines! But the mechanism that achieves that is different. In this example, we subtly changed the syntax that was possible, eliminating the need for one of the "with" statements. This is only possible with this kind of macro construction as far as I know. It still is not a game changer of programming, but does illustrate some new ways to think about writing these programs. It is not necessary to wrap the code into a function just to delay it from being executed.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/28/Managing-contexts---Python-vs-hy.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>More hyjinks - space - the final frontier</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/24/More-hyjinks-space-the-final-frontier</link>
      <pubDate>Sun, 24 Apr 2016 13:23:05 EDT</pubDate>
      <category><![CDATA[unknown]]></category>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">R5refcAntN1HmU_OhzC3-t2x8Z0=</guid>
      <description>More hyjinks - space - the final frontier</description>
      <content:encoded><![CDATA[



&lt;p&gt;
Apologies in advance if you haven't come across the programming language &lt;a href="http://esolangs.org/wiki/ook!"&gt;ook&lt;/a&gt; before now. It kind of looks like you recorded an orangutan as a program. It cracks me up to look at it.  You will not be a better person for learning about it here, or for what is about to follow. This would have been a great April Fool's joke.
&lt;/p&gt;

&lt;p&gt;
Here is a typical ook program. The canonical one for any language. I run it in a &lt;a href="https://github.com/jcharra/ook/blob/master/bf.py"&gt;Python ook&lt;/a&gt; interpreter. You might notice this program actually converts ook to its &lt;a href="https://en.wikipedia.org/wiki/Brainfuck"&gt;isomorphic relative&lt;/a&gt; and executes that program.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ook &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; *

&lt;span style="color: #BA36A5;"&gt;interpreter&lt;/span&gt; = BFInterpreter()

&lt;span style="color: #BA36A5;"&gt;program&lt;/span&gt; = &lt;span style="color: #008000;"&gt;"""Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook. Ook? Ook."""&lt;/span&gt;

interpreter.run_commands(convertOokToBF(program))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Hello World!
&lt;/pre&gt;

&lt;p&gt;
Yes, that odd looking program prints "Hello World!". Ook has just three syntax elements (Ook. Ook? Ook!), which when combined in pairs lead to 8 commands. You can represent any text in ook, as well as programs. It is supposedly Turing complete.
&lt;/p&gt;

&lt;p&gt;
Think it could not get worse? Prepare for disappointment. There are at least 8 different &lt;a href="https://www.cs.tut.fi/~jkorpela/chars/spaces.html"&gt;unicode spaces&lt;/a&gt; &amp;#x2026; You see where this is going. Yes, this is just a &lt;a href="http://esolangs.org/wiki/TrivialBrainfuckSubstitution"&gt;trivial substitution&lt;/a&gt; exercise. Go ahead and queue &lt;a href="https://www.youtube.com/watch?v=Fq3QmtV8vT0"&gt;Disturbed -- Down with the Sickness&lt;/a&gt; . Put it on repeat.
&lt;/p&gt;

&lt;p&gt;
Introducing: space - the final frontier. A place where noone should ever go. Yep. A whole, Turing complete language using different kinds of unicode spaces as the commands.  This idea is so bad that the only other language similar to it was an April Fool's joke more than a decade ago (&lt;a href="https://en.wikipedia.org/wiki/Whitespace_(programming_language)"&gt;https://en.wikipedia.org/wiki/Whitespace_(programming_language)&lt;/a&gt; )! They stuck with the ascii whitespace characters. Anyone else who ever had this idea probably had the decency to keep it to themselves. Here is probably the one and only (and hopefully last) space program in existence.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[space [*]]&lt;/span&gt;)

(space &lt;span style="color: #008000;"&gt;"&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8198;&amp;#8195;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8193;&amp;#8199;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8193;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8198;&amp;#8195;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8193;&amp;#8199;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8196;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8193;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8198;&amp;#8195;&amp;#8192;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8193;&amp;#8199;&amp;#8192;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8196;&amp;#8193;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8198;&amp;#8195;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8193;&amp;#8199;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8193;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8198;&amp;#8195;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8193;&amp;#8199;&amp;#8192;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8196;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8196;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8196;&amp;#8193;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8194;&amp;#8198;&amp;#8195;&amp;#8192;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8193;&amp;#8199;&amp;#8192;&amp;#8195;&amp;#8195;&amp;#8195;&amp;#8196;&amp;#8193;"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Hello World!
&lt;/pre&gt;

&lt;p&gt;
That's right, a program of nothing but different kinds of spaces that actually does something. Sure space can do anything any other Turing complete language can do, with an infinite sized stack, and a &lt;a href="http://www.dictionary.com/browse/sisyphean"&gt;Sysyphean&lt;/a&gt; patience and endurance, and a healthy dose of self-loathing. But why would you want to?
&lt;/p&gt;

&lt;p&gt;
That program is hiding out in the open there. It is a special kind of noise. Like a modern ascii art interpreted in unicode spaces. Maybe &lt;a href="http://www.bloombergview.com/articles/2014-11-14/why-pay-15-million-for-a-white-canvas"&gt;these paintings&lt;/a&gt; really have hidden messages in them. Forget steganography to hide your messages. Just &lt;a href="http://www.splitbrain.org/_static/ook/"&gt;encode them&lt;/a&gt; in ook, convert them to space and put them out there. Who would even know they were there if they did not know to look. Even if they did look, what do they see? space. I am probably getting on an NSA list for that suggestion. Space is so useful. You could use a unicode space version of Morse code. Three short spaces regular space three long spaces regular space three short spaces, i.e. "           ". Those quotes are just to hint they are there. A cry for help. If a space is on the page and nobody sees it, is it really there? A space by any other name would look like &amp;#x2026; a space?
&lt;/p&gt;

&lt;p&gt;
This hackery is actually just a trivial substitution on ook that translates each different space to the ook command it corresponds to and then runs it. I built it off of this &lt;a href="http://hackingjohnnz.blogspot.com/2011/06/ook-interpreter-in-python.html"&gt;Python ook intepreter&lt;/a&gt; , which translates the ook command to another program to run it. I implemented space in hy below. As bad as this idea is, I did not want to build a native space interpreter, just show the absurdity of it. Oh, and write a bit of hy code with dictionaries and comprehension. Sorry to drag that interesting project to this dark corner. Hy sure looks reasonable compared to this! Here is the thin layer.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; ook_lookup {(&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook."&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook?"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2000"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook?"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook."&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2001"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook."&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook."&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2002"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook!"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook!"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2003"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook!"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook."&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2004"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook."&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook!"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2005"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook!"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook?"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2006"&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook?"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Ook!"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"\u2007"&lt;/span&gt;}
      space_lookup (dict-comp v k [[k v] (.iteritems ook_lookup)]))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;ook2space&lt;/span&gt; [program]
  &lt;span style="color: #008000;"&gt;"Convert an ook PROGRAM to space syntax."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [chars (.split (.replace program &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;) &lt;span style="color: #008000;"&gt;" "&lt;/span&gt;)
        p1 (&lt;span style="color: #006FE0;"&gt;cut&lt;/span&gt; chars 0 &lt;span style="color: #D0372D;"&gt;nil&lt;/span&gt; 2)
        p2 (&lt;span style="color: #006FE0;"&gt;cut&lt;/span&gt; chars 1 &lt;span style="color: #D0372D;"&gt;nil&lt;/span&gt; 2)
        pairs (&lt;span style="color: #006FE0;"&gt;zip&lt;/span&gt; p1 p2)
        sp &lt;span style="color: #008000;"&gt;""&lt;/span&gt;]
    (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [ch pairs] (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; sp (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; ook_lookup ch)))
    sp))


(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;space2ook&lt;/span&gt; [program]
  &lt;span style="color: #008000;"&gt;"Convert a space PROGRAM to ook syntax."&lt;/span&gt;
  (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; space_lookup char)) [char program])))


(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[ook [*]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;space&lt;/span&gt; [space_program]
  &lt;span style="color: #008000;"&gt;"Run a space program."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [interpreter (BFInterpreter)
        bf_program (convertOokToBF (space2ook space_program))]
    (.run_commands interpreter bf_program)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can convert an ook program to a space program. I put the brackets in just for a visual boundary of the space program.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[space [*]]&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [program &lt;span style="color: #008000;"&gt;"Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook!&lt;/span&gt;
&lt;span style="color: #008000;"&gt;Ook! Ook! Ook. Ook? Ook."&lt;/span&gt;]
 (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.encode (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; &lt;span style="color: #008000;"&gt;"["&lt;/span&gt; (ook2space program) &lt;span style="color: #008000;"&gt;"]"&lt;/span&gt;) &lt;span style="color: #008000;"&gt;"utf-8"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
[                                                                                                                                                                                                             ]
&lt;/pre&gt;

&lt;p&gt;
Nothing but space here folks. Move along.
&lt;/p&gt;

&lt;p&gt;
What did we learn today? Evidently I have strange ideas sometimes, and I am not alone in that. Just because you can do something, certainly doesn't mean you should. Sorry for this use of your time if you got here. Please come back again!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/24/More-hyjinks---space---the-final-frontier.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Don't get hysterical - they are just unicode function names</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/23/Don-t-get-hysterical-they-are-just-unicode-function-names</link>
      <pubDate>Sat, 23 Apr 2016 12:57:58 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">NPMWe7J8o_Q_XO-D9v5hAuvgzK8=</guid>
      <description>Don't get hysterical - they are just unicode function names</description>
      <content:encoded><![CDATA[



&lt;p&gt;
&lt;a href="http://hylang.org"&gt;Hy&lt;/a&gt; allows us to define functions with unicode names. Here we play around with this to define logical operators with the symbols you normally see in formal papers (i.e. the LaTeX symbols). I think in Python3 you can also define unicode names for functions. It definitely does not work for Python2.7 which we use here (although remarkably via Hy it does work).
&lt;/p&gt;

&lt;p&gt;
First, we define the logical operators or, and, xor and not, and a few other interesting ones. In case it is not clear why a unicode representation of and is helpful, note there are three instances of the word and in the previous sentence, and only one is a logical operator!  This is just some syntactical beauty, but it will shortly make for a different representation of code. We tangle this code block to logical_operators.hy.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#8744;&lt;/span&gt; [a b] (&lt;span style="color: #006FE0;"&gt;or&lt;/span&gt; a b))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#8743;&lt;/span&gt; [a b] (&lt;span style="color: #006FE0;"&gt;and&lt;/span&gt; a b))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#8853;&lt;/span&gt; [a b] (xor a b))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#172;&lt;/span&gt; [a] (&lt;span style="color: #006FE0;"&gt;not&lt;/span&gt; a))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#8704;&lt;/span&gt; [x func]
  &lt;span style="color: #008000;"&gt;"(func x) is True for every x."&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;every?&lt;/span&gt; func x))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#8707;&lt;/span&gt; [x func]
  &lt;span style="color: #008000;"&gt;"func(x) is true for at least one x."&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;some&lt;/span&gt; func x))

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;&amp;#8707;!&lt;/span&gt; [x func]
  &lt;span style="color: #008000;"&gt;"func(x) is true for exactly one x."&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; 1 (len (list (&lt;span style="color: #006FE0;"&gt;filter&lt;/span&gt; func x)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is an example of using those operators. At the moment, we use the prefix notation of Lisp.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[logical_operators [*]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[serialize [stringify]]&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;show&lt;/span&gt; [body]
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.encode (.format &lt;span style="color: #008000;"&gt;"{0} = {1}"&lt;/span&gt; (stringify '~body) ~body) &lt;span style="color: #008000;"&gt;"utf-8"&lt;/span&gt;))))

(show (&amp;#172; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show (&amp;#8743; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show (&amp;#8743; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show (&amp;#8744; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show (&amp;#8744; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show (&amp;#8853; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show (&amp;#8853; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show (&amp;#8853; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show (&amp;#8704; [2 4 6] even?))
(show (&amp;#8707; [2 3 4] odd?))
(show (&amp;#8707;! [2 3 4] odd?))
(show (&amp;#8707;! [2 3 5] odd?))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
(¬ True) = False
(∧ True False) = False
(∧ True True) = True
(∨ True False) = True
(∨ True True) = True
(⊕ True False) = True
(⊕ True True) = False
(⊕ False False) = False
(∀ [2 4 6] is_even) = True
(∃ [2 3 4] is_odd) = True
(∃_bang [2 3 4] is_odd) = True
(∃_bang [2 3 5] is_odd) = False
&lt;/pre&gt;

&lt;p&gt;
Note the exclamation mark got expanded to _bang. It is evidently an ordinary ascii character.
&lt;/p&gt;

&lt;p&gt;
We can get an infix notation if we use our infix module and the #$ reader macro defined in it. Here are some examples. Note it doesn't make sense to use this all time, e.g. it would even be a mistake to do this with the not operator.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[logical_operators [*]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[serialize [stringify]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;[infix [*]]&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;show&lt;/span&gt; [body]
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.encode (.format &lt;span style="color: #008000;"&gt;"{0} = {1}"&lt;/span&gt; (stringify '~body) ~body) &lt;span style="color: #008000;"&gt;"utf-8"&lt;/span&gt;))))

(show (&amp;#172; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &amp;#8743; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &amp;#8743; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &amp;#8744; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &amp;#8744; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &amp;#8853; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt; &amp;#8853; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(show #$(&lt;span style="color: #D0372D;"&gt;False&lt;/span&gt; &amp;#8853; &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
(¬ True) = False
(dispatch_reader_macro "$" (True ∧ False)) = False
(dispatch_reader_macro "$" (True ∧ True)) = True
(dispatch_reader_macro "$" (True ∨ False)) = True
(dispatch_reader_macro "$" (True ∨ True)) = True
(dispatch_reader_macro "$" (True ⊕ False)) = True
(dispatch_reader_macro "$" (True ⊕ True)) = False
(dispatch_reader_macro "$" (False ⊕ False)) = False
&lt;/pre&gt;

&lt;p&gt;
The show macro shows us how the reader macro gets expanded into, you guessed it, regular old function calls. They are just syntactical sugar to help us be more concise. The unicode symbols are not quite as simple to type as ascii names, but there are solutions to this: abbreviations in Emacs (&lt;a href="http://ergoemacs.org/emacs/emacs_n_unicode.html"&gt;http://ergoemacs.org/emacs/emacs_n_unicode.html&lt;/a&gt; ), custom commands, learn the keystrokes (&lt;a href="http://www.johndcook.com/blog/emacs_unicode/"&gt;http://www.johndcook.com/blog/emacs_unicode/&lt;/a&gt; ) and C-x 8 RET and the unicode name, etc&amp;#x2026; Is it worth it? That might depend on how ingrained those logical symbols are in your mental model of your work. If it is deeply ingrained, your code will be better aligned with your thoughts, and easier to understand.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/23/Don't-get-hysterical---they-are-just-unicode-function-names.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Code completion in HyDE</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/18/Code-completion-in-HyDE</link>
      <pubDate>Mon, 18 Apr 2016 11:24:13 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">eg8IDQzl-8dIu2kqoax0llvdL5k=</guid>
      <description>Code completion in HyDE</description>
      <content:encoded><![CDATA[



&lt;p&gt;
Code completion is often useful in an editor. Today, we add some code completion to Emacs for &lt;a href="http://hylang.org"&gt;hy&lt;/a&gt; . It isn't that hard; we get a list of known keywords from the hy language, a list of functions and macros, and a list of variables from the current buffer. If you are following this line of development, the code can be found here: &lt;a href="https://github.com/jkitchin/jmax/blob/master/mile-hy.el"&gt;https://github.com/jkitchin/jmax/blob/master/mile-hy.el&lt;/a&gt; 
&lt;/p&gt;

&lt;p&gt;
If not, there might be some interesting tips here on getting completion in Emacs ;)
&lt;/p&gt;

&lt;p&gt;
We will use auto-complete (&lt;a href="http://auto-complete.org/doc/manual.html#extend"&gt;http://auto-complete.org/doc/manual.html#extend&lt;/a&gt; ) for now. First, we can add hy-mode to the list of ac-modes:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;* auto-complete&lt;/span&gt;
(add-to-list 'ac-modes 'hy-mode)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next, we need to define some sources and functions for completion. Over at &lt;a href="https://github.com/jkitchin/hyve/blob/master/hylp.hy#L65"&gt;https://github.com/jkitchin/hyve/blob/master/hylp.hy#L65&lt;/a&gt; I defined a function that returns a list of all hy core functions and macros that Emacs can directly read.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy-all-keywords-emacs-completion&lt;/span&gt; []
  &lt;span style="color: #008000;"&gt;"Return a string for Emacs completion suitable for read in Emacs.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;We unmangle the names and replace _ with -."&lt;/span&gt;
  (str
   (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; &lt;span style="color: #008000;"&gt;"("&lt;/span&gt;
      (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"\"{}\""&lt;/span&gt; (.replace x &lt;span style="color: #008000;"&gt;"_"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"-"&lt;/span&gt;))
                            [x (hy-all-keywords)]))
      &lt;span style="color: #008000;"&gt;")"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
Here, we define a source that gets that information from the hy repl using the lispy&amp;#x2013;eval-hy function. This has the downside of calling the repl, but it seems fast, and I haven't noticed any lags so far. The upside is it only gets called once and has everything hy knows about, i.e. i don't have to update this for new core functions/macros.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;ac-source-hy-keywords&lt;/span&gt;
  `((candidates . ,(read (lispy--eval-hy &lt;span style="color: #008000;"&gt;"(hy-all-keywords-emacs-completion)"&lt;/span&gt;))))
  &lt;span style="color: #036A07;"&gt;"Keywords known from hy. The command is defined in hyve.hylp."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It would also be nice to have the defns/macros in the current file available for completion. This hackery searches the current buffer for these with a pretty simple regex and accumulates the results.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy-defns-macros&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Get a list of defns in the current file."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((defns '()))
    (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
      (goto-char (point-min))
      (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (re-search-forward &lt;span style="color: #008000;"&gt;"&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?:&lt;/span&gt;&lt;span style="color: #008000;"&gt;defn&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;defmacro&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;[[:space:]]+&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;.*?&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt; "&lt;/span&gt;nil t)
        (&lt;span style="color: #0000FF;"&gt;push&lt;/span&gt; (match-string 1) defns)))
    defns))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Finally, we would also like the variable names from setv and let. Hy is lispy, so we use a hybrid regex search, followed by read to get every other name in the case of setv, and the vector expression in the let case.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy-variables&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Collect the variable names in the current buffer.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;These are every other name after setv."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((vars '())
        expr
        set-vars
        let-vars)
    (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
      (goto-char (point-min))
      (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (re-search-forward &lt;span style="color: #008000;"&gt;"(setv"&lt;/span&gt; nil t)
        (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
          (goto-char (match-beginning 0))
          (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; expr (read (current-buffer)))
          (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; set-vars (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for x in (cdr expr) by #'cddr
                               collect x)))))
    (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
      (goto-char (point-min))
      (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (re-search-forward &lt;span style="color: #008000;"&gt;"(let"&lt;/span&gt; nil t)
        (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
          (goto-char (match-beginning 0))
          (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; expr (read (current-buffer)))
          &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this is read as a vector, so we convert to a list.&lt;/span&gt;
          (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; let-vars
                (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for x in (append (nth 1 expr) nil)
                      by #'cddr collect x)))))
    (append set-vars let-vars)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next, we define two new sources for completion that use those two functions:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;ac-source-hy-defns&lt;/span&gt;
  '((candidates . hy-defns-macros))
  &lt;span style="color: #036A07;"&gt;"Functions/macros defined in the file."&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;ac-source-hy-variables&lt;/span&gt;
  '((candidates . hy-variables))
  &lt;span style="color: #036A07;"&gt;"Hy variables defined in the file."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And finally add this to the hy-setup hook function:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ac-sources '(ac-source-hy-keywords
                     ac-source-hy-defns
                     ac-source-hy-variables))

  (ac-set-trigger-key &lt;span style="color: #008000;"&gt;"TAB"&lt;/span&gt;)
  (auto-complete-mode 1)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And we should be good to go with completion. Let's try it out.
&lt;/p&gt;

&lt;p&gt;
Checkout the video here: &lt;a href="https://www.youtube.com/watch?v=L6j5IWkpoz0"&gt;https://www.youtube.com/watch?v=L6j5IWkpoz0&lt;/a&gt; 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [some-long-name 5
      boring-and-tedious &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;]
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; boring-and-tedious))

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; another-var &lt;span style="color: #D0372D;"&gt;nil&lt;/span&gt; inline-name (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 4 5)
      hylarious-var 5)

(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; hylarious-var 8 )

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;Some-long-function&lt;/span&gt; []
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; 6))

(Some-long-function)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
tree
6
&lt;/pre&gt;

&lt;p&gt;
Sweet.&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/18/Code-completion-in-HyDE.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>What are you hy?</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/15/What-are-you-hy</link>
      <pubDate>Fri, 15 Apr 2016 08:46:02 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">Wp01ifnZ3lR6gsgax_O-HYdyPzQ=</guid>
      <description>What are you hy?</description>
      <content:encoded><![CDATA[



&lt;p&gt;
Hy lets us do things that either aren't possible, or definitely aren't easy in Python. You may have drank the Python Koolaid  and don't think those things are necessary, but we have Hy-C, and we took a sip of that just now, so let's see what we can do.
&lt;/p&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2016-04-15-What-are-you-hy%3F/hyss.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
We can have functions that are punctuation!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;!&lt;/span&gt; [arg] (&lt;span style="color: #006FE0;"&gt;not&lt;/span&gt; arg))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (! &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (! &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
False
True
&lt;/pre&gt;

&lt;p&gt;
How about that function that just returns something truthy? Shouldn't those end in a question-mark? They can and sometimes do. Not a problem when you are hy.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;string?&lt;/span&gt; [s]
 (isinstance s str))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;string?&lt;/span&gt; 4))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;string?&lt;/span&gt; &lt;span style="color: #008000;"&gt;"4"&lt;/span&gt;))        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;haha. strings in hy like "4" are unicode, not a str.&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;string?&lt;/span&gt; (str &lt;span style="color: #008000;"&gt;"4"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
False
False
True
False
&lt;/pre&gt;

&lt;p&gt;
Isn't that better than is_a_string?
&lt;/p&gt;

&lt;p&gt;
Underscores. Pfffft&amp;#x2026;. Dashes in names are awesome. Unless you hate your pinky and are shifty.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;100-yard-&lt;/span&gt; [x]
  &lt;span style="color: #008000;"&gt;"Funniest function name ever. Don't do this at home."&lt;/span&gt;
  (.format &lt;span style="color: #008000;"&gt;"You ran that in {} seconds! New World Record!"&lt;/span&gt; 9.42))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (100-yard- 2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
You ran that in 9.42 seconds! New World Record!
&lt;/pre&gt;

&lt;p&gt;
Why not build code with code? Here is a fun way to add up only the even numbers in a list. wHy? wHy?? Because we can, and it leads to other interesting opportunities!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [a [1 2 3 4 5 6]
      code '()]
  (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; code `(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt;))  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;add an operator&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [n a]
    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;even?&lt;/span&gt; n)
      (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; code `(~(hy.models.integer.HyInteger n)))))
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; code)

  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; code)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(u'+' 2L 4L 6L)
12
&lt;/pre&gt;

&lt;p&gt;
Ok, that isn't so beautiful, but it shows we can generate code and then execute it. We could also do that like we do in python where you build up the list of even numbers, and then sum them. It's the beginning of macros.
&lt;/p&gt;

&lt;p&gt;
But I can't live without objects! How else can you encapsulate data? Let's see how and give you some closure to get on with programming. (yea, the puns get worse ;).
&lt;/p&gt;

&lt;p&gt;
This next example illustrates a closure which we can use to encapsulate data. We use let to create a context with the variable i defined. i doesn't exist outside the context, but the lambda function created inside it retains access to the variable i.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #006FE0;"&gt;def&lt;/span&gt; counter
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [i [0]]
    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; [] (&lt;span style="color: #006FE0;"&gt;assoc&lt;/span&gt; i 0 (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 1 (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; i 0))) (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; i 0))))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (counter))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (counter))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;i is not a global var!&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;
 (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; i)
 (&lt;span style="color: #0000FF;"&gt;except&lt;/span&gt; [e NameError] (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"i is not defined here!"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1
2
i is not defined here!
&lt;/pre&gt;

&lt;p&gt;
Yes, the use of a list to store the counter is wonky; it is because of namespaces in Python. We get around the issue with a list here, that stores the data. Thanks Paul Tagliamonte (the resident Hypster) for the tip. Apparently Python scoping doesn't work enough here, but the list approach does, as does creating class instances to store the counter. Hylarious.
&lt;/p&gt;

&lt;p&gt;
Let's check out a macro. First, here is a code example. A common pattern is to save a value in a let statement temporarily, so we can reuse it in other expressions.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [x (&lt;span style="color: #006FE0;"&gt;&amp;gt;&lt;/span&gt; 2 0)]
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; x
    (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; x))
   (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; x))))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;a one line version for comparison&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [x (&lt;span style="color: #006FE0;"&gt;&amp;lt;&lt;/span&gt; 2 0)] (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; x (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; x)) (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; x))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
True
False
&lt;/pre&gt;

&lt;p&gt;
That example has a lot of parentheses, and it might nice if there were fewer parentheses. There is a macro form to deal with this (it is actually defined in the hylang contrib directory, but it is short so we look at it here). This is called an anaphoric macro, because it captures a variable called "it" for reuse later in the macro. With the aif macro we can eliminate the use of the let statement in production code, eliminating a set of parentheses, and also the temporary variable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;aif&lt;/span&gt; [test-form then-form &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; else-form]
  `(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [it ~test-form]
     (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; it ~then-form ~else-form)))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;In this code, it is bound to the first form value.&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (aif (&lt;span style="color: #006FE0;"&gt;&amp;gt;&lt;/span&gt; 2 0) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (aif (&lt;span style="color: #006FE0;"&gt;&amp;lt;&lt;/span&gt; 2 0) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it)))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;How does it work? By expanding to code.&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;macroexpand&lt;/span&gt; '(aif (&lt;span style="color: #006FE0;"&gt;&amp;lt;&lt;/span&gt; 2 0) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
True
False
((u'fn' [] (u'setv' u'it' (u'&amp;lt;' 2L 0L)) (u'if' u'it' (u'.format' u'{}' u'it') (u'.format' u'{}' u'it'))))
&lt;/pre&gt;

&lt;p&gt;
Here is how you would do this in a regular program if you wanted to use the contrib library in hy.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy.contrib.anaphoric&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (ap-if (&lt;span style="color: #006FE0;"&gt;&amp;gt;&lt;/span&gt; 2 0) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it) (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; it)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
True
&lt;/pre&gt;

&lt;p&gt;
Macros are useful for changing syntax and simplifying code. That works because the code in the macro is like data that can be manipulated and selectively evaluated. Here is an example of manipulating code like that. We start with an expression to add two numbers, and then modify it to be a multiplication.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; code '(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 5 6))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; code))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;change + to *&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;assoc&lt;/span&gt; code 0 '*)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; code)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; code))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
11
(u'*' 5L 6L)
30
&lt;/pre&gt;

&lt;p&gt;
That is an indication that we can do some very interesting things with Lisp! Let's be fair and show this can also be done in Python. We just have to parse out the AST, and then we can manipulate it and get back to code. It isn't pretty, but doable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; ast

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;parse the statement&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;p&lt;/span&gt; = ast.parse(&lt;span style="color: #008000;"&gt;"print 5 + 6"&lt;/span&gt;)

&lt;span style="color: #0000FF;"&gt;exec&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;compile&lt;/span&gt;(p, &lt;span style="color: #008000;"&gt;"&amp;lt;string&amp;gt;"&lt;/span&gt;, &lt;span style="color: #008000;"&gt;"exec"&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt; ast.dump(p)

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Change + to *&lt;/span&gt;
p.body[0].values[0]&lt;span style="color: #BA36A5;"&gt;.op&lt;/span&gt; = ast.Mult()

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;exec&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;compile&lt;/span&gt;(p, &lt;span style="color: #008000;"&gt;"&amp;lt;string&amp;gt;"&lt;/span&gt;, &lt;span style="color: #008000;"&gt;"exec"&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt; ast.dump(p)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
11
Module(body=[Print(dest=None, values=[BinOp(left=Num(n=5), op=Add(), right=Num(n=6))], nl=True)])

30
Module(body=[Print(dest=None, values=[BinOp(left=Num(n=5), op=Mult(), right=Num(n=6))], nl=True)])
&lt;/pre&gt;

&lt;p&gt;
That is not as clear as what we did in hy! Why? Because we had to transform the Python to AST, and manipulate it. In Lisp, the code is already in the abstract tree form, and we manipulate it more directly. It is easier to reason about.
&lt;/p&gt;

&lt;p&gt;
I bet you didn't think we could use a hy program &lt;i&gt;for more than one thing&lt;/i&gt;. Sure we may want to run it, but maybe we would like a different representation of the program than the code too.  Here we define two macros that both take a program as input. One simply evaluates the program, so we can use it. The other takes the program, and outputs a LaTeX representation of it. It only converts a division expression correctly (and only if all the arguments are numbers and not other expressions), but it illustrates that we can use a program as data, and do different things with it!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;run&lt;/span&gt; [body] `(&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; ~body))

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;latex&lt;/span&gt; [body]
  `(&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;car&lt;/span&gt; ~body) '/)
    (.format &lt;span style="color: #008000;"&gt;"\(\\frac{{{0}}} {{{1}}}\)"&lt;/span&gt;
            (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; ~body 1)
            (.join &lt;span style="color: #008000;"&gt;" \\cdot "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (str x) [x (&lt;span style="color: #006FE0;"&gt;cut&lt;/span&gt; ~body 2)])))]
   [&lt;span style="color: #D0372D;"&gt;true&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;raise&lt;/span&gt; (Exception &lt;span style="color: #008000;"&gt;"Unsupported program"&lt;/span&gt;))]))

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; code '(&lt;span style="color: #006FE0;"&gt;/&lt;/span&gt; 1 2 4.0))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (run code))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (latex code))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0.125
\(\frac{1} {2 \cdot 4.0}\)
&lt;/pre&gt;

&lt;p&gt;
It is possible to do something kind of like this in Python. In &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/05/16/Python-data-structures-to-lisp/"&gt;this post&lt;/a&gt; I put a lisp function onto the base classes of objects so you could transform Python objects to lisp representations.
&lt;/p&gt;

&lt;p&gt;
Well, that is probably enough Hy-C for the day. I am still playing around to figure out what kinds of things can we do with Hy that aren't easy or feasible in Python. These are a few of my favorite examples! If you have other cool things you do, put them in a comment hyre!&lt;/p&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/15/What-are-you-hy?.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;
]]></content:encoded>
    </item>
    <item>
      <title>Operator precedence in infix notation by automatic parenthesizing</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/10/Operator-precedence-in-infix-notation-by-automatic-parenthesizing</link>
      <pubDate>Sun, 10 Apr 2016 13:32:00 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">JDUc4301QcqwF6zS0jpflmysyQs=</guid>
      <description>Operator precedence in infix notation by automatic parenthesizing</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-1"&gt;1. Another test of a real problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I am continuing some investigation in getting operator precedence right with infix notation. You can fully parenthesize your expressions for this, but it is tedious and hard to read. Apparently in Fortran I (yep, one) the compiler would expand each operator in an expression with a sequence of parentheses to get the precedence right (&lt;a href="https://en.wikipedia.org/wiki/Operator-precedence_parser"&gt;https://en.wikipedia.org/wiki/Operator-precedence_parser&lt;/a&gt; )!
&lt;/p&gt;

&lt;p&gt;
Roughly, these were the rules.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;replace + and – with ))+(( and ))-((, respectively;
&lt;/li&gt;
&lt;li&gt;replace * and / with )*( and )/(, respectively;
&lt;/li&gt;
&lt;li&gt;add (( at the beginning of each expression and after each left parenthesis in the original expression; and
&lt;/li&gt;
&lt;li&gt;add )) at the end of the expression and before each right parenthesis in the original expression.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
So this
&lt;/p&gt;
&lt;pre class="example"&gt;
a * b + c ^ d / e
&lt;/pre&gt;

&lt;p&gt;
becomes
&lt;/p&gt;

&lt;pre class="example"&gt;
((((a))*((b)))+(((c)^(d))/((e))))
&lt;/pre&gt;

&lt;p&gt;
Not too pretty, but correct! The wikipedia page provides an example C program to implement this, and we adapt it here for hy. The idea is to take an expression as a string, parenthesize it, and then we could eval it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;parenthesize&lt;/span&gt; [input]
  &lt;span style="color: #008000;"&gt;"Fully parenthize the input string."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [s &lt;span style="color: #008000;"&gt;""&lt;/span&gt;]
    (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"(((("&lt;/span&gt;)
    (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [(&lt;span style="color: #006FE0;"&gt;,&lt;/span&gt; i char) (enumerate input)]
      (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;"("&lt;/span&gt;)
        (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"(((("&lt;/span&gt;)]
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;")"&lt;/span&gt;)
        (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"))))"&lt;/span&gt;)]
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;rewrite ^ to **&lt;/span&gt;
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;"^"&lt;/span&gt;)
        (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;")**("&lt;/span&gt;)]
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;"*"&lt;/span&gt;)
        (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"))*(("&lt;/span&gt;)]
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;"/"&lt;/span&gt;)
        (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"))/(("&lt;/span&gt;)]
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;"+"&lt;/span&gt;)
        (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;or&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; 0 i) (&lt;span style="color: #006FE0;"&gt;in&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; input (&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; i 1)) [&lt;span style="color: #008000;"&gt;"("&lt;/span&gt; &lt;span style="color: #008000;"&gt;"^"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"*"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"/"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"+"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"-"&lt;/span&gt;]))
          (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"+ "&lt;/span&gt;)
          (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;")))+((("&lt;/span&gt;))]
       [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; char &lt;span style="color: #008000;"&gt;"-"&lt;/span&gt;)
        (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;or&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; 0 i) (&lt;span style="color: #006FE0;"&gt;in&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; input (&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; i 1)) [&lt;span style="color: #008000;"&gt;"("&lt;/span&gt; &lt;span style="color: #008000;"&gt;"^"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"*"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"/"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"+"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"-"&lt;/span&gt;]))
          (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"- "&lt;/span&gt;)
          (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;")))-((("&lt;/span&gt;))]
       [&lt;span style="color: #D0372D;"&gt;true&lt;/span&gt;
        (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s char)]))
    (&lt;span style="color: #006FE0;"&gt;+=&lt;/span&gt; s &lt;span style="color: #008000;"&gt;"))))"&lt;/span&gt;)
    s))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Let's try it out.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (parenthesize &lt;span style="color: #008000;"&gt;"a * b + c ^ d / e"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
((((a ))*(( b )))+((( c )**( d ))/(( e))))
&lt;/pre&gt;

&lt;p&gt;
For comparison:
&lt;/p&gt;

&lt;p&gt;
((((a))*((b)))+(((c)^(d))/((e))))
&lt;/p&gt;

&lt;p&gt;
Spaces aside, it looks like we got that right. The spaces should not be a problem for lisp. This is another strategy to get infix notation with operator precedence! Let's see some examples.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (nfx (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt; (parenthesize &lt;span style="color: #008000;"&gt;"1 + 2 * 5"&lt;/span&gt;)))))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (nfx (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt; (parenthesize &lt;span style="color: #008000;"&gt;"1 * 2 + 5"&lt;/span&gt;)))))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (nfx (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt; (parenthesize &lt;span style="color: #008000;"&gt;"1 * 2 + 2^2"&lt;/span&gt;)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
11
7
6
&lt;/pre&gt;

&lt;p&gt;
We can get that string representation easy enough.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (nfx (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt; (parenthesize (stringify `(1 + 2)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3
&lt;/pre&gt;

&lt;p&gt;
This too is worthy of simplifying the notation with a function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;NFX&lt;/span&gt; [code &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; [globals (globals)]]
  &lt;span style="color: #008000;"&gt;"Evaluate the infix CODE.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;CODE is stringified, parenthesized, read back and infixed."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;serialize&lt;/span&gt;)
  (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (infix.nfx
         (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt;
          (infix.parenthesize
           (serialize.stringify code)))) globals))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;NFX&lt;/span&gt; [code]
  &lt;span style="color: #036A07;"&gt;"Evaluate the infix CODE.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;CODE is stringified, parenthesized, read back and infixed."&lt;/span&gt;
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
    (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;serialize&lt;/span&gt;)
    (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (infix.nfx
           (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt;
            (infix.parenthesize
             (serialize.stringify ~code)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is a simple example.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(import [infix [*]])&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (NFX `(1 + 2 * 5)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (NFX `((1 + 2) * 5)))

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (NFX `(1 + (np.exp 2))))

&lt;span style="color: #8D8D84;"&gt;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;not working because of infix&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(print (NFX `(1 + (np.linspace 0 1 5))))&lt;/span&gt;

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;But this is ok since no infix mangling happens.&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [a (np.linspace 0 1 5)]
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (NFX `(1 + a))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
11
15
8.38905609893
[ 1.    1.25  1.5   1.75  2.  ]
&lt;/pre&gt;

&lt;p&gt;
That is slightly heavy still, and we can fix it with a new reader macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defreader&lt;/span&gt; &lt;span style="color: #006699;"&gt;m&lt;/span&gt; [code]
 `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
    (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;serialize&lt;/span&gt;)
    (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (infix.nfx
           (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt;
            (infix.parenthesize
             (serialize.stringify ~code)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Since we return code in that reader macro, we have to quote the code. This is debatably more concise than the NFX macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #m`(1 + 2 + 5))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #m`(1 + 2 * 5))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #m`((1 + 2) * 5))

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #m`((1 + (np.exp 2))))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;these are all the same&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 1 (np.exp 2) (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; 2 5)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #m(`(1 + (np.exp 2) + 2 * 5)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (NFX `(1 + (np.exp 2) + 2 * 5)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
8
11
15
8.38905609893
18.3890560989
18.3890560989
18.3890560989
&lt;/pre&gt;


&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Another test of a real problem&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Here is another test of using an infix notation, this time with operator precedence. Note the use of ^ for exponentiation. The parenthesize function assumes single character operators, and would take some work to use **. Note we still need the space between - and x to avoid a mangling issue with _x in hy.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(import [scipy.integrate [odeint]])
(import [scipy.special [jn]])
(import [matplotlib.pyplot &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; plt])

(import [infix [*]])
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;fbessel&lt;/span&gt; [Y x]
  &lt;span style="color: #008000;"&gt;"System of 1st order ODEs for the Bessel equation."&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; nu 0.0
        y (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; Y 0)
        z (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; Y 1))

  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;define the derivatives&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; dydx z
        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the Python way is: "1.0 / x**2 * (-x * z - (x**2 - nu**2) * y)"&lt;/span&gt;
        dzdx #m`((1.0 / x^2) * ((&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; x) * z - (x^2 - nu^2) * y)))
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Here is what it was with prefix notation&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;dzdx (* (/ 1.0 (** x 2)) (- (* (* -1 x) z) (* (- (** x 2) (** nu 2)) y))))&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;return derivatives&lt;/span&gt;
  [dydx dzdx])

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; x0 1e-15
      y0 1.0
      z0 0.0
      Y0 [y0 z0])

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; xspan (np.linspace 1e-15 10)
      sol (odeint fbessel Y0 xspan))

(plt.plot xspan (. sol [[Ellipsis 0]]) &lt;span style="color: #D0372D;"&gt;:label&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Numerical solution"&lt;/span&gt;)
(plt.plot xspan (jn 0 xspan) &lt;span style="color: #008000;"&gt;"r--"&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;:label&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Analytical solution"&lt;/span&gt;)
(plt.legend &lt;span style="color: #D0372D;"&gt;:loc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"best"&lt;/span&gt;)

(plt.savefig &lt;span style="color: #008000;"&gt;"bessel-infix-m.png"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2016-04-10-Operator-precedence-in-infix-notation-by-automatic-parenthesizing/bessel-infix-m.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
I wonder if there is actually some ambiguity in the expression or how it is parenthesized. We get the right answer with:
&lt;/p&gt;

&lt;pre class="example"&gt;
(1.0 / x^2) * ((- x) * z - (x^2 - nu^2) * y)
&lt;/pre&gt;

&lt;p&gt;
but not with:
&lt;/p&gt;

&lt;pre class="example"&gt;
1.0 / x^2 * ((- x) * z - (x^2 - nu^2) * y))
&lt;/pre&gt;

&lt;p&gt;
Let's see if we can see why. Consider 1 / x * a. This should probably be evaluated as (1 / x) * a. This shows the algorithm does not do that.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;
 (nfx
 (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt;
 (parenthesize
  (stringify `(1 / x * a))))))
&lt;span style="color: #8D8D84;"&gt;;   &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;`(1.0 / x^2 * ((- x) * z - (x^2 - nu^2) * y)))))))&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(u'/' 1L (u'*' u'x' u'a'))
&lt;/pre&gt;

&lt;p&gt;
That reads: 1 / (x * a)
&lt;/p&gt;

&lt;p&gt;
If we had a layer of parentheses we get the right answer.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;
 (nfx
 (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt;
 (parenthesize
  (stringify `((1 / x) * a))))))
&lt;span style="color: #8D8D84;"&gt;;   &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;`((1.0 / x^2) * ((- x) * z - (x^2 - nu^2) * y)))))))&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(u'*' (u'/' 1L u'x') u'a')
&lt;/pre&gt;

&lt;p&gt;
This reads (1 / x) * a. Our algorithm doesn't do exactly what we expect here. I guess this could be a general issue of neighboring operators with equal precedence.
&lt;/p&gt;

&lt;p&gt;
Related to this, the Wikipedia page points out this example:
&lt;/p&gt;

&lt;pre class="example"&gt;
- a ^ 2
&lt;/pre&gt;

&lt;p&gt;
What does this mean? It is either (-a)^2 or -(a^2). The second is correct based on normal precedence, but the algorithm gives the unary operator - a higher precedence.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [parenthesize]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (parenthesize &lt;span style="color: #008000;"&gt;"- a ^ 2"&lt;/span&gt;))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (parenthesize &lt;span style="color: #008000;"&gt;"- (a ^ 2)"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
((((-  a )**( 2))))
((((-  ((((a )**( 2))))))))
&lt;/pre&gt;

&lt;p&gt;
To get the right thing, you need to use parentheses. Sometimes I do that in real code anyway to make sure what I want to happen does. Maybe some of this can be fixed in our parser function. Probably for another day.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/10/Operator-precedence-in-infix-notation-by-automatic-parenthesizing.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Getting towards an infix notation for hy</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/09/Getting-towards-an-infix-notation-for-hy</link>
      <pubDate>Sat, 09 Apr 2016 14:54:04 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">g1MMhtIvVNex3BjA-KsfqMrXN2s=</guid>
      <description>Getting towards an infix notation for hy</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-1"&gt;1. using strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-2"&gt;2. Infix to prefix using code manipulation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-3"&gt;3. The final test&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-3-1"&gt;3.1. with the string reader&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-3-2"&gt;3.2. with #$ reader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;
Engineers need infix notation. It's a bold statement I know, but I am an engineer, teach engineers, and write a fair bit of mathematical programs. Your typical engineer is not a programmer, and just wants to write an equation they way we would write it on paper. It is hard to undo 20+ years of education on that point! So, here we consider how to adapt hy to use infix notation.
&lt;/p&gt;

&lt;p&gt;
In a recent &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2016/03/31/More-on-Hy-and-why-I-think-it-is-a-big-deal/"&gt;post&lt;/a&gt; &lt;a href="https://disqus.com/by/disqus_LNqeXKtJMi/"&gt;gilch&lt;/a&gt; suggested using strings with the builtin python eval function. There are some potential downsides to that approach including the overhead of byte-compiling each time it is eval'd,  but the payoff is operator precedence, and doing it like you would do it in Python.
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; using strings&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
UPDATE: Thanks to some help from Jiege Chen I updated this section to solve the namespace issues previously discussed. That resulted in quite a bit of improvement. Thanks Jiege!
&lt;/p&gt;

&lt;p&gt;
Here is one implementation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #006FE0;"&gt;def&lt;/span&gt; py-eval (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; __builtins__ &lt;span style="color: #008000;"&gt;"eval"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And how to use it.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (py-eval &lt;span style="color: #008000;"&gt;"2+3*5"&lt;/span&gt;))

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (py-eval &lt;span style="color: #008000;"&gt;"2 * np.exp(np.pi / 2)"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
17
9.62095476193
&lt;/pre&gt;

&lt;p&gt;
We can eliminate the need for quotes (") with the stringify code we previously developed.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [*]])
(import [infix [*]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (py-eval (stringify `(2+3*5))))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (py-eval (stringify `(2 + 3 * 5))))

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (py-eval (stringify `(2 * np.exp(np.pi / 2)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
17
17
9.62095476193
&lt;/pre&gt;

&lt;p&gt;
Let's just take that one more step with a new reader macro to tighten the syntax up. A critical feature of this reader macro is that it expands to code evaluated in the namespace where it is used. Nothing gets evaluated in the macro. That occurs in another namespace, where most things in a script are not available.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defreader&lt;/span&gt; &lt;span style="color: #006699;"&gt;p&lt;/span&gt; [code]
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (import [serialize [stringify]])
    (import [infix [py-eval]])
    (py-eval (stringify ~code))))

(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;py&lt;/span&gt; [code]
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (import [serialize [stringify]])
    (import [infix [py-eval]])
    (py-eval (stringify ~code))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we can use it like this. We have to require the infix module to get the reader macro. It seems unfortunate to me we still have to quote the code. Later I show an example where that isn't necessary, so there must be some subtle difference I have not found yet.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;we have to require to get the reader macro&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #p`(2 + 3 * 5))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #p`((2 + 3) * 5))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #p`(1 + 1 * np.exp(7)))

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; x 5)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #p`(x + 2))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #p`(1 + 1 * np.exp(1e-15)))
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;note the real python syntax with commas.&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;also not the extra parens around 1e-5&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #p`(1 + np.linspace((1e-5), 1, 5)))

&lt;span style="color: #8D8D84;"&gt;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The 1e-5 gets mangled to 1e-5 in this example&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(print #p`(1 + np.linspace(1e-5, 1, 5)))&lt;/span&gt;

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Here is the macro form. It is about as easy to write.&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (py `(1 + np.linspace((1e-5), 1, 5))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
17
25
1097.63315843
7
2.0
[ 1.00001    1.2500075  1.500005   1.7500025  2.       ]
[ 1.00001    1.2500075  1.500005   1.7500025  2.       ]
&lt;/pre&gt;

&lt;p&gt;
Lots of things seem to work! Let's look into some other solutions that do not rely on the builtin eval.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Infix to prefix using code manipulation&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
This solution is inspired by &lt;a href="https://sourceforge.net/p/readable/wiki/Solution/"&gt;https://sourceforge.net/p/readable/wiki/Solution/&lt;/a&gt; , but probably isn't a full implementation. We will first develop a function to convert infix notation to prefix notation. This function is recursive to deal with nested expressions. So far it doesn't seem possible to recurse with macros (at least, I cannot figure out how to do it). We tangle this function to infix.hy so we can use it later.
&lt;/p&gt;

&lt;p&gt;
It will have some limitations though:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;No operator precedence.  We will use parentheses for precedence.
&lt;/li&gt;
&lt;li&gt;Lisp syntax means 3+4 is not the same as 3 + 4. The first is interpreted as a name. So we will need spaces to separate everything.
&lt;/li&gt;
&lt;/ol&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;
 (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (3+4))
 (&lt;span style="color: #0000FF;"&gt;except&lt;/span&gt; [e Exception]
   (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; e)))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 3 4))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
name '3+4' is not defined
7
&lt;/pre&gt;

&lt;p&gt;
So, here is our infix function. Roughly, the function takes a CODE argument. If the CODE is iterable, it is a list of symbols, and we handle a few cases:
&lt;/p&gt;
&lt;ul class="org-ul"&gt;
&lt;li&gt;If it is a string, we return it.
&lt;/li&gt;
&lt;li&gt;if it has a length of one and is an expression we recurse on it, otherwise return the symbol.
&lt;/li&gt;
&lt;li&gt;if it has a length of two, we assume a unary operator and recurse on each element.
&lt;/li&gt;
&lt;li&gt;If there are three elements, we take the middle one as the operator, and switch it with the first element.
&lt;/li&gt;
&lt;li&gt;Otherwise we switch the first and second elements, and recurse on the rest of the list.
&lt;/li&gt;
&lt;li&gt;If it is not iterable we just return the element.
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Two optional arguments provide some debug support to print what is happening.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [*]])

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;nfx&lt;/span&gt; [code &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; [indent 0] [debug &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;]]
  &lt;span style="color: #008000;"&gt;"Transform the CODE expression to prefix notation.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;We assume that CODE is in infix notation."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; indent) &lt;span style="color: #008000;"&gt;"code: "&lt;/span&gt; code &lt;span style="color: #008000;"&gt;" type: "&lt;/span&gt; (type code)))
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   [(&lt;span style="color: #006FE0;"&gt;coll?&lt;/span&gt; code)
    (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;treat lists in [] special&lt;/span&gt;
     [(&lt;span style="color: #006FE0;"&gt;and&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;instance?&lt;/span&gt;  hy.models.list.HyList code)
           (&lt;span style="color: #006FE0;"&gt;not&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;instance?&lt;/span&gt;  hy.models.expression.HyExpression code)))
      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"list: "&lt;/span&gt; code &lt;span style="color: #008000;"&gt;" type: "&lt;/span&gt; (type code)))
      code]

     [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; 1 (len code))
      &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;element is an Expression&lt;/span&gt;
      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; indent) &lt;span style="color: #008000;"&gt;"1: "&lt;/span&gt; code))
      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (isinstance (&lt;span style="color: #006FE0;"&gt;car&lt;/span&gt; code) hy.models.expression.HyExpression)
        (nfx (&lt;span style="color: #006FE0;"&gt;car&lt;/span&gt; code) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug)
        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;single element&lt;/span&gt;
        (&lt;span style="color: #006FE0;"&gt;car&lt;/span&gt; code))]

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;{- 1} -&amp;gt;  (- 1)&lt;/span&gt;
     [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; 2 (len code))
      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; indent) &lt;span style="color: #008000;"&gt;"2: "&lt;/span&gt; code))
      `(~(nfx (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 0) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug)
         ~(nfx (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 1) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug))]

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;{1 + 2} -&amp;gt; (+ 1 2)&lt;/span&gt;
     [(&lt;span style="color: #006FE0;"&gt;=&lt;/span&gt; 3 (len code))
      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; indent) &lt;span style="color: #008000;"&gt;"3: "&lt;/span&gt; code))
      `(~(&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 1)
         ~(nfx (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 0) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug)
         ~(nfx (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 2) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug))]

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;longer expression, swap first two and take the rest.&lt;/span&gt;
     [&lt;span style="color: #D0372D;"&gt;true&lt;/span&gt;
      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; &lt;span style="color: #008000;"&gt;"expr: "&lt;/span&gt; code))
      `(~(nfx (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 1) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug)
         ~(nfx (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; code 0) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug)
         (~@(nfx (&lt;span style="color: #006FE0;"&gt;cut&lt;/span&gt; code 2) (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; indent 1) debug)))])]

   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;non-iterable just gets returned&lt;/span&gt;
   [&lt;span style="color: #D0372D;"&gt;true&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; indent) &lt;span style="color: #008000;"&gt;"true: "&lt;/span&gt; code))
    code]))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, for some tests. First, an example with debug we can see what happens.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (nfx `(1 + (3 * 4)) &lt;span style="color: #D0372D;"&gt;:debug&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
 code:  (1L u'+' (3L u'*' 4L))  type:  &amp;lt;class 'hy.models.expression.HyExpression'&amp;gt;
 3:  (1L u'+' (3L u'*' 4L))
  code:  1  type:  &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;
  true:  1
  code:  (3L u'*' 4L)  type:  &amp;lt;class 'hy.models.expression.HyExpression'&amp;gt;
  3:  (3L u'*' 4L)
   code:  3  type:  &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;
   true:  3
   code:  4  type:  &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;
   true:  4
(u'+' 1L (u'*' 3L 4L))
&lt;/pre&gt;

&lt;p&gt;
You can see we return a list of symbols, and the result is not evaluated. Now for some more thorough tests. I use a little helper function here to show the input and output.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])
(import [serialize [stringify]])

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;show&lt;/span&gt; [code]
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{0} -&amp;gt; {1}\n"&lt;/span&gt;
                  (stringify code)
                  (stringify (nfx code)))))

(show 1)
(show `(1))
(show `(&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; 1))
(show `((1)))
(show `(&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; (2 + 1)))

(show `(2 ** 4))
(show `(3 &amp;lt; 5))

(show `(1 + 3 * 5 + 6 - 9))
(show `((1 + (1 + 2)) * 5 + 6 - 9))
(show `(1 + 1 * (5 - 4)))
(show `(1 + 1 * (np.exp (17 - 10))))

&lt;span style="color: #8D8D84;"&gt;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Note this one does not work right.&lt;/span&gt;
(show `(1 + (np.linspace 1e-5  1 5)))

(show `(x + long-name)) &lt;span style="color: #8D8D84; font-style: italic;"&gt;; note name mangling occurs.&lt;/span&gt;

(show `(1 + 1 + 1 + 1 + 1))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1 -&amp;gt; 1

(1) -&amp;gt; 1

(- 1) -&amp;gt; (- 1)

((1)) -&amp;gt; 1

(- (2 + 1)) -&amp;gt; (- (+ 2 1))

(2 ** 4) -&amp;gt; (** 2 4)

(3 &amp;lt; 5) -&amp;gt; (&amp;lt; 3 5)

(1 + 3 * 5 + 6 - 9) -&amp;gt; (+ 1 (* 3 (+ 5 (- 6 9))))

((1 + (1 + 2)) * 5 + 6 - 9) -&amp;gt; (* (+ 1 (+ 1 2)) (+ 5 (- 6 9)))

(1 + 1 * (5 - 4)) -&amp;gt; (+ 1 (* 1 (- 5 4)))

(1 + 1 * (np.exp (17 - 10))) -&amp;gt; (+ 1 (* 1 (np.exp (- 17 10))))

(1 + (np.linspace 1e-05 1 5)) -&amp;gt; (+ 1 (1e-05 np.linspace (1 5)))

(x + long_name) -&amp;gt; (+ x long_name)

(1 + 1 + 1 + 1 + 1) -&amp;gt; (+ 1 (+ 1 (+ 1 (+ 1 1))))
&lt;/pre&gt;

&lt;p&gt;
Those all look reasonable I think. The last case could be simplified, but it would take some logic to make sure all the operators are the same, and that handles if any of the operands are expressions. We save that for later.
&lt;/p&gt;

&lt;p&gt;
Now, we illustrate that the output code can be evaluated. Since we expand to code, we don't seem to have the namespace issues since the code is executed in our script.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (nfx `(1 + 1 * (5 - 4)))))

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (nfx `(1 + 1 * (np.exp (17 - 10))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2
1097.63315843
&lt;/pre&gt;

&lt;p&gt;
That syntax is not particularly nice, so next we build up a macro, and a new reader syntax. First, the macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;$&lt;/span&gt; [&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; code]
  &lt;span style="color: #036A07;"&gt;"Eval CODE in infix notation."&lt;/span&gt;
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
    (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (infix.nfx ~code))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we can use the simpler syntax here. It seems we still have quote the math to prevent it from being evaluated (which causes an error).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; ($ `(1 + 1 * (5 - 4))))

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; ($ `(1 + 1 * (np.exp (17 - 10)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2
1097.63315843
&lt;/pre&gt;

&lt;p&gt;
For the penultimate act, we introduce a new syntax for this. In the &lt;a href="https://sourceforge.net/p/readable/wiki/Solution/"&gt;sweet expression&lt;/a&gt; syntax we would use {} for this, but this isn't currently possible for hylang, and is also used for dictionaries. We define a reader macro for this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defreader&lt;/span&gt; &lt;span style="color: #006699;"&gt;$&lt;/span&gt; [code]
  (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
  (infix.nfx code))

(&lt;span style="color: #0000FF;"&gt;defreader&lt;/span&gt; &lt;span style="color: #006699;"&gt;P&lt;/span&gt; [code]
  `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)
       (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (infix.nfx ~code))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; 1))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; (2 + 1)))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(2 ** 4))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(3 &amp;lt; 5))

(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(1 + 3 * 5 + 6 - 9))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$((1 + (1 + 2)) * 5 + 6 - 9))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(1 + 1 * (5 - 4)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(1 + 1 + 1 + 1 + 1))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;we still have to be lispy with function calls (func args)&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(1 + 1 * (np.exp (17 - 10))))

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; a 3 t 6)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(a + t))

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; long-a 5 long-b 6)
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; #$(long-a + long-b))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this fails because the linspace should not get unfixed. This is a bug in&lt;/span&gt;
&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;our implementation&lt;/span&gt;

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;(print #P`(1 + (np.linspace 1e-5  1 5)))&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
-1
-3
16
True
7
8
2
5
1097.63315843
9
11
&lt;/pre&gt;

&lt;p&gt;
Mostly wonderful! We get variables passed through, and the name-mangling doesn't seem to matter. Note we don't have to quote this code. I think it is because in this reader macro we do not return code, but actually evaluate it I think. And somehow it works.
&lt;/p&gt;


&lt;p&gt;
There is an issue with &lt;code&gt;(print #$(1 + (np.linspace 1e-5  1 5)))&lt;/code&gt;. The linspace call gets unfixed, which is wrong. There are some ways we could deal with that. One might be to only unfix known operators. Another might be some escape syntax that indicates not to unfix certain lists. For another day (TM).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [infix [*]])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (nfx `(1 + (np.linspace 1e-5  1 5)) &lt;span style="color: #D0372D;"&gt;:debug&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
 code:  (1L u'+' (u'np.linspace' 1e-05 1L 5L))  type:  &amp;lt;class 'hy.models.expression.HyExpression'&amp;gt;
 3:  (1L u'+' (u'np.linspace' 1e-05 1L 5L))
  code:  1  type:  &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;
  true:  1
  code:  (u'np.linspace' 1e-05 1L 5L)  type:  &amp;lt;class 'hy.models.expression.HyExpression'&amp;gt;
expr:  (u'np.linspace' 1e-05 1L 5L)
   code:  1e-05  type:  &amp;lt;class 'hy.models.float.HyFloat'&amp;gt;
   true:  1e-05
   code:  np.linspace  type:  &amp;lt;class 'hy.models.symbol.HySymbol'&amp;gt;
   true:  np.linspace
   code:  (1L 5L)  type:  &amp;lt;class 'hy.models.expression.HyExpression'&amp;gt;
   2:  (1L 5L)
    code:  1  type:  &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;
    true:  1
    code:  5  type:  &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;
    true:  5
(u'+' 1L (1e-05 u'np.linspace' (1L 5L)))
&lt;/pre&gt;

&lt;p&gt;
See, the linspace call is out of order.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; The final test&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
For the final act, we use infix notation in a real problem we posed before.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-1" class="outline-3"&gt;
&lt;h3 id="sec-3-1"&gt;&lt;span class="section-number-3"&gt;3.1&lt;/span&gt; with the string reader&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-1"&gt;
&lt;p&gt;
We almost get way with exactly what we would have done in Python. The only thing was we had to put a space between -x to avoid a mangling issue that turned it into _x. I feel like that might be a fixable issue.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(import [scipy.integrate [odeint]])
(import [scipy.special [jn]])
(import [matplotlib.pyplot &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; plt])

(import [infix [*]])
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;fbessel&lt;/span&gt; [Y x]
  &lt;span style="color: #008000;"&gt;"System of 1st order ODEs for the Bessel equation."&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; nu 0.0
        y (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; Y 0)
        z (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; Y 1))

  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;define the derivatives&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; dydx z
        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the Python way is: "1.0 / x**2 * (-x * z - (x**2 - nu**2) * y)"&lt;/span&gt;
        dzdx (py `(1.0 / x**2 * (&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; x * z - (x**2 - nu**2) * y))))
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Here is what it was with prefix notation&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;dzdx (* (/ 1.0 (** x 2)) (- (* (* -1 x) z) (* (- (** x 2) (** nu 2)) y))))&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;return derivatives&lt;/span&gt;
  [dydx dzdx])

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; x0 1e-15
      y0 1.0
      z0 0.0
      Y0 [y0 z0])

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; xspan (np.linspace 1e-15 10)
      sol (odeint fbessel Y0 xspan))

(plt.plot xspan (. sol [[Ellipsis 0]]) &lt;span style="color: #D0372D;"&gt;:label&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Numerical solution"&lt;/span&gt;)
(plt.plot xspan (jn 0 xspan) &lt;span style="color: #008000;"&gt;"r--"&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;:label&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Analytical solution"&lt;/span&gt;)
(plt.legend &lt;span style="color: #D0372D;"&gt;:loc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"best"&lt;/span&gt;)

(plt.savefig &lt;span style="color: #008000;"&gt;"bessel-infix-s.png"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;


&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2016-04-09-Getting-towards-an-infix-notation-for-hy/bessel-infix-s.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-3-2" class="outline-3"&gt;
&lt;h3 id="sec-3-2"&gt;&lt;span class="section-number-3"&gt;3.2&lt;/span&gt; with #$ reader&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-3-2"&gt;
&lt;p&gt;
This version is also somewhat close to the Python syntax, but it needs a lot more parentheses to get the right precedence, and spaces between almost everything for the lisp syntax, i.e. x**2 is a name, and (x ** 2) is the infix notation for exponentiation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])
(import [scipy.integrate [odeint]])
(import [scipy.special [jn]])
(import [matplotlib.pyplot &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; plt])

(import [infix [*]])
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; &lt;span style="color: #006699;"&gt;infix&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;fbessel&lt;/span&gt; [Y x]
  &lt;span style="color: #008000;"&gt;"System of 1st order ODEs for the Bessel equation."&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; nu 0.0
        y (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; Y 0)
        z (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; Y 1))

  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;define the derivatives&lt;/span&gt;
  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; dydx z
        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the Python way is: "1.0 / x**2 * (-x * z - (x**2 - nu**2) * y)"&lt;/span&gt;
        dzdx #$((1.0 / (x ** 2)) * ((&lt;span style="color: #006FE0;"&gt;-&lt;/span&gt; x) * z) - (((x ** 2) - (nu ** 2)) * y)))
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Here is what it was with prefix notation&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;dzdx (* (/ 1.0 (** x 2)) (- (* (* -1 x) z) (* (- (** x 2) (** nu 2)) y))))&lt;/span&gt;
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;return derivatives&lt;/span&gt;
  [dydx dzdx])

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; x0 1e-15
      y0 1.0
      z0 0.0
      Y0 [y0 z0])

(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; xspan (np.linspace 1e-15 10)
      sol (odeint fbessel Y0 xspan))

(plt.plot xspan (. sol [[Ellipsis 0]]) &lt;span style="color: #D0372D;"&gt;:label&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Numerical solution"&lt;/span&gt;)
(plt.plot xspan (jn 0 xspan) &lt;span style="color: #008000;"&gt;"r--"&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;:label&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Analytical solution"&lt;/span&gt;)
(plt.legend &lt;span style="color: #D0372D;"&gt;:loc&lt;/span&gt; &lt;span style="color: #008000;"&gt;"best"&lt;/span&gt;)

(plt.savefig &lt;span style="color: #008000;"&gt;"bessel-infix.png"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="figure"&gt;
&lt;p&gt;&lt;img src="/media/2016-04-09-Getting-towards-an-infix-notation-for-hy/bessel-infix.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
That worked pretty well. This feels like an improvement for writing engineering programs in lisp!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/09/Getting-towards-an-infix-notation-for-hy.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Writing hy code from hy code</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2016/04/07/Writing-hy-code-from-hy-code</link>
      <pubDate>Thu, 07 Apr 2016 13:06:16 EDT</pubDate>
      <category><![CDATA[hylang]]></category>
      <guid isPermaLink="false">KQN9I0t9_G2e3k-AIZ6MzojwOos=</guid>
      <description>Writing hy code from hy code</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sec-1"&gt;1. Serialize as compiled Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sec-2"&gt;2. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;
Here is one of the main reasons I am interested in a lisp for programming. I want to write programs that write programs. In Python, I have ended up doing things like this where we build up a script with string formatting and manipulation, write it to a file, and run it later or somewhere else. We need this because we run a lot of our calculations through a queue system which runs asynchronously from the work we do in an editor.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; os
&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; x &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [1, 2, 3]:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;fname&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'p{0}.py'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(x)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;program&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'''#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #008000;"&gt;def f(x):&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #008000;"&gt;   return x**{0}&lt;/span&gt;

&lt;span style="color: #008000;"&gt;import sys&lt;/span&gt;
&lt;span style="color: #008000;"&gt;print f(float(sys.argv[1]))'''&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(x)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(fname, &lt;span style="color: #008000;"&gt;'w'&lt;/span&gt;) &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; f:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   f.write(program)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   os.chmod(fname, 0o755)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Then you can call these now at the command line like:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;./p2.py 3
./p3.py 3
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
9.0
27.0
&lt;/pre&gt;

&lt;p&gt;
That is not too bad because the script is simple, but it is tedious to keep the indentation right, it is not always easy to keep track of the arguments (even with numbered indexes, names, etc&amp;#x2026; in the formatting), there is limited logic you can use in the arguments (e.g. no if/elif/elif/else, etc&amp;#x2026;), you lose all the value of having an editor in Python mode, so no syntax highlighting, eldoc, code completion, automatic indentation, etc&amp;#x2026; I don't like it, but it gets the job done.
&lt;/p&gt;

&lt;p&gt;
Lisps allow you to treat code like data, in an editor in lisp-mode, so it should be ideal for this kind of thing. Here we look at getting that done with hy. For the simplest forms, we simply convert the code to a string, which can then be written to a file. You can see we probably got lucky here that the objects in the expression all print in a simple form that allows us to reconstruct the code. You can see here some aspects of Python peeking through the hy implementation. In data/quoted mode, the atoms in the list are not all simple symbols. By the time the program gets to running the code, they have been transformed to objects of various types that need to be handled separately.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; program `(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 4 5))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; &lt;span style="color: #008000;"&gt;"("&lt;/span&gt; (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (str x) [x program])) &lt;span style="color: #008000;"&gt;")"&lt;/span&gt;))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (type x) [x program]))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(+ 4 5)
[&amp;lt;class 'hy.models.symbol.HySymbol'&amp;gt;, &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;, &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;]
&lt;/pre&gt;


&lt;p&gt;
Real programs are not this simple, and we need to handle nested expressions and other types of objects. Consider this program. It has many different types in it, and they don't all get represented by the right syntax in print (i.e. with (repr object).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; [program `(list {&lt;span style="color: #008000;"&gt;"a"&lt;/span&gt; 1 &lt;span style="color: #008000;"&gt;"b"&lt;/span&gt; 3} &lt;span style="color: #008000;"&gt;"b"&lt;/span&gt; 3 3.0 [1 1 2] &lt;span style="color: #D0372D;"&gt;:keyword&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; [x] (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; x 3)))]
  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (type x) [x program]))
  (&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [x program] (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{0!r}"&lt;/span&gt; x))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[&amp;lt;class 'hy.models.symbol.HySymbol'&amp;gt;, &amp;lt;class 'hy.models.dict.HyDict'&amp;gt;, &amp;lt;class 'hy.models.string.HyString'&amp;gt;, &amp;lt;class 'hy.models.integer.HyInteger'&amp;gt;, &amp;lt;class 'hy.models.float.HyFloat'&amp;gt;, &amp;lt;class 'hy.models.list.HyList'&amp;gt;, &amp;lt;class 'hy.models.keyword.HyKeyword'&amp;gt;, &amp;lt;class 'hy.models.expression.HyExpression'&amp;gt;]
u'list'
{u'a' 1L u'b' 3L}
u'b'
3L
3.0
[1L 1L 2L]
u'\ufdd0:keyword'
(u'lambda' [u'x'] (u'*' u'x' 3L))
&lt;/pre&gt;

&lt;p&gt;
Next we make a recursive expression to handle some of these. It is recursive to handle nested expressions. Here are the things in hy.models that might need special treatment. We make sure to wrap expressions in (), lists in [], dictionaries in {}, and strings in "". Keywords have a unicode character put in front of them, so we cut that off. Everything else seems to be ok to just convert to a string. This function gets tangled to serialize.hy so it can be used in subsequent code examples.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;stringify&lt;/span&gt; [form &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; debug]
  &lt;span style="color: #008000;"&gt;"Convert a FORM to a string."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; debug (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"{0}: {1}"&lt;/span&gt; form (type form))))
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   [(isinstance form hy.models.expression.HyExpression)
    (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; &lt;span style="color: #008000;"&gt;"("&lt;/span&gt; (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (stringify x debug) [x form])) &lt;span style="color: #008000;"&gt;")"&lt;/span&gt;)]
   [(isinstance form hy.models.dict.HyDict)
    (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; &lt;span style="color: #008000;"&gt;"{"&lt;/span&gt; (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (stringify x debug) [x form])) &lt;span style="color: #008000;"&gt;"}"&lt;/span&gt;)]
   [(isinstance form hy.models.list.HyList)
    (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; &lt;span style="color: #008000;"&gt;"["&lt;/span&gt; (.join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;list-comp&lt;/span&gt; (stringify x debug) [x form])) &lt;span style="color: #008000;"&gt;"]"&lt;/span&gt;)]
   [(isinstance form hy.models.symbol.HySymbol)
    (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; form)]
   [(isinstance form hy.models.keyword.HyKeyword)
    &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;these have some unicode prefix I want to remove&lt;/span&gt;
    (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;cut&lt;/span&gt; form 1))]
   [(&lt;span style="color: #006FE0;"&gt;or&lt;/span&gt; (isinstance form hy.models.string.HyString)
        (isinstance form unicode))
    (.format &lt;span style="color: #008000;"&gt;"\"{}\""&lt;/span&gt; form)]
   [&lt;span style="color: #D0372D;"&gt;true&lt;/span&gt;
    (.format &lt;span style="color: #008000;"&gt;"{}"&lt;/span&gt; form)]))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, some examples. These cover most of what I can imagine coming up.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [stringify]])  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;tangled from the block above&lt;/span&gt;

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;some examples that cover most of what I am doing.&lt;/span&gt;
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 5 6.0)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt; [x] (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; 2 x))))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; {&lt;span style="color: #008000;"&gt;"a"&lt;/span&gt; 1 &lt;span style="color: #008000;"&gt;"b"&lt;/span&gt; 3} &lt;span style="color: #008000;"&gt;"b"&lt;/span&gt;)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 4 5 (&lt;span style="color: #006FE0;"&gt;*&lt;/span&gt; 6 7)))))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(import [numpy &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; np])))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(import [scipy.optimize [fsolve]])))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(set [2 2 3])))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(complex 4 5)))
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (stringify `(&lt;span style="color: #006FE0;"&gt;cons&lt;/span&gt; 4 5)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
(+ 5 6.0)
(defn f [x] (* 2 x))
(get {"a" 1 "b" 3} "b")
(print (+ 4 5 (* 6 7)))
(import [numpy :as np])
(import [scipy.optimize [fsolve]])
(set [2 2 3])
(complex 4 5)
(cons 4 5)
&lt;/pre&gt;

&lt;p&gt;
Those all look promising. Maybe it looks like nothing happened. Something &lt;i&gt;did&lt;/i&gt; happen! We took &lt;i&gt;code&lt;/i&gt; that was quoted (and hence like a list of &lt;i&gt;data&lt;/i&gt;), and converted it into a string representation of the code. Now that we have a string form, we can do things like write it to a file.
&lt;/p&gt;

&lt;p&gt;
Next, we add a function that can write that to an executable script.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;scriptify&lt;/span&gt; [form fname]
  (&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; [f (open fname &lt;span style="color: #008000;"&gt;"w"&lt;/span&gt;)]
        (.write f &lt;span style="color: #008000;"&gt;"#!/usr/bin/env hy\n"&lt;/span&gt;)
        (.write f (stringify form)))
  (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;os&lt;/span&gt;)
  (os.chmod fname 0o755))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is an example
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [stringify scriptify]])

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;make functions&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [x (&lt;span style="color: #006FE0;"&gt;range&lt;/span&gt; 1 4)]
  (scriptify
   `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
     (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;sys&lt;/span&gt;)
     (&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt; [x]
       (&lt;span style="color: #006FE0;"&gt;**&lt;/span&gt; x ~x))
     (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (f (float (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; sys.argv 1)))))
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;fname to write to&lt;/span&gt;
   (.format &lt;span style="color: #008000;"&gt;"h{}.hy"&lt;/span&gt; x)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is the proof those programs got created.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;ls h[0-9].hy
&lt;span style="color: #006FE0;"&gt;echo&lt;/span&gt;
cat h1.hy
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
h1.hy
h2.hy
h3.hy

#!/usr/bin/env hy
(do (import sys) (defn f [x] (** x 1)) (print (f (float (get sys.argv 1)))))
&lt;/pre&gt;

&lt;p&gt;
The code is all on one line, which doesn't matter or hy. Yep, if it didn't occur to you, we could take those strings and send them over the internet so they could get executed remotely. They are one read-str and eval away from being lisp code again. Yes there are security concerns with that. And an amazing way to get something done.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [*]])
(&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;eval&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;read-str&lt;/span&gt; (stringify `(&lt;span style="color: #006FE0;"&gt;+&lt;/span&gt; 4 5)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
9
&lt;/pre&gt;

&lt;p&gt;
We can run those programs at the command line:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;hy h2.hy 10
hy h3.hy 10
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
100.0
1000.0
&lt;/pre&gt;

&lt;p&gt;
Now for a more realistic test. I make some scripts related to the kinds of molecular simulation we do. These scripts just setup a model of bulk Cu or Pt, and print the generated object. In a real application we would compute some thing from this object.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [stringify scriptify]])

(&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; [element [&lt;span style="color: #008000;"&gt;"Cu"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Pt"&lt;/span&gt;]]
  (scriptify `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt; (import [ase.lattice [bulk]])
                  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;we have to str the element to avoid a unicode error&lt;/span&gt;
                  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;ase does not do unicode.&lt;/span&gt;
                  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; atoms (bulk (str ~element) &lt;span style="color: #D0372D;"&gt;:a&lt;/span&gt; 4.5 &lt;span style="color: #D0372D;"&gt;:cubic&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;))
                  (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; atoms))
             (.format &lt;span style="color: #008000;"&gt;"{}.hy"&lt;/span&gt; element)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is what one of those scripts looks like
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;cat Pt.hy
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
#!/usr/bin/env hy
(do (import [ase.lattice [bulk]]) (setv atoms (bulk (str "Pt") :a 4.5 :cubic True)) (print atoms))
&lt;/pre&gt;

&lt;p&gt;
Note the comments are not in the generated script. These are evidently ignored in hy, and are not even elements. We can run this at the command line to. If this script did an actual calculation, we would have a mechanism to generate simulation scripts that run calculations and output the results we want!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;hy Pt.hy
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Atoms(symbols='Pt4', positions=..., cell=[4.5, 4.5, 4.5], pbc=[True, True, True])
&lt;/pre&gt;

&lt;p&gt;
So, we can write programs that &lt;i&gt;write&lt;/i&gt; programs!
&lt;/p&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Serialize as compiled Python&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
It could be convenient to run the generated programs from Python instead of hy. Here we consider how to do that. I adapted this code from hy.importer.write_hy_as_pyc.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [hy.importer &lt;span style="color: #D0372D;"&gt;:as&lt;/span&gt; hi])
(import [hy._compat [PY3 PY33 MAGIC wr_long long_type]])
(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;marshal&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;os&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;hy2pyc&lt;/span&gt; [code fname]
  &lt;span style="color: #008000;"&gt;"Write CODE as Python compiled byte-code in FNAME."&lt;/span&gt;

  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; program (stringify code))

  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; _ast (hi.import_buffer_to_ast
              program
              &lt;span style="color: #008000;"&gt;"main"&lt;/span&gt;))

  (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; code (hi.ast_compile _ast &lt;span style="color: #008000;"&gt;"&amp;lt;string&amp;gt;"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"exec"&lt;/span&gt;))

  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;create file and close it so we get the size&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; [f (open fname &lt;span style="color: #008000;"&gt;"wb"&lt;/span&gt;)] &lt;span style="color: #D0372D;"&gt;nil&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; [f (open fname &lt;span style="color: #008000;"&gt;"wb"&lt;/span&gt;)]
        (&lt;span style="color: #0000FF;"&gt;try&lt;/span&gt;
         (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; st (os.fstat (f.fileno)))
         (&lt;span style="color: #0000FF;"&gt;except&lt;/span&gt; [e AttributeError]
           (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; st (os.stat fname))))
        (&lt;span style="color: #006FE0;"&gt;setv&lt;/span&gt; timestamp (long_type (. st st_mtime))))
  (&lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; [fc (open fname &lt;span style="color: #008000;"&gt;"wb"&lt;/span&gt;)]
        (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; PY3
          (.write fc b&lt;span style="color: #008000;"&gt;"\0\0\0\0"&lt;/span&gt;) &lt;span style="color: #8D8D84; font-style: italic;"&gt;; I amnot sure this is right in hy with b""&lt;/span&gt;
          (.write fc &lt;span style="color: #008000;"&gt;"\0\0\0\0"&lt;/span&gt;))
        (wr_long fc timestamp)
        (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; PY33
          (wr_long fc st.st_size))
        (.dump marshal code fc)
        (.flush fc)
        (.seek fc 0 0)
        (.write fc MAGIC)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
Now for an example.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-hy"&gt;(import [serialize [*]])

(hy2pyc `(&lt;span style="color: #0000FF;"&gt;do&lt;/span&gt;
          (&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006699;"&gt;sys&lt;/span&gt;)
          (&lt;span style="color: #0000FF;"&gt;defn&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt; [x]
            (&lt;span style="color: #006FE0;"&gt;**&lt;/span&gt; x 3))
          (&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt; (.format &lt;span style="color: #008000;"&gt;"Hy! {0}^3 is {1}."&lt;/span&gt;
                          (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; sys.argv 1)
                          (f (float (&lt;span style="color: #006FE0;"&gt;get&lt;/span&gt; sys.argv 1))))))
          &lt;span style="color: #008000;"&gt;"main.pyc"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we can execute it like this.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;python main.pyc 4
&lt;/pre&gt;
&lt;/div&gt;
&lt;pre class="example"&gt;
Hy! 4^3 is 64.0.
&lt;/pre&gt;

&lt;p&gt;
Well, that worked fine too!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-sec-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
In some ways this is similar to the string manipulation approach (they both generate programs after all), but there are these differences:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;We do not have the indentation issues of generating Python.
&lt;/li&gt;
&lt;li&gt;The code is edited in hy-mode with full language support.
&lt;/li&gt;
&lt;li&gt;Instead of formatting, and string replacements, you have to think of what is quoted and what is evaluated. I find that easier to think about than with strings.
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
There are some ways we could simplify this perhaps. In this &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/05/16/Python-data-structures-to-lisp/"&gt;post&lt;/a&gt; I added code to the built in python types so they could be represented as lisp code. We could add something like this to each of the hy.model objects so they natively can be represented as hy code. The repr functions on these should technically be used for that I think. On the other hand, this serialize code works fine, and lets me do what I want. It is pretty cool this is all possible!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2016 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2016/04/07/Writing-hy-code-from-hy-code.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 8.2.10&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
