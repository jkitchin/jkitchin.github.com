

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group: dynamic-module</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules/" rel="bookmark" title="Permanent Link to Linear algebra in Emacs using MKL and dynamic modules">Linear algebra in Emacs using MKL and dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 21, 2017 at 03:48 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbfb8d4e">1. Convenience functions to get array properties</a></li>
<li><a href="#orga1c9a60">2. Matrix multiplication</a>
<ul>
<li><a href="#orgf536480">2.1. 1d * 1d</a></li>
<li><a href="#org76f193d">2.2. 2d * 1d</a></li>
<li><a href="#org82cc641">2.3. 1d * 2d</a></li>
<li><a href="#org0849c80">2.4. 2d * 2d</a></li>
</ul>
</li>
<li><a href="#org4a14b46">3. Summary thoughts</a></li>
<li><a href="#orgba66efb">4. The module code</a></li>
<li><a href="#org4be1bce">5. Elisp helper functions</a></li>
</ul>
</div>
</div>
<p>
In a <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules/">previous post</a> I integrated some linear algebra into Emacs using the GNU Scientific library and a dynamic module. In this post, I use a similar approach that uses the Intel MKL library in conjunction with some helper elisp functions to mimic the array broadcasting features in Numpy. I thought this might be easier and lead to at least a complementary set of functionalities.
</p>

<p>
Note: I had to follow the directions <a href="http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x">here</a> to disable some security feature on my Mac so that it would use the MKL libraries. Thanks Apple.
</p>

<p>
It is convenient to use vectors for the representation of arrays in Emacs because there are nice functions in the emacs-module.h for accessing vector properties. Also vectors sound closer to an array than a list. So what about array broadcasting, e.g. the way numpy lets you multiply a 2d array with a 1d array? If you multiply two arrays with size (m1, n1) * (m2, n2), it is required that the number of columns in the first array (n1) be equal to the number of rows in the second one (m2), and the resulting size of the array product will be (m1, n2). What should happen though when we have 1d array? This is neither a row or column vector itself, but we can treat as either one if we choose too. For example the vector [1 2 3] can be thought of as an array with the shape (1, 3), e.g. a single row with three columns, or (3, 1), i.e. three rows in a single column. We will build this capability into the module for convenience.
</p>

<p>
I still find it moderately tedious to write c functions that take emacs arguments, transform them to c arguments, do some c computations, and convert the results back to emacs values. So, we only implement one c function for this that multiplies two 2d arrays together using the cblas_dgemm routine in the MKL library. Then, we will create a complementary elisp library that will provide some additional functionality to get the shapes of vector arrays, dimensions, and allow us to multiply 1d and 2d vectors together the same way Numpy does array broadcasting.
</p>

<p>
The dynamic module code is listed in <a href="#orgba66efb">The module code</a>. The elisp code is listed in <a href="#org4be1bce">Elisp helper functions</a>.  In the following sections we just demonstrate how to use the results.
</p>

<div id="outline-container-orgbfb8d4e" class="outline-2">
<h2 id="orgbfb8d4e"><span class="section-number-2">1</span> Convenience functions to get array properties</h2>
<div class="outline-text-2" id="text-1">
<p>
I found it convenient to do array shape and dimension analysis in elisp before sending arrays to the dynamic module. The shape of an array is just the number of elements in each dimension. Here we look at a 2&times; 3 array.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(vector-shape [[1 2 3]
               [3 4 5]])
</pre>
</div>

<pre class="example">
[2 3]

</pre>

<p>
You see it returns a vector showing two rows and three columns. There are two convenience commands to get the number of rows (vector-nrows) and columns (vector-ncols). Here is one of them.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(vector-ncols [[1 2 3]
               [3 4 5]])
</pre>
</div>

<pre class="example">
3

</pre>
</div>
</div>


<div id="outline-container-orga1c9a60" class="outline-2">
<h2 id="orga1c9a60"><span class="section-number-2">2</span> Matrix multiplication</h2>
<div class="outline-text-2" id="text-2">
<p>
The main problem we want to calculate is the matrix multiplication \(A\cdotB\) where \(A\) and \(B\) are either 1d vectors or 2d arrays. Here we examine several representative cases of matrix multiplication.
</p>
</div>

<div id="outline-container-orgf536480" class="outline-3">
<h3 id="orgf536480"><span class="section-number-3">2.1</span> 1d * 1d</h3>
<div class="outline-text-3" id="text-2-1">
<p>
This is a simple dot-product that is actually calculated in elisp.
</p>

<p>
\([1 1 1] \cdot [2 2 2] = 6\)
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(matrix-multiply [1 1 1] [2 2 2])
</pre>
</div>

<pre class="example">
6.0

</pre>

<p>
âœ“
</p>

<p>
Note we get a float. That is because we initialize the sum with 0.0 to be consistent with all the other cases which are done with floats. dgemm is a double routine in MKL, which means it should return floats. Internally in the module, we cast all numbers as doubles for the multiplication.
</p>
</div>
</div>

<div id="outline-container-org76f193d" class="outline-3">
<h3 id="org76f193d"><span class="section-number-3">2.2</span> 2d * 1d</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This is a matrix multiplication that is typically like \(A b\) where \(b\) is a column vector. We return a 1d array as a result, rather than a 2d array of nrows and 1 column.
</p>

<p>
\[ \left[\begin{array}{cc}
1 & 2 \\
3 & 4 \end{array}\right] 
\left [ \begin{array}{c}
1 \\ 1 \end{array}\right] = \left[\begin{array}{c}3\\7\end{array}\right]\]
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[1 2]
          [3 4]])
      (b [1 1]))
  (matrix-multiply  A b))
</pre>
</div>

<pre class="example">
[3.0 7.0]

</pre>

<p>
âœ“
</p>
</div>
</div>

<div id="outline-container-org82cc641" class="outline-3">
<h3 id="org82cc641"><span class="section-number-3">2.3</span> 1d * 2d</h3>
<div class="outline-text-3" id="text-2-3">
<p>
This case is \(b A\) where \(b\) is a row vector. For example:
</p>

<p>
\[\left[\begin{array}{cc}1 & 1\end{array}\right]
\left[\begin{array}{cc} 1 & 2\\ 3 & 4\end{array}\right] = \left[\begin{array}{cc} 4 & 6 \end{array}\right ]\]
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(matrix-multiply [1 1]
                 [[1 2]
                  [3 4]])
</pre>
</div>

<pre class="example">
[4.0 6.0]

</pre>

<p>
âœ“
</p>

<p>
As with the previous case, we return a 1d vector result rather than a 2d array with 1 row and ncolumns.
</p>
</div>
</div>

<div id="outline-container-org0849c80" class="outline-3">
<h3 id="org0849c80"><span class="section-number-3">2.4</span> 2d * 2d</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Finally we have the case of \(A B\). The number of columns in A must be the same as the number of rows in B, and the result has a size that is the number of rows in A and the number of columns in B. Here is one <a href="http://www.sosmath.com/matrix/matrix1/matrix1.html">example</a>:
</p>

<p>
\[\left[\begin{array}{cc} 0 & 1\\ 0 & 0\end{array}\right]  
\left[\begin{array}{cc} 0 & 0\\ 1 & 0\end{array}\right]  
= \left[\begin{array}{cc} 1 & 0\\ 0 & 0\end{array}\right]  \]
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(matrix-multiply [[0 1]
                  [0 0]]
                 [[0 0]
                  [1 0]])
</pre>
</div>

<pre class="example">
[[1.0 0.0] [0.0 0.0]]

</pre>

<p>
âœ“
</p>

<p>
This example is adapted from <a href="https://stackoverflow.com/questions/21547462/how-to-multiply-2-dimensional-arrays-matrix-multiplication">here</a>. The correct answer is at the bottom of that page, and shown here.
</p>

<p>
\[\left[\begin{array}{cccc} 1 & 2 & -2 & 0 \\ -3 & 4 & 7 & 2 \\ 6 & 0 & 3 & 1\end{array}\right]  
\left[\begin{array}{cc} -1 & 3 \\ 0 & 9 \\ 1 & -11 \\ 4 & -5 \end{array}\right]
= \left[\begin{array}{cc} -3 & 43 \\ 18 & -60 \\ 4 & -5\end{array}\right]    \]
</p>

<p>
For readability we use temporary variables here, and pretty-print the result.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[1 2 -2 0]
          [-3 4 7 2]
          [6 0 3 1]])
      (B [[-1 3]
          [0  9]
          [1 -11]
          [4 -5]]))
  (pp (matrix-multiply A B)))
</pre>
</div>

<pre class="example">
[[-3.0 43.0]
 [18.0 -60.0]
 [1.0 -20.0]]

</pre>

<p>
âœ“
</p>

<p>
So, all these example work as we expect. The elisp function for matrix-multiply does a lot of work for you to make these cases work, including error checking for dimensional consistency.
</p>
</div>
</div>
</div>

<div id="outline-container-org4a14b46" class="outline-2">
<h2 id="org4a14b46"><span class="section-number-2">3</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-3">
<p>
It was not any easier to write this dynamic module than the previous one I used with the Gnu Scientific Library. The approach and code are remarkably similar. In one way the GSL was easier to use; it worked out of the box, whereas I had to fiddle with a security option in my OS to get it to run MKL! My  Anaconda Python distribution must get around that somehow since it ships with an MKL compiled Numpy and scipy.
</p>

<p>
The idea of using elisp for analysis of the inputs and making sure they are correct is a good one and helps prevent segfaults. Of course it is a good idea to write defensive c-code to avoid that too. Overall, this is another good example of expanding the capabilities of Emacs with a dynamic module.
</p>
</div>
</div>

<div id="outline-container-orgba66efb" class="outline-2">
<h2 id="orgba66efb"><a id="ID-45D04B39-1927-44ED-9402-E89D166AE8C8"></a><span class="section-number-2">4</span> The module code</h2>
<div class="outline-text-2" id="text-4">
<p>
The c-code is loosely adapted from <a href="https://software.intel.com/en-us/node/529735">https://software.intel.com/en-us/node/529735</a>. We do not implement the full dgemm behavior which is able to calculate \(C = \alpha A * B + \beta*C\). We set &alpha;=1, and &beta;=0 in this example. We should do some dimension checking here, but it is easier to do it in emacs in a helper function. As long as you use the helper function there should not be an issue, but it is possible to segfault Emacs if you use the module function incorrectly.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module-helpers.h"</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;mkl.h&gt;</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #6434A3;">emacs_value</span> <span style="color: #006699;">Fmkl_dgemm</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #6434A3;">ptrdiff_t</span> <span style="color: #BA36A5;">nargs</span>, <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[], <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">data</span>)
{
  <span style="color: #6434A3;">double</span> *<span style="color: #BA36A5;">A</span>, *<span style="color: #BA36A5;">B</span>, *<span style="color: #BA36A5;">C</span>;
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">m</span>, <span style="color: #BA36A5;">n</span>, <span style="color: #BA36A5;">k</span>, <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">alpha</span> = 1.0;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">beta</span> = 0.0;
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">These will be 2d vectors</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">M0</span> = args[0]; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">array 1 - A (m x k)</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">M1</span> = args[1]; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">array 2 - B (k x n)</span>

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">I need to get the number of rows and columns of each one.</span>
  m = env-&gt;vec_size(env, M0);
  k  = 0;
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">We assume that we have a 2d array.</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">el1</span> = env-&gt;vec_get (env, M0, 0);
  k = env-&gt;vec_size(env, el1);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Now we know A has dimensions (m, k)</span>
 
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">el2</span> = env-&gt;vec_get (env, M1, 0);
  n = env-&gt;vec_size(env, el2);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Now we know M1 had dimensions (k, n)</span>
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Now we have to build up arrays.</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">We are looking at a * b = c</span>
  A = (<span style="color: #6434A3;">double</span> *)mkl_malloc( m*k*<span style="color: #0000FF;">sizeof</span>( <span style="color: #6434A3;">double</span> ), 64 );
  B = (<span style="color: #6434A3;">double</span> *)mkl_malloc( k*n*<span style="color: #0000FF;">sizeof</span>( <span style="color: #6434A3;">double</span> ), 64 );
  C = (<span style="color: #6434A3;">double</span> *)mkl_malloc( m*n*<span style="color: #0000FF;">sizeof</span>( <span style="color: #6434A3;">double</span> ), 64 );
  <span style="color: #0000FF;">if</span> (A == <span style="color: #D0372D;">NULL</span> || B == <span style="color: #D0372D;">NULL</span> || C == <span style="color: #D0372D;">NULL</span>) {
    printf( <span style="color: #008000;">"\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"</span>);
    mkl_free(A);
    mkl_free(B);
    mkl_free(C);
    <span style="color: #0000FF;">return</span> 1;
  }

  <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">populate A</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">row</span>, <span style="color: #BA36A5;">ij</span>;
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; m; i++)
    {
      row = env-&gt;vec_get(env, M0, i);
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; k; j++)
        {
          <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">get M0[i, j]</span>
          ij = env-&gt;vec_get(env, row, j);
          A[k * i + j] = extract_double(env, ij);
        }
    }

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">populate B</span>
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; k; i++)
    {
      row = env-&gt;vec_get(env, M1, i);
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; n; j++)
        {         
          <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">get M0[i, j]</span>
          ij = env-&gt;vec_get(env, row, j);
          B[n * i + j] = extract_double(env, ij);
        }
    }

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">initialize C.  The solution will have dimensions of (rows1, cols2).</span>
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; m; i++)
    {
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; n; j++)
        {
          C[n * i + j] = 0.0;
        }
    }

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">the multiplication is done here.</span>
  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 
                m, n, k, alpha, A, k, B, n, beta, C, n);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">now we build up the vector to return</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">vector</span> = env-&gt;intern(env, <span style="color: #008000;">"vector"</span>);
  <span style="color: #6434A3;">emacs_value</span> *<span style="color: #BA36A5;">array</span> = malloc(<span style="color: #0000FF;">sizeof</span>(emacs_value) * m);
  <span style="color: #6434A3;">emacs_value</span> *<span style="color: #BA36A5;">row1</span>;
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">vec</span>;
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; m; i++)
    {
      row1 = malloc(<span style="color: #0000FF;">sizeof</span>(emacs_value) * n);
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; n; j++)
        {
          row1[j] = env-&gt;make_float(env, C[j + i * n]);
        }
      vec = env-&gt;funcall(env, vector, n, row1);
      array[i] = vec;
      free(row1);
    }

  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">result</span> = env-&gt;funcall(env, vector, m, array);
  free(array);
  <span style="color: #0000FF;">return</span> result;
}


<span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  DEFUN(<span style="color: #008000;">"mkl-dgemm"</span>, Fmkl_dgemm, 2, 2,
        <span style="color: #008000;">"(mkl-dgemm A B)\n"</span>\
        <span style="color: #008000;">"Multiply the matrices A and B. A and B must both be 2d vectors.\n"</span> \
        <span style="color: #008000;">"Returns the product as a vector."</span>,
        <span style="color: #D0372D;">NULL</span>);
  provide(env, <span style="color: #008000;">"mkl"</span>);
  
  <span style="color: #0000FF;">return</span> 0;
}

</pre>
</div>

<p>
To build this we have to run <a href="org-babel-tangle">org-babel-tangle</a> to generate the mkl.c file, and then run this shell block to compile it.
</p>

<div class="org-src-container">
<pre class="src src-sh">sh /opt/intel/mkl/bin/mklvars.sh intel64
gcc -Wall -m64 -I${<span style="color: #BA36A5;">MKLROOT</span>}/include -fPIC -c mkl.c
gcc -shared -L${<span style="color: #BA36A5;">MKLROOT</span>}/lib -Wl,-rpath,${<span style="color: #BA36A5;">MKLROOT</span>}/lib -lmkl_rt -lpthread -lm -ldl -L. -lemacs-module-helpers -o mkl.so mkl.o
</pre>
</div>
</div>
</div>


<div id="outline-container-org4be1bce" class="outline-2">
<h2 id="org4be1bce"><a id="ID-F5AEAF4E-317F-48D4-9815-8EB0331AF0E5"></a><span class="section-number-2">5</span> Elisp helper functions</h2>
<div class="outline-text-2" id="text-5">
<p>
We will often want to know the shape of our arrays. The shape is how many elements there are in each dimension. Here we define a recursive function that gets the shape of arbitrarily nested vectors and returns a vector of the shape. We define some helper functions to get the number of dimensions, elements, rows and columns.
</p>

<p>
The main function is a helper elisp function that multiplies two arrays. The function analyzes the shapes and transforms 1d vectors into the right 2d shape to multiply them together, and then returns the shape that makes sense. The c-code is not very robust to mistakes in the array dimensions. It tends to make emacs segfault if you get it wrong. So we try to avoid that if possible.
</p>

<p>
We have four cases to consider for multiplication:
</p>

<dl class="org-dl">
<dt>2d * 2d</dt><dd>(assert (= m1 n2)) return (n1, m2)</dd>
<dt>1d * 2d</dt><dd>1d is a row vector (1, n1) (assert (= n1 m2)) return vector with n2 elements</dd>
<dt>2d * 1d</dt><dd>1d is a column vector (m2, 1) (assert (= n1 m2)) return vector with m2 elements</dd>
<dt>1d * 1d</dt><dd>(assert (= (length m1) (length m2)) return a scalar</dd>
</dl>

<p>
Here is the 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">mkl</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">cl</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">seq</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-shape</span> (vec)
  <span style="color: #036A07;">"Return a vector of the shape of VEC."</span>
  (<span style="color: #0000FF;">let</span> ((shape (vector (length vec))))
    (<span style="color: #0000FF;">if</span> (vectorp (aref vec 0))
        (vconcat shape (vector-shape (aref vec 0)))
      shape)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-ndims</span> (vec)
  <span style="color: #036A07;">"Returns the number of dimensions in VEC."</span>
  (length (vector-shape vec)))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-numel</span> (vec)
  <span style="color: #036A07;">"Returns the number of elements in VEC."</span>
  (<span style="color: #0000FF;">if</span> (&gt; (length vec) 0)
      (seq-reduce '* (vector-shape vec) 1)
    0))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-nrows</span> (vec)
 <span style="color: #036A07;">"Return the number of rows in VEC."</span>
 (aref (vector-shape vec) 0))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-ncols</span> (vec)
 <span style="color: #036A07;">"Return the number of columns in VEC."</span>
 (aref (vector-shape vec) 1))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">matrix-multiply</span> (A B)
  <span style="color: #036A07;">"Return A * B in the matrix multiply sense."</span>
  (<span style="color: #0000FF;">cond</span>
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">1d * 1d i.e. a dot-product</span>
   ((<span style="color: #0000FF;">and</span> (= 1 (vector-ndims A))
         (= 1 (vector-ndims B))
         (= (length A) (length B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">this is easy to compute so we don't use dgemm.</span>
    (seq-reduce '+ (mapcar* (<span style="color: #0000FF;">lambda</span> (a b) (* a b)) A B) 0.0))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">2d * 1d (m1, n1) * (n2, 1)</span>
   ((<span style="color: #0000FF;">and</span> (= 2 (vector-ndims A))
         (= 1 (vector-ndims B))
         <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">ncols-A = len-B</span>
         (= (vector-ncols A) (length B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">transform B into a 2d column vector</span>
    (<span style="color: #0000FF;">let*</span> ((B2d (apply 'vector (mapcar 'vector B)))
           (result  (mkl-dgemm A B2d)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Now call (dgemm A B2d) -&gt; (m2, 1) column vector</span>
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">and convert it back to a 1d result</span>
      (cl-map 'vector (<span style="color: #0000FF;">lambda</span> (v) (aref v 0)) result)))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">1d * 2d (1, n1) * (m2, n2) len-A = nrows-B</span>
   ((<span style="color: #0000FF;">and</span> (= 1 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (length A) (vector-nrows B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">transform B into a 2d row vector</span>
    (<span style="color: #0000FF;">let*</span> ((A2d (vector A))
           (result  (mkl-dgemm A2d B)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">should be a 2d row vector</span>
      (aref result 0)))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">2d * 2d (m1, n1) * (m2, n2) rows-A = ncols-B</span>
   ((<span style="color: #0000FF;">and</span> (= 2 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (vector-ncols A)
            (vector-nrows B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">call (dgemm A B) and return result</span>
    (mkl-dgemm A B))
   (t
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Error checking, getting here means none of the cases above were caught.</span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">something is probably wrong.</span>
    (<span style="color: #0000FF;">cond</span>
     ((<span style="color: #0000FF;">or</span> (&gt; (vector-ndims A) 2)
          (&gt; (vector-ndims B) 2))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"One of your arrays has more than 2 dimensions. Only 1 or 2d arrays are supported"</span>))
     ((<span style="color: #0000FF;">and</span> (= 1 (vector-ndims A))
           (= 1 (vector-ndims B))
           (not (= (length A) (length B))))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"A and B must be the same length.</span>
<span style="color: #008000;">len(A) = %d</span>
<span style="color: #008000;">len(B) = %d"</span> (length A) (length B)))
     ((<span style="color: #0000FF;">and</span>
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 2)
       (not (= (vector-nrows A) (vector-ncols B))))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Your array shapes are not correct.</span>
<span style="color: #008000;">The number of rows in array A must equal the number of columns in array B.</span>
<span style="color: #008000;">There are %d rows in A and %d columns in B"</span> (vector-nrows A) (vector-ncols B)))
     ((<span style="color: #0000FF;">and</span>
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 1)
       (not (= (vector-nrows A) (length B))))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Your array shapes are not correct.</span>
<span style="color: #008000;">The number of rows in array A must equal the number of columns in array B.</span>
<span style="color: #008000;">There are %d rows in A and %d columns in B"</span> (vector-nrows A) (length B)))
     (t
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Unknown error"</span>))))))
</pre>
</div>

<pre class="example">
matrix-multiply

</pre>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="An-Emacs-zeromq-library-using-an-ffi"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi/" rel="bookmark" title="Permanent Link to An Emacs zeromq library using an ffi">An Emacs zeromq library using an ffi</a></h2>
      <p><small><span class="blog_post_date">Posted July 13, 2017 at 06:44 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/zeromq/'>zeromq</a>, <a href='/blog/category/ffi/'>ffi</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org9367268">1. Summary thoughts</a></li>
<li><a href="#org4003ff3">2. Modified ffi-define-function macro</a></li>
<li><a href="#org77956c2">3. The zeromq bindings</a></li>
</ul>
</div>
</div>
<p>
An alternative approach to writing your own dynamic module (which requires some proficiency in c) is to use a foreign function interface (ffi). There is one for emacs at <a href="https://github.com/tromey/emacs-ffi">https://github.com/tromey/emacs-ffi</a>, and it is also a dynamic module itself that uses <a href="https://github.com/libffi/libffi">libffi</a>. This lets you use elisp to create functions in Emacs that actually call functions in some other library installed on your system. Here, we use this module to recreate our zeromq bindings that I previously <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules/">posted</a>.
</p>

<p>
The emacs-ffi module works fine as it is, but I found it useful to redefine one of the main macros (define-ffi-function) with the following goals in mind:
</p>

<ol class="org-ol">
<li>Allow me to specify the argument names and docstrings for each arg that contain its type and a description of the arg.</li>
<li>Document what each function returns (type and description).</li>
<li>Combine those two things into an overall docstring on the function.</li>
</ol>

<p>
These are important to me because it allows Emacs to work at its fullest potential while writing elisp code, including having the right function signatures in eldoc, and easy access to documentation of each function. You can see the new definition <a href="#org4003ff3">here</a>. For example, here is a docstring for zmq-send using that new macro:
</p>

<pre class="example">
zmq-send is a Lisp function.

(zmq-send *SOCKET *MSG LEN FLAGS)

For more information check the manuals.

send a message part on a socket.
http://api.zeromq.org/4-2:zmq-send

*SOCKET (:pointer) Pointer to a socket.
*MSG (:pointer) Pointer to a C-string to send
LEN (:size_t) Number of bytes to send
FLAGS (:int) 

Returns: Number of bytes sent or -1 on failure. (:int)
</pre>

<p>
That has everything you need to know
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">define-ffi-function</span> zmq-send-ori <span style="color: #008000;">"zmq_send"</span> <span style="color: #006FE0;">:int</span> (<span style="color: #006FE0;">:pointer</span> <span style="color: #006FE0;">:pointer</span> <span style="color: #006FE0;">:size_t</span> <span style="color: #006FE0;">:int</span>) zmq)
</pre>
</div>

<pre class="example">
zmq-send-ori

</pre>

<p>
Compare that to this docstring from the original macro. 
</p>

<pre class="example">
zmq-send-ori is a Lisp function.

(zmq-send-ori G251 G252 G253 G254)

For more information check the manuals.
</pre>

<p>
You can see the zeromq function definitions in elisp <a href="#org77956c2">here</a>. Here is a list of the functions we have created:
</p>

<pre class="example">
Type RET on a type label to view its full documentation.

zmq
  Function: Returns a pointer to the libzmq library.
zmq-close
  Function: close Ã˜MQ socket.
zmq-connect
  Function: create outgoing connection from socket.
zmq-ctx-destroy
  Function: terminate a Ã˜MQ context.
zmq-ctx-new
  Function: create new Ã˜MQ context.
zmq-recv
  Function: receive a message part from a socket.
zmq-send
  Function: send a message part on a socket.
zmq-socket
  Function: create Ã˜MQ socket.
</pre>

<p>
Now we can use these to create the client, this time in elisp. Just as in the last post, you need to run the hwserver in a terminal for this to work. Here is the client code.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ)))

  (<span style="color: #0000FF;">with-ffi-string</span> (endpoint <span style="color: #008000;">"tcp://localhost:5555"</span>)
    (zmq-connect socket endpoint))

  (<span style="color: #0000FF;">with-ffi-string</span> (msg <span style="color: #008000;">"Hi there"</span>)
    (zmq-send socket msg 5 0))

  (<span style="color: #0000FF;">with-ffi-string</span> (recv (make-string 10 <span style="color: #008000;">""</span>))
    (<span style="color: #0000FF;">let</span> ((status -1))
      (<span style="color: #0000FF;">cl-loop</span> do (<span style="color: #0000FF;">setq</span> status (zmq-recv socket recv 10 0)) until (not (= -1 status)))) 
    (print (ffi-get-c-string recv)))

  (zmq-close socket)
  (zmq-ctx-destroy context))
</pre>
</div>

<pre class="example">

"World     "

</pre>

<p>
This client basically performs the same as the previously one we built. You can see we are mixing some programming styles here. For example, we have to create pointers to string variables in advance that the ffi will be writing to later like we would do in c. We use the with-ffi-string macro which frees the pointer when we are done with it. It basically just avoids me having to create, use, and destroy the pointers myself. So, there it is, a working elisp zeromq client!
</p>


<div id="outline-container-org9367268" class="outline-2">
<h2 id="org9367268"><span class="section-number-2">1</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-1">
<p>
For this example, I feel like the ffi approach here (with my modified function making macro) was much easier than what I previously did with a compiled c-library (although it benefited a lot from my recent work on the c-library). I really like working in elisp, which is a much greater strength of mine than programming in c. It is pretty clear, however, that you have to know how c works to use this, otherwise it isn't so obvious that some functions will return a status, and do something by side effect, e.g. put results in one of the arguments. The signatures of the ffi functions are basically limited by the signatures of the c-functions. If you want to change the signature in Emacs, you have to write wrapper functions to do that.
</p>

<p>
The macro I used here to create the functions creates really good (the kind I like anyway) docstrings when you use it fully. That isn't a totally new idea, I tried it out <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/">here</a> before.  In contrast, the original version not only didn't have a docstring, but every arg had a gensym (i.e. practically random) name! I think it would be very difficult to get the same level of documentation when writing c-code to make a module. In the c-code, there is a decoupling of the definition of a c-function (which always has the same signature) that gets data from the Emacs env, e.g. arguments, does stuff with them, and creates data to put back into the env, and the emacs_module_init function where you declare these functions to Emacs and tell it what to call the function in emacs, about how many arguments it takes, etc&#x2026; The benefit of this is you define what the Emacs signature will look like, and then write the c-function that does the required work. The downside of this is the c-function and Emacs declarations are often far apart in the editor, and there is no easy way to auto-generate docstrings like I can with lisp macros. You would have to manually build them up yourself, and keep them synchronized. Also, I still have not figured out how to get emacs to show the right signature for c-generated functions.
</p>

<p>
The ffi approach still uses a dynamic module approach, so it still requires a modern Emacs with the module compiled and working. It still requires (in this case) the zeromq library to be installed on the system too. Once you have those, however, the elisp zeromq bindings by this approach is done <i>completely in elisp</i>!
</p>

<p>
It will be interesting in the coming weeks to see how this approach works with the GNU Scientific Library, particularly with arrays. Preliminary work shows that while the elisp ffi code is <i>much</i> shorter and easier to write than the corresponding c-code for some examples (e.g. a simple mathematical function), it is not as fast. So if performance is crucial, it may still pay off to write the c-code.
</p>
</div>
</div>

<div id="outline-container-org4003ff3" class="outline-2">
<h2 id="org4003ff3"><a id="ID-A2B7F051-EA53-4882-A978-05FAD211BB81"></a><span class="section-number-2">2</span> Modified ffi-define-function macro</h2>
<div class="outline-text-2" id="text-2">
<p>
Here are two macros I modified to add docstrings and named arguments too.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">define-ffi-library</span> (symbol name)
  <span style="color: #036A07;">"Create a pointer named to the c library."</span>
  (<span style="color: #0000FF;">let</span> ((library (cl-gensym))
        (docstring (format <span style="color: #008000;">"Returns a pointer to the %s library."</span> name)))
    (set library nil)
    `(<span style="color: #0000FF;">defun</span> ,symbol ()
       ,docstring
       (<span style="color: #0000FF;">or</span> ,library
           (<span style="color: #0000FF;">setq</span> ,library (ffi--dlopen ,name))))))

(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">define-ffi-function</span> (name c-name return args library <span style="color: #6434A3;">&amp;optional</span> docstring)
  <span style="color: #036A07;">"Create an Emacs function from a c-function.</span>
<span style="color: #036A07;">NAME is a symbol for  the emacs function to create.</span>
<span style="color: #036A07;">C-NAME is a string of the c-function to use.</span>
<span style="color: #036A07;">RETURN is a type-keyword or (type-keyword docstring)</span>
<span style="color: #036A07;">ARGS is a list of type-keyword or (type-keyword name &amp;optional arg-docstring)</span>
<span style="color: #036A07;">LIBRARY is a symbol usually defined by `</span><span style="color: #D0372D;">define-ffi-library</span><span style="color: #036A07;">'</span>
<span style="color: #036A07;">DOCSTRING is a string for the function to be created.</span>

<span style="color: #036A07;">An overall docstring is created for the function from the arg and return docstrings.</span>
<span style="color: #036A07;">"</span>
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Turn variable references into actual types; while keeping</span>
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">keywords the same.</span>
  (<span style="color: #0000FF;">let*</span> ((return-type (<span style="color: #0000FF;">if</span> (keywordp return)
                          return
                        (car return)))
         (return-docstring (format <span style="color: #008000;">"Returns: %s (%s)"</span>
                                   (<span style="color: #0000FF;">if</span> (listp return)
                                       (second return)
                                     <span style="color: #008000;">""</span>)
                                   return-type))
         (arg-types (vconcat (mapcar (<span style="color: #0000FF;">lambda</span> (arg)
                                       (<span style="color: #0000FF;">if</span> (keywordp arg)
                                           (symbol-value arg)
                                         <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">assume list (type-keyword name &amp;optional doc)</span>
                                         (symbol-value (car arg))))
                                     args)))
         (arg-names (mapcar (<span style="color: #0000FF;">lambda</span> (arg)
                              (<span style="color: #0000FF;">if</span> (keywordp arg)
                                  (cl-gensym)
                                <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">assume list (type-keyword name &amp;optional doc)</span>
                                (second arg)))
                            args))
         (arg-docstrings (mapcar (<span style="color: #0000FF;">lambda</span> (arg)
                                   (<span style="color: #0000FF;">cond</span>
                                    ((keywordp arg)
                                     <span style="color: #008000;">""</span>)
                                    ((<span style="color: #0000FF;">and</span> (listp arg) (= 3 (length arg)))
                                     (third arg))
                                    (t <span style="color: #008000;">""</span>)))
                                 args))
         <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Combine all the arg docstrings into one string</span>
         (arg-docstring (mapconcat 'identity
                                   (mapcar* (<span style="color: #0000FF;">lambda</span> (name type arg-doc)
                                              (format <span style="color: #008000;">"%s (%s) %s"</span>
                                                      (upcase (symbol-name name))
                                                      type
                                                      arg-doc))
                                            arg-names arg-types arg-docstrings)
                                   <span style="color: #008000;">"\n"</span>))
         (<span style="color: #0000FF;">function</span> (cl-gensym))
         (cif (ffi--prep-cif (symbol-value return-type) arg-types)))
    (set function nil)
    `(<span style="color: #0000FF;">defun</span> ,name (,@arg-names)
       ,(concat docstring <span style="color: #008000;">"\n\n"</span> arg-docstring <span style="color: #008000;">"\n\n"</span> return-docstring)
       (<span style="color: #0000FF;">unless</span> ,function
         (<span style="color: #0000FF;">setq</span> ,function (ffi--dlsym ,c-name (,library))))
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">FIXME do we even need a separate prep?</span>
       (ffi--call ,cif ,function ,@arg-names))))
</pre>
</div>

<pre class="example">
define-ffi-function

</pre>
</div>
</div>


<div id="outline-container-org77956c2" class="outline-2">
<h2 id="org77956c2"><a id="ID-29C81B62-C0DF-44D4-AFE2-6EE239C70500"></a><span class="section-number-2">3</span> The zeromq bindings</h2>
<div class="outline-text-2" id="text-3">
<p>
These define the ffi functions we use in this post. I use a convention that pointer args start with a * so they look more like the c arguments. I also replace all _ with - so it looks more lispy, and the function names are easier to type.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">ffi</span>)

(<span style="color: #0000FF;">define-ffi-library</span> zmq <span style="color: #008000;">"libzmq"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-ctx-new <span style="color: #008000;">"zmq_ctx_new"</span>
  (<span style="color: #006FE0;">:pointer</span> <span style="color: #008000;">"Pointer to a context"</span>)
  nil zmq
  <span style="color: #008000;">"create new &#216;MQ context.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-ctx-new"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-ctx-destroy <span style="color: #008000;">"zmq_ctx_destroy"</span>
  (<span style="color: #006FE0;">:int</span> <span style="color: #008000;">"status"</span>)
  ((<span style="color: #006FE0;">:pointer</span> *context)) zmq
  <span style="color: #008000;">"terminate a &#216;MQ context.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-ctx-destroy"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-socket <span style="color: #008000;">"zmq_socket"</span>
  (<span style="color: #006FE0;">:pointer</span> <span style="color: #008000;">"Pointer to a socket."</span>)
  ((<span style="color: #006FE0;">:pointer</span> *context <span style="color: #008000;">"Created by `</span><span style="color: #D0372D;">zmq-ctx-new </span><span style="color: #008000;">'."</span>) (<span style="color: #006FE0;">:int</span> type)) zmq
  <span style="color: #008000;">"create &#216;MQ socket.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-socket"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-close <span style="color: #008000;">"zmq_close"</span>
  (<span style="color: #006FE0;">:int</span> <span style="color: #008000;">"Status"</span>)
  ((<span style="color: #006FE0;">:pointer</span> *socket <span style="color: #008000;">"Socket pointer created by `</span><span style="color: #D0372D;">zmq-socket</span><span style="color: #008000;">'"</span>)) zmq
  <span style="color: #008000;">"close &#216;MQ socket.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-close"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-connect <span style="color: #008000;">"zmq_connect"</span> 
  (<span style="color: #006FE0;">:int</span> <span style="color: #008000;">"Status"</span>)
  ((<span style="color: #006FE0;">:pointer</span> *socket <span style="color: #008000;">"Socket pointer created by `</span><span style="color: #D0372D;">zmq-socket</span><span style="color: #008000;">'"</span>)
   (<span style="color: #006FE0;">:pointer</span> *endpoint <span style="color: #008000;">"Char pointer, e.g. (ffi-make-c-string \"tcp://localhost:5555\")"</span>))
  zmq
  <span style="color: #008000;">"create outgoing connection from socket.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-connect"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-send <span style="color: #008000;">"zmq_send"</span>
  (<span style="color: #006FE0;">:int</span> <span style="color: #008000;">"Number of bytes sent or -1 on failure."</span>)
  ((<span style="color: #006FE0;">:pointer</span> *socket <span style="color: #008000;">"Pointer to a socket."</span>)
   (<span style="color: #006FE0;">:pointer</span> *msg <span style="color: #008000;">"Pointer to a C-string to send"</span>)
   (<span style="color: #006FE0;">:size_t</span> len <span style="color: #008000;">"Number of bytes to send"</span>)
   (<span style="color: #006FE0;">:int</span> flags)) 
  zmq
   <span style="color: #008000;">"send a message part on a socket.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-send"</span>)


(<span style="color: #0000FF;">define-ffi-function</span> zmq-recv <span style="color: #008000;">"zmq_recv"</span>
  (<span style="color: #006FE0;">:int</span> <span style="color: #008000;">"Number of bytes received or -1 on failure."</span>)
  ((<span style="color: #006FE0;">:pointer</span> *socket)
   (<span style="color: #006FE0;">:pointer</span> *buf <span style="color: #008000;">"Pointer to c-string to put result in."</span>)
   (<span style="color: #006FE0;">:size_t</span> len <span style="color: #008000;">"Length to truncate message at."</span>)
   (<span style="color: #006FE0;">:int</span> flags)) 
  zmq
   <span style="color: #008000;">"receive a message part from a socket.</span>
<span style="color: #008000;">http://api.zeromq.org/4-2:zmq-recv"</span>)


<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">We cannot get these through a ffi because the are #define'd for the CPP and</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">invisible in the library. They only exist in the zmq.h file.</span>
(<span style="color: #0000FF;">defconst</span> <span style="color: #BA36A5;">ZMQ-REQ</span> 3
  <span style="color: #036A07;">"A socket of type ZMQ_REQ is used by a client to send requests</span>
<span style="color: #036A07;">  to and receive replies from a service. This socket type allows</span>
<span style="color: #036A07;">  only an alternating sequence of zmq_send(request) and</span>
<span style="color: #036A07;">  subsequent zmq_recv(reply) calls. Each request sent is</span>
<span style="color: #036A07;">  round-robined among all services, and each reply received is</span>
<span style="color: #036A07;">  matched with the last issued request."</span>)
</pre>
</div>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/13/An-Emacs-zeromq-library-using-an-ffi.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/13/An-Emacs-zeromq-library-using-an-ffi#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Zeromq-bindings-for-Emacs-via-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules/" rel="bookmark" title="Permanent Link to Zeromq bindings for Emacs via dynamic modules">Zeromq bindings for Emacs via dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 12, 2017 at 07:38 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I do a lot of scientific programming, and it is one of the reasons I have been learning to extend Emacs with dynamic modules. They have allowed me to add physical constants, numerical integration, root finding and linear algebra from established c-libraries to Emacs. Today I am taking a break from that and finally getting to another one of the reasons I started playing around with dynamic modules: <a href="http://zguide.zeromq.org/">zeromq</a>. Zeromq is a messaging library that <a href="http://jupyter-client.readthedocs.io/en/latest/messaging.html">Jupyter</a> uses to communicate with kernels. I thought we might get a smoother integration with Emacs and Jupyter if we could use zeromq directly to communicate between org-mode and the kernel. Currently we have to run a web server that does the communication for us via http requests. We won't solve the Jupyter problem today, but we will look at communicating with a Zeromq server from Emacs.
</p>

<p>
This might have lots of other useful applications. Suppose Emacs could communicate directly with other zeromq servers to retrieve data from, perhaps scientific data. It might even be possible for Emacs to run its own zeromq server, and other instances of Emacs could then communicate with it. Collaborative editing anyone? 
</p>

<p>
Here we just implement the "Hello world" client example in the <a href="http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive">zeromq guide</a>. The code for the server, a c-client, the mod-zmq library, a makefile and tests can be found at <a href="https://github.com/jkitchin/emacs-modules/tree/master/zeromq">https://github.com/jkitchin/emacs-modules/tree/master/zeromq</a>. All the server does is receive a string, and then send a response (in this case just the string "World") back to the client. 
</p>

<p>
To run this, make sure to run the hwserver executable in a terminal. I wrapped the  zeromq commands required to implement the client into a dynamic module. Since this example focuses on strings, the module returns strings to Emacs. I am not sure if that is always the right thing to do, as zeromq more generically uses bytes, but I will have to wait until I know more about zeromq to know if this is an issue. 
</p>

<p>
This dynamic module uses a new feature that none of the previous posts used, and that is the user_ptr. These allow you to essentially return a reference pointer back to emacs that you can pass back to another function. That way they stay alive between function calls. For example, here we have to create a context and socket and pass these items to functions like zmq_send and zmq_recv.
</p>

<p>
The directory this library is in is not on my path, so we load it like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">mod-zmq</span>)
</pre>
</div>

<p>
Here are the functions and their signatures that have been implemented so far. I only implemented the ones I needed for the client. The signatures may change in the future; this is just a proof of concept for now for the purpose of building the client.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos-command <span style="color: #008000;">"zmq*"</span> t)
(<span style="color: #0000FF;">with-current-buffer</span> <span style="color: #008000;">"*Apropos*"</span> (buffer-string))
</pre>
</div>

<pre class="example">
Type RET on a type label to view its full documentation.

zmq-close
  Function: (zmq-close SOCKET)
zmq-connect
  Function: (zmq-connect SOCKET ENDPOINT)
zmq-ctx-destroy
  Function: (zmq-ctx-destroy CONTEXT)
zmq-ctx-new
  Function: (zmq-ctx-new)
zmq-recv
  Function: (zmq-recv SOCKET LEN FLAGS)
zmq-send
  Function: (zmq-send SOCKET BUF FLAGS)
zmq-socket
  Function: (zmq-socket CONTEXT TYPE)
</pre>

<p>
You can see the c code for the client here: <a href="/media/hwclient.c">hwclient.c</a> . Here is a simple elisp version of the hwclient that basically does the same thing! The main difference is I added a while loop around the zmq-recv because sometimes it returns -1 and no result. So, here we loop until the return result is not -1. That seems to do the right thing.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ))
       (recv-ret -1)
       (result))

  (zmq-connect socket <span style="color: #008000;">"tcp://localhost:5555"</span>)
  (zmq-send socket <span style="color: #008000;">"Hello"</span> 0)

  (<span style="color: #0000FF;">while</span> (= recv-ret -1)
    (<span style="color: #0000FF;">setq</span> result (zmq-recv socket 10 0)
          recv-ret (second result)))

  (print result)

  (zmq-close socket)
  (zmq-ctx-destroy context))
</pre>
</div>

<pre class="example">

("World" 5)

</pre>

<p>
Basically this creates the context, then the socket, and connects to it on port 5555 of the localhost where the server is running. Then we send the string "Hello". The server returns the string "World" and tells us it sent 5 bytes. Then we close the socket and destroy the context. There is a lot of code in the module to make this happen. A lot of it is converting args in emacs functions to things we can use in c, running a few lines of zmq commands, and then code to convert those results back to emacs values. Finally, there is code to register each function and define docstrings for them. I am not totally convinced this is the best way to do this, but it does work! An alternative might be <a href="https://github.com/tromey/emacs-ffi">emacs-ffi</a>, which might enable most of this to be developed in just elisp. 
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules/" rel="bookmark" title="Permanent Link to Adding linear algebra to Emacs with the GSL and dynamic modules">Adding linear algebra to Emacs with the GSL and dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 11, 2017 at 10:27 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The goal of this post is to be able to solve equations like this one:
</p>

<p>
\[\left(\begin{array}{cccc}
 0.18& 0.60& 0.57& 0.96 \\
 0.41& 0.24& 0.99& 0.58 \\
 0.14& 0.30& 0.97& 0.66 \\
 0.51& 0.13& 0.19& 0.85 \end{array} \right ) 
\left ( \begin{array}{c} x_0 \\ x_1 \\ x_2 \\ x_3 \end{array} \right )
= \left ( \begin{array}{c} 1.0 \\ 2.0 \\ 3.0 \\ 4.0 \end{array} \right ) \]
</p>

<p>
The answer is <a href="https://www.gnu.org/software/gsl/doc/html/linalg.html#examples:">given</a> as
</p>

<p>
\[x = \left ( \begin{array}{c} -4.05205 \\ -12.6056 \\ 1.66091 \\ 8.69377 \end{array} \right ) \]
</p>

<p>
The syntax we want to use is shown below, and we want it to return a vector containing the solution:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[0.18 0.60 0.57 0.96]
          [0.41 0.24 0.99 0.58]
          [0.14 0.30 0.97 0.66]
          [0.51 0.13 0.19 0.85]])
      (b [1.0 2.0 3.0 4.0]))
  (gsl-linalg-LU-solve A b))
</pre>
</div>

<p>
Rather than put all the code in here like I have for the past several posts, I started a git repo at <a href="https://github.com/jkitchin/emacs-modules">https://github.com/jkitchin/emacs-modules</a> that contains this code. 
</p>


<p>
The module for this post can be found here: <a href="https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c">https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c</a>. There are a few notable features in it. First, I started writing/collecting <a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c">some helper functions</a> to make these modules simpler to write. For example, look how nice this looks to declare the functions and provide the feature.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  DEFUN(<span style="color: #008000;">"gsl-linalg-LU-solve"</span>, Fgsl_linalg_LU_solve, 2, 2,
        <span style="color: #008000;">"(gsl-linalg-LU-solve A b).\n"</span> \
        <span style="color: #008000;">"Solve A x = b for x.\n"</span> \
        <span style="color: #008000;">"Returns a vector containing the solution x."</span>,
        <span style="color: #D0372D;">NULL</span>);
  provide(env, <span style="color: #008000;">"gsl-linalg"</span>);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
The DEFUN and provide function are defined in <a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c">https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c</a>.
</p>

<p>
Within the module itself, we have to loop over the inputs to create the arrays that GSL wants to solve this problem. Second, after the solution is obtained, we have to build up a vector to return. The solution is in a gsl_vector, and we need to create an array of emacs_value elements containing each element of the gsl_vector as a float, and then create a vector to return to emacs. I use vectors here because it was easy to get the size of the b vector, which is also related to the size of the A matrix.
</p>

<p>
The repo has a Makefile in it, so we can build this module with:
</p>

<div class="org-src-container">
<pre class="src src-sh">make gsl-linalg.so
</pre>
</div>

<p>
Once it is compiled, we load it like this. In this post we are in the emacs-modules directory where the gsl-linalg.so library is, and it is not on my load-path, so I add it here.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-linalg</span>)
</pre>
</div>

<pre class="example">
gsl-linalg

</pre>

<p>
Here is one function in the module:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'gsl-linalg-LU-solve)
</pre>
</div>

<pre class="example">
gsl-linalg-LU-solve is a Lisp function.

(gsl-linalg-LU-solve &amp;rest ARGS)

For more information check the manuals.

(gsl-linalg-LU-solve A b).
Solve A x = b for x.
Returns a vector containing the solution x.

</pre>

<p>
Now, we can solve linear equations like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-linalg-LU-solve
 [[0.18 0.60 0.57 0.96]
  [0.41 0.24 0.99 0.58]
  [0.14 0.30 0.97 0.66]
  [0.51 0.13 0.19 0.85]]
 [1.0 2.0 3.0 4.0])
</pre>
</div>

<pre class="example">
[-4.052050229573973 -12.605611395906903 1.6609116267088417 8.693766928795227]

</pre>


<p>
We have a limited ability to confirm this answer. I have written a function that uses blas for multiplication of 2d vectors. You can see from this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-blas-dgemm [[0.18 0.60 0.57 0.96]
                 [0.41 0.24 0.99 0.58]
                 [0.14 0.30 0.97 0.66]
                 [0.51 0.13 0.19 0.85]]
                [[-4.052050229573973]
                 [-12.605611395906903]
                 [1.6609116267088417]
                 [8.693766928795227]])
</pre>
</div>

<pre class="example">
[[1.0] [1.9999999999999991] [2.9999999999999996] [4.0]]

</pre>

<p>
That within float that indeed \(A x = b\).
</p>

<p>
The main limitation of this module at the moment is that you have to use vectors; you cannot put in a list of numbers. It is possible to make it take lists and vectors, but for now I am leaving it at vectors. Also, it only produces solutions of float numbers (not integers).
</p>

<p>
The module does not handle 1d vectors well,, e.g. in gsl-linalg-LU-solve example, the right hand side is implied to be a column vector, and we don't have the array broadcasting features of Python yet. Those are doable things for some future day perhaps. For now I am happy to have figured out how to handle arrays!
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-GSL-constants-to-Emacs-in-a-dynamic-module"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module/" rel="bookmark" title="Permanent Link to Adding GSL constants to Emacs in a dynamic module">Adding GSL constants to Emacs in a dynamic module</a></h2>
      <p><small><span class="blog_post_date">Posted July 10, 2017 at 09:38 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The GNU Scientific Library defines a lot of <a href="https://www.gnu.org/software/gsl/doc/html/const.html">physical constants</a>. Since we are exploring how to make Emacs a more scientific environment to work in, it would be nice to import these constants to elisp. We do that through a dynamic module. This turned out to be tricky. I thought we could just use a funcall to defconst or defvar, but these are special forms and you cannot funcall them. @polizta on Stackoverflow <a href="https://emacs.stackexchange.com/questions/34049/how-do-you-define-constants-in-an-emacs-dynamic-module/34063#34063">pointed me to the path</a> that led to success: You make a list like '(defconst sym val doc) and then eval it. That can be funcall'd, and it works nicely in the module below. It is a growing theme that it takes much hacking around to figure out how to do things like this.
</p>

<p>
The only other notable feature of this module is that I created a defconst function to make adding multiple constants less verbose. Here I only add two constants. There are about 408 constants defined in gsl_const_*.h, so brevity might be a good idea! Here is the module.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_const_mksa.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;string.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">I assume here that all values will be double. I can't think of any that would</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">be ints</span>
<span style="color: #0000FF;">static</span> <span style="color: #6434A3;">void</span> <span style="color: #006699;">defconst</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">name</span>, <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">value</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">doc</span>)
{
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">These are functions we will call</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">eval</span> = env-&gt;intern(env, <span style="color: #008000;">"eval"</span>);  
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">list</span> = env-&gt;intern(env, <span style="color: #008000;">"list"</span>);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">These will make up the list we will eventally eval</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fdefconst</span> = env-&gt;intern(env, <span style="color: #008000;">"defconst"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">sym</span> = env-&gt;intern(env, name);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">val</span> = env-&gt;make_float(env, value);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">sdoc</span> = env-&gt;make_string(env, doc, strlen(doc));

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">make a list of (defconst sym val doc)</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">largs</span>[] = {fdefconst, sym, val, sdoc};
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">qlist</span> = env-&gt;funcall(env, list, 4, &amp;largs);   

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">now eval the list of symbols</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[] = { qlist };  
  env-&gt;funcall(env, eval, 1, &amp;args);
}

<span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);

  defconst(env, <span style="color: #008000;">"GSL-CONST-MKSA-SPEED-OF-LIGHT"</span>,
           GSL_CONST_MKSA_SPEED_OF_LIGHT,
           <span style="color: #008000;">"Speed of light in vacuum (m/s)."</span>);
  
  defconst(env, <span style="color: #008000;">"GSL-CONST-MKSA-PLANCKS-CONSTANT-H"</span>,
           GSL_CONST_MKSA_PLANCKS_CONSTANT_H,
           <span style="color: #008000;">"Plank's constant, h"</span>);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">This is what allows the shared library to provide a feature </span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide</span> = env-&gt;intern(env, <span style="color: #008000;">"provide"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide_args</span>[] = { env-&gt;intern(env, <span style="color: #008000;">"gsl-constants"</span>) };
  env-&gt;funcall(env, provide, 1, provide_args);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>


<p>
Regular gcc will work to compile this module. 
</p>

<div class="org-src-container">
<pre class="src src-sh">rm -f gsl-constants.so gsl-constants.o
gcc -Wall -I/usr/local/include -fPIC -c gsl-constants.c
gcc -shared -L/usr/local/include -lgsl -o gsl-constants.so gsl-constants.o
</pre>
</div>

<p>
Here is in action. 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #008000;">"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-constants</span>)
GSL-CONST-MKSA-SPEED-OF-LIGHT
</pre>
</div>

<pre class="example">
299792458.0

</pre>

<p>
We can see there is a docstring on that constant:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-variable 'GSL-CONST-MKSA-SPEED-OF-LIGHT)
</pre>
</div>

<pre class="example">
GSL-CONST-MKSA-SPEED-OF-LIGHT's value is 299792458.0


  This variable can be risky when used as a file-local variable.

Documentation:
Speed of light in vacuum (m/s).

For more information check the manuals.

</pre>


<p>
It is worth thinking about what we accomplished here. The value of each constant in GSL is stored in a header file. The units are stored in a comment next to the value, and the documentation is in an html page somewhere. It is not easy to introspect that! Getting it all into an Emacs variable makes that more introspectable, and findable. That means while typing elisp code you will get completion on these variables. Check this out:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos-variable <span style="color: #008000;">"GSL-*"</span>)
(<span style="color: #0000FF;">with-current-buffer</span> <span style="color: #008000;">"*Apropos*"</span> (buffer-string))
</pre>
</div>

<pre class="example">
Type RET on a type label to view its full documentation.

GSL-CONST-MKSA-PLANCKS-CONSTANT-H
  Variable: Plank's constant, h
GSL-CONST-MKSA-SPEED-OF-LIGHT
  Variable: Speed of light in vacuum (m/s).

</pre>

<p>
It seems like it might be possible to partially automate creation of this module by parsing the gsl_const*.h files. There is no automating adding the doc strings though, I am pretty sure that will have to be done by hand ;(
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/dynamic-module/2">Next Page Â»</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/10/09/Compressibility-variation-from-an-implicit-equation-of-state/">Compressibility variation from an implicit equation of state</a></li>
      <li><a href="/blog/2018/10/08/Getting-derivatives-from-implicit-functions-with-autograd/">Getting derivatives from implicit functions with autograd</a></li>
      <li><a href="/blog/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches/">Compressibility factor variation from the van der Waals equation by three different approaches</a></li>
      <li><a href="/blog/2018/09/24/Solving-nonlinear-algebra-problems-with-internal-state-information/">Solving nonlinear algebra problems with internal state information</a></li>
      <li><a href="/blog/2018/09/05/Integration-of-the-heat-capacity/">Integration of the heat capacity</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



