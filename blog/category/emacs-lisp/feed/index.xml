<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>https://kitchingroup.cheme.cmu.edu/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Thu, 04 Jul 2024 11:53:24 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>The loop macro in emacs lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/11/20/The-loop-macro-in-emacs-lisp</link>
      <pubDate>Thu, 20 Nov 2014 09:50:00 EST</pubDate>
      <category><![CDATA[emacs_lisp]]></category>
      <guid isPermaLink="false">MiNAccBMPmVFgJgu8OOvK5oKHoE=</guid>
      <description>The loop macro in emacs lisp</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I was reading &lt;a href="http://landoflisp.com"&gt;The Land Of Lisp&lt;/a&gt; chapter on the loop macro in Common Lisp. I am not too familiar with it, or the implementation in emacs-lisp, so in this post we explore what it can do. Here I will explore some uses of the loop macro to do things I used to do in Python all the time.
&lt;/p&gt;

&lt;p&gt;
Here is a simple example to generate a list of numbers with the loop macro..
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i
      below 5
      collect i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;0&lt;/td&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Evidently, i starts at 0, and increments by one. We can specify a different value like this. Here we use the &lt;code&gt;to&lt;/code&gt; token, which also includes the last value.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i from 2 to 10
  collect i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;5&lt;/td&gt;
&lt;td class="right"&gt;6&lt;/td&gt;
&lt;td class="right"&gt;7&lt;/td&gt;
&lt;td class="right"&gt;8&lt;/td&gt;
&lt;td class="right"&gt;9&lt;/td&gt;
&lt;td class="right"&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
IF you want to go backwards:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i downfrom 10 to 2 collect i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;10&lt;/td&gt;
&lt;td class="right"&gt;9&lt;/td&gt;
&lt;td class="right"&gt;8&lt;/td&gt;
&lt;td class="right"&gt;7&lt;/td&gt;
&lt;td class="right"&gt;6&lt;/td&gt;
&lt;td class="right"&gt;5&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
And if you want an (de)increment different than one, use the &lt;code&gt;by&lt;/code&gt; token.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i downfrom 10 to 2 by 3 collect i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;10&lt;/td&gt;
&lt;td class="right"&gt;7&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
We can use this to iterate over a list too. Let us collect the square of each element in a simple list. This is similar to the mapcar function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i in '(1 2 3 4)
  collect (* i i))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;9&lt;/td&gt;
&lt;td class="right"&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
You can combine the ideas to get something similar to the enumerate function in python. 
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i
      from 0
      for month
      in '(january february march april may june july august september
                   october november december)
      collect (cons i month))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;((0 . january)
 (1 . february)
 (2 . march)
 (3 . april)
 (4 . may)
 (5 . june)
 (6 . july)
 (7 . august)
 (8 . september)
 (9 . october)
 (10 . november)
 (11 . december))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The loop stops because we run out of months to iterate over.  Here is a variation like the zip function in python.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for element1 in '(a b c d)
      for element2 in '(1 2 3 4)
      collect (list element1 element2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;a&lt;/td&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;b&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;c&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;d&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
We can sum in the loop:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i in '(100 200 300) sum i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
600
&lt;/pre&gt;

&lt;p&gt;
We can conditionally sum things in the loop, e.g. sum only the odd numbers.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i in '(1 2 3 4 5)
  when (oddp i)
  sum i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
9
&lt;/pre&gt;

&lt;p&gt;
We can find the minima and maxima in a list
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i in '(-1 0 1)
  minimize i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
-1
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i in '(-1 0 1)
  maximize i)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1
&lt;/pre&gt;

&lt;p&gt;
You may want to do some action in the loop. Say we want to print even numbers from a list.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i in '(1 2 3 4)
      when (evenp i)
      do (print i))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2

4
&lt;/pre&gt;

&lt;p&gt;
There are some ways to break out of a loop using &lt;code&gt;return&lt;/code&gt; like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i upto 10
      when (= i 3)
      return 'done
      do (print i))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0

1

2
&lt;/pre&gt;

&lt;p&gt;
Alternatively, you can use while/until.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i downfrom 10
      do (print i)
      until (= i 6))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
10

9

8

7

6
&lt;/pre&gt;

&lt;p&gt;
Or the while variation:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(loop for i downfrom 10
      do (print i)
      while (&amp;gt; i 6))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
10

9

8

7

6
&lt;/pre&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This is not everything the loop macro can do! Here is what the help for that function says.
&lt;/p&gt;

&lt;pre class="example"&gt;
loop is an alias for `cl-loop' in `cl.el'.

(loop CLAUSE...)

The Common Lisp `loop' macro.
Valid clauses include:
  For clauses:
    for VAR from/upfrom/downfrom EXPR1 to/upto/downto/above/below EXPR2 by EXPR3
    for VAR = EXPR1 then EXPR2
    for VAR in/on/in-ref LIST by FUNC
    for VAR across/across-ref ARRAY
    for VAR being:
      the elements of/of-ref SEQUENCE [using (index VAR2)]
      the symbols [of OBARRAY]
      the hash-keys/hash-values of HASH-TABLE [using (hash-values/hash-keys V2)]
      the key-codes/key-bindings/key-seqs of KEYMAP [using (key-bindings VAR2)]
      the overlays/intervals [of BUFFER] [from POS1] [to POS2]
      the frames/buffers
      the windows [of FRAME]
  Iteration clauses:
    repeat INTEGER
    while/until/always/never/thereis CONDITION
  Accumulation clauses:
    collect/append/nconc/concat/vconcat/count/sum/maximize/minimize FORM
      [into VAR]
  Miscellaneous clauses:
    with VAR = INIT
    if/when/unless COND CLAUSE [and CLAUSE]... else CLAUSE [and CLAUSE...]
    named NAME
    initially/finally [do] EXPRS...
    do EXPRS...
    [finally] return EXPR

For more details, see Info node `(cl)Loop Facility'.
&lt;/pre&gt;

&lt;p&gt;
It is obviously quite powerful, although the syntax seems quite different than the usual lisp code I have been writing. It is not clear when this is superior to something like mapcar/mapconcat, or the dolist/dotimes functions. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/11/20/The-loop-macro-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.7c&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Generate emacs-lisp documentation</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/10/17/Generate-emacs-lisp-documentation</link>
      <pubDate>Fri, 17 Oct 2014 14:39:49 EDT</pubDate>
      <category><![CDATA[emacs_lisp]]></category>
      <guid isPermaLink="false">h7qO-ywtQxNM2s9adKVNLlz1jb0=</guid>
      <description>Generate emacs-lisp documentation</description>
      <content:encoded><![CDATA[



&lt;p&gt;
Emacs has some pretty amazing features to get help on a function (describe-function), to navigate quickly to functions in an elisp file (speedbar and imenu). Other languages have tools for generating documentation for all the functions in a file, e.g. epydoc, javadoc, Doxygen,&amp;#x2026; I have not found an equivalent to this in emacs-lisp. Here, we explore some options to get something similar to this. Our goal will be to take an emacs-lisp file, and generate an org-file of documentation, and then convert that to PDF for reading.
&lt;/p&gt;

&lt;p&gt;
Say we have a function, jmax-bibtex-next-entry, and we want some information about it. Here are three functions that give us the argument list, documentation string, and function definition.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(help-function-arglist 'jmax-bibtex-next-entry)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;&amp;amp;optional&lt;/td&gt;
&lt;td class="left"&gt;n&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(documentation 'jmax-bibtex-next-entry)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Jump to the beginning of the next bibtex entry. N is a prefix
argument. If it is numeric, jump that many entries
forward. Negative numbers do nothing.
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(symbol-function 'jmax-bibtex-next-entry)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;lambda&lt;/td&gt;
&lt;td class="left"&gt;(&amp;amp;optional n)&lt;/td&gt;
&lt;td class="left"&gt;Jump to the beginning of the next bibtex entry. N is a prefix\nargument. If it is numeric, jump that many entries\nforward. Negative numbers do nothing.&lt;/td&gt;
&lt;td class="left"&gt;(interactive P)&lt;/td&gt;
&lt;td class="left"&gt;(if (= (point) (save-excursion (bibtex-beginning-of-entry))) (progn (forward-char) (bibtex-next-entry)))&lt;/td&gt;
&lt;td class="left"&gt;(if (re-search-forward bibtex-entry-head nil t (and (numberp n) n)) (progn (bibtex-beginning-of-entry)))&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
That will not always be the code we wrote, but it is functionally similar.
&lt;/p&gt;

&lt;p&gt;
So we could create an org-entry like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fun2org&lt;/span&gt; (function-symbol)
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((args (help-function-arglist function-symbol))
        (doc  (documentation function-symbol))
        (code (symbol-function function-symbol)))
    (format &lt;span style="color: #228b22;"&gt;"** %s %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;%s&lt;/span&gt;

&lt;span style="color: #228b22;"&gt;#+BEGIN_SRC emacs-lisp&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;%S&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;#+END_SRC&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;"&lt;/span&gt; function-symbol args doc code)))

(fun2org 'jmax-bibtex-next-entry)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-org"&gt;&lt;span style="color: #8b008b;"&gt;** jmax-bibtex-next-entry (&amp;amp;optional n)&lt;/span&gt;
Jump to the beginning of the next bibtex entry. N is a prefix
argument. If it is numeric, jump that many entries
forward. Negative numbers do nothing.

&lt;span style="color: #ff0000; font-weight: bold;"&gt;#+BEGIN_SRC emacs-lisp&lt;/span&gt;
&lt;span style="background-color: #b0c4de;"&gt;(&lt;/span&gt;&lt;span style="color: #8b0000; background-color: #b0c4de;"&gt;lambda&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (&lt;/span&gt;&lt;span style="color: #4682b4; background-color: #b0c4de;"&gt;&amp;amp;optional&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; n) &lt;/span&gt;&lt;span style="color: #228b22; background-color: #b0c4de;"&gt;"Jump to the beginning of the next bibtex entry. N is a prefix&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt;
&lt;/span&gt;&lt;span style="color: #228b22; background-color: #b0c4de;"&gt;argument. If it is numeric, jump that many entries&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt;
&lt;/span&gt;&lt;span style="color: #228b22; background-color: #b0c4de;"&gt;forward. Negative numbers do nothing."&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (interactive &lt;/span&gt;&lt;span style="color: #228b22; background-color: #b0c4de;"&gt;"P"&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt;) (&lt;/span&gt;&lt;span style="color: #8b0000; background-color: #b0c4de;"&gt;if&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (= (point) (&lt;/span&gt;&lt;span style="color: #8b0000; background-color: #b0c4de;"&gt;save-excursion&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (bibtex-beginning-of-entry))) (&lt;/span&gt;&lt;span style="color: #8b0000; background-color: #b0c4de;"&gt;progn&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (forward-char) (bibtex-next-entry))) (&lt;/span&gt;&lt;span style="color: #8b0000; background-color: #b0c4de;"&gt;if&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (re-search-forward bibtex-entry-head nil t (and (numberp n) n)) (&lt;/span&gt;&lt;span style="color: #8b0000; background-color: #b0c4de;"&gt;progn&lt;/span&gt;&lt;span style="background-color: #b0c4de;"&gt; (bibtex-beginning-of-entry))))
&lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;#+END_SRC&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The code is not that beautifully indented, but it is optional. 
&lt;/p&gt;

&lt;p&gt;
For variables, there are similar functions to get their documentation:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(documentation-property 'jmax-bibtex-journal-abbreviations 'variable-documentation)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
List of (string journal-full-name journal-abbreviation). Find abbreviations at http://cassi.cas.org/search.jsp.
&lt;/pre&gt;

&lt;p&gt;
The problem still is, you have to know the variable and function names in advance. I want to take a file, and generate this for each function, and variable. 
&lt;/p&gt;

&lt;p&gt;
I posted a question on &lt;a href="http://stackoverflow.com/questions/26330363/how-do-i-get-a-list-of-functions-defined-in-an-emacs-lisp-file/26360946?iemail=1&amp;noredirect=1#26360946"&gt;StackOverflow&lt;/a&gt; on how to get the functions defined in a file. The most feasible suggestion was to use the variable load-history, which contains a history of the variables and functions loaded, and the files they are in.
&lt;/p&gt;

&lt;p&gt;
Here is an example of getting the entries associated with jmax-bibtex.el
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(cdr (assoc &lt;span style="color: #228b22;"&gt;"/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"&lt;/span&gt; load-history ))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(jmax-bibtex-journal-abbreviations
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-bibtex-generate-longtitles)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-bibtex-generate-shorttitles)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-stringify-journal-name)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-set-journal-string)
 jmax-nonascii-latex-replacements
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-replace-nonascii)
 jmax-lower-case-words
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-title-case-article)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-sentence-case-article)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-bibtex-next-entry)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-bibtex-previous-entry)
 (&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;.&lt;/span&gt; jmax-bibtex-mode-keys)
 (&lt;span style="color: #8b0000;"&gt;provide&lt;/span&gt; &lt;span style="color: #cd0000;"&gt;.&lt;/span&gt; jmax-bibtex))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Each element in this case is either a variable, defun or provide. Here, we can use this to print some information about the variables defined in this file. I think it is sufficient to check if the element in the list is a symbol, because all the other elements are cons elements. I suppose there are other possibilities, including defcustom, defgroup, defalias, defsubst, and maybe others.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (element (cdr
                  (assoc
                   &lt;span style="color: #228b22;"&gt;"/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"&lt;/span&gt;
                   load-history )))
  (&lt;span style="color: #8b0000;"&gt;when&lt;/span&gt; (symbolp element)
    (princ 
    (format &lt;span style="color: #228b22;"&gt;"%s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;Documentation: %s&lt;/span&gt;

&lt;span style="color: #228b22;"&gt;"&lt;/span&gt; element (documentation-property element 'variable-documentation)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
jmax-bibtex-journal-abbreviations
Documentation: List of (string journal-full-name journal-abbreviation). Find abbreviations at http://cassi.cas.org/search.jsp.

jmax-nonascii-latex-replacements
Documentation: Cons list of non-ascii characters and their LaTeX representations

jmax-lower-case-words
Documentation: List of words to keep lowercase
&lt;/pre&gt;

&lt;p&gt;
We can handle functions by checking if an element is a cons cell with a first element of defun.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (element (cdr
                  (assoc
                   &lt;span style="color: #228b22;"&gt;"/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"&lt;/span&gt;
                   load-history )))
  (&lt;span style="color: #8b0000;"&gt;when&lt;/span&gt; (and (consp element)
             (eq (car element) 'defun))
    (princ (format &lt;span style="color: #228b22;"&gt;"%s is a function\n"&lt;/span&gt; (cdr element))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
jmax-bibtex-generate-longtitles is a function
jmax-bibtex-generate-shorttitles is a function
jmax-stringify-journal-name is a function
jmax-set-journal-string is a function
jmax-replace-nonascii is a function
jmax-title-case-article is a function
jmax-sentence-case-article is a function
jmax-bibtex-next-entry is a function
jmax-bibtex-previous-entry is a function
jmax-bibtex-mode-keys is a function
&lt;/pre&gt;


&lt;p&gt;
So, we have the important pieces to mash up what I am looking for. Let us refine the goal. I want to create a PDF documentation of what is in an elisp file with a section on variables, and a section on functions. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;let*&lt;/span&gt; ((elements (cdr
                  (assoc
                   &lt;span style="color: #228b22;"&gt;"/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"&lt;/span&gt;
                   load-history)))
       (vars (-filter 'symbolp elements))
       (funcons (-filter (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (x)
                           (and (consp x)
                                (eq 'defun (car x))))
                         elements))
       (funcs (mapcar 'cdr funcons)))
  (switch-to-buffer &lt;span style="color: #228b22;"&gt;"*org-doc*"&lt;/span&gt;)
  (erase-buffer)
  (insert (format &lt;span style="color: #228b22;"&gt;"#+TITLE: Documentation for %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;#+OPTIONS: toc:nil&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;\\maketitle&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;\\tableofcontents&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el"&lt;/span&gt;))
  (insert &lt;span style="color: #228b22;"&gt;"* Variables\n"&lt;/span&gt;)
  (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (var (sort vars 'string-lessp))
    (insert (format &lt;span style="color: #228b22;"&gt;"** %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;Documentation: %s\n\n"&lt;/span&gt; var  (documentation-property var 'variable-documentation))))

  (insert &lt;span style="color: #228b22;"&gt;"* Functions\n\n"&lt;/span&gt;)
  (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (funcs (sort funcs 'string-lessp))
    (insert (format &lt;span style="color: #228b22;"&gt;"** %s %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;Documentation: %s&lt;/span&gt;

&lt;span style="color: #228b22;"&gt;Code:&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;#+BEGIN_SRC emacs-lisp&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;%S&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;#+END_SRC&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
                    funcs
                    (or (help-function-arglist funcs) &lt;span style="color: #228b22;"&gt;""&lt;/span&gt;)
                    (documentation funcs)
                    (symbol-function funcs))))

  (org-mode)
  (write-file &lt;span style="color: #228b22;"&gt;"jmax-bibtex-doc.org"&lt;/span&gt;)
  (org-export-to-file 'latex &lt;span style="color: #228b22;"&gt;"jmax-bibtex-doc.tex"&lt;/span&gt;)
  (org-latex-compile &lt;span style="color: #228b22;"&gt;"jmax-bibtex-doc.tex"&lt;/span&gt;)
  (kill-buffer &lt;span style="color: #228b22;"&gt;"*org-doc*"&lt;/span&gt;)
  (kill-buffer &lt;span style="color: #228b22;"&gt;"jmax-bibtex-doc.org"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is the resulting pdf: &lt;a href="/media/2014-10-17-Generate-emacs-lisp-documentation/jmax-bibtex-doc.pdf"&gt;jmax-bibtex-doc.pdf&lt;/a&gt; . It is not too bad. The code is not beautiful, and it would take some work to get that looking nice. It might be nice to find all instances of '` and replace them with links to variable names, but I leave that for another day. There is also no information about the header comments, but I leave this for another day to.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/10/17/Generate-emacs-lisp-documentation.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.7c&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Randomize a list in Emacs</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/09/06/Randomize-a-list-in-Emacs</link>
      <pubDate>Sat, 06 Sep 2014 10:08:04 EDT</pubDate>
      <category><![CDATA[emacs_lisp]]></category>
      <guid isPermaLink="false">PnPQO-nrnMjsPMd3u_zDw6Ixnhs=</guid>
      <description>Randomize a list in Emacs</description>
      <content:encoded><![CDATA[



&lt;p&gt;
I have an application where I have a list of userids, and I want to randomize the order of the list. Today, I explore some ways to do that. The first idea is to simply mimic the algorithm in Python's random.shuffle algorithm.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-python"&gt;    &lt;span style="color: #8b0000;"&gt;def&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;shuffle&lt;/span&gt;(&lt;span style="color: #8b0000;"&gt;self&lt;/span&gt;, x, &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;random&lt;/span&gt;=&lt;span style="color: #8b0000;"&gt;None&lt;/span&gt;):
        &lt;span style="color: #228b22;"&gt;"""x, random=random.random -&amp;gt; shuffle list x in place; return None.&lt;/span&gt;

&lt;span style="color: #228b22;"&gt;        Optional arg random is a 0-argument function returning a random&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;        float in [0.0, 1.0); by default, the standard random.random.&lt;/span&gt;

&lt;span style="color: #228b22;"&gt;        """&lt;/span&gt;

        &lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; random &lt;span style="color: #8b0000;"&gt;is&lt;/span&gt; &lt;span style="color: #8b0000;"&gt;None&lt;/span&gt;:
            &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;random&lt;/span&gt; = &lt;span style="color: #8b0000;"&gt;self&lt;/span&gt;.random
        &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;_int&lt;/span&gt; =&lt;span style="color: #cd0000;"&gt; int&lt;/span&gt;
        &lt;span style="color: #8b0000;"&gt;for&lt;/span&gt; i &lt;span style="color: #8b0000;"&gt;in&lt;/span&gt;&lt;span style="color: #cd0000;"&gt; reversed(xrange&lt;/span&gt;(&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;,&lt;span style="color: #cd0000;"&gt; len&lt;/span&gt;(x))):
            &lt;span style="color: #ff0000; font-weight: bold;"&gt;# pick an element in x[:i+1] with which to exchange x[i]&lt;/span&gt;
            &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;j&lt;/span&gt; = _int(random() * (i+&lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;1&lt;/span&gt;))
            x[i], &lt;span style="color: #000000; background-color: #cccccc; font-weight: bold;"&gt;x&lt;/span&gt;[j] = x[j], x[i]
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It looks like we loop through the elements, and swap them at random.
&lt;/p&gt;

&lt;p&gt;
We have a similar feature for xrange in emacs-lisp:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(number-sequence 1 5)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Note that number-sequence includes the last value, unlike xrange. And for reverse:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(reverse (number-sequence 1 5))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;5&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Of course, we can select random numbers:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(random 5) ; &lt;span style="color: #ff0000; font-weight: bold;"&gt;random between 0 and 5&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
4
&lt;/pre&gt;

&lt;p&gt;
Last, we need to work out how to swap to elements. It looks like this will swap elements 2 and 3. We store element 3 temporarily, set 3 to 2, and then set 2 to the temporarily stored value of 3.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;let*&lt;/span&gt; ((L '(1 2 3 4))
       (tmp (nth 3 L)))
  (setf (nth 3 L) (nth 2 L))
  (setf (nth 2 L) tmp)
L)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
So, now we can shuffle our list.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(setq userids '(user1 user2 user3 user4 user5 user6))

(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;swap&lt;/span&gt; (LIST el1 el2)
  &lt;span style="color: #228b22;"&gt;"in LIST swap indices EL1 and EL2 in place"&lt;/span&gt;
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((tmp (nth el1 LIST)))
    (setf (nth el1 LIST) (nth el2 LIST))
    (setf (nth el2 LIST) tmp)))

;; &lt;span style="color: #ff0000; font-weight: bold;"&gt;now run the loop&lt;/span&gt;
(loop for i in (reverse (number-sequence 1 (1- (length userids))))
      do (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((j (random (+ i 1))))
           (swap userids i j)))

userids
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;user4&lt;/td&gt;
&lt;td class="left"&gt;user6&lt;/td&gt;
&lt;td class="left"&gt;user3&lt;/td&gt;
&lt;td class="left"&gt;user2&lt;/td&gt;
&lt;td class="left"&gt;user1&lt;/td&gt;
&lt;td class="left"&gt;user5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
The order has certainly changed. It is a little difficult to tell how randomized it actually is, but what is important for my application is that the order is different each time I use it. It looks like this will accomplish that objective. I think this basically implements the algorithm in the Python random.shuffle code. That code does something a little differently. It generates a random float between 0-1, multiplies it by i + 1, and converts the result to an integer. We directly get an integer in the range of 0 to i + 1. I think the result is practically the same.
&lt;/p&gt;

&lt;p&gt;
Finally, let us wrap the whole thing up in a nice neat function for future use. We will use elt instead of nth so it works for arrays too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;swap&lt;/span&gt; (LIST el1 el2)
  &lt;span style="color: #228b22;"&gt;"in LIST swap indices EL1 and EL2 in place"&lt;/span&gt;
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))


(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;shuffle&lt;/span&gt; (LIST)
  &lt;span style="color: #228b22;"&gt;"Shuffle the elements in LIST.&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;shuffling is done in place."&lt;/span&gt;
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
        do (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((j (random (+ i 1))))
             (swap LIST i j)))
  LIST)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
shuffle
&lt;/pre&gt;

&lt;p&gt;
Example usage for a list:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(shuffle '(user1 user2 user3 user4 user5 user6))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;user4&lt;/td&gt;
&lt;td class="left"&gt;user2&lt;/td&gt;
&lt;td class="left"&gt;user3&lt;/td&gt;
&lt;td class="left"&gt;user5&lt;/td&gt;
&lt;td class="left"&gt;user6&lt;/td&gt;
&lt;td class="left"&gt;user1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
And for a vector:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(shuffle [user1 user2 user3 user4 user5 user6])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[user3 user2 user6 user4 user5 user1]
&lt;/pre&gt;

&lt;div id="outline-container-sec-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Addendum&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Artur at &lt;a href="http://endlessparentheses.com"&gt;http://endlessparentheses.com&lt;/a&gt; suggested one can use psetf to swap values. Thanks for the tip, I was not aware of that cool function. It evaluates the values first, then sets them, so there is no need for a temporary storage of a value! Here is an example usage. We could rewrite our swap function like this if we wanted.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((LIST '(1 2 3 4 5)))
  (psetf (elt LIST 2) (elt LIST 1)
         (elt LIST 1) (elt LIST 2))
LIST)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;2&lt;/td&gt;
&lt;td class="right"&gt;4&lt;/td&gt;
&lt;td class="right"&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/09/06/Randomize-a-list-in-Emacs.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.7c&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
