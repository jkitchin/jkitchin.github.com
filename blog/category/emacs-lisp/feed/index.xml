<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>https://kitchingroup.cheme.cmu.edu/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Fri, 11 Apr 2025 13:28:26 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>A partial symbolic numeric solver in emacs-lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp</link>
      <pubDate>Sun, 21 May 2017 11:33:15 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[emacs-lisp]]></category>
      <category><![CDATA[math]]></category>
      <guid isPermaLink="false">yXBmBn5c2JK1DkEAlZuJewhh724=</guid>
      <description>A partial symbolic numeric solver in emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org18a4554"&gt;1. The Newton solver in emacs-lisp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I have been exploring  ways to use emacs-lisp to express scientific ideas. In this post, we explore a partial symbolic numeric solver in Emacs-lisp. This involves some syntactic developments to more clearly identify something we want to solve for and to then generate the code required to solve it.
&lt;/p&gt;

&lt;p&gt;
In section &lt;a href="#org18a4554"&gt;The Newton solver&lt;/a&gt; you can find a simple implementation of a Newton solver in emacs-lisp. This function allows you to numerically solve equations that can be written in the form \(f(x) = 0\) for \(x\) given an initial guess. You write a function for \(f(x)\) and pass the function to the solver. This is a standard approach used in Python with fsolve, for example. Here is an example of solving a trivial problem: \(x - 4 = 0\) just to check that it works. We use a lambda function for \(f(x) = x - 4 = 0\). The answer is \(x=4\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(newton-f (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (- x 4)) 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That syntax is not too bad, but we have the whole lambda expression in there, and some repetition of what we want to solve for as an argument and in the function. It would be interesting if we could just have an expression that gets solved, e.g. &lt;code&gt;(newton-f (- x? 4) 2)&lt;/code&gt; where &lt;code&gt;x?&lt;/code&gt; indicates the thing to solve for.
&lt;/p&gt;

&lt;p&gt;
We can do that! We can take an expression, flatten it and find the variable names that end with ?. We should check that there is only one, but for now we don't. Here is an example that does that. I use a nested expression here just to illustrate that the code finds the &lt;code&gt;x?&lt;/code&gt; variable correctly.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;dash&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((body '((* (- x? 4) 1))))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for item in (-flatten body)
        if (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (symbolp item) (s-ends-with? &lt;span style="color: #008000;"&gt;"?"&lt;/span&gt; (symbol-name item)))
        collect item))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
So, given an expression we can identify the unknown that should be the argument to a lambda function. So, we create a macro that takes that expression and constructs a function to solve it, then calls newton-f on it. The macro is syntactically useful here because we do not have to quote the expression. Here is that macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;solve&lt;/span&gt; (expression guess)
  `(newton-f
    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for item in (-flatten expression)
                   if (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (symbolp item) (s-ends-with? &lt;span style="color: #008000;"&gt;"?"&lt;/span&gt; (symbol-name item)))
                   collect item)
      ,expression)
    ,guess))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
I call this a partial symbolic solver because we do some introspection symbolically to identify what to solve for, and then construct the code required to solve it. Here is that trivial example (x? - 4 = 0). It just shows we can have some nesting and it still works. I am not so thrilled with the initial guess, but this is an iterative solver, so you either need an initial guess, or a solution range.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;solve&lt;/span&gt; (* (- x? 4) 1) 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is what that expands into:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(macroexpand '(solve (* (- x? 4) 1) 3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It expands into what we would have written in the first place. The benefit to us is less typing, and a simpler syntax. Both of those reduce the opportunity to make errors!
&lt;/p&gt;

&lt;p&gt;
A more realistic problem might be: Reactant A flows into a continuously stirred tank reactor at a rate of  \(F_{A0} = 1\) mol/min with a volumetric flow of \(v_0 = 1\) L/min.. The reactor achieves 50% conversion (\(X\)) of A to products. The reaction rate law is known to be \(-r_A = k C_A\) with \(k = 0.1\) 1/min. Estimate the volume of the reactor. If you have taken my class in reaction engineering, you know the following facts:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;The exit molar flow is defined by \(F_A = F_{A0} (1 - X)\)&lt;/li&gt;
&lt;li&gt;The exit concentration is \(C_A = F_A / v_0\)&lt;/li&gt;
&lt;li&gt;The mole balance is defined by \(0 = F_{A0} - F_A + r_A V\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
That is all we need; we can solve for \(V\) from the last equation. This is simple enough you might do the algebra to get: \(V = \frac{F_{A0} - F_A}{-r_A}\) which can be simply evaluated. We use our solver here and compare it to the evaluation.
&lt;/p&gt;

&lt;p&gt;
Here is the solver:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((Fa0 1)
       (X 0.5)
       (Fa (* Fa0 (- 1 X)))
       (k 0.1)
       (v0 1)
       (Ca (/ Fa v0))
       (r (* k Ca))
       (ra (* r -1)))
  (&lt;span style="color: #0000FF;"&gt;solve&lt;/span&gt; (+ Fa0 (* Fa -1) (* ra V?)) 2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It is pretty hard to imagine doing something like this in Python! It would probably involve parsing a string.
&lt;/p&gt;

&lt;p&gt;
Here is the evaluation from our algebra:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((Fa0 1)
       (X 0.5)
       (Fa (* Fa0 (- 1 X)))
       (k 0.1)
       (v0 1)
       (Ca (/ Fa v0))
       (r (* k Ca))
       (ra (* r -1)))
  (/ (- Fa0 Fa) (* -1 ra)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Within the tolerance specified in &lt;code&gt;newton-f&lt;/code&gt;, these are the same.
&lt;/p&gt;

&lt;p&gt;
This is just the tip of the iceberg though. You may have noticed that none of the variables in the let* had any descriptions. Sure, you could put some comments after them, but those are not really part of the code.
&lt;/p&gt;

&lt;p&gt;
Also, we had to define the variables in advance of the expression. That is a limitation of how computers work, they cannot evaluate undefined variables. It &lt;i&gt;constrains&lt;/i&gt; how we can express the idea. What if we could instead specify the equation first, then the data? That way we are clear what we are trying to do at a higher level, and fill in the details later. Suppose we wanted a syntax like the block below instead. Here we emphasize the equation we are solving first, and then define the variables and quantities used in the equation, and finally the guess that we use to find the solution.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;solve1&lt;/span&gt;
 (eqn (+ Fa0 (* -1 Fa) (* ra V?)))
 (data ((k 0.1 &lt;span style="color: #008000;"&gt;"rate constant 1/min"&lt;/span&gt;)
        (Ca0 1.0 &lt;span style="color: #008000;"&gt;"feed concentration"&lt;/span&gt;)
        (v0 1 &lt;span style="color: #008000;"&gt;"volumetric flow L/min"&lt;/span&gt;)
        (Fa0 (* v0 Ca0) &lt;span style="color: #008000;"&gt;"Inlet molar flow"&lt;/span&gt;)
        (X 0.5 &lt;span style="color: #008000;"&gt;"Desired conversion"&lt;/span&gt;)
        (Fa (* Fa0 (- 1 X)) &lt;span style="color: #008000;"&gt;"Exit molar flow"&lt;/span&gt;)
        (Ca (/ Fa v0) &lt;span style="color: #008000;"&gt;"exit concentration"&lt;/span&gt;)
        (ra (* -1 k Ca) &lt;span style="color: #008000;"&gt;"rate in the reactor"&lt;/span&gt;)))
 (guess 8))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That is achievable with the solve1 macro below! It too has some limitations, mostly the order of the data block still has to be correct, e.g. you cannot use a variable before it is defined. It would take some serious macro-fu to sort these so that everything is defined in the right order! Still, it allows you to express an &lt;i&gt;executable&lt;/i&gt; idea in the order we defined. The strings in this syntax for documenting the variables are ignored, but they could be used in the macro to print useful information or something else you could imagine. You could also make them mandatory to encourage documentation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;solve1&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((expression (second (assoc 'eqn body)))
        (data (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for d in (second (assoc 'data body))
                    collect (list (first d) (second d))))
        (guess (second (assoc 'guess body))))
    `(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ,data
       (newton-f
        (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for item in (-flatten expression)
                       if (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (symbolp item) (s-ends-with? &lt;span style="color: #008000;"&gt;"?"&lt;/span&gt; (symbol-name item)))
                       collect item)
          ,expression)
        ,guess))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
To summarize, lisp macros allow us to rewrite the syntax of code before it is evaluated. This gives us the opportunity to inspect it, and generate new code, e.g. functions with arguments based on the contents of expressions, to save us typing. It also allows us to define ideas in a near arbitrary order that make sense to us, and then rearrange them so they make sense to the computer. See, for example,  &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/"&gt;this post&lt;/a&gt; for an example of changing how functions are defined.
&lt;/p&gt;

&lt;p&gt;
This seems to be heading in the domain specific language direction. I think it would be very helpful in engineering problem solving to build up tools like this. They could start out simple for new students to use. They never need to see the macro parts of this, just to learn how to use them for problem solving. These beginner tools would be limited in what they could do to minimize how much lisp is required to be learned so students can focus on the problem solving. Eventually they might outgrow them, and in the process transition to having the full lisp language at their disposal for problem solving.
&lt;/p&gt;


&lt;div id="outline-container-org18a4554" class="outline-2"&gt;
&lt;h2 id="org18a4554"&gt;&lt;a id="ID-53A5F60F-F929-43BB-AD9D-167D6EBEB8EB"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; The Newton solver in emacs-lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This is an emacs-lisp implementation of Newton's method. It is a simple implementation for a single variable. The tolerance and step-size are hard-coded for this post because we focus on the partial symbolic solver, not the best solver methods.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;See https://en.wikipedia.org/wiki/Newton%27s_method for the method&lt;/span&gt;

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;newton-f&lt;/span&gt; (func x0)
  &lt;span style="color: #036A07;"&gt;"Solve the equation FUNC(x)=0 using Newton's method.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;X0 is an initial guess."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((tolerance 1e-6)
         (x x0)
         (dx 1e-6)
         fx fpx)
    (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (&amp;gt; (abs (funcall func x)) tolerance)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; fx (funcall func x)
            fpx (/ (- (funcall func (+ x dx)) (funcall func (- x dx))) (* 2 dx))
            x (- x (/ fx fpx))))
    x))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Collecting entries from files in a directory</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/08/25/Collecting-entries-from-files-in-a-directory</link>
      <pubDate>Mon, 25 Aug 2014 21:42:05 EDT</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">DCyaUvdAukLdI2coz2BaWmbyGWE=</guid>
      <description>Collecting entries from files in a directory</description>
      <content:encoded><![CDATA[



&lt;p&gt;
I am running a class where students will be generating files that contain their answers. I want to quickly get a list of counts of all the answers. For example, six students will create a file called animal.dat in a directory called example/&amp;lt;studentid&amp;gt;, and that file will contain their favorite animal. I made some example files to test this idea out. Here are the contents.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-sh"&gt;cat example/*/animal.dat
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
dog
cat
dog
bird
dog
bird
&lt;/pre&gt;

&lt;p&gt;
You can see there are three dogs, two birds and a cat. I want code to do this counting, because in my real application there will be 58 of these files, and lots of times I need to aggregate them. Let us start with a simple example that counts the elements in a list.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((animals '(dog cat dog bird dog bird))
      (counts '())
      place)
  (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (animal animals)
    (setq place (assoc animal counts))
    (message &lt;span style="color: #228b22;"&gt;"place = %s"&lt;/span&gt; place)
    (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; place
        (setf (cdr place) (+ 1 (cdr place)))
      (setq counts (cons `(,animal . 1) counts))))
  counts)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
((bird . 2) (cat . 1) (dog . 3))
&lt;/p&gt;

&lt;p&gt;
Let us turn that into a function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;counts&lt;/span&gt; (list)
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((counts '())
        place)
    (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (el list)   
      (setq place (assoc el  counts))
    (message &lt;span style="color: #228b22;"&gt;"place = %s"&lt;/span&gt; place)
    (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; place
        (setf (cdr place) (+ 1 (cdr place)))
      (setq counts (cons `(,el . 1) counts))))
    counts))

(counts '(dog cat dog bird dog bird))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
((bird . 2) (cat . 1) (dog . 3))
&lt;/p&gt;

&lt;p&gt;
Nice. Now we need a simple way to get that list. We need to glob the files to find them, then open them and read the value. Here is a way to get the files.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(f-entries &lt;span style="color: #228b22;"&gt;"example"&lt;/span&gt;
           (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (f)
             (string= (file-name-nondirectory f) &lt;span style="color: #228b22;"&gt;"animal.dat"&lt;/span&gt;))
           t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;/Users/jkitchin/blogofile-jkitchin.github.com/&lt;sub&gt;blog&lt;/sub&gt;/collect-entries/example/s1/animal.dat&lt;/td&gt;
&lt;td class="left"&gt;/Users/jkitchin/blogofile-jkitchin.github.com/&lt;sub&gt;blog&lt;/sub&gt;/collect-entries/example/s2/animal.dat&lt;/td&gt;
&lt;td class="left"&gt;/Users/jkitchin/blogofile-jkitchin.github.com/&lt;sub&gt;blog&lt;/sub&gt;/collect-entries/example/s3/animal.dat&lt;/td&gt;
&lt;td class="left"&gt;/Users/jkitchin/blogofile-jkitchin.github.com/&lt;sub&gt;blog&lt;/sub&gt;/collect-entries/example/s4/animal.dat&lt;/td&gt;
&lt;td class="left"&gt;/Users/jkitchin/blogofile-jkitchin.github.com/&lt;sub&gt;blog&lt;/sub&gt;/collect-entries/example/s5/animal.dat&lt;/td&gt;
&lt;td class="left"&gt;/Users/jkitchin/blogofile-jkitchin.github.com/&lt;sub&gt;blog&lt;/sub&gt;/collect-entries/example/s6/animal.dat&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Now we just need to run a mapcar over this list of files.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(mapcar
 (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (f)
   (&lt;span style="color: #8b0000;"&gt;with-temp-buffer&lt;/span&gt;
     (insert-file-contents f)
     (s-trim (buffer-string))))
 (f-entries &lt;span style="color: #228b22;"&gt;"example"&lt;/span&gt;
            (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (f)
              (string= (file-name-nondirectory f) &lt;span style="color: #228b22;"&gt;"animal.dat"&lt;/span&gt;))
            t))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;dog&lt;/td&gt;
&lt;td class="left"&gt;cat&lt;/td&gt;
&lt;td class="left"&gt;dog&lt;/td&gt;
&lt;td class="left"&gt;bird&lt;/td&gt;
&lt;td class="left"&gt;dog&lt;/td&gt;
&lt;td class="left"&gt;bird&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
Finally, putting this together, we have some code that maps over the files, and counts the entries.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(counts
 (mapcar
  (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (f)
    (&lt;span style="color: #8b0000;"&gt;with-temp-buffer&lt;/span&gt;
      (insert-file-contents f)
      (s-trim (buffer-string))))
  (f-entries &lt;span style="color: #228b22;"&gt;"example"&lt;/span&gt;
             (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (f)
               (string= (file-name-nondirectory f) &lt;span style="color: #228b22;"&gt;"animal.dat"&lt;/span&gt;))
             t)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
((bird . 2) (cat . 1) (dog . 3))
&lt;/p&gt;

&lt;p&gt;
This will be helpful in dealing with 58 entries during my class!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/08/25/Collecting-entries-from-files-in-a-directory.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.7c&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Autogenerating functions in emacs-lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/05/12/Autogenerating-functions-in-emacs-lisp</link>
      <pubDate>Mon, 12 May 2014 18:05:45 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">d3hbFuxiIuGrO08l_vmlhTqDbrI=</guid>
      <description>Autogenerating functions in emacs-lisp</description>
      <content:encoded><![CDATA[



&lt;p&gt;
I have a need to generate a lot of similar functions, and I do not want to cut and paste the code. I want to generate the functions with code. This seems to be what macros are for in emacs lisp. 
&lt;/p&gt;

&lt;p&gt;
As a prototype example, we will make functions that raise a number to a power. We want functions like power-3 and power-4 that raise numbers to the third and fourth powers. We will define functions like this for the numbers 0-9.
&lt;/p&gt;

&lt;p&gt;
Here we define the macro. i do not want to get into the nitty gritty details of macro definitions here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(make-power-n 4)

(power-4 4)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
256
&lt;/pre&gt;

&lt;p&gt;
Now we use the macro and mapcar on it onto a list of numbers. We have to eval the macro in the mapcar lambda function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(mapcar (lambda (x) (eval `(make-power-n ,x))) '(0 1 2 3 4 5 6 7 8 9))
 
;; example of a few functions
(list (power-0 3) (power-1 3) (power-2 3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;

&lt;col  class="right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="right"&gt;1&lt;/td&gt;
&lt;td class="right"&gt;3&lt;/td&gt;
&lt;td class="right"&gt;9&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
It works! We created 10 functions in a little bit of code. 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/05/12/Autogenerating-functions-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.6&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Language specific default headers for code blocks in org-mode</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode</link>
      <pubDate>Sun, 26 Jan 2014 12:06:12 EST</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">dxG8WRpnI2O4piZWvxZ4X0zp34o=</guid>
      <description>Language specific default headers for code blocks in org-mode</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I use code blocks in org-mode &lt;i&gt;a lot&lt;/i&gt;. I usually code in Python, and
in Python I usually write code that prints output which I want to see. So I almost always
want the code blocks to return the output, and not the value of the
last function. I have set my default header args like this:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;org-babel-default-header-args
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;(:exports . both)&lt;/td&gt;
&lt;td class="left"&gt;(:results . replace output)&lt;/td&gt;
&lt;td class="left"&gt;(:session . none)&lt;/td&gt;
&lt;td class="left"&gt;(:cache . no)&lt;/td&gt;
&lt;td class="left"&gt;(:noweb . no)&lt;/td&gt;
&lt;td class="left"&gt;(:hlines . no)&lt;/td&gt;
&lt;td class="left"&gt;(:tangle . no)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
However, I would prefer that emacs-lisp blocks use value for the
results. I know I can get that by putting  &lt;code&gt;:results value&lt;/code&gt;  in the
code block header, but that annoys me. I learned today from
&lt;a href="http://orgmode.org/worg/org-contrib/babel/header-args.html"&gt;http://orgmode.org/worg/org-contrib/babel/header-args.html&lt;/a&gt; that you
can make language specific default headers!
&lt;/p&gt;

&lt;p&gt;
This code in my init file sets emacs-lisp specific default headers:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(setq org-babel-default-header-args:emacs-lisp 
      (cons '(&lt;span style="color: #cd0000;"&gt;:results&lt;/span&gt; . &lt;span style="color: #228b22;"&gt;"value"&lt;/span&gt;)
            (assq-delete-all &lt;span style="color: #cd0000;"&gt;:results&lt;/span&gt; org-babel-default-header-args)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That way I do not have type &lt;code&gt;:results value&lt;/code&gt; at the top of every elisp
block. Of course, if I want the output I could specify &lt;code&gt;:results
output&lt;/code&gt; in the block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;org-babel-default-header-args:emacs-lisp
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;(:results . value)&lt;/td&gt;
&lt;td class="left"&gt;(:exports . both)&lt;/td&gt;
&lt;td class="left"&gt;(:session . none)&lt;/td&gt;
&lt;td class="left"&gt;(:cache . no)&lt;/td&gt;
&lt;td class="left"&gt;(:noweb . no)&lt;/td&gt;
&lt;td class="left"&gt;(:hlines . no)&lt;/td&gt;
&lt;td class="left"&gt;(:tangle . no)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Problem solved!
&lt;/p&gt;

&lt;p&gt;
On a related note, I find I write so many blocks of python and elisp I
added these templates:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;add &amp;lt;p for python expansion&lt;/span&gt;
(add-to-list 'org-structure-template-alist
             '(&lt;span style="color: #228b22;"&gt;"p"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"#+BEGIN_SRC python\n?\n#+END_SRC"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"&amp;lt;src lang=\"python\"&amp;gt;\n?\n&amp;lt;/src&amp;gt;"&lt;/span&gt;))

&lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;add &amp;lt;el for emacs-lisp expansion&lt;/span&gt;
(add-to-list 'org-structure-template-alist
             '(&lt;span style="color: #228b22;"&gt;"el"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"&amp;lt;src lang=\"emacs-lisp\"&amp;gt;\n?\n&amp;lt;/src&amp;gt;"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
I probably could have also coded the :results header into those
too. They add a tidbit of convenience so I do not have to type python
or emacs-lisp after expanding a source block with &amp;lt;s.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.5g&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Another alternative to string templates</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/01/26/Another-alternative-to-string-templates</link>
      <pubDate>Sun, 26 Jan 2014 09:56:45 EST</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">2CSJtQUZFLi1s80SezzyNKawts8=</guid>
      <description>Another alternative to string templates</description>
      <content:encoded><![CDATA[


&lt;p&gt;
In the &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/"&gt;last post&lt;/a&gt; I explored a way to expand a string template that was
more readable than the usual format. Today I look at another approach
where I use sexp expansions to accomplish the same thing. The idea is
to embed lisp expressions and replace them by what they evaluate to.
&lt;/p&gt;

&lt;p&gt;
In emacs-lisp, if we have a command in a string, we can "read" it, and
then eval it. 
&lt;/p&gt;

&lt;p&gt;
Here we get the user-full-name:
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(eval (read &lt;span style="color: #228b22;"&gt;"user-full-name"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin
&lt;/pre&gt;

&lt;p&gt;
We can use this on variables too.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(setq some-variable &lt;span style="color: #228b22;"&gt;"test"&lt;/span&gt;)
(eval (read &lt;span style="color: #228b22;"&gt;"some-variable"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
test
&lt;/pre&gt;

&lt;p&gt;
So, if we use a syntax to identify what to replace, we can substitute
in the values. Let us try %() as the syntax.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;expand-template&lt;/span&gt; (s)
  &lt;span style="color: #228b22;"&gt;"expand a template containing %() with the eval of its contents"&lt;/span&gt;
  (replace-regexp-in-string &lt;span style="color: #228b22;"&gt;"%(&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;^&lt;/span&gt;&lt;span style="color: #228b22;"&gt;)]+&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #228b22;"&gt;)"&lt;/span&gt;
                            (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (arg)
                              (format &lt;span style="color: #228b22;"&gt;"%s"&lt;/span&gt; (eval (read (substring arg 2 -1))))) s))


(&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((key &lt;span style="color: #228b22;"&gt;"kitchin-2014"&lt;/span&gt;)
      (author &lt;span style="color: #228b22;"&gt;"Kitchin, J. R."&lt;/span&gt;)
      (journal &lt;span style="color: #228b22;"&gt;"HACS"&lt;/span&gt;)
      (year &lt;span style="color: #228b22;"&gt;"2014"&lt;/span&gt;)
      (volume &lt;span style="color: #228b22;"&gt;"1"&lt;/span&gt;)
      (pages &lt;span style="color: #228b22;"&gt;"1--10"&lt;/span&gt;)
      (doi &lt;span style="color: #228b22;"&gt;"10.1.1.109/hacs.1.10"&lt;/span&gt;)
      (url &lt;span style="color: #228b22;"&gt;"http://hacs.org/10.1.1.109/hacs.1.10"&lt;/span&gt;)
      (pdf-dir &lt;span style="color: #228b22;"&gt;"/home/jkitchin/pdfs"&lt;/span&gt;)
      (template &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :PROPERTIES:&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :Custom_ID: %(key)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :AUTHOR: %(author&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :JOURNAL: %(journal)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :YEAR: %(year)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :VOLUME: %(volume)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :PAGES: %(pages)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :DOI: %(doi)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :URL: %(url)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :END:&lt;/span&gt;
&lt;span style="color: #ff0000; font-weight: bold;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[cite:%(key)]] [[file:%(pdf-dir)/%(key).pdf][pdf]]\n\n"&lt;/span&gt;))

(expand-template template))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
&lt;/pre&gt;

&lt;p&gt;
That is pretty nice. I like it better than the plist expansion I used
before. Presumably these variables would already be defined somewhere
in your code.
&lt;/p&gt;

&lt;p&gt;
I thought of trying this on a more complex expansion, and discovered a
weakness in the regexp that finds the expansion values. It turns out
to be simpler to use %{} as the delimiter than %(), because you may
want nested parentheses. The regexp above does not correctly match
sets of parentheses.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;expand-template&lt;/span&gt; (s)
  &lt;span style="color: #228b22;"&gt;"expand a template containing %{} with the eval of its contents"&lt;/span&gt;
  (replace-regexp-in-string &lt;span style="color: #228b22;"&gt;"%{&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;^&lt;/span&gt;&lt;span style="color: #228b22;"&gt;}]+&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #228b22;"&gt;}"&lt;/span&gt;
                            (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (arg)
                              (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((sexp (substring arg 2 -1)))
                                (format &lt;span style="color: #228b22;"&gt;"%s"&lt;/span&gt; (eval (read sexp))))) s))

(expand-template &lt;span style="color: #228b22;"&gt;"2 * 2 = %{(* 2 2)}"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2 * 2 = 4
&lt;/pre&gt;


&lt;p&gt;
I am not sure this is a desirable way to make a template, with
multiline code to be expanded, but at least this works!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;expand-template&lt;/span&gt; (s)
  &lt;span style="color: #228b22;"&gt;"expand a template containing %{} with the eval of its contents"&lt;/span&gt;
  (replace-regexp-in-string &lt;span style="color: #228b22;"&gt;"%{&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;^&lt;/span&gt;&lt;span style="color: #228b22;"&gt;}]+&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #228b22;"&gt;}"&lt;/span&gt;
                            (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (arg)
                              (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((sexp (substring arg 2 -1)))
                                (format &lt;span style="color: #228b22;"&gt;"%s"&lt;/span&gt; (eval (read sexp))))) s))

(expand-template &lt;span style="color: #228b22;"&gt;"The result is %{(progn&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  (if (&amp;gt; 4 3)&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;      'true&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;    'false))}"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The result is true
&lt;/pre&gt;

&lt;p&gt;
The regexp used in the expansion is not very robust. In particular if
there is a } in the code, it will probably fail because the regexp
does not match closing } correctly. Fixing that is beyond me right
now!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/01/26/Another-alternative-to-string-templates.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.5g&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Alternatives to long complex format statements in emacs-lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp</link>
      <pubDate>Mon, 20 Jan 2014 09:50:26 EST</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">tDjoXb3YYfeNMIT853gUlB6-9zA=</guid>
      <description>Alternatives to long complex format statements in emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;p&gt;
At one point I had a string I wanted to fill in with a bunch of variables. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(insert (format&lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :PROPERTIES:&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :Custom_ID: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :AUTHOR: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :JOURNAL: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :YEAR: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :VOLUME: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :PAGES: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :DOI: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :URL: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :END:&lt;/span&gt;
&lt;span style="color: #228b22; font-weight: bold;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"&lt;/span&gt;
key author journal year volume pages doi url key jorg-bib-pdf-directory key ))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
I find that very difficult to use, because it is tedious to make sure all the variables are in the right order, and it is difficult to change later. In Python, you would be able to put named expansions in, e.g. {author} and then used named arguments. That does not exist as far as I know in emacs-lisp.
&lt;/p&gt;

&lt;p&gt;
Below is an alternatme approach that uses concat to construct this string.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((key &lt;span style="color: #228b22;"&gt;"kitchin-2014"&lt;/span&gt;)
      (author &lt;span style="color: #228b22;"&gt;"Kitchin, J. R."&lt;/span&gt;)
      (journal &lt;span style="color: #228b22;"&gt;"HACS"&lt;/span&gt;)
      (year &lt;span style="color: #228b22;"&gt;"2014"&lt;/span&gt;)
      (volume &lt;span style="color: #228b22;"&gt;"1"&lt;/span&gt;)
      (pages &lt;span style="color: #228b22;"&gt;"1--10"&lt;/span&gt;)
      (doi &lt;span style="color: #228b22;"&gt;"10.1.1.109/hacs.1.10"&lt;/span&gt;)
      (url &lt;span style="color: #228b22;"&gt;"http://hacs.org/10.1.1.109/hacs.1.10"&lt;/span&gt;)
      (jorg-bib-pdf-directory &lt;span style="color: #228b22;"&gt;"/home/jkitchin/pdfs"&lt;/span&gt;))

(concat &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :PROPERTIES:&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :Custom_ID: "&lt;/span&gt; key &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :AUTHOR: "&lt;/span&gt; author &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :JOURNAL: "&lt;/span&gt; journal &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :YEAR: "&lt;/span&gt; year &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :VOLUME: "&lt;/span&gt; volume &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :PAGES: "&lt;/span&gt; pages &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :DOI: "&lt;/span&gt; doi &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :URL: "&lt;/span&gt; url &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :END:&lt;/span&gt;
&lt;span style="color: #228b22; font-weight: bold;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[cite:"&lt;/span&gt; key &lt;span style="color: #228b22;"&gt;"]] [[file:"&lt;/span&gt; jorg-bib-pdf-directory &lt;span style="color: #228b22;"&gt;"/"&lt;/span&gt; key &lt;span style="color: #228b22;"&gt;".pdf][pdf]]\n\n"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
&lt;/pre&gt;

&lt;p&gt;
That is kind of interesting. It is a little tedious to use all the quotes. It seems like there should be soemthing like named expansions. Let us write one of our own. We will use a regular expression to find {:keyword} and a plist. There is a regexp to match this, and then we can take the characters from position 1 to the second to last character as the keyword. That is not beautiful to me, but it works here. Then we just get the keyword from the plist. The keywords in a plist are symbols, and we will have strings. We have to use the &lt;code&gt;intern&lt;/code&gt; function to convert them to symbols.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;expand-template&lt;/span&gt; (s plist)
  &lt;span style="color: #228b22;"&gt;"expand a template containing {:keyword} with the definitions in plist"&lt;/span&gt;
  (replace-regexp-in-string &lt;span style="color: #228b22;"&gt;"{&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #228b22;"&gt;:[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;^&lt;/span&gt;&lt;span style="color: #228b22;"&gt;}]+&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #228b22; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #228b22;"&gt;}"&lt;/span&gt; 
                            (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (arg) 
                              (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((keyword (intern (substring arg 1 -1))))
                                (format &lt;span style="color: #228b22;"&gt;"%s"&lt;/span&gt; (plist-get plist keyword)))) s))

(&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((template &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :PROPERTIES:&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :Custom_ID: {:key}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :AUTHOR: {:author}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :JOURNAL: {:journal}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :YEAR: {:year}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :VOLUME: {:volume}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :PAGES: {:pages}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :DOI: {:doi}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;  :URL: {:url}&lt;/span&gt;
&lt;span style="color: #228b22;"&gt; :END:&lt;/span&gt;
&lt;span style="color: #228b22; font-weight: bold;"&gt;[&lt;/span&gt;&lt;span style="color: #228b22;"&gt;[cite:{:key}]] [[file:{:pdf-dir}/{:key}.pdf][pdf]]\n\n"&lt;/span&gt;))

(expand-template template
                 '(&lt;span style="color: #cd0000;"&gt;:key&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"kitchin-2014"&lt;/span&gt;
                        &lt;span style="color: #cd0000;"&gt;:author&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"Kitchin, J. R."&lt;/span&gt;
                        &lt;span style="color: #cd0000;"&gt;:journal&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"HACS"&lt;/span&gt;
                        &lt;span style="color: #cd0000;"&gt;:year&lt;/span&gt; 2014
                        &lt;span style="color: #cd0000;"&gt;:volume&lt;/span&gt; 1
                        &lt;span style="color: #cd0000;"&gt;:pages&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"1--10"&lt;/span&gt;
                        &lt;span style="color: #cd0000;"&gt;:doi&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"10.1.1.109/hacs.1.10"&lt;/span&gt;
                        &lt;span style="color: #cd0000;"&gt;:url&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"http://hacs.org/10.1.1.109/hacs.1.10"&lt;/span&gt;
                        &lt;span style="color: #cd0000;"&gt;:pdf-dir&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"/home/jkitchin/pdfs"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
&lt;/pre&gt;

&lt;p&gt;
That is pretty close to what I am used to from python! I am surprised there aren't other solutions for this around. I looked, and couldn't find them.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;&lt;p&gt;Org-mode version = 8.2.5f&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Send email to a list of users</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2014/01/13/Send-email-to-a-list-of-users</link>
      <pubDate>Mon, 13 Jan 2014 18:41:55 EST</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">b4EUGcnni1zJe-iPNyAZ1lbDEMs=</guid>
      <description>Send email to a list of users</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapcar to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;send-mail&lt;/span&gt; (userid password)
  &lt;span style="color: #228b22;"&gt;"send email to userid@andrew.cmu.edu containing their password"&lt;/span&gt;
  (interactive)
  (mail)
  (mail-to)
  (insert (format &lt;span style="color: #228b22;"&gt;"%s@andrew.cmu.edu"&lt;/span&gt; userid))
  (mail-subject)
  (insert &lt;span style="color: #228b22;"&gt;"[06-640] account information"&lt;/span&gt;)
  (mail-text)
  (insert (format &lt;span style="color: #228b22;"&gt;"&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;An account has been created on gilgamesh.cheme.cmu.edu&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;userid: %s&lt;/span&gt;
&lt;span style="color: #228b22;"&gt;password: %s"&lt;/span&gt; userid password))
  (mail-send-and-exit))

(send-mail &lt;span style="color: #228b22;"&gt;"jkitchin"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"trustme99"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That worked well. I ran the block and got the email. 
&lt;/p&gt;

&lt;p&gt;
Now, suppose I have this data:
&lt;/p&gt;
&lt;table id="users" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="left" /&gt;

&lt;col  class="left" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="left"&gt;userid&lt;/th&gt;
&lt;th scope="col" class="left"&gt;password&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;user1&lt;/td&gt;
&lt;td class="left"&gt;trustme99&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;user2&lt;/td&gt;
&lt;td class="left"&gt;foolme99&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;user3&lt;/td&gt;
&lt;td class="left"&gt;blameme99&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
We can pass that to a source block as a list of lists that will look like this:
&lt;/p&gt;
&lt;pre class="example"&gt;
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
&lt;/pre&gt;

&lt;p&gt;
Then, we can use a mapcar to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fun&lt;/span&gt; (a b)
  (princ (format &lt;span style="color: #228b22;"&gt;"user: %s\npassword: %s\n"&lt;/span&gt; a b)))

(mapcar (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (x) (fun (car x) (cadr x))) data)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
user: user1
password: trustme99
user: user2
password: foolme99
user: user3
password: blameme99
&lt;/pre&gt;

&lt;p&gt;
I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;fun&lt;/span&gt; (a b)
  (princ (format &lt;span style="color: #228b22;"&gt;"user: %s\npassword: %s\n"&lt;/span&gt; a b)))

(mapcar (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (x) (fun (nth 0 x) (nth 1 x))) data)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
user: user1
password: trustme99
user: user2
password: foolme99
user: user3
password: blameme99
&lt;/pre&gt;
&lt;p&gt;Copyright (C) 2014 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2014/01/13/Send-email-to-a-list-of-users.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>An improved index function for emacs-lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2013/12/22/An-improved-index-function-for-emacs-lisp</link>
      <pubDate>Sun, 22 Dec 2013 12:01:48 EST</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">RlJV9TkiILeP_U_cHBnBbddRwy4=</guid>
      <description>An improved index function for emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I previously worked out an &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp/"&gt;index&lt;/a&gt; function for a list of strings in emacs-lisp, but at the end I showed it would not work for arbitrary elements of a list. Here is an exercise to improve on that. The goal is a function that looks like this:
&lt;/p&gt;
&lt;pre class="example"&gt;
(index 1 '("a" 2 1 "b"))
&lt;/pre&gt;
&lt;p&gt;
that would return 2 in this case. Last time I used string=, which is why I could not find a number in the list. This time, we will use &lt;code&gt;equal&lt;/code&gt; (see &lt;a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html"&gt;http://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html&lt;/a&gt; ) which compares components of objects for equality. That should let us find arbitrary objects in a list. 
&lt;/p&gt;

&lt;p&gt;
Here is our improved function:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;index&lt;/span&gt; (object list)
  &lt;span style="color: #228b22;"&gt;"return the index of object in list"&lt;/span&gt;
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((counter 0)
        (found nil))
    (&lt;span style="color: #8b0000;"&gt;catch&lt;/span&gt; '&lt;span style="color: #cd0000;"&gt;finished&lt;/span&gt;
      (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (listelement list counter)
        (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; (equal object listelement)
            (&lt;span style="color: #8b0000;"&gt;progn&lt;/span&gt;
              (setq found t)
              (&lt;span style="color: #8b0000;"&gt;throw&lt;/span&gt; '&lt;span style="color: #cd0000;"&gt;finished&lt;/span&gt; counter))
          &lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;else increment counter&lt;/span&gt;
          (incf counter)))
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;if we found it return counter otherwise return nil&lt;/span&gt;
    (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; found counter nil))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, let us test some examples:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index 1 '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; 2 1 &lt;span style="color: #228b22;"&gt;"b"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2
&lt;/pre&gt;

&lt;p&gt;
No problem finding a number in a list.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index &lt;span style="color: #228b22;"&gt;"b"&lt;/span&gt; '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; 2 1 &lt;span style="color: #228b22;"&gt;"b"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3
&lt;/pre&gt;

&lt;p&gt;
How about something more complicated, like a list in a list?
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index '(1 2) '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; 2 1 (1 2) &lt;span style="color: #228b22;"&gt;"b"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3
&lt;/pre&gt;

&lt;p&gt;
That looks good.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(princ (index '(1 2) '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; 2 1 (2 (1 2)) &lt;span style="color: #228b22;"&gt;"b"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
nil
&lt;/pre&gt;

&lt;p&gt;
Note, we do not find the nested object. That is ok, the location of that object would require two indices, which this function is not designed for. 
&lt;/p&gt;

&lt;p&gt;
Here we consider an object of an a-list
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index '(&lt;span style="color: #228b22;"&gt;"nut"&lt;/span&gt; . &lt;span style="color: #228b22;"&gt;"acorn"&lt;/span&gt;) '((&lt;span style="color: #228b22;"&gt;"nut"&lt;/span&gt; . &lt;span style="color: #228b22;"&gt;"acorn"&lt;/span&gt;) (&lt;span style="color: #228b22;"&gt;"fruit"&lt;/span&gt; . &lt;span style="color: #228b22;"&gt;"apple"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0
&lt;/pre&gt;

&lt;p&gt;
I am not quite sure how you would use that, but it does illustrate the generality of the index function!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/12/22/An-improved-index-function-for-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Summarizing org-files in a report</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2013/04/30/Summarizing-org-files-in-a-report</link>
      <pubDate>Tue, 30 Apr 2013 08:30:01 EDT</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">v2wpyyxyjkNJc-o-oo_-fUMaWy8=</guid>
      <description>Summarizing org-files in a report</description>
      <content:encoded><![CDATA[


&lt;p&gt;
This is an example of using emacs-lisp to extract pieces of information about a bunch of org-files into a single report, as well as aggregating data from those files. The scenario where this would likely be useful is if you have a set of org-files that contain information, e.g. from a bunch of different calculations, or from documents turned in by different students, and you want to aggregate the results into a report.
&lt;/p&gt;

&lt;p&gt;
In this example, I have a set of org-files in this directory that contain simulated homework assignments turned in. The files in this example all look something like this. Each heading corresponds to a problem, and there is a properties drawer for each heading that contains the grade. 
&lt;/p&gt;

&lt;p&gt;
We will create a navigation document that facilitates reviewing each of the files, as well as collecting the grades from the files. Here is what a typical file looks like:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+PROPERTY: NAME Ellen Donnte
* 1a
  :PROPERTIES:
  :lettergrade: A
  :END:
* 1b
  :PROPERTIES:
  :lettergrade: R
  :END:
* 2
  :PROPERTIES:
  :lettergrade: A
  :END:
#+BEGIN_SRC emacs-lisp
(prin1 42)
#+END_SRC

#+RESULTS:
: 42

* 3
  :PROPERTIES:
  :lettergrade: C
  :END:
&lt;/pre&gt;


&lt;div id="outline-container-1" class="outline-2"&gt;
&lt;h2 id="sec-1"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Creating a navigation document&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
In this section we write some code that creates text with a link to each file we need to review. This is something I imagine we would do after all the files have been turned in and collected. This buffer would facilitate navigating all the files, and checking them off. First we create checkboxes. All this does is create an easy to use navigation document that facilitates opening the files, grading them, and marking them as done.&lt;sup&gt;&lt;a id="fnr.1" name="fnr.1" class="footref" href="#fn.1"&gt;1&lt;/a&gt;&lt;/sup&gt;
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;require&lt;/span&gt; '&lt;span style="color: #cd0000;"&gt;find-lisp&lt;/span&gt;)

(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (fname (find-lisp-find-files &lt;span style="color: #228b22;"&gt;"."&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"\\HW1.org$"&lt;/span&gt;) nil)
  (princ (format &lt;span style="color: #228b22;"&gt;"- [ ] [[file:%s][%s]]\n"&lt;/span&gt; fname (file-name-nondirectory fname))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[X]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Slim-Shady-HW1.html" &gt;Slim-Shady-HW1.org&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;nbsp;]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/John-Doe-HW1.html" &gt;John-Doe-HW1.org&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;nbsp;]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Jim-Vicious-HW1.html" &gt;Jim-Vicious-HW1.org&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;nbsp;]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Ellen-Donnte-HW1.html" &gt;Ellen-Donnte-HW1.org&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;
In the results above I have marked one entry as completed.
&lt;/p&gt;

&lt;p&gt;
It might be preferrable to have links to places in the file, e.g. to problem 2.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;require&lt;/span&gt; '&lt;span style="color: #cd0000;"&gt;find-lisp&lt;/span&gt;)

(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (fname (find-lisp-find-files &lt;span style="color: #228b22;"&gt;"."&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"\\HW1.org$"&lt;/span&gt;) nil)
  (princ (format &lt;span style="color: #228b22;"&gt;"- [ ] [[file:%s::*2][%s - problem 2]]\n"&lt;/span&gt; fname (file-name-nondirectory fname))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[&amp;nbsp;]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Slim-Shady-HW1.html" &gt;Slim-Shady-HW1.org - problem 2&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;nbsp;]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/John-Doe-HW1.html" &gt;John-Doe-HW1.org - problem 2&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[X]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Jim-Vicious-HW1.html" &gt;Jim-Vicious-HW1.org - problem 2&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;nbsp;]&lt;/code&gt; &lt;a href="file://c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Ellen-Donnte-HW1.html" &gt;Ellen-Donnte-HW1.org - problem 2&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-2" class="outline-2"&gt;
&lt;h2 id="sec-2"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Aggregating properties&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Our goal here is to use emacs-lisp to aggregate the letter grades from all the assignments into a table. This would be done after all the files have been reviewed. First, we write a function that gets the data we want. The function should take a filename, and return the letter grade for a problem, e.g. (get-letter-grade filename problem) -&amp;gt; lettergrade. Then, we will map that function onto a list of files.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;require&lt;/span&gt; '&lt;span style="color: #cd0000;"&gt;find-lisp&lt;/span&gt;)

(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;get-letter-grade&lt;/span&gt; (filename problem-name)
  &lt;span style="color: #228b22;"&gt;"Open filename, get the grade associated with the heading of problem-name."&lt;/span&gt;
  (&lt;span style="color: #8b0000;"&gt;with-temp-buffer&lt;/span&gt;
    (insert-file-contents filename)
    (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((studentname nil)
           (lettergrade nil))
      (org-ctrl-c-ctrl-c) &lt;span style="color: #ff0000; font-weight: bold;"&gt;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;this is needed to read the NAME property!&lt;/span&gt;
      (setq studentname (org-entry-get (point) &lt;span style="color: #228b22;"&gt;"NAME"&lt;/span&gt; t))
      (goto-char (point-min))
      (search-forward problem-name)
      (setq lettergrade (org-entry-get (point) &lt;span style="color: #228b22;"&gt;"lettergrade"&lt;/span&gt;))
      
      (princ (format &lt;span style="color: #228b22;"&gt;"|%s|%s|%s|\n"&lt;/span&gt; studentname problem-name lettergrade)))))

(princ &lt;span style="color: #228b22;"&gt;"#+ATTR_HTML: :border 2 :rules all :frame border\n"&lt;/span&gt;)
(princ &lt;span style="color: #228b22;"&gt;"#+tblname: GRADES\n"&lt;/span&gt;)
(princ &lt;span style="color: #228b22;"&gt;"| Name | Problem | Grade |\n|-\n"&lt;/span&gt;)

(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (problem-name '(&lt;span style="color: #228b22;"&gt;"1a"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"1b"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"2"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"3"&lt;/span&gt;) nil)
  (mapcar (&lt;span style="color: #8b0000;"&gt;lambda&lt;/span&gt; (fname) (get-letter-grade fname problem-name)) 
      (find-lisp-find-files &lt;span style="color: #228b22;"&gt;"."&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"\\HW1.org$"&lt;/span&gt;)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" id="GRADES"&gt;
&lt;caption&gt;&lt;/caption&gt;

&lt;colgroup&gt;
&lt;col class="left"/&gt;

&lt;col class="left"/&gt;

&lt;col class="left"/&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="left"&gt;Name&lt;/th&gt;
&lt;th scope="col" class="left"&gt;Problem&lt;/th&gt;
&lt;th scope="col" class="left"&gt;Grade&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="left"&gt;Slim Shady&lt;/td&gt;
&lt;td class="left"&gt;1a&lt;/td&gt;
&lt;td class="left"&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;John Doe&lt;/td&gt;
&lt;td class="left"&gt;1a&lt;/td&gt;
&lt;td class="left"&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Jim Vicious&lt;/td&gt;
&lt;td class="left"&gt;1a&lt;/td&gt;
&lt;td class="left"&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Ellen Donnte&lt;/td&gt;
&lt;td class="left"&gt;1a&lt;/td&gt;
&lt;td class="left"&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Slim Shady&lt;/td&gt;
&lt;td class="left"&gt;1b&lt;/td&gt;
&lt;td class="left"&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;John Doe&lt;/td&gt;
&lt;td class="left"&gt;1b&lt;/td&gt;
&lt;td class="left"&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Jim Vicious&lt;/td&gt;
&lt;td class="left"&gt;1b&lt;/td&gt;
&lt;td class="left"&gt;C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Ellen Donnte&lt;/td&gt;
&lt;td class="left"&gt;1b&lt;/td&gt;
&lt;td class="left"&gt;R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Slim Shady&lt;/td&gt;
&lt;td class="left"&gt;2&lt;/td&gt;
&lt;td class="left"&gt;R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;John Doe&lt;/td&gt;
&lt;td class="left"&gt;2&lt;/td&gt;
&lt;td class="left"&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Jim Vicious&lt;/td&gt;
&lt;td class="left"&gt;2&lt;/td&gt;
&lt;td class="left"&gt;R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Ellen Donnte&lt;/td&gt;
&lt;td class="left"&gt;2&lt;/td&gt;
&lt;td class="left"&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Slim Shady&lt;/td&gt;
&lt;td class="left"&gt;3&lt;/td&gt;
&lt;td class="left"&gt;R&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;John Doe&lt;/td&gt;
&lt;td class="left"&gt;3&lt;/td&gt;
&lt;td class="left"&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Jim Vicious&lt;/td&gt;
&lt;td class="left"&gt;3&lt;/td&gt;
&lt;td class="left"&gt;D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="left"&gt;Ellen Donnte&lt;/td&gt;
&lt;td class="left"&gt;3&lt;/td&gt;
&lt;td class="left"&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;
You could imagine some other kind of aggregating or analysis here too. Now that we have that table, we can use it in other analysis. Let us count the number of A's. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;save-excursion&lt;/span&gt;
  (goto-char (point-min))
  (search-forward-regexp &lt;span style="color: #228b22;"&gt;"^#\\+tblname: GRADES"&lt;/span&gt;)
  (next-line)
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((A-COUNT 0)
        (letter-grade nil)
        &lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;cddr is used to remove the first two rows of the table&lt;/span&gt;
        (data (cddr (org-table-to-lisp))))
    (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (entry data nil)
      (setq letter-grade (nth 2 entry))
      (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; (equal  letter-grade &lt;span style="color: #228b22;"&gt;"A"&lt;/span&gt;)
          (incf A-COUNT)))
    (princ (format &lt;span style="color: #228b22;"&gt;"%s A's counted"&lt;/span&gt; A-COUNT))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
4 A's counted
&lt;/pre&gt;

&lt;p&gt;
Since we are in org-mode, we can use the table directly! Let us do that and count the number of R's.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((COUNT 0)
      (letter-grade nil))
    (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (entry (cddr data) nil)
      (setq letter-grade (nth 2 entry))
      (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; (equal  letter-grade &lt;span style="color: #228b22;"&gt;"R"&lt;/span&gt;)
          (incf COUNT)))
    (princ (format &lt;span style="color: #228b22;"&gt;"%s R's counted"&lt;/span&gt; COUNT))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
4 R's counted
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-3" class="outline-2"&gt;
&lt;h2 id="sec-3"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Aggregating sections of org-files into one file&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Another scenario that may be interesting is to collect all of the responses in a single document. This might be useful to show examples in class, or to review all the problems to see if there are common errors. Here we collect Problem 2.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;require&lt;/span&gt; '&lt;span style="color: #cd0000;"&gt;find-lisp&lt;/span&gt;)

(generate-new-buffer &lt;span style="color: #228b22;"&gt;"Problem 2"&lt;/span&gt;)
(set-buffer &lt;span style="color: #228b22;"&gt;"Problem 2"&lt;/span&gt;)
(insert &lt;span style="color: #228b22;"&gt;"#+TITLE: Summary of problem 2\n"&lt;/span&gt;)

(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (fname (find-lisp-find-files &lt;span style="color: #228b22;"&gt;"."&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"\\HW1.org$"&lt;/span&gt;) nil)
  (&lt;span style="color: #8b0000;"&gt;save-excursion&lt;/span&gt;
    (goto-char (point-max))
    (org-mode)
    (&lt;span style="color: #8b0000;"&gt;with-temp-buffer&lt;/span&gt; 
      (insert-file-contents fname)
      (org-mode)
      (goto-char (point-min))
      (setq studentname (org-entry-get nil &lt;span style="color: #228b22;"&gt;"NAME"&lt;/span&gt; t))
      (search-forward &lt;span style="color: #228b22;"&gt;"* 2"&lt;/span&gt;)
      (org-narrow-to-subtree)
      (forward-line) &lt;span style="color: #ff0000; font-weight: bold;"&gt;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;skip heading&lt;/span&gt;
      (setq text (buffer-substring (point) (point-max))))
    (insert (format &lt;span style="color: #228b22;"&gt;"* 2 - %s\n"&lt;/span&gt; studentname))
    (insert text &lt;span style="color: #228b22;"&gt;"\n"&lt;/span&gt;)
          
    (search-backward &lt;span style="color: #228b22;"&gt;"* 2"&lt;/span&gt;)
    (org-entry-put nil &lt;span style="color: #228b22;"&gt;"NAME"&lt;/span&gt; studentname)
    (org-entry-put nil &lt;span style="color: #228b22;"&gt;"source"&lt;/span&gt; (format &lt;span style="color: #228b22;"&gt;"[[%s][link]]"&lt;/span&gt; fname))
))

(switch-to-buffer &lt;span style="color: #228b22;"&gt;"Problem 2"&lt;/span&gt;)
(org-mode) &lt;span style="color: #ff0000; font-weight: bold;"&gt;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;switch to org-mode in that buffer&lt;/span&gt;

&lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;print the lines to see what we got&lt;/span&gt;
(&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (line (split-string (buffer-string) &lt;span style="color: #228b22;"&gt;"\n"&lt;/span&gt;) nil) (princ (format &lt;span style="color: #228b22;"&gt;": %s\n"&lt;/span&gt; line)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
: #+TITLE: Summary of problem 2
: * 2 - Slim Shady
:   :PROPERTIES:
:   :lettergrade: R
:   :NAME:     Slim Shady
:   :source:   [[c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Slim-Shady-HW1.org][link]]
:   :END:
: #+BEGIN_SRC python
: print 3
: 
: #+END_SRC
: 
: #+RESULTS:
: : 3
: 
: * 2 - John Doe
:   :PROPERTIES:
:   :lettergrade: B
:   :NAME:     John Doe
:   :source:   [[c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/John-Doe-HW1.org][link]]
:   :END:
: Here is my solution
: #+BEGIN_SRC python
: print 4
: #+END_SRC
: 
: #+RESULTS:
: : 4
: 
: * 2 - Jim Vicious
:   :PROPERTIES:
:   :lettergrade: R
:   :NAME:     Jim Vicious
:   :source:   [[c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Jim-Vicious-HW1.org][link]]
:   :END:
: I could not figure this out
: * 2 - Ellen Donnte
:   :PROPERTIES:
:   :lettergrade: A
:   :NAME:     Ellen Donnte
:   :source:   [[c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/org-report/Ellen-Donnte-HW1.org][link]]
:   :END:
: #+BEGIN_SRC emacs-lisp
: (prin1 42)
: #+END_SRC
: 
: #+RESULTS:
: : 42
&lt;/pre&gt;






&lt;p&gt;
I am not super thrilled with this approach. It feels too much like hand-crafting a result, but it does show some possibilities!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/04/30/Summarizing-org-files-in-a-report.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
    <item>
      <title>An index function for strings in emacs-lisp</title>
      <link>https://kitchingroup.cheme.cmu.edu/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp</link>
      <pubDate>Tue, 05 Mar 2013 19:28:30 EST</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">mBL1p8VrqWdP30pmFOzi2v6yMUA=</guid>
      <description>An index function for strings in emacs-lisp</description>
      <content:encoded><![CDATA[



&lt;p&gt;
I could not find an index function for strings in emacs-lisp. The &lt;code&gt;position&lt;/code&gt; function seems to work for numbers, but not strings. Here is a version that works on strings.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #8b0000;"&gt;defun&lt;/span&gt; &lt;span style="color: #8b2323;"&gt;index&lt;/span&gt; (item list)
  &lt;span style="color: #228b22;"&gt;"return index of item in list or nil"&lt;/span&gt;
  (&lt;span style="color: #8b0000;"&gt;let&lt;/span&gt; ((counter 0)
        (found nil))
    (&lt;span style="color: #8b0000;"&gt;dolist&lt;/span&gt; (listelement list counter)
      (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; (string= item listelement)
        (&lt;span style="color: #8b0000;"&gt;progn&lt;/span&gt; 
          (setq found t)
          (&lt;span style="color: #8b0000;"&gt;return&lt;/span&gt; counter)) &lt;span style="color: #ff0000; font-weight: bold;"&gt;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;exit the loop&lt;/span&gt;
        &lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;else increment counter&lt;/span&gt;
        (incf counter)))
    &lt;span style="color: #ff0000; font-weight: bold;"&gt;;; &lt;/span&gt;&lt;span style="color: #ff0000; font-weight: bold;"&gt;if we found it return counter otherwise return nil&lt;/span&gt;
    (&lt;span style="color: #8b0000;"&gt;if&lt;/span&gt; found counter nil)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
index
&lt;/pre&gt;

&lt;p&gt;
Here are some example uses:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index &lt;span style="color: #228b22;"&gt;"test"&lt;/span&gt; '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"test"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"y"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index &lt;span style="color: #228b22;"&gt;"z"&lt;/span&gt; '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"b"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"z"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index &lt;span style="color: #228b22;"&gt;"testy"&lt;/span&gt; '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"test"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"y"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
nil
&lt;/pre&gt;

&lt;p&gt;
This raises an error because we use string=.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre class="src src-emacs-lisp"&gt;(index 1 '(&lt;span style="color: #228b22;"&gt;"a"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"test"&lt;/span&gt; &lt;span style="color: #228b22;"&gt;"y"&lt;/span&gt; 1))
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2013 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;&lt;p&gt;&lt;a href="/org/2013/03/05/An-index-function-for-strings-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
