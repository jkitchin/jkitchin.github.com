

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Finding-similar-bibtex-entries"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/09/16/Finding-similar-bibtex-entries/" rel="bookmark" title="Permanent Link to Finding similar bibtex entries">Finding similar bibtex entries</a></h2>
      <p><small><span class="blog_post_date">Posted September 16, 2017 at 10:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bibtex/'>bibtex</a>, <a href='/blog/category/similarity/'>similarity</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
A common task while writing scientific papers is citing previous research. I use org-ref extensively for that, and it makes it pretty easy to find similar references, e.g. that have common authors, or common keywords. It also lets me find similar articles in Web of Science or Scopus. Suppose that I have cited a particular paper, e.g. e <a class='org-ref-reference' href="#boes-2016-neural-networ">boes-2016-neural-networ</a>, and I want to find similar references to it that are <i>already</i> in my bibtex file, and similar by <i>my definition</i>. With org-ref I can easily search by keyword or author to find similar entries, but these are limited by what I search for, and they are not sorted. Today, I will explore the first step in a recommender system that calculates similarity, and provides a sorted list of candidates with the most relevant ones first.
</p>

<p>
The idea is to calculate some measure of similarity between the title of that reference, and the titles of other references in my bibtex file, and then sort them by similarity. This is the reference I want to find similar entries for:
</p>

<p>
Boes, J. R., Groenenboom, M. C., Keith, J. A., &amp; Kitchin, J. R., Neural network and Reaxff comparison for Au properties, Int. J. Quantum Chem., 116(13), 979–987 (2016).  <a href="https://doi.org/10.1002/qua.25115">https://doi.org/10.1002/qua.25115</a>
</p>

<p>
The first thing we do is read in our bibtex file, and print a representative entry.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> bibtexparser
<span style="color: #0000FF;">from</span> bibtexparser.bparser <span style="color: #0000FF;">import</span> BibTexParser

<span style="color: #0000FF;">with</span> <span style="color: #006FE0;">open</span>(<span style="color: #008000;">'/Users/jkitchin/Dropbox/bibliography/references.bib'</span>) <span style="color: #0000FF;">as</span> bibtex_file:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">parser</span> = BibTexParser()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">bib_database</span> = bibtexparser.load(bibtex_file, parser=parser)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">entries</span> = bib_database.entries

<span style="color: #0000FF;">print</span>(entries[10])
</pre>
</div>

<p>
{'author': 'Jaan Aarik and Aleks Aidla and V{\\"a}ino Sammelselg and Teet\nUustare', 'title': 'Effect of Growth Conditions on Formation of \\ce{TiO_2}-{II}\nThin Films in Atomic Layer Deposition Process', 'journal': 'Journal of Crystal Growth', 'volume': '181', 'number': '3', 'pages': '259 - 264', 'year': '1997', 'doi': '10.1016/S0022-0248(97)00279-0', 'link': 'http://www.sciencedirect.com/science/article/pii/S0022024897002790', 'issn': '0022-0248', 'ENTRYTYPE': 'article', 'ID': 'aarik-1997-effec-growt'}
</p>

<p>
Each entry is a dictionary containing the fields and their values. For this exploration, I will only consider similarities between titles. The next step is we find which entry corresponds to the reference we want to find similarities to.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">ids</span> = [e[<span style="color: #008000;">'ID'</span>] <span style="color: #0000FF;">for</span> e <span style="color: #0000FF;">in</span> entries]
<span style="color: #BA36A5;">i</span> = ids.index(<span style="color: #008000;">'boes-2016-neural-networ'</span>)
<span style="color: #0000FF;">print</span>(entries[i])
</pre>
</div>

<p>
{'author': 'Jacob R. Boes and Mitchell C. Groenenboom and John A. Keith\nand John R. Kitchin', 'title': 'Neural Network and {Reaxff} Comparison for {Au} Properties', 'journal': 'Int. J. Quantum Chem.', 'volume': '116', 'number': '13', 'pages': '979-987', 'year': '2016', 'doi': '10.1002/qua.25115', 'link': 'https://doi.org/10.1002/qua.25115', 'issn': '1097-461X', 'keyword': 'Kohn-Sham density functional theory, neural networks, reactive\nforce fields, potential energy surfaces, machine learning', 'ENTRYTYPE': 'article', 'ID': 'boes-2016-neural-networ'}
</p>

<p>
It is best if we make the entry we want to find similarities to the first one, so here we swap the first and i<sup>th</sup> entries.
</p>

<div class="org-src-container">
<pre class="src src-ipython">entries[0], <span style="color: #BA36A5;">entries</span>[i] = entries[i], entries[0]
</pre>
</div>

<p>
Now, we prepare the list of strings to get similarities for.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #BA36A5;">titles</span> = [e.get(<span style="color: #008000;">'title'</span>, <span style="color: #008000;">''</span>) <span style="color: #0000FF;">for</span> e <span style="color: #0000FF;">in</span> entries]
</pre>
</div>


<p>
We will use <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">term frequency–inverse document frequency</a> to get a vector that represents each title, and then use <a href="https://en.wikipedia.org/wiki/Cosine_similarity">cosine similarity</a> as a measure of similarity. Here is the place to note that <i>I chose</i> these, and could choose other ones too. Also, it is worth noting that in this measure of similarity I did <i>not</i> choose which keywords to measure similarity on.
</p>

<p>
The functionality for this is provided by <a href="http://scikit-learn.org/stable/">sklearn</a>. It has implemented functions for the algorithms above, and in just a few lines of code you get an array of tf-idf features to analyze. The array we get from our vectorizer contains normalized vectors, so we can get the cosine similarity just from a dot product of the vectors. The first row corresponds to the similarity of the first string to all the others. I want them sorted in descending order. The argsort function returns ascending order, so we use a trick to sort the negative of the similarity score which achieves that. There are certainly more advanced treatments of the text we could use by <a href="http://scikit-learn.org/stable/modules/feature_extraction.html#customizing-the-vectorizer-classes">customizing the vectorizer</a>, e.g. word stemming, but for now we neglect that.
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">from</span> sklearn.feature_extraction.text <span style="color: #0000FF;">import</span> TfidfVectorizer

<span style="color: #BA36A5;">vectorizer</span> = TfidfVectorizer(stop_words=<span style="color: #008000;">'english'</span>)
<span style="color: #BA36A5;">X</span> = vectorizer.fit_transform(titles)

<span style="color: #BA36A5;">cosine_similarities</span> = (X * X.T).A[0]

<span style="color: #BA36A5;">related_docs_indices</span> = (-cosine_similarities).argsort()

<span style="color: #0000FF;">print</span>(<span style="color: #008000;">'The top 10 recommendations for {} are:\n'</span>.<span style="color: #006FE0;">format</span>(S[0]))
<span style="color: #0000FF;">for</span> i, j <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">enumerate</span>(related_docs_indices[1:11]):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'{i}. {ID}: {title}, {author}\n'</span>.<span style="color: #006FE0;">format</span>(i=i + 1, **entries[j]))
</pre>
</div>

<p>
The top 10 recommendations for Neural Network and {Reaxff} Comparison for {Au} Properties are:
</p>

<ol class="org-ol">
<li>behler-2010-neural: Neural network potential-energy surfaces for atomistic</li>
</ol>
<p>
simulations, J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>boes-2017-neural-networ: Neural Network Predictions of Oxygen Interactions on a Dynamic</li>
</ol>
<p>
{Pd} Surface, Jacob R. Boes and John R. Kitchin
</p>

<ol class="org-ol">
<li>eshet-2010-ab: Ab Initio Quality Neural-Network Potential for Sodium, Hagai Eshet and Rustam Z. Khaliullin and Thomas D. K{\"u}hne</li>
</ol>
<p>
and J{\"o}rg Behler and Michele Parrinello
</p>

<ol class="org-ol">
<li>behler-2014-repres-poten: Representing Potential Energy Surfaces By High-Dimensional</li>
</ol>
<p>
Neural Network Potentials, J Behler
</p>

<ol class="org-ol">
<li>behler-2007-gener-neural: Generalized Neural-Network Representation of High-Dimensional</li>
</ol>
<p>
Potential-Energy Surfaces, J{\"o}rg Behler and Michele Parrinello
</p>

<ol class="org-ol">
<li>artrith-2012-high: High-Dimensional Neural Network Potentials for Metal Surfaces:</li>
</ol>
<p>
A Prototype Study for Copper, Nongnuch Artrith and J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>behler-2015-const: Constructing High-Dimensional Neural Network Potentials: A</li>
</ol>
<p>
Tutorial Review, J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>artrith-2011-high: High-Dimensional Neural-Network Potentials for Multicomponent</li>
</ol>
<p>
Systems: Applications To Zinc Oxide, Nongnuch Artrith and Tobias Morawietz and J{\"o}rg Behler
</p>

<ol class="org-ol">
<li>sosso-2012-neural-gete: Neural Network Interatomic Potential for the Phase Change</li>
</ol>
<p>
Material \ce{GeTe}, Gabriele C. Sosso and Giacomo Miceli and Sebastiano Caravati
and J{\"o}rg Behler and Marco Bernasconi
</p>

<ol class="org-ol">
<li>lorenz-2006-descr: Descriptions of Surface Chemical Reactions Using a Neural</li>
</ol>
<p>
Network Representation of the Potential-Energy Surface, S{\"o}nke Lorenz and Matthias Scheffler and Axel Gross
</p>

<p>
It is evident that this is showing other references containing the words "neural network"! I guess that is a little disappointing, since these would just as easily been narrowed down in org-ref. On the other hand, they are sorted and grouped, which would not happen in org-ref. This is a comparison of pretty short strings (just the titles), so maybe this would be much more interesting if abstracts were also included. Including authors would give a different set as well (I tried it, and got a bunch of my own references!).
</p>

<p>
I don't think it would be very difficult to get this into an Emacs selection tool, e.g. helm/ivy. Check this out:
</p>

<div class="org-src-container">
<pre class="src src-ipython"><span style="color: #0000FF;">import</span> pycse.lisp

related_docs_indices[1:6].lisp
</pre>
</div>

<p>

</p>

<p>
'(1592 1650 299 1751 103)'
</p>


<p>
That is a result that can be read directly by lisp, so we could simply write the code above as a shell script that takes an argument, and returns a list of indices to sort the candidates on. The alternative is to implement this in elisp, perhaps via a dynamic module if there is already a good C library for this. My sense is the Python libraries are more advanced in functionality.
</p>

<p>
This could have a number of other applications. Given some reference content, you could imagine finding emails that are similar to it, finding RSS entries that are similar to it, finding org headlines that are related, similar files, or similarity with any other set of strings that can be gathered, e.g. from Crossref or some other search, etc. I predict there will be more on these topics in the future!
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/09/16/Finding-similar-bibtex-entries.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/09/16/Finding-similar-bibtex-entries">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-in-Journal-of-Physics-Condensed-Matter"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter/" rel="bookmark" title="Permanent Link to New publication in Journal of Physics Condensed Matter">New publication in Journal of Physics Condensed Matter</a></h2>
      <p><small><span class="blog_post_date">Posted August 06, 2017 at 11:04 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/publication/'>publication</a>, <a href='/blog/category/news/'>news</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated August 06, 2017 at 11:05 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The Atomic Simulation Environment is a powerful python library for setting up, running and analyzing molecular simulations. I have been using it and contributing to it since around 2002 when I used the ASE-2 version in Python 1.5! The new ase-3 version is much simpler to use, and much more powerful. This paper describes some of its design principles and capabilities. If you use ASE, please cite this paper! 
</p>

<div class="org-src-container">
<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">larsen-2017-atomic-simul</span>,
  <span style="color: #BA36A5;">author</span> =       {Ask Hjorth Larsen and Jens J{\o}rgen Mortensen and Jakob
                  Blomqvist and Ivano E Castelli and Rune Christensen and
                  Marcin Du&#322;ak and Jesper Friis and Michael N Groves and
                  Bj{\o}rk Hammer and Cory Hargus and Eric D Hermes and Paul C
                  Jennings and Peter Bjerre Jensen and James Kermode and John
                  R Kitchin and Esben Leonhard Kolsbjerg and Joseph Kubal and
                  Kristen Kaasbjerg and Steen Lysgaard and J{\'o}n Bergmann
                  Maronsson and Tristan Maxson and Thomas Olsen and Lars
                  Pastewka and Andrew Peterson and Carsten Rostgaard and Jakob
                  Schi{\o}tz and Ole Sch{\"u}tt and Mikkel Strange and Kristian
                  S Thygesen and Tejs Vegge and Lasse Vilhelmsen and Michael
                  Walter and Zhenhua Zeng and Karsten W Jacobsen},
  <span style="color: #BA36A5;">title</span> =        {The Atomic Simulation Environment-A Python Library for Working
                  With Atoms},
  <span style="color: #BA36A5;">journal</span> =      {Journal of Physics: Condensed Matter},
  <span style="color: #BA36A5;">volume</span> =       29,
  <span style="color: #BA36A5;">number</span> =       27,
  <span style="color: #BA36A5;">pages</span> =        273002,
  <span style="color: #BA36A5;">year</span> =         2017,
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;">http://stacks.iop.org/0953-8984/29/i=27/a=273002</span>},
  <span style="color: #BA36A5;">abstract</span> =     {The atomic simulation environment (ASE) is a software package
                  written in the Python programming language with the aim of
                  setting up, steering, and analyzing atomistic simulations. In
                  ASE, tasks are fully scripted in Python. The powerful syntax
                  of Python combined with the NumPy array library make it
                  possible to perform very complex simulation tasks. For
                  example, a sequence of calculations may be performed with the
                  use of a simple 'for-loop' construction. Calculations of
                  energy, forces, stresses and other quantities are performed
                  through interfaces to many external electronic structure codes
                  or force fields using a uniform interface. On top of this
                  calculator interface, ASE provides modules for performing many
                  standard simulation tasks such as structure optimization,
                  molecular dynamics, handling of constraints and performing
                  nudged elastic band calculations.},
}

</pre>
</div>

<p>
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1088/1361-648X/aa680e'></div> 
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/08/06/New-publication-in-Journal-of-Physics-Condensed-Matter">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-in-Crystal-Growth-Design"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/08/05/New-publication-in-Crystal-Growth-Design/" rel="bookmark" title="Permanent Link to New publication in Crystal Growth & Design">New publication in Crystal Growth & Design</a></h2>
      <p><small><span class="blog_post_date">Posted August 05, 2017 at 01:11 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/publication/'>publication</a>, <a href='/blog/category/news/'>news</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated August 05, 2017 at 01:16 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Usually, metal oxides grow in a single, most stable crystal structure at a particular set of conditions. For example, TiO<sub>2</sub> grows in the rutile structure for a large range of pressure and temperature conditions, but under some conditions it can also grow in the anatase structure. In this paper we show that epitaxial stabilization can be used to influence which crystal structures are observed for the growth of tin oxide. Tin oxide is normally only observed in the rutile structure. We grew tin oxide as an epitaxial film on a poly-crystalline substrate of CoNb<sub>2</sub>O<sub>6</sub> which has an &alpha;-PbO<sub>2</sub> crystal structure. We found that both rutile and &alpha;-PbO<sub>2</sub> structures could be found in the film, and that the structure correlated with the orientation of the underlying grains. In other words, the orientation of a substrate can influence the structure of an epitaxial film, enabling one to grow films in crystal structures that may be metastable, and unobtainable in bulk samples.
</p>

<div class="org-src-container">
<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">wittkamper-2017-compet-growt</span>,
  <span style="color: #BA36A5;">author</span> =       {Wittkamper, Julia and Xu, Zhongnan and Kombaiah, Boopathy and
                  Ram, Farangis and De Graef, Marc and Kitchin, John R. and
                  Rohrer, Gregory S. and Salvador, Paul A.},
  <span style="color: #BA36A5;">title</span> =        {Competitive Growth of Scrutinyite (<span style="color: #008000;">$\alpha$</span>-PbO2) and Rutile
                  Polymorphs of \ce{SnO2} on All Orientations of Columbite
                  \ce{CoNb2O6} Substrates},
  <span style="color: #BA36A5;">journal</span> =      {Crystal Growth \&amp; Design},
  <span style="color: #BA36A5;">volume</span> =       17,
  <span style="color: #BA36A5;">number</span> =       7,
  <span style="color: #BA36A5;">pages</span> =        {3929-3939},
  <span style="color: #BA36A5;">year</span> =         2017,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1021/acs.cgd.7b00569</span>},
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;">https://doi.org/10.1021/acs.cgd.7b00569</span>},
  <span style="color: #BA36A5;">eprint</span> =       { https://doi.org/10.1021/acs.cgd.7b00569 },
}

</pre>
</div>

<p>
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/acs.cgd.7b00569'></div>
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/08/05/New-publication-in-Crystal-Growth-&-Design.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/08/05/New-publication-in-Crystal-Growth-Design">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Overloading-mathematical-operators-in-elisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/23/Overloading-mathematical-operators-in-elisp/" rel="bookmark" title="Permanent Link to Overloading mathematical operators in elisp">Overloading mathematical operators in elisp</a></h2>
      <p><small><span class="blog_post_date">Posted July 23, 2017 at 02:13 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/elisp/'>elisp</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated July 23, 2017 at 04:03 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgccfe3c4">1. Addendum</a></li>
</ul>
</div>
</div>
<p>
In Python I am used to some simple idioms like this:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">print</span>([1, 2, 3] * 2)
<span style="color: #0000FF;">print</span>(<span style="color: #008000;">"ab"</span> * 3)
</pre>
</div>

<p>
[1, 2, 3, 1, 2, 3]
ababab
</p>

<p>
There is even such fanciness as defining operators for objects, as long as they have the appropriate dunder methods defined:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #0000FF;">class</span> <span style="color: #6434A3;">Point</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__init__</span>(<span style="color: #0000FF;">self</span>, x, y):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.x = x
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">self</span>.y = y

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__str__</span>(<span style="color: #0000FF;">self</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">"Point ({}, {})"</span>.<span style="color: #006FE0;">format</span>(<span style="color: #0000FF;">self</span>.x, <span style="color: #0000FF;">self</span>.y)

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__mul__</span>(<span style="color: #0000FF;">self</span>, a):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> Point(<span style="color: #0000FF;">self</span>.x * a, <span style="color: #0000FF;">self</span>.y * a)

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">__rmul__</span>(<span style="color: #0000FF;">self</span>, a):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> Point(<span style="color: #0000FF;">self</span>.x * a, <span style="color: #0000FF;">self</span>.y * a)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   
<span style="color: #BA36A5;">p</span> = Point(1, 1)
<span style="color: #0000FF;">print</span>(p * 2)
<span style="color: #0000FF;">print</span>(3 * p)
</pre>
</div>

<p>
Point (2, 2)
Point (3, 3)
</p>

<p>
Out of the box, these things are not possible in elisp. Operators like  * in elisp only take numbers or markers. We have a few options to change this. The worst option is to simply redefine these functions. That is bad because it is not reversible. We could define new functions that have the behavior we want, but then we lose the semantic meaning of "*" that we were aiming for. A better option is to <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Advising-Functions.html">advise</a> these functions. This is reversible, because you can later unadvise them. Today we look at some strategies to do this.
</p>

<p>
We will use "around" advise because it will let us bypass the original intent of the function when we want to, or use it when we do. First, we create a function that will be the advice and add it to the * function. This first draft won't actually change the behavior of *; if all the args are numbers or markers it will simply use the original function as before.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">dash</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"if every arg is a number do *, else do something else."</span>
  (<span style="color: #0000FF;">cond</span>
   ((-every? (<span style="color: #0000FF;">lambda</span> (x) (<span style="color: #0000FF;">or</span> (numberp x) (markerp x))) args)
    (apply orig-fun args))))

(advice-add '* <span style="color: #006FE0;">:around</span> #'*--*-around)
</pre>
</div>

<p>
Let's just confirm
</p>
<div class="org-src-container">
<pre class="src src-emacs-lisp">(* 1 2 3)
</pre>
</div>

<pre class="example">
6

</pre>

<p>
Now, we can start modifying our function to handle some other cases. Let's do the list and string first. The * function is variadic, but in these cases it makes sense to limit to two arguments. We need two cases for each type since we can write (* 2 list) or (* list 2). We also should create a fall-through case that raises an error to alert us we can't multiply things.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"if every arg is a number do *, else do something else."</span>
  (<span style="color: #0000FF;">cond</span>
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">The original behavior</span>
   ((-every? (<span style="color: #0000FF;">lambda</span> (x) (<span style="color: #0000FF;">or</span> (numberp x) (markerp x))) args)
    (apply orig-fun args))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">create repeated copies of list</span>
   ((<span style="color: #0000FF;">and</span> (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) append (copy-list (first args))))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) append (copy-list (second args))))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Make repeated string</span>
   ((<span style="color: #0000FF;">and</span> (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) concat (first args)))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) concat (second args)))

   (t
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"You cannot * %s"</span> args))))
</pre>
</div>

<pre class="example">
*--*-around

</pre>

<p>
Here is the new advice in action. 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(list
 (* '(a b) 2)
 (* 2 '(c d))
 (* 2 <span style="color: #008000;">"ab"</span>)
 (* <span style="color: #008000;">"cd"</span> 2))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(a b a b)</td>
<td class="org-left">(c d c d)</td>
<td class="org-left">abab</td>
<td class="org-left">cdcd</td>
</tr>
</tbody>
</table>

<p>
That captures the spirit of overloading * for lists and strings. What about that object example? We have to make some assumptions here. Python looks for an uses a dunder <span class="underline"><span class="underline">mul</span></span> method. We will assume a double dash method (&#x2013;mul&#x2013;) in a similar spirit. We have to modify the advice one final time. We just add a condition to check if one of the arguments is an eieio-object, and then call the &#x2013;mul&#x2013; function on the arguments.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"if every arg is a number do *, else do something else."</span>
  (<span style="color: #0000FF;">cond</span>
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">The original behavior</span>
   ((-every? (<span style="color: #0000FF;">lambda</span> (x) (<span style="color: #0000FF;">or</span> (numberp x) (markerp x))) args)
    (apply orig-fun args))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">create repeated copies of list</span>
   ((<span style="color: #0000FF;">and</span> (listp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) append (copy-list (first args))))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (listp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) append (copy-list (second args))))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Make repeated string</span>
   ((<span style="color: #0000FF;">and</span> (stringp (first args))
         (integerp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (second args) concat (first args)))

   ((<span style="color: #0000FF;">and</span> (integerp (first args))
         (stringp (second args))
         (= 2 (length args)))
    (<span style="color: #0000FF;">loop</span> for i from 0 below (first args) concat (second args)))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Handle object</span>
   ((<span style="color: #0000FF;">or</span> (<span style="color: #0000FF;">and</span> (eieio-object-p (first args))
             (numberp (second args)))
        (<span style="color: #0000FF;">and</span> (numberp (first args))
             (eieio-object-p (second args))))
    (apply '--mul-- args))

   (t
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"You cannot * %s"</span> args))))
</pre>
</div>

<pre class="example">
*--*-around

</pre>

<p>
Now, we can define a class and the &#x2013;mul&#x2013; function and show that our overloaded * function works. Note we can define two signatures of &#x2013;mul&#x2013; so it is not necessary to define an &#x2013;rmul&#x2013; in this case as it was with Python (although we still create two functions in the end).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">eieio</span>)

(<span style="color: #0000FF;">defclass</span> <span style="color: #6434A3;">Point</span> ()
  ((x <span style="color: #006FE0;">:initarg</span> <span style="color: #006FE0;">:x</span>)
   (y <span style="color: #006FE0;">:initarg</span> <span style="color: #006FE0;">:y</span>)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">--mul--</span> ((p Point) a)
  (Point <span style="color: #006FE0;">:x</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:x</span>) a) <span style="color: #006FE0;">:y</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:y</span>) a)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">--mul--</span> (a (p Point))
  (Point <span style="color: #006FE0;">:x</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:x</span>) a) <span style="color: #006FE0;">:y</span> (* (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:y</span>) a)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">--str--</span> ((p Point))
  (format <span style="color: #008000;">"Point (%s, %s)"</span> (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:x</span>) (<span style="color: #0000FF;">oref</span> p <span style="color: #006FE0;">:y</span>)))

(<span style="color: #0000FF;">let</span> ((P (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Point (2, 2)</td>
<td class="org-left">Point (3, 3)</td>
</tr>
</tbody>
</table>

<p>
That is pretty awesome. Before going on, here is how you remove the advice:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(advice-remove '* '*--*-around)
</pre>
</div>

<p>
This example has been pretty instructive. You have to handle overloading for all the intrinsic types. We did lists and strings here; you might also consider vectors. For objects, it looks like we can at least try using a generic method like &#x2013;mul&#x2013;. One detail I neglected to consider here is that * is natively variadic. For these special cases, we did not implement variadic versions. This isn't a feature of Python which uses infix notation, so every call is with two arguments. In some cases it might make sense to support variadic args, but that seems like a generally challenging thing to do. While (* "a" 2 3) might be expected to create a string of "aaaaaa", (* "a" 2 '(3)) doesn't make sense at all.
</p>

<p>
It would be straightforward to extend this to other operators like '+ to concatenate strings, lists and vectors, or '- to remove chars or elements, including extensions to objects using double-dash functions like &#x2013;add&#x2013;, &#x2013;subtract&#x2013;, etc. Another nice idea might be to advise print to use &#x2013;str&#x2013; on objects.
</p>

<p>
On the surface this looks useful so far. Python defines <i>a lot</i> of dunder methods that cover all kinds of scenarios including logical comparisons, bit shifting, mod, incrementing operators, casting, comparisons, right/left operations, indexing and assignment, length and others. That would be a lot of advices. This approach is moderately tedious to expand though; you have to keep adding conditional cases. 
</p>

<p>
An alternative to the big conditional statement used in the advice might be the use of a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html">generic function</a>. With this approach we define a generic function that just does multiplication by default. Then we define specific cases with specific signatures that are used for lists, strings, objects, etc. That is basically all our conditional above was doing, matching signatures and executing a chunk of code accordingly.
</p>

<p>
Here is our default case that does the original behavior. We still use advice to apply the function.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defgeneric</span> <span style="color: #006699;">generic-multiply</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  <span style="color: #036A07;">"Generic multiply for when no specific case exists."</span>
  (apply orig-fun args))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">*--*-around-generic</span> (orig-fun <span style="color: #6434A3;">&amp;rest</span> args)
  (apply 'generic-multiply orig-fun args))

(advice-add '* <span style="color: #006FE0;">:around</span> #'*--*-around-generic)
</pre>
</div>

<p>
That should just work as usual for regular multiplication.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(* 1 2 3 4)
</pre>
</div>

<pre class="example">
24

</pre>

<p>
Sure enough it does. Now, we can define a specific method for a string. We need a specialized method for each signature, e.g. pre and post multiplication.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (s string) (n integer))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n concat s))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (n integer) (s string))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n concat s))

(list
 (* <span style="color: #008000;">"Ac"</span> 2)
 (* 2 <span style="color: #008000;">"Ad"</span>))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">AcAc</td>
<td class="org-left">AdAd</td>
</tr>
</tbody>
</table>

<p>
That works fine, and we did not have to modify our original advice function at all! Next the  list:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (L list) (n integer))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n append (copy-list L)))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (n integer) (L list))
  (<span style="color: #0000FF;">loop</span> for i from 0 below n append (copy-list L)))

(list (* '(1 2) 2)
      (* 2 '(3 4)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>

<p>
That also works fine. Last, our class example. This should work on all objects I think (unless there is some way to make classes that do not inherit the default superclass).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (n integer) (obj eieio-default-superclass))
  (--mul-- n obj))

(<span style="color: #0000FF;">cl-defmethod</span> <span style="color: #006699;">generic-multiply</span> ((orig-fun subr) (obj eieio-default-superclass) (n integer))
  (--mul-- n obj))

(<span style="color: #0000FF;">let</span> ((P (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1)))
  (list
   (--str-- (* P 2))
   (--str-- (* 3 P))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Point (2, 2)</td>
<td class="org-left">Point (3, 3)</td>
</tr>
</tbody>
</table>

<p>
This is a much better approach to extending the multiplication operator! If I continue this path in the future I would probably take this one.  This could be useful to make elisp more like some more popular contemporary languages like Python, as well as to add linear algebra like notation or mathematical operations on objects in elisp. It kind of feels like these operations ought to be generic functions to start with to make this kind of overloading easier from the beginning.  Functions like "*" are currently defined in the C source code though, maybe for performance reasons. It is not obvious what the consequences of making them generic might be.
</p>

<div id="outline-container-orgccfe3c4" class="outline-2">
<h2 id="orgccfe3c4"><span class="section-number-2">1</span> Addendum</h2>
<div class="outline-text-2" id="text-1">
<p>
Christopher Wellons <a href="http://disq.us/p/1kr76r9">pointed out</a> an important limitation of advice: they don't work on byte-compiled functions. Let's see what he means. Here is a simple function that will just multiply a Point object by an integer:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">to-be-bytten</span> (p1 n)
  (* p1 n))
</pre>
</div>

<pre class="example">
to-be-bytten

</pre>

<p>
Here it is in action, and here it works fine.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(to-be-bytten (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1) 2)
</pre>
</div>

<pre class="example">
[eieio-class-tag--Point 2 2]

</pre>

<p>
Now, let's byte-compile that function and try it again:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(byte-compile 'to-be-bytten)

(<span style="color: #0000FF;">condition-case</span> err
    (to-be-bytten (Point <span style="color: #006FE0;">:x</span> 1 <span style="color: #006FE0;">:y</span> 1) 2)
  ((<span style="color: #ff0000; font-weight: bold;">error</span> r)
   (message <span style="color: #008000;">"Doh! Christopher was right. It did not work...\n%s"</span> err)))
</pre>
</div>

<pre class="example">
Doh! Christopher was right. It did not work...
(wrong-type-argument number-or-marker-p [eieio-class-tag--Point 1 1])

</pre>

<p>
So the advice is pretty limited since most of the functions in Emacs core are likely to be byte-compiled, and it might mean you have to redefine * completely, or define some new function that looks like it. Too bad, the advice was pretty easy! 
</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/23/Overloading-mathematical-operators-in-elisp.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/07/23/Overloading-mathematical-operators-in-elisp">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules/" rel="bookmark" title="Permanent Link to Linear algebra in Emacs using MKL and dynamic modules">Linear algebra in Emacs using MKL and dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 21, 2017 at 03:48 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a>, <a href='/blog/category/dynamic-module/'>dynamic-module</a></span> | tags: 
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgbfb8d4e">1. Convenience functions to get array properties</a></li>
<li><a href="#orga1c9a60">2. Matrix multiplication</a>
<ul>
<li><a href="#orgf536480">2.1. 1d * 1d</a></li>
<li><a href="#org76f193d">2.2. 2d * 1d</a></li>
<li><a href="#org82cc641">2.3. 1d * 2d</a></li>
<li><a href="#org0849c80">2.4. 2d * 2d</a></li>
</ul>
</li>
<li><a href="#org4a14b46">3. Summary thoughts</a></li>
<li><a href="#orgba66efb">4. The module code</a></li>
<li><a href="#org4be1bce">5. Elisp helper functions</a></li>
</ul>
</div>
</div>
<p>
In a <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules/">previous post</a> I integrated some linear algebra into Emacs using the GNU Scientific library and a dynamic module. In this post, I use a similar approach that uses the Intel MKL library in conjunction with some helper elisp functions to mimic the array broadcasting features in Numpy. I thought this might be easier and lead to at least a complementary set of functionalities.
</p>

<p>
Note: I had to follow the directions <a href="http://osxdaily.com/2015/10/05/disable-rootless-system-integrity-protection-mac-os-x">here</a> to disable some security feature on my Mac so that it would use the MKL libraries. Thanks Apple.
</p>

<p>
It is convenient to use vectors for the representation of arrays in Emacs because there are nice functions in the emacs-module.h for accessing vector properties. Also vectors sound closer to an array than a list. So what about array broadcasting, e.g. the way numpy lets you multiply a 2d array with a 1d array? If you multiply two arrays with size (m1, n1) * (m2, n2), it is required that the number of columns in the first array (n1) be equal to the number of rows in the second one (m2), and the resulting size of the array product will be (m1, n2). What should happen though when we have 1d array? This is neither a row or column vector itself, but we can treat as either one if we choose too. For example the vector [1 2 3] can be thought of as an array with the shape (1, 3), e.g. a single row with three columns, or (3, 1), i.e. three rows in a single column. We will build this capability into the module for convenience.
</p>

<p>
I still find it moderately tedious to write c functions that take emacs arguments, transform them to c arguments, do some c computations, and convert the results back to emacs values. So, we only implement one c function for this that multiplies two 2d arrays together using the cblas_dgemm routine in the MKL library. Then, we will create a complementary elisp library that will provide some additional functionality to get the shapes of vector arrays, dimensions, and allow us to multiply 1d and 2d vectors together the same way Numpy does array broadcasting.
</p>

<p>
The dynamic module code is listed in <a href="#orgba66efb">The module code</a>. The elisp code is listed in <a href="#org4be1bce">Elisp helper functions</a>.  In the following sections we just demonstrate how to use the results.
</p>

<div id="outline-container-orgbfb8d4e" class="outline-2">
<h2 id="orgbfb8d4e"><span class="section-number-2">1</span> Convenience functions to get array properties</h2>
<div class="outline-text-2" id="text-1">
<p>
I found it convenient to do array shape and dimension analysis in elisp before sending arrays to the dynamic module. The shape of an array is just the number of elements in each dimension. Here we look at a 2&times; 3 array.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(vector-shape [[1 2 3]
               [3 4 5]])
</pre>
</div>

<pre class="example">
[2 3]

</pre>

<p>
You see it returns a vector showing two rows and three columns. There are two convenience commands to get the number of rows (vector-nrows) and columns (vector-ncols). Here is one of them.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(vector-ncols [[1 2 3]
               [3 4 5]])
</pre>
</div>

<pre class="example">
3

</pre>
</div>
</div>


<div id="outline-container-orga1c9a60" class="outline-2">
<h2 id="orga1c9a60"><span class="section-number-2">2</span> Matrix multiplication</h2>
<div class="outline-text-2" id="text-2">
<p>
The main problem we want to calculate is the matrix multiplication \(A\cdotB\) where \(A\) and \(B\) are either 1d vectors or 2d arrays. Here we examine several representative cases of matrix multiplication.
</p>
</div>

<div id="outline-container-orgf536480" class="outline-3">
<h3 id="orgf536480"><span class="section-number-3">2.1</span> 1d * 1d</h3>
<div class="outline-text-3" id="text-2-1">
<p>
This is a simple dot-product that is actually calculated in elisp.
</p>

<p>
\([1 1 1] \cdot [2 2 2] = 6\)
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(matrix-multiply [1 1 1] [2 2 2])
</pre>
</div>

<pre class="example">
6.0

</pre>

<p>
✓
</p>

<p>
Note we get a float. That is because we initialize the sum with 0.0 to be consistent with all the other cases which are done with floats. dgemm is a double routine in MKL, which means it should return floats. Internally in the module, we cast all numbers as doubles for the multiplication.
</p>
</div>
</div>

<div id="outline-container-org76f193d" class="outline-3">
<h3 id="org76f193d"><span class="section-number-3">2.2</span> 2d * 1d</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This is a matrix multiplication that is typically like \(A b\) where \(b\) is a column vector. We return a 1d array as a result, rather than a 2d array of nrows and 1 column.
</p>

<p>
\[ \left[\begin{array}{cc}
1 & 2 \\
3 & 4 \end{array}\right] 
\left [ \begin{array}{c}
1 \\ 1 \end{array}\right] = \left[\begin{array}{c}3\\7\end{array}\right]\]
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[1 2]
          [3 4]])
      (b [1 1]))
  (matrix-multiply  A b))
</pre>
</div>

<pre class="example">
[3.0 7.0]

</pre>

<p>
✓
</p>
</div>
</div>

<div id="outline-container-org82cc641" class="outline-3">
<h3 id="org82cc641"><span class="section-number-3">2.3</span> 1d * 2d</h3>
<div class="outline-text-3" id="text-2-3">
<p>
This case is \(b A\) where \(b\) is a row vector. For example:
</p>

<p>
\[\left[\begin{array}{cc}1 & 1\end{array}\right]
\left[\begin{array}{cc} 1 & 2\\ 3 & 4\end{array}\right] = \left[\begin{array}{cc} 4 & 6 \end{array}\right ]\]
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(matrix-multiply [1 1]
                 [[1 2]
                  [3 4]])
</pre>
</div>

<pre class="example">
[4.0 6.0]

</pre>

<p>
✓
</p>

<p>
As with the previous case, we return a 1d vector result rather than a 2d array with 1 row and ncolumns.
</p>
</div>
</div>

<div id="outline-container-org0849c80" class="outline-3">
<h3 id="org0849c80"><span class="section-number-3">2.4</span> 2d * 2d</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Finally we have the case of \(A B\). The number of columns in A must be the same as the number of rows in B, and the result has a size that is the number of rows in A and the number of columns in B. Here is one <a href="http://www.sosmath.com/matrix/matrix1/matrix1.html">example</a>:
</p>

<p>
\[\left[\begin{array}{cc} 0 & 1\\ 0 & 0\end{array}\right]  
\left[\begin{array}{cc} 0 & 0\\ 1 & 0\end{array}\right]  
= \left[\begin{array}{cc} 1 & 0\\ 0 & 0\end{array}\right]  \]
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(matrix-multiply [[0 1]
                  [0 0]]
                 [[0 0]
                  [1 0]])
</pre>
</div>

<pre class="example">
[[1.0 0.0] [0.0 0.0]]

</pre>

<p>
✓
</p>

<p>
This example is adapted from <a href="https://stackoverflow.com/questions/21547462/how-to-multiply-2-dimensional-arrays-matrix-multiplication">here</a>. The correct answer is at the bottom of that page, and shown here.
</p>

<p>
\[\left[\begin{array}{cccc} 1 & 2 & -2 & 0 \\ -3 & 4 & 7 & 2 \\ 6 & 0 & 3 & 1\end{array}\right]  
\left[\begin{array}{cc} -1 & 3 \\ 0 & 9 \\ 1 & -11 \\ 4 & -5 \end{array}\right]
= \left[\begin{array}{cc} -3 & 43 \\ 18 & -60 \\ 4 & -5\end{array}\right]    \]
</p>

<p>
For readability we use temporary variables here, and pretty-print the result.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[1 2 -2 0]
          [-3 4 7 2]
          [6 0 3 1]])
      (B [[-1 3]
          [0  9]
          [1 -11]
          [4 -5]]))
  (pp (matrix-multiply A B)))
</pre>
</div>

<pre class="example">
[[-3.0 43.0]
 [18.0 -60.0]
 [1.0 -20.0]]

</pre>

<p>
✓
</p>

<p>
So, all these example work as we expect. The elisp function for matrix-multiply does a lot of work for you to make these cases work, including error checking for dimensional consistency.
</p>
</div>
</div>
</div>

<div id="outline-container-org4a14b46" class="outline-2">
<h2 id="org4a14b46"><span class="section-number-2">3</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-3">
<p>
It was not any easier to write this dynamic module than the previous one I used with the Gnu Scientific Library. The approach and code are remarkably similar. In one way the GSL was easier to use; it worked out of the box, whereas I had to fiddle with a security option in my OS to get it to run MKL! My  Anaconda Python distribution must get around that somehow since it ships with an MKL compiled Numpy and scipy.
</p>

<p>
The idea of using elisp for analysis of the inputs and making sure they are correct is a good one and helps prevent segfaults. Of course it is a good idea to write defensive c-code to avoid that too. Overall, this is another good example of expanding the capabilities of Emacs with a dynamic module.
</p>
</div>
</div>

<div id="outline-container-orgba66efb" class="outline-2">
<h2 id="orgba66efb"><a id="ID-45D04B39-1927-44ED-9402-E89D166AE8C8"></a><span class="section-number-2">4</span> The module code</h2>
<div class="outline-text-2" id="text-4">
<p>
The c-code is loosely adapted from <a href="https://software.intel.com/en-us/node/529735">https://software.intel.com/en-us/node/529735</a>. We do not implement the full dgemm behavior which is able to calculate \(C = \alpha A * B + \beta*C\). We set &alpha;=1, and &beta;=0 in this example. We should do some dimension checking here, but it is easier to do it in emacs in a helper function. As long as you use the helper function there should not be an issue, but it is possible to segfault Emacs if you use the module function incorrectly.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module-helpers.h"</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;mkl.h&gt;</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #6434A3;">emacs_value</span> <span style="color: #006699;">Fmkl_dgemm</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #6434A3;">ptrdiff_t</span> <span style="color: #BA36A5;">nargs</span>, <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[], <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">data</span>)
{
  <span style="color: #6434A3;">double</span> *<span style="color: #BA36A5;">A</span>, *<span style="color: #BA36A5;">B</span>, *<span style="color: #BA36A5;">C</span>;
  <span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">m</span>, <span style="color: #BA36A5;">n</span>, <span style="color: #BA36A5;">k</span>, <span style="color: #BA36A5;">i</span>, <span style="color: #BA36A5;">j</span>;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">alpha</span> = 1.0;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">beta</span> = 0.0;
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">These will be 2d vectors</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">M0</span> = args[0]; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">array 1 - A (m x k)</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">M1</span> = args[1]; <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">array 2 - B (k x n)</span>

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">I need to get the number of rows and columns of each one.</span>
  m = env-&gt;vec_size(env, M0);
  k  = 0;
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">We assume that we have a 2d array.</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">el1</span> = env-&gt;vec_get (env, M0, 0);
  k = env-&gt;vec_size(env, el1);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Now we know A has dimensions (m, k)</span>
 
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">el2</span> = env-&gt;vec_get (env, M1, 0);
  n = env-&gt;vec_size(env, el2);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Now we know M1 had dimensions (k, n)</span>
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Now we have to build up arrays.</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">We are looking at a * b = c</span>
  A = (<span style="color: #6434A3;">double</span> *)mkl_malloc( m*k*<span style="color: #0000FF;">sizeof</span>( <span style="color: #6434A3;">double</span> ), 64 );
  B = (<span style="color: #6434A3;">double</span> *)mkl_malloc( k*n*<span style="color: #0000FF;">sizeof</span>( <span style="color: #6434A3;">double</span> ), 64 );
  C = (<span style="color: #6434A3;">double</span> *)mkl_malloc( m*n*<span style="color: #0000FF;">sizeof</span>( <span style="color: #6434A3;">double</span> ), 64 );
  <span style="color: #0000FF;">if</span> (A == <span style="color: #D0372D;">NULL</span> || B == <span style="color: #D0372D;">NULL</span> || C == <span style="color: #D0372D;">NULL</span>) {
    printf( <span style="color: #008000;">"\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"</span>);
    mkl_free(A);
    mkl_free(B);
    mkl_free(C);
    <span style="color: #0000FF;">return</span> 1;
  }

  <span style="color: #8D8D84;">//</span><span style="color: #8D8D84; font-style: italic;">populate A</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">row</span>, <span style="color: #BA36A5;">ij</span>;
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; m; i++)
    {
      row = env-&gt;vec_get(env, M0, i);
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; k; j++)
        {
          <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">get M0[i, j]</span>
          ij = env-&gt;vec_get(env, row, j);
          A[k * i + j] = extract_double(env, ij);
        }
    }

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">populate B</span>
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; k; i++)
    {
      row = env-&gt;vec_get(env, M1, i);
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; n; j++)
        {         
          <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">get M0[i, j]</span>
          ij = env-&gt;vec_get(env, row, j);
          B[n * i + j] = extract_double(env, ij);
        }
    }

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">initialize C.  The solution will have dimensions of (rows1, cols2).</span>
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; m; i++)
    {
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; n; j++)
        {
          C[n * i + j] = 0.0;
        }
    }

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">the multiplication is done here.</span>
  cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, 
                m, n, k, alpha, A, k, B, n, beta, C, n);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">now we build up the vector to return</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">vector</span> = env-&gt;intern(env, <span style="color: #008000;">"vector"</span>);
  <span style="color: #6434A3;">emacs_value</span> *<span style="color: #BA36A5;">array</span> = malloc(<span style="color: #0000FF;">sizeof</span>(emacs_value) * m);
  <span style="color: #6434A3;">emacs_value</span> *<span style="color: #BA36A5;">row1</span>;
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">vec</span>;
  <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">i</span> = 0; i &lt; m; i++)
    {
      row1 = malloc(<span style="color: #0000FF;">sizeof</span>(emacs_value) * n);
      <span style="color: #0000FF;">for</span> (<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">j</span> = 0; j &lt; n; j++)
        {
          row1[j] = env-&gt;make_float(env, C[j + i * n]);
        }
      vec = env-&gt;funcall(env, vector, n, row1);
      array[i] = vec;
      free(row1);
    }

  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">result</span> = env-&gt;funcall(env, vector, m, array);
  free(array);
  <span style="color: #0000FF;">return</span> result;
}


<span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  DEFUN(<span style="color: #008000;">"mkl-dgemm"</span>, Fmkl_dgemm, 2, 2,
        <span style="color: #008000;">"(mkl-dgemm A B)\n"</span>\
        <span style="color: #008000;">"Multiply the matrices A and B. A and B must both be 2d vectors.\n"</span> \
        <span style="color: #008000;">"Returns the product as a vector."</span>,
        <span style="color: #D0372D;">NULL</span>);
  provide(env, <span style="color: #008000;">"mkl"</span>);
  
  <span style="color: #0000FF;">return</span> 0;
}

</pre>
</div>

<p>
To build this we have to run <a href="org-babel-tangle">org-babel-tangle</a> to generate the mkl.c file, and then run this shell block to compile it.
</p>

<div class="org-src-container">
<pre class="src src-sh">sh /opt/intel/mkl/bin/mklvars.sh intel64
gcc -Wall -m64 -I${<span style="color: #BA36A5;">MKLROOT</span>}/include -fPIC -c mkl.c
gcc -shared -L${<span style="color: #BA36A5;">MKLROOT</span>}/lib -Wl,-rpath,${<span style="color: #BA36A5;">MKLROOT</span>}/lib -lmkl_rt -lpthread -lm -ldl -L. -lemacs-module-helpers -o mkl.so mkl.o
</pre>
</div>
</div>
</div>


<div id="outline-container-org4be1bce" class="outline-2">
<h2 id="org4be1bce"><a id="ID-F5AEAF4E-317F-48D4-9815-8EB0331AF0E5"></a><span class="section-number-2">5</span> Elisp helper functions</h2>
<div class="outline-text-2" id="text-5">
<p>
We will often want to know the shape of our arrays. The shape is how many elements there are in each dimension. Here we define a recursive function that gets the shape of arbitrarily nested vectors and returns a vector of the shape. We define some helper functions to get the number of dimensions, elements, rows and columns.
</p>

<p>
The main function is a helper elisp function that multiplies two arrays. The function analyzes the shapes and transforms 1d vectors into the right 2d shape to multiply them together, and then returns the shape that makes sense. The c-code is not very robust to mistakes in the array dimensions. It tends to make emacs segfault if you get it wrong. So we try to avoid that if possible.
</p>

<p>
We have four cases to consider for multiplication:
</p>

<dl class="org-dl">
<dt>2d * 2d</dt><dd>(assert (= m1 n2)) return (n1, m2)</dd>
<dt>1d * 2d</dt><dd>1d is a row vector (1, n1) (assert (= n1 m2)) return vector with n2 elements</dd>
<dt>2d * 1d</dt><dd>1d is a column vector (m2, 1) (assert (= n1 m2)) return vector with m2 elements</dd>
<dt>1d * 1d</dt><dd>(assert (= (length m1) (length m2)) return a scalar</dd>
</dl>

<p>
Here is the 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">mkl</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">cl</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">seq</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-shape</span> (vec)
  <span style="color: #036A07;">"Return a vector of the shape of VEC."</span>
  (<span style="color: #0000FF;">let</span> ((shape (vector (length vec))))
    (<span style="color: #0000FF;">if</span> (vectorp (aref vec 0))
        (vconcat shape (vector-shape (aref vec 0)))
      shape)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-ndims</span> (vec)
  <span style="color: #036A07;">"Returns the number of dimensions in VEC."</span>
  (length (vector-shape vec)))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-numel</span> (vec)
  <span style="color: #036A07;">"Returns the number of elements in VEC."</span>
  (<span style="color: #0000FF;">if</span> (&gt; (length vec) 0)
      (seq-reduce '* (vector-shape vec) 1)
    0))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-nrows</span> (vec)
 <span style="color: #036A07;">"Return the number of rows in VEC."</span>
 (aref (vector-shape vec) 0))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">vector-ncols</span> (vec)
 <span style="color: #036A07;">"Return the number of columns in VEC."</span>
 (aref (vector-shape vec) 1))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">matrix-multiply</span> (A B)
  <span style="color: #036A07;">"Return A * B in the matrix multiply sense."</span>
  (<span style="color: #0000FF;">cond</span>
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">1d * 1d i.e. a dot-product</span>
   ((<span style="color: #0000FF;">and</span> (= 1 (vector-ndims A))
         (= 1 (vector-ndims B))
         (= (length A) (length B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">this is easy to compute so we don't use dgemm.</span>
    (seq-reduce '+ (mapcar* (<span style="color: #0000FF;">lambda</span> (a b) (* a b)) A B) 0.0))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">2d * 1d (m1, n1) * (n2, 1)</span>
   ((<span style="color: #0000FF;">and</span> (= 2 (vector-ndims A))
         (= 1 (vector-ndims B))
         <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">ncols-A = len-B</span>
         (= (vector-ncols A) (length B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">transform B into a 2d column vector</span>
    (<span style="color: #0000FF;">let*</span> ((B2d (apply 'vector (mapcar 'vector B)))
           (result  (mkl-dgemm A B2d)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Now call (dgemm A B2d) -&gt; (m2, 1) column vector</span>
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">and convert it back to a 1d result</span>
      (cl-map 'vector (<span style="color: #0000FF;">lambda</span> (v) (aref v 0)) result)))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">1d * 2d (1, n1) * (m2, n2) len-A = nrows-B</span>
   ((<span style="color: #0000FF;">and</span> (= 1 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (length A) (vector-nrows B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">transform B into a 2d row vector</span>
    (<span style="color: #0000FF;">let*</span> ((A2d (vector A))
           (result  (mkl-dgemm A2d B)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">should be a 2d row vector</span>
      (aref result 0)))

   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">2d * 2d (m1, n1) * (m2, n2) rows-A = ncols-B</span>
   ((<span style="color: #0000FF;">and</span> (= 2 (vector-ndims A))
         (= 2 (vector-ndims B))
         (= (vector-ncols A)
            (vector-nrows B)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">call (dgemm A B) and return result</span>
    (mkl-dgemm A B))
   (t
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Error checking, getting here means none of the cases above were caught.</span>
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">something is probably wrong.</span>
    (<span style="color: #0000FF;">cond</span>
     ((<span style="color: #0000FF;">or</span> (&gt; (vector-ndims A) 2)
          (&gt; (vector-ndims B) 2))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"One of your arrays has more than 2 dimensions. Only 1 or 2d arrays are supported"</span>))
     ((<span style="color: #0000FF;">and</span> (= 1 (vector-ndims A))
           (= 1 (vector-ndims B))
           (not (= (length A) (length B))))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"A and B must be the same length.</span>
<span style="color: #008000;">len(A) = %d</span>
<span style="color: #008000;">len(B) = %d"</span> (length A) (length B)))
     ((<span style="color: #0000FF;">and</span>
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 2)
       (not (= (vector-nrows A) (vector-ncols B))))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Your array shapes are not correct.</span>
<span style="color: #008000;">The number of rows in array A must equal the number of columns in array B.</span>
<span style="color: #008000;">There are %d rows in A and %d columns in B"</span> (vector-nrows A) (vector-ncols B)))
     ((<span style="color: #0000FF;">and</span>
       (= (vector-ndims A) 2)
       (= (vector-ndims B) 1)
       (not (= (vector-nrows A) (length B))))
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Your array shapes are not correct.</span>
<span style="color: #008000;">The number of rows in array A must equal the number of columns in array B.</span>
<span style="color: #008000;">There are %d rows in A and %d columns in B"</span> (vector-nrows A) (length B)))
     (t
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Unknown error"</span>))))))
</pre>
</div>

<pre class="example">
matrix-multiply

</pre>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2017/07/21/Linear-algebra-in-Emacs-using-MKL-and-dynamic-modules">Discuss on Twitter</a>

  <hr class="interblog" />
 <a href="../9">« Previous Page</a>
  --  
 <a href="../11">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2021/06/21/New-publication-Machine-learning-accelerated-geometry-optimization-in-molecular-simulation/">New publication "Machine-learning accelerated geometry optimization in molecular simulation"</a></li>
      <li><a href="/blog/2021/03/07/New-publication-Semi-grand-Canonical-Monte-Carlo-Simulation-of-the-Acrolein-induced-Surface-Segregation-and-Aggregation-of-AgPd-with-Machine-Learning-Surrogate-Models/">New publication - Semi-grand Canonical Monte Carlo Simulation of the Acrolein induced Surface Segregation and Aggregation of AgPd with Machine Learning Surrogate Models</a></li>
      <li><a href="/blog/2020/07/09/New-publication-SingleNN-Modified-Behler-Parrinello-Neural-Network-with-Shared-Weights-for-Atomistic-Simulations-with-Transferability/">New publication SingleNN - Modified Behler–Parrinello Neural Network with Shared Weights for Atomistic Simulations with Transferability</a></li>
      <li><a href="/blog/2020/03/10/New-publication-Parallelized-Screening-of-Characterized-and-DFT-Modelled-Bimetallic-Colloidal-Co-Catalysts-for-Photocatalytic-Hydrogen-Evolution/">New publication - Parallelized Screening of Characterized and DFT-Modelled Bimetallic Colloidal Co-Catalysts for Photocatalytic Hydrogen Evolution</a></li>
      <li><a href="/blog/2019/10/02/Using-autograd-to-plot-implicit-functions/">Using autograd to plot implicit functions</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2021
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



