

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Multiple-search-criteria-to-find-bibtex-entries"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries/" rel="bookmark" title="Permanent Link to Multiple search criteria to find bibtex entries">Multiple search criteria to find bibtex entries</a></h2>
      <p><small><span class="blog_post_date">Posted April 08, 2014 at 08:45 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bibtex/'>bibtex</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
I have been thinking about ways to search my bibtex file with multiple criteria. Eventually, I want a decent natural language search like "au=kitchin and alloy" to find papers authored by me about alloys. For now, I am going to settle with a way to find these. This strategy will create a search function that prints the entries that are found. Here is the prototype idea:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">my-search</span> (key start end)
  (<span style="color: #8b0000;">when</span> (and (re-search-forward <span style="color: #228b22;">"kitchin"</span> end t)
           (re-search-forward <span style="color: #228b22;">"alloy"</span> end t))
      (princ (format <span style="color: #228b22;">"%s\n"</span> (buffer-substring start end)))))

(<span style="color: #8b0000;">with-temp-buffer</span>
  (insert-file-contents <span style="color: #228b22;">"../../bibliography/references.bib"</span>)
  (bibtex-map-entries  'my-search))
</pre>
</div>

<pre class="example">
@ARTICLE{inoglu-2011-ident-sulfur,
  pdf =		 {[[file:bibtex-pdfs/inoglu-2011-ident-sulfur.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::inoglu-2011-ident-sulfur]]},
  author =	 {Inoglu, Nilay and Kitchin, John R.},
  title =	 {Identification of Sulfur-Tolerant Bimetallic
                  Surfaces Using {DFT} Parametrized Models and
                  Atomistic Thermodynamics},
  journal =	 {ACS Catalysis},
  year =	 2011,
  pages =	 {399--407},
  abstract =	 {The identification of sulfur-tolerant alloys for
                  catalytic applications is difficult due to the
                  combinatorially large number of alloy compositions
                  and surface structures that may be
                  considered. Density functional theory calculations
                  (DFT) are not fast enough to enumerate all the
                  possible structures and their sulfur tolerance. In
                  this work, a DFT parametrized algebraic model that
                  accounts for structure and composition was used to
                  estimate the d-band properties and sulfur adsorption
                  energies of 370 transition metal-based bimetallic
                  alloy surfaces.  The estimated properties were
                  validated by DFT calculations for 110 of the surface
                  structures. We then utilized an atomistic
                  thermodynamic framework that includes surface
                  segregation, the presence of adsorbates, and effects
                  of environmental conditions to identify alloy
                  compositions and structures with enhanced sulfur
                  tolerance that are likely to be stable under the
                  environmental conditions. As a case study, we show
                  how this database can be used to identify
                  sulfur-tolerant Cu-based catalysts and compare the
                  results with what is known about these catalysts
                  experimentally.},
  doi =		 {10.1021/cs200039t},
  issn =	 {null},
  type =	 {Journal Article}
}
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {https://doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
@ARTICLE{tierney-2009-hydrog-dissoc,
  pdf =		 {[[file:bibtex-pdfs/tierney-2009-hydrog-dissoc.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::tierney-2009-hydrog-dissoc]]},
  author =	 {Tierney, H. L. and Baber, A. E. and Kitchin,
                  J. R. and Sykes, E.  C. H.},
  title =	 {Hydrogen Dissociation and Spillover on Individual
                  Isolated Palladium Atoms},
  journal =	 {Physical Review Letters},
  year =	 2009,
  volume =	 103,
  number =	 24,
  abstract =	 {Using a combination of low-temperature scanning
                  tunneling microscopy and density functional theory
                  it is demonstrated how the nature of an inert host
                  metal of an alloy can affect the thermodynamics and
                  kinetics of a reaction pathway in a much more
                  profound way than simply a dilution, electronic, or
                  geometric effect. This study reveals that
                  individual, isolated Pd atoms can promote H-2
                  dissociation and spillover onto a Cu(111) surface,
                  but that the same mechanism is not observed for an
                  identical array of Pd atoms in Au(111).},
  pages =	 246102,
  doi =		 {10.1103/PhysRevLett.103.246102},
  issn =	 {0031-9007},
  url =		 {http://prl.aps.org/abstract/PRL/v103/i24/e246102},
  type =	 {Journal Article}
}
</pre>

<p>
That is not too bad. If I had a parser like <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags/">this one</a> , I could do some reasonable searches. I could try integrating it with reftex or something similar for selecting citations. I would like that a lot.
</p>

<p>
What if I wanted to find articles with Kitchin as an author, and alloy in the title? This is my best effort at doing that, where I explicitly match the fields in the bibtex entries.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(find-file <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
(bibtex-map-entries (<span style="color: #8b0000;">lambda</span> (bibtex-key start end)
                      (<span style="color: #8b0000;">let*</span> ((entry (bibtex-parse-entry))
                             (title (cdr (assoc <span style="color: #228b22;">"title"</span> entry)))
                             (authors (cdr (assoc <span style="color: #228b22;">"author"</span> entry))))
                        (<span style="color: #8b0000;">when</span> (and title (string-match <span style="color: #228b22;">"alloy"</span> title)
                                   authors (string-match <span style="color: #228b22;">"kitchin"</span> authors))
                          (princ (buffer-substring start end)))))))
</pre>
</div>

<pre class="example">
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {https://doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
</pre>

<p>
This is a more precise search, which yields only one entry. That is not exactly nimble searching, but it does provide precision. I need to think about this some more.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-in-JACS"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/04/07/New-publication-in-JACS/" rel="bookmark" title="Permanent Link to New publication in JACS">New publication in JACS</a></h2>
      <p><small><span class="blog_post_date">Posted April 07, 2014 at 09:08 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/news/'>news</a>, <a href='/blog/category/publication/'>publication</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/04/07/New-publication-in-JACS#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<b>Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator</b>
</p>

<p>
Ethan L. Demeter, Shayna L. Hilburg, Newell R. Washburn, Terrence J. Collins, and John R. Kitchin
</p>

<p>
Iron complexes of tetra-amido macrocyclic ligands are important members of the suite of oxidation catalysts known as TAML activators. TAML activators are known to be fast homogeneous water oxidation (WO) catalysts, producing oxygen in the presence of chemical oxidants, e.g., ceric ammonium nitrate. These homogeneous systems exhibited low turnover numbers (TONs). Here we demonstrate immobilization on glassy carbon and carbon paper in an ink composed of the prototype TAML activator, carbon black, and Nafion and the subsequent use of this composition in heterogeneous electrocatalytic WO. The immobilized TAML system is shown to readily produce O2 with much higher TONs than the homogeneous predecessors.
</p>

<p>
<a href="http://pubs.acs.org/doi/full/10.1021/ja5015986">http://pubs.acs.org/doi/full/10.1021/ja5015986</a> 
</p>

<p>
Congratulations Ethan!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/07/New-publication-in-JACS.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/04/07/New-publication-in-JACS#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Scheduling-tasks-on-a-rotating-semester-basis"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/04/03/Scheduling-tasks-on-a-rotating-semester-basis/" rel="bookmark" title="Permanent Link to Scheduling tasks on a rotating semester basis">Scheduling tasks on a rotating semester basis</a></h2>
      <p><small><span class="blog_post_date">Posted April 03, 2014 at 07:29 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/python/'>python</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/04/03/Scheduling-tasks-on-a-rotating-semester-basis#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated April 03, 2014 at 07:29 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
Let us say we have a list of tasks labeled task a through k. We want to schedule these tasks on a rotating basis, so that some tasks are done in even years and some tasks are done in odd years. Within those years, some tasks are done in the Fall, and some are done in the spring. This post explores how to code those tasks so we can figure out which tasks should be done in some part of some year. 
</p>

<p>
We break the problem down like this. A year is an even year if <code>mod(year,2)=0</code>, and it is odd if <code>mod(year,2)=1</code>. So for a year, we have a bit of information. Now, since there are two times of the year we will do the tasks, we can assign this as another bit, e.g. <code>FALL=0</code>, and <code>SPRING=1</code>. Now, we have the following possibilities:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">year</th>
<th scope="col" class="left">time period</th>
<th scope="col" class="right">binary code</th>
<th scope="col" class="right">decimal number</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">2013</td>
<td class="left">Fall</td>
<td class="right">10</td>
<td class="right">2</td>
</tr>

<tr>
<td class="right">2014</td>
<td class="left">Spring</td>
<td class="right">01</td>
<td class="right">1</td>
</tr>

<tr>
<td class="right">2014</td>
<td class="left">Fall</td>
<td class="right">00</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">2015</td>
<td class="left">Spring</td>
<td class="right">11</td>
<td class="right">3</td>
</tr>
</tbody>
</table>

<p>
And then the cycle will repeat. So, if we code each task with an integer of 0, 1, 2 or 3, we can say in a given year and time period whether a task should be completed. If <code>2 * mod(year, 2) + period_code</code> is equal to the code on the task, then it should be executed.
</p>

<p>
Now, we need to start the task sequence. Let us say we start in the Fall of 2013. That is an odd year, so <code>year % 2 = 1</code>, and we use a tag  of <code>0</code> to represent the Fall semester, giving an overall binary code of <code>10</code> which is equal to 2, so all tasks labeled 2 should be executed. 
</p>

<p>
We will assign the codes to each task by enumerating a string of letters, and giving the task a code of mod(letter index, 4). That will loop through the tasks assigning codes of 0, 1, 2 or 3 to each task. 
</p>

<p>
So to schedule these we will loop through a list of years, calculate the code for each year and time perid, and then filter the list of tasks with that code.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">tasks</span> = [(letter, i % 4) <span style="color: #8b0000;">for</span> i,letter <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">enumerate</span>(<span style="color: #228b22;">'abcdefghijk'</span>)]

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'tasks = '</span>,tasks

<span style="color: #8b008b;">SEMESTERS</span> = ((<span style="color: #228b22;">'FALL'</span>,0), (<span style="color: #228b22;">'SPRING'</span>,1))

<span style="color: #8b0000;">for</span> year <span style="color: #8b0000;">in</span> [2013, 2014, 2015, 2016, 2017, 2018]:
    <span style="color: #8b0000;">for</span> semester,i <span style="color: #8b0000;">in</span> SEMESTERS:
        <span style="color: #8b008b;">N</span> = 2 * (year % 2) + i
        <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0} {1:8s}: {2}'</span>.<span style="color: #cd0000;">format</span>(year, semester,
                                    [x[0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> 
                                     <span style="color: #cd0000;">filter</span>(<span style="color: #8b0000;">lambda</span> x: x[1]==N,
                                            tasks)])
</pre>
</div>

<pre class="example">
tasks =  [('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 0), ('f', 1), ('g', 2), ('h', 3), ('i', 0), ('j', 1), ('k', 2)]
2013 FALL    : ['c', 'g', 'k']
2013 SPRING  : ['d', 'h']
2014 FALL    : ['a', 'e', 'i']
2014 SPRING  : ['b', 'f', 'j']
2015 FALL    : ['c', 'g', 'k']
2015 SPRING  : ['d', 'h']
2016 FALL    : ['a', 'e', 'i']
2016 SPRING  : ['b', 'f', 'j']
2017 FALL    : ['c', 'g', 'k']
2017 SPRING  : ['d', 'h']
2018 FALL    : ['a', 'e', 'i']
2018 SPRING  : ['b', 'f', 'j']
</pre>

<p>
This leads to each task being completed every other year. We could also write a function and filter by list comprehension.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">tasks</span> = [(letter, i % 4) <span style="color: #8b0000;">for</span> i,letter <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">enumerate</span>(<span style="color: #228b22;">'abcdefghijk'</span>)]

<span style="color: #8b008b;">FALL</span> = 0
<span style="color: #8b008b;">SPRING</span> = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">execute_p</span>(year, semester, task):
    <span style="color: #228b22;">'year is an integer, semester is 0 for fall, 1 for spring, task is a tuple of (label,code)'</span>
    <span style="color: #8b008b;">N</span> = 2 * (year % 2) + semester
    <span style="color: #8b0000;">return</span> task[1] == N

<span style="color: #8b008b;">YEAR</span>, SEMESTER = 2018, FALL
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0} {1:8s}: {2}'</span>.<span style="color: #cd0000;">format</span>(YEAR, 
                               <span style="color: #228b22;">'FALL'</span> <span style="color: #8b0000;">if</span> SEMESTER==0 <span style="color: #8b0000;">else</span> <span style="color: #228b22;">'SPRING'</span>,
                               [task[0]  <span style="color: #8b0000;">for</span> task <span style="color: #8b0000;">in</span> tasks
                                <span style="color: #8b0000;">if</span> execute_p(2018, FALL, task)])
</pre>
</div>

<pre class="example">
2018 FALL    : ['a', 'e', 'i']
</pre>

<p>
Now, at any point in the future you can tell what tasks should be done!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/03/Scheduling-tasks-on-a-rotating-semester-basis.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/04/03/Scheduling-tasks-on-a-rotating-semester-basis#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Using-pyparsing-for-search-queries-with-tags"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags/" rel="bookmark" title="Permanent Link to Using pyparsing for search  queries with tags">Using pyparsing for search  queries with tags</a></h2>
      <p><small><span class="blog_post_date">Posted March 31, 2014 at 01:21 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/python/'>python</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Parsing simple string and generating lisp</a></li>
<li><a href="#sec-2">2. Parsing a search string to generate python set notations</a></li>
</ul>
</div>
</div>

<p>
A few times I  have wanted  to use  a more natural search string like "A and pw and 350 and not  kpt". The trouble  is figuring out how to parse that string and turn it  into search code. There  may  be nested logic,  e.g. "(A xor B)  and  (pw and (200 or 300))". This means we have  to recursively parse  the sstring. Rather  than invent this from  scratch, we  use pyparsing which is designed for that. There is   some code in "Getting started with pyparsing" that provides an example on parsing search strings. I want to see how I can turn the parsed output into search code. Here, we parse the search string and generate something that looks like lisp code. 
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Parsing simple string and generating lisp</h2>
<div class="outline-text-2" id="text-1">
<p>
We define  a  hiearchy of classes that codifythe operators, and which print representations of the logic. The grammar we implement is basically words or  strings separatedd by logic operators.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pyparsing <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">UnaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'takes one operand,e.g. not'</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op, <span style="color: #8b0000;">self</span>.operands = tokens[0]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">BinaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'takes two or more operands, e.g. and, or'</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op = tokens[0][1]
        <span style="color: #8b0000;">self</span>.operands = tokens[0][0::2]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchAnd</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(AND {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #228b22;">' '</span>.join(<span style="color: #cd0000;">str</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands))
        
<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchOr</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(OR {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #228b22;">' '</span>.join(<span style="color: #cd0000;">str</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands))

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchNot</span>(UnaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(NOT {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.operands)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchTerm</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'represents a termthat is being searched. here just a word'</span>                         
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.term = tokens[0]

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">self</span>.term

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the grammar</span>
<span style="color: #8b008b;">and_</span> = CaselessLiteral(<span style="color: #228b22;">"and"</span>)
<span style="color: #8b008b;">or_</span> = CaselessLiteral(<span style="color: #228b22;">"or"</span>)
<span style="color: #8b008b;">not_</span> = CaselessLiteral(<span style="color: #228b22;">"not"</span>)

<span style="color: #8b008b;">searchTerm</span> = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

<span style="color: #8b008b;">searchExpr</span> = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])


<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not kpt'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not (kpt and eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue or red'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue and heavy or red'</span>)[0]
</pre>
</div>

<pre class="example">
(NOT kpt)
(NOT (AND kpt eos))
(OR (AND wood blue) red)
(OR (AND wood blue heavy) red)
</pre>

<p>
That works pretty well, and does not seem overly complicated to me. There is a lot of class definition, but that would presumably get buried in a module as a one time investment, and some function interface would look like this: <code>search('wood and blue or red')</code>.
</p>

<p>
Now, let us try python notation. 
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Parsing a search string to generate python set notations</h2>
<div class="outline-text-2" id="text-2">
<p>
I will use a similar idea as I used before with TAGS. We will use set operations with the binary logical operators to do the actual searching. Finally, we wrap the code in a little function to search a dictionary we previously made.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pyparsing <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">UnaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op, <span style="color: #8b0000;">self</span>.operands = tokens[0]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">BinaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op = tokens[0][1]
        <span style="color: #8b0000;">self</span>.operands = tokens[0][0::2]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchAnd</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' &amp; '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) + <span style="color: #228b22;">')'</span>
        
<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchOr</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' | '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) +<span style="color: #228b22;">')'</span>

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchXor</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' ^ '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) + <span style="color: #228b22;">')'</span>

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchNot</span>(UnaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'TAGS[\'all\'] - {}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.operands)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchTerm</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.term = tokens[0]

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #228b22;">'instead of just the  term, we represent it as TAGS[term]'</span>
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'TAGS[\'{0}\']'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.term)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the grammar</span>
<span style="color: #8b008b;">and_</span> = CaselessLiteral(<span style="color: #228b22;">"and"</span>)
<span style="color: #8b008b;">or_</span> = CaselessLiteral(<span style="color: #228b22;">"or"</span>)
<span style="color: #8b008b;">xor_</span> = CaselessLiteral(<span style="color: #228b22;">"xor"</span>)
<span style="color: #8b008b;">not_</span> = CaselessLiteral(<span style="color: #228b22;">"not"</span>)

<span style="color: #8b008b;">searchTerm</span> = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

<span style="color: #8b008b;">searchExpr</span> = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (xor_, 2, opAssoc.LEFT, SearchXor),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])

<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not kpt'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not (kpt and eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'kpt or not eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue or red'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue xor red'</span>)[0]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">check it out on tags.</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">search_tags</span>(srch):
    <span style="color: #228b22;">'function to  search the TAGS  file'</span>
    <span style="color: #8b0000;">import</span> pickle

    <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
        <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())
    
    <span style="color: #8b008b;">s</span> = searchExpr.parseString(srch)[0]
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">eval</span>(<span style="color: #cd0000;">str</span>(s))
<span style="color: #8b0000;">print</span> search_tags(<span style="color: #228b22;">'pw and A and not 300'</span>)
</pre>
</div>

<pre class="example">
TAGS['all'] - TAGS['kpt']
TAGS['all'] - (TAGS['kpt'] &amp; TAGS['eos'])
(TAGS['kpt'] | TAGS['all'] - TAGS['eos'])
((TAGS['wood'] &amp; TAGS['blue']) | TAGS['red'])
((TAGS['wood'] &amp; TAGS['blue']) ^ TAGS['red'])
set(['tags\\A\\pw\\350', 'tags\\A\\pw', 'tags\\A\\pw\\200', 'tags\\A\\pw\\400', 'tags\\A\\pw\\250'])
</pre>

<p>
That is pretty nice. It looks like a nice syntax for queries. One day I will try incorporating this into a database application.
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/31/Using-pyparsing-for-search-queries-with-tags.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Searching-for-directories-by-tags"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/03/29/Searching-for-directories-by-tags/" rel="bookmark" title="Permanent Link to Searching for directories by tags">Searching for directories by tags</a></h2>
      <p><small><span class="blog_post_date">Posted March 29, 2014 at 05:41 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/python/'>python</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/03/29/Searching-for-directories-by-tags#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 30, 2014 at 12:02 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
Today I explore searching for directories by using tags. We will create a TAGS table by first walking through the directories and tagging each directory with all of the relative path components. Then, we will use set algebra to identify specific directories.
</p>

<p>
First, let us make a directory setup to use. We will nest some calculations that might be typical. These will be nested directories that might contain planewave (pw) and k-points (kpts) convergence and equation of state (eos) directories, with the sets of calculations inside those. The idea then is that the directory components will form at least some of the tags.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os

os.mkdir(<span style="color: #228b22;">'tags'</span>)

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> c <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'pw'</span>, <span style="color: #228b22;">'kpts'</span>, <span style="color: #228b22;">'eos'</span>]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, c))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [1, 2, 3, 4, 5]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'eos'</span>, <span style="color: #cd0000;">str</span>(run)))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [200, 250, 300, 350, 400]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'pw'</span>, <span style="color: #cd0000;">str</span>(run)))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'2x2x2'</span>, <span style="color: #228b22;">'4x4x4'</span>, <span style="color: #228b22;">'8x8x8'</span>]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'kpts'</span>, <span style="color: #cd0000;">str</span>(run)))
</pre>
</div>

<p>
Let us just double check what this directory tree looks like for one compound A.
</p>
<div class="org-src-container">

<pre class="src src-sh">ls tags/A/*
</pre>
</div>

<pre class="example">
tags/A/eos:
1
2
3
4
5

tags/A/kpts:
2x2x2
4x4x4
8x8x8

tags/A/pw:
200
250
300
350
400
</pre>

<p>
Now, we will walk through the directories, and split the path components to create a TAGS structure. I will store these as sets within a dictionary. We will save the structure in a pickle file to reuse it later.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">import</span> pickle

<span style="color: #8b008b;">TAGS</span> = {}
<span style="color: #8b008b;">TAGS</span>[<span style="color: #228b22;">'all'</span>] = <span style="color: #cd0000;">set</span>()

<span style="color: #8b0000;">for</span> root, dirs, files <span style="color: #8b0000;">in</span> os.walk(<span style="color: #228b22;">'tags'</span>):
    <span style="color: #8b008b;">base</span>, <span style="color: #8b008b;">tail</span> = os.path.split(root)
    TAGS[<span style="color: #228b22;">'all'</span>].add(root)
    <span style="color: #8b0000;">while</span> base:
        <span style="color: #8b0000;">if</span> tail <span style="color: #8b0000;">in</span> TAGS:
            TAGS[tail].add(root)
        <span style="color: #8b0000;">else</span>:
            <span style="color: #8b008b;">TAGS</span>[tail] = <span style="color: #cd0000;">set</span>([root])
        <span style="color: #8b008b;">base</span>, <span style="color: #8b008b;">tail</span> = os.path.split(base)

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'w'</span>) <span style="color: #8b0000;">as</span> f:
    f.write(pickle.dumps(TAGS))

<span style="color: #8b0000;">print</span> TAGS.keys()
</pre>
</div>

<pre class="example">
['A', '1', 'all', 'B', '250', 'pw', '2x2x2', '300', 'C', '400', 'kpts', '8x8x8', 'eos', '3', '2', '5', '4', '350', '200', '4x4x4', 'D']
</pre>

<p>
Now we have a lot of keys that tag each directory. Each tag is a set of directories, and we can do set algebra to get specific results. For example, we can find a result by appropriate differences, intersections and unions of the sets. An advantage of this approach is that order of the tags is not relevant (unlike the path, where each component must be in the right order).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>].intersection(TAGS[<span style="color: #228b22;">'pw'</span>]).intersection(TAGS[<span style="color: #228b22;">'300'</span>])
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'300'</span>].intersection(TAGS[<span style="color: #228b22;">'pw'</span>]).intersection(TAGS[<span style="color: #228b22;">'A'</span>])
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300'])
set(['tags\\A\\pw\\300'])
</pre>

<p>
The syntax here is a tad heavy because of the chained dot notation operations. You can also use the logical operators like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">300 and pw and A</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'300'</span>] &amp; TAGS[<span style="color: #228b22;">'pw'</span>] &amp; TAGS[<span style="color: #228b22;">'A'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300'])
</pre>


<p>
We can get a set of calculations, for example an equation of state like this:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">300 and pw and A</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>] &amp; TAGS[<span style="color: #228b22;">'eos'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\eos', 'tags\\A\\eos\\5', 'tags\\A\\eos\\4', 'tags\\A\\eos\\1', 'tags\\A\\eos\\3', 'tags\\A\\eos\\2'])
</pre>

<p>
Now, let us construct some more complex queries. With sets we use intersections for <code>and</code> and we construct unions of queries that are like an or. We examine different notations to see which one is better.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find calculation 3 in eos for B and C</span>
<span style="color: #8b0000;">print</span> (TAGS[<span style="color: #228b22;">'3'</span>]
       .intersection(TAGS[<span style="color: #228b22;">'eos'</span>])
       .intersection(TAGS[<span style="color: #228b22;">'B'</span>])
       .union
       (TAGS[<span style="color: #228b22;">'3'</span>]
        .intersection(TAGS[<span style="color: #228b22;">'eos'</span>])
        .intersection(TAGS[<span style="color: #228b22;">'C'</span>])))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this notation makes more sense to me. ^ = or</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'3'</span>] &amp; TAGS[<span style="color: #228b22;">'eos'</span>] &amp; (TAGS[<span style="color: #228b22;">'B'</span>] ^ TAGS[<span style="color: #228b22;">'C'</span>])
</pre>
</div>

<pre class="example">
set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
</pre>

<p>
You can see the two approaches give the same results. The logical operator syntax is more concise and (I think) more readable. Let us consider a query with "not". We can use a difference operator for that. We subtract all the paths with tag "B" from the set containing "4x4x4", which will give us paths tagged with "4x4x4" but not "B".
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find calculation 4x4x4 but not B</span>
<span style="color: #8b0000;">print</span> (TAGS[<span style="color: #228b22;">'4x4x4'</span>].difference(TAGS[<span style="color: #228b22;">'B'</span>]))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this makes more sense 4x4x4 but not B, </span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">i.e. subtract paths tagged B from those tagged 4x4x4</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'4x4x4'</span>] -  TAGS[<span style="color: #228b22;">'B'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
</pre>


<p>
Note it is not so obvious how to get results not tagged with "A". We need to subtract the tagged calculations from some set. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'all'</span>] - TAGS[<span style="color: #228b22;">'A'</span>]  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">not A</span>
</pre>
</div>

<pre class="example">
set(['tags\\D\\kpts', 'tags\\D\\pw\\200', 'tags\\D\\pw\\350', 'tags\\D\\pw\\250', 'tags\\D\\kpts\\8x8x8', 'tags\\C\\eos', 'tags\\D\\eos\\2', 'tags\\D\\eos\\3', 'tags\\D\\eos\\4', 'tags\\D\\eos\\5', 'tags\\B\\kpts\\2x2x2', 'tags\\C\\kpts\\4x4x4', 'tags\\C\\eos\\3', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1', 'tags\\C\\kpts\\8x8x8', 'tags\\C\\eos\\5', 'tags\\C\\eos\\4', 'tags\\B\\kpts', 'tags\\C\\pw\\200', 'tags\\B\\eos\\2', 'tags\\B\\pw\\350', 'tags\\B\\eos\\1', 'tags\\B\\kpts\\8x8x8', 'tags\\C\\pw\\300', 'tags\\B\\eos\\4', 'tags\\B\\eos\\5', 'tags\\C\\kpts', 'tags\\D\\pw\\300', 'tags\\B\\kpts\\4x4x4', 'tags\\C\\kpts\\2x2x2', 'tags\\D\\kpts\\4x4x4', 'tags\\B\\pw\\250', 'tags', 'tags\\D\\pw\\400', 'tags\\D\\eos', 'tags\\C\\pw\\400', 'tags\\D\\kpts\\2x2x2', 'tags\\D\\pw', 'tags\\C\\pw\\250', 'tags\\C\\pw\\350', 'tags\\C\\pw', 'tags\\D\\eos\\1', 'tags\\B\\pw\\400', 'tags\\B\\pw', 'tags\\B\\eos', 'tags\\B\\pw\\300', 'tags\\B\\eos\\3', 'tags\\C', 'tags\\B', 'tags\\D', 'tags\\B\\pw\\200'])
</pre>

<p>
We can also look at "or". This is done with the <code>union</code> function, which is the set of elements in either set. The logical operator is <code>|</code>.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'1'</span>].union(TAGS[<span style="color: #228b22;">'2'</span>])
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'1'</span>] | TAGS[<span style="color: #228b22;">'2'</span>]        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1 or 2</span>
</pre>
</div>

<pre class="example">
set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
</pre>

<p>
There is an <code>xor</code> operator too. xor is not the same as or, it means <code>A xor B</code> means "A or B but not both". The <code>symmetric_difference</code> function gives this behavior. The logical operator is <code>^</code>. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">I think this is like the xor, A or 2 but not both</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>].symmetric_difference(TAGS[<span style="color: #228b22;">'2'</span>]), <span style="color: #228b22;">'\n'</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>] ^ TAGS[<span style="color: #228b22;">'2'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200']) 

set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200'])
</pre>



<p>
To summarize, this is one approach to using tags with the technical infrastructure of the set. The advantage is flexibility, that you do not need to know the full path to a result, provided you know the set of tags that refers to it. You can use the tags in any order.
</p>

<p>
There are many alternative approaches to implementing this idea. One could create a sqlite table and do SQL queries. You could also store lists in the dictionary, and use python code to find the matches. The syntax here is varied. Using the functional approach, the syntax gets heavy with all the dot notation. With the logical operators, the syntax is a little lighter. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/29/Searching-for-directories-by-tags.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/03/29/Searching-for-directories-by-tags#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../59">« Previous Page</a>
  --  
 <a href="../61">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/12/31/2018-in-a-nutshell-for-the-Kitchin-Research-Group/">2018 in a nutshell for the Kitchin Research Group</a></li>
      <li><a href="/blog/2018/11/16/Line-integrals-in-Python-with-autograd/">Line integrals in Python with autograd</a></li>
      <li><a href="/blog/2018/11/05/Using-autograd-for-error-propagation/">Using autograd for error propagation</a></li>
      <li><a href="/blog/2018/11/03/Constrained-optimization-with-Lagrange-multipliers-and-autograd/">Constrained optimization with Lagrange multipliers and autograd</a></li>
      <li><a href="/blog/2018/11/02/Solving-coupled-ODEs-with-a-neural-network-and-autograd/">Solving coupled ODEs with a neural network and autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



