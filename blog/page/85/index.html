

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Another-approach-to-error-propagation"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/07/Another-approach-to-error-propagation/" rel="bookmark" title="Permanent Link to Another approach to error propagation">Another approach to error propagation</a></h2>
      <p><small><span class="blog_post_date">Posted March 07, 2013 at 09:26 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/03/07/Another-approach-to-error-propagation#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated April 23, 2013 at 09:28 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In the previous section we examined an analytical approach to error propagation, and a simulation based approach. There is another approach to error propagation, using the uncertainties module (<a href="https://pypi.python.org/pypi/uncertainties/" >https://pypi.python.org/pypi/uncertainties/</a>). You have to install this package, e.g. <code>pip install uncertainties</code>. After that, the module provides new classes of numbers and functions that incorporate uncertainty and propagate the uncertainty through the functions. In the examples that follow, we repeat the calculations from the previous section using the uncertainties module. 
</p>

<p>
<span style="text-decoration:underline;">Addition and subtraction</span>
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> uncertainties <span style="color: #8b0000;">as</span> u

A = u.ufloat((2.5, 0.4))
B = u.ufloat((4.1, 0.3))
<span style="color: #8b0000;">print</span> A + B
<span style="color: #8b0000;">print</span> A - B
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 6.6+/-0.5
-1.6+/-0.5
</pre>

<p>
<span style="text-decoration:underline;">Multiplication and division</span>
</p>
<div class="org-src-container">

<pre class="src src-python">F = u.ufloat((25, 1))
x = u.ufloat((6.4, 0.4))

t = F * x
<span style="color: #8b0000;">print</span> t

d = F / x
<span style="color: #8b0000;">print</span> d
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 160.0+/-11.8726576637
&gt;&gt;&gt; &gt;&gt;&gt; 3.90625+/-0.289859806243
</pre>

<p>
<span style="text-decoration:underline;">Exponentiation</span>
</p>
<div class="org-src-container">

<pre class="src src-python">t = u.ufloat((2.03, 0.0203))
<span style="color: #8b0000;">print</span> t**5

<span style="color: #8b0000;">from</span> uncertainties.umath <span style="color: #8b0000;">import</span> sqrt
A = u.ufloat((16.07, 0.06))
<span style="color: #8b0000;">print</span> sqrt(A)
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">print np.sqrt(A) # this does not work</span>

<span style="color: #8b0000;">from</span> uncertainties <span style="color: #8b0000;">import</span> unumpy <span style="color: #8b0000;">as</span> unp
<span style="color: #8b0000;">print</span> unp.sqrt(A)
</pre>
</div>

<pre class="example">
34.4730881243+/-1.72365440621
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 4.00874045057+/-0.00748364738749
... &gt;&gt;&gt; &gt;&gt;&gt; 4.00874045057+/-0.00748364738749
</pre>

<p>
Note in the last example, we had to either import a function from uncertainties.umath or import a special version of numpy that handles uncertainty. This may be a limitation of teh uncertainties package as not all functions in arbitrary modules can be covered. Note, however, that you can wrap a function to make it handle uncertainty like this.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

wrapped_sqrt = u.wrap(np.sqrt)
<span style="color: #8b0000;">print</span> wrapped_sqrt(A)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; 4.00874045057+/-0.00748364738774
</pre>

<p>
<span style="text-decoration:underline;">Propagation of errors in an integral</span>
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> uncertainties <span style="color: #8b0000;">as</span> u

x = np.array([u.ufloat((1, 0.01)), 
              u.ufloat((2, 0.1)),
              u.ufloat((3, 0.1))])

y = 2 * x

<span style="color: #8b0000;">print</span> np.trapz(x, y)
</pre>
</div>
<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 8.0+/-0.600333240792
</pre>

<p>
<span style="text-decoration:underline;">Chain rule in error propagation</span>
</p>
<div class="org-src-container">

<pre class="src src-python">v0 = u.ufloat((1.2, 0.02))
a = u.ufloat((3.0, 0.3))
t = u.ufloat((12.0, 0.12))

v = v0 + a * t
<span style="color: #8b0000;">print</span> v
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 37.2+/-3.61801050303
</pre>

<p>
<span style="text-decoration:underline;">A real example?</span>
This is what I would setup for a real working example. We try to compute the exit concentration from a CSTR. The idea is to wrap the &ldquo;external&rdquo; fsolve function using the <code>uncertainties.wrap</code> function, which handles the units. Unfortunately, it does not work, and it is not clear why. But see the following discussion for a fix. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

Fa0 = u.ufloat((5.0, 0.05))
v0 = u.ufloat((10., 0.1))

V = u.ufloat((66000.0, 100))  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">reactor volume L^3</span>
k = u.ufloat((3.0, 0.2))      <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">rate constant L/mol/h</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Ca):
    <span style="color: #228b22;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
    Fa = v0 * Ca     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">exit molar flow of A</span>
    ra = -k * Ca**2  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">rate of reaction of A L/mol/h</span>
    <span style="color: #8b0000;">return</span> Fa0 - Fa + V * ra

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">CA guess that that 90 % is reacted away</span>
CA_guess = 0.1 * Fa0 / v0

wrapped_fsolve = u.wrap(fsolve)
CA_sol = wrapped_fsolve(func, CA_guess)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The exit concentration is {0} mol/L'</span>.format(CA_sol)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... ... &gt;&gt;&gt; ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;function fsolve at 0x148f25f0&gt;
&gt;&gt;&gt; &gt;&gt;&gt; The exit concentration is NotImplemented mol/L
</pre>

<p>
I got a note from the author of the uncertainties package explaining the cryptic error above, and a solution for it. The error arises because fsolve does not know how to deal with uncertainties. The idea is to create a function that returns a float, when everything is given as a float. Then, we wrap the fsolve call, and finally wrap the wrapped fsolve call! 
</p>

<ul>
<li>Step 1. Write the function to solve with arguments for all unitted quantities. This function may be called with uncertainties, or with floats.
</li>

<li>Step 2. Wrap the call to fsolve in a function that takes all the parameters as arguments, and that returns the solution.
</li>

<li>Step 3. Use uncertainties.wrap to wrap the function in Step 2 to get the answer with uncertainties.
</li>
</ul>

<p>
Here is the code that does work:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> uncertainties <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

Fa0 = u.ufloat((5.0, 0.05))
v0 = u.ufloat((10., 0.1))

V = u.ufloat((66000.0, 100.0))  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">reactor volume L^3</span>
k = u.ufloat((3.0, 0.2))      <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">rate constant L/mol/h</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Step 1</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Ca, v0, k, Fa0, V):
    <span style="color: #228b22;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
    Fa = v0 * Ca     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">exit molar flow of A</span>
    ra = -k * Ca**2  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">rate of reaction of A L/mol/h</span>
    <span style="color: #8b0000;">return</span> Fa0 - Fa + V * ra

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Step 2</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">Ca_solve</span>(v0, k, Fa0, V): 
    <span style="color: #228b22;">'wrap fsolve to pass parameters as float or units'</span>
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this line is a little fragile. You must put [0] at the end or</span>
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">you get the NotImplemented result</span>
    sol = fsolve(func, 0.1 * Fa0 / v0, args=(v0, k, Fa0, V))[0]
    <span style="color: #8b0000;">return</span> sol

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Step 3</span>
<span style="color: #8b0000;">print</span> u.wrap(Ca_solve)(v0, k, Fa0, V)
</pre>
</div>

<pre class="example">
0.005+/-0.000167764327667
</pre>

<p>
It would take some practice to get used to this, but the payoff is that you have an &ldquo;automatic&rdquo; error propagation method.
</p>

<p>
Being ever the skeptic, let us compare the result above to the Monte Carlo approach to error estimation below.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

N = 10000
Fa0 = np.random.normal(5, 0.05, (1, N))
v0 = np.random.normal(10.0, 0.1, (1, N))
V =  np.random.normal(66000, 100, (1,N))
k = np.random.normal(3.0, 0.2, (1, N))

SOL = np.zeros((1, N))

<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(N):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Ca):
        <span style="color: #8b0000;">return</span> Fa0[0,i] - v0[0,i] * Ca + V[0,i] * (-k[0,i] * Ca**2)
    SOL[0,i] = fsolve(func, 0.1 * Fa0[0,i] / v0[0,i])[0]

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Ca(exit) = {0}+/-{1}'</span>.format(np.mean(SOL), np.std(SOL))
</pre>
</div>

<pre class="example">
Ca(exit) = 0.00500829453185+/-0.000169103578901
</pre>

<p>
I am pretty content those are the same!
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
The uncertainties module is pretty amazing. It automatically propagates errors through a pretty broad range of computations. It is a little tricky for third-party packages, but it seems doable.
</p>

<p>
Read more about the package at <a href="http://pythonhosted.org/uncertainties/index.html" >http://pythonhosted.org/uncertainties/index.html</a>.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/07/Another-approach-to-error-propagation.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/07/Another-approach-to-error-propagation#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Boundary-value-problem-in-heat-conduction"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/06/Boundary-value-problem-in-heat-conduction/" rel="bookmark" title="Permanent Link to Boundary value problem in heat conduction">Boundary value problem in heat conduction</a></h2>
      <p><small><span class="blog_post_date">Posted March 06, 2013 at 07:35 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bvp/'>bvp</a></span> | tags: <a href='/blog/tag/heat-transfer/'>heat transfer</a>
        | <a href="http://jkitchin.github.io/blog/2013/03/06/Boundary-value-problem-in-heat-conduction#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 07:37 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/11/boundary-value-problem-in-heat-conduction/" >Matlab post</a>
</p>

<p>
For steady state heat conduction the temperature distribution in one-dimension is governed by the Laplace equation:
</p>

<p>
$$ \nabla^2 T = 0$$
</p>

<p>
with boundary conditions that at \(T(x=a) = T_A\) and \(T(x=L) = T_B\).
</p>

<p>
The analytical solution is not difficult here: \(T = T_A-\frac{T_A-T_B}{L}x\), but we will solve this by finite differences.
</p>

<p>
For this problem, lets consider a slab that is defined by x=0 to x=L, with \(T(x=0) = 100\), and \(T(x=L) = 200\). We want to find the function T(x) inside the slab.
</p>

<p>
We approximate the second derivative by finite differences as
</p>

<p>
\( f''(x) \approx \frac{f(x-h) - 2 f(x) + f(x+h)}{h^2} \)
</p>

<p>
Since the second derivative in this case is equal to zero, we have at each discretized node \(0 = T_{i-1} - 2 T_i + T_{i+1}\). We know the values of \(T_{x=0} = \alpha\) and \(T_{x=L} = \beta\).
</p>

<p>
\[A = \left [ \begin{array}{ccccc} %
 -2         & 1 & 0                    & 0 & 0 \\
1           & -2& 1 & 0 & 0 \\
0                    & \ddots               & \ddots               & \ddots & 0 \\
0                    & 0                    & 1 & -2 & 1 \\
0                    & 0                    & 0  & 1  & -2  \end{array} \right ] \]
</p>

<p>
\[ x = \left [ \begin{array}{c} T_1 \\ \vdots \\ T_N \end{array} \right ] \]
</p>

<p>
\[ b = \left [ \begin{array}{c} -T(x=0) \\
0 \\
\vdots \\
0 \\
-T(x=L) \end{array} \right] \]
</p>

<p>
These are linear equations in the unknowns \(x\) that we can easily solve. Here, we evaluate the solution.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">we use the notation T(x1) = alpha and T(x2) = beta</span>
x1 = 0; alpha = 100
x2 = 5; beta = 200

npoints = 100

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">preallocate and shape the b vector and A-matrix</span>
b = np.zeros((npoints, 1));
b[0] = -alpha
b[-1] = -beta

A = np.zeros((npoints, npoints));

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">now we populate the A-matrix and b vector elements</span>
<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(npoints ):
    <span style="color: #8b0000;">for</span> j <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(npoints):
        <span style="color: #8b0000;">if</span> j == i: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the diagonal</span>
            A[i,j] = -2
        <span style="color: #8b0000;">elif</span> j == i - 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">left of the diagonal</span>
            A[i,j] = 1
        <span style="color: #8b0000;">elif</span> j == i + 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">right of the diagonal</span>
            A[i,j] = 1
 
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">solve the equations A*y = b for Y</span>
Y = np.linalg.solve(A,b)

x = np.linspace(x1, x2, npoints + 2)
y = np.hstack([alpha, Y[:,0], beta])

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot(x, y)

plt.plot(x, alpha + (beta - alpha)/(x2 - x1) * x, <span style="color: #228b22;">'r--'</span>)

plt.xlabel(<span style="color: #228b22;">'X'</span>)
plt.ylabel(<span style="color: #228b22;">'T(X)'</span>)
plt.legend((<span style="color: #228b22;">'finite difference'</span>, <span style="color: #228b22;">'analytical soln'</span>), loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-heat-conduction-1d.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-heat-conduction-1d.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Boundary-value-problem-in-heat-conduction.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/06/Boundary-value-problem-in-heat-conduction#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Modeling-a-transient-plug-flow-reactor"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/06/Modeling-a-transient-plug-flow-reactor/" rel="bookmark" title="Permanent Link to Modeling a transient plug flow reactor">Modeling a transient plug flow reactor</a></h2>
      <p><small><span class="blog_post_date">Posted March 06, 2013 at 03:51 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/pde/'>pde</a>, <a href='/blog/category/animation/'>animation</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
        | <a href="http://jkitchin.github.io/blog/2013/03/06/Modeling-a-transient-plug-flow-reactor#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 25, 2013 at 09:50 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/17/modeling-a-transient-plug-flow-reactor" >Matlab post</a>



</p>

<p>
The PDE that describes the transient behavior of a plug flow reactor with constant volumetric flow rate is:
</p>

<p>
\( \frac{\partial C_A}{\partial dt} = -\nu_0 \frac{\partial C_A}{\partial dV} + r_A \).
</p>

<p>
To solve this numerically in python, we will utilize the method of lines. The idea is to discretize the reactor in volume, and approximate the spatial derivatives by finite differences. Then we will have a set of coupled ordinary differential equations that can be solved in the usual way. Let us simplify the notation with \(C = C_A\), and let \(r_A = -k C^2\). Graphically this looks like this:
</p>

<p><img src="/img/./images/pde-method-of-lines.png"><p>

<p>
This leads to the following set of equations:
</p>

\begin{eqnarray}
\frac{dC_0}{dt} &=& 0 \text{ (entrance concentration never changes)} \\
\frac{dC_1}{dt} &=& -\nu_0 \frac{C_1 - C_0}{V_1 - V_0} - k C_1^2 \\
\frac{dC_2}{dt} &=& -\nu_0 \frac{C_2 - C_1}{V_2 - V_1} - k C_2^2 \\
\vdots \\
\frac{dC_4}{dt} &=& -\nu_0 \frac{C_4 - C_3}{V_4 - V_3} - k C_4^2 
\end{eqnarray}

<p>
Last, we need initial conditions for all the nodes in the discretization. Let us assume the reactor was full of empty solvent, so that \(C_i = 0\) at \(t=0\). In the next block of code, we get the transient solutions, and the steady state solution.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

Ca0 = 2     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Entering concentration</span>
vo = 2      <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">volumetric flow rate</span>
volume = 20 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">total volume of reactor, spacetime = 10</span>
k = 1       <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">reaction rate constant</span>

N = 100     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of points to discretize the reactor volume on</span>

init = np.zeros(N)    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Concentration in reactor at t = 0</span>
init[0] = Ca0         <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">concentration at entrance</span>

V = np.linspace(0, volume, N) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">discretized volume elements</span>
tspan = np.linspace(0, 25)    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">time span to integrate over</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">method_of_lines</span>(C, t):
    <span style="color: #228b22;">'coupled ODES at each node point'</span>
    D = -vo * np.diff(C) / np.diff(V) - k * C[1:]**2
    <span style="color: #8b0000;">return</span> np.concatenate([[0], <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">C0 is constant at entrance</span>
                            D])


sol = odeint(method_of_lines, init, tspan)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">steady state solution</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">pfr</span>(C, V):
    <span style="color: #8b0000;">return</span> 1.0 / vo * (-k * C**2)

ssol = odeint(pfr, Ca0, V)
</pre>
</div>

<p>
The transient solution contains the time dependent behavior of each node in the discretized reactor. Each row contains the concentration as a function of volume at a specific time point. For example, we can plot the concentration of A at the exit vs. time (that is, the last entry of each row) as:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
plt.plot(tspan, sol[:, -1])
plt.xlabel(<span style="color: #228b22;">'time'</span>)
plt.ylabel(<span style="color: #228b22;">'$C_A$ at exit'</span>)
plt.savefig(<span style="color: #228b22;">'images/transient-pfr-1.png'</span>)
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D object at 0x05A18830&gt;]
&lt;matplotlib.text.Text object at 0x059FE1D0&gt;
&lt;matplotlib.text.Text object at 0x05A05270&gt;
</pre>


<p><img src="/img/./images/transient-pfr-1.png"><p>

<p>
After approximately one space time, the steady state solution is reached at the exit. For completeness, we also examine the steady state solution.
</p>
<div class="org-src-container">

<pre class="src src-python">plt.figure()
plt.plot(V, ssol, label=<span style="color: #228b22;">'Steady state'</span>)
plt.plot(V, sol[-1], label=<span style="color: #228b22;">'t = {}'</span>.format(tspan[-1]))
plt.xlabel(<span style="color: #228b22;">'Volume'</span>)
plt.ylabel(<span style="color: #228b22;">'$C_A$'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/transient-pfr-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/transient-pfr-2.png"><p>

<p>
There is some minor disagreement between the final transient solution and the steady state solution. That is due to the approximation in discretizing the reactor volume. In this example we used 100 nodes. You get better agreement with a larger number of nodes, say 200 or more. Of course, it takes slightly longer to compute then, since the number of coupled odes is equal to the number of nodes.
</p>

<p>
We can also create an animated gif to show how the concentration of A throughout the reactor varies with time. Note, I had to install ffmpeg (<a href="http://ffmpeg.org/" >http://ffmpeg.org/</a>) to save the animation.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> matplotlib <span style="color: #8b0000;">import</span> animation

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">make empty figure</span>
fig = plt.figure()
ax = plt.axes(xlim=(0, 20), ylim=(0, 2))
line, = ax.plot(V, init, lw=2)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">animate</span>(i):
    line.set_xdata(V)
    line.set_ydata(sol[i])
    ax.set_title(<span style="color: #228b22;">'t = {0}'</span>.format(tspan[i]))
    ax.figure.canvas.draw() 
    <span style="color: #8b0000;">return</span> line,
    

anim = animation.FuncAnimation(fig, animate, frames=50,  blit=<span style="color: #8b0000;">True</span>)

anim.save(<span style="color: #228b22;">'images/transient_pfr.mp4'</span>, fps=10)
</pre>
</div>

<p>
<a href="http://jkitchin.github.com/media/transient_pfr.mp4" >http://jkitchin.github.com/media/transient_pfr.mp4</a>
</p>

<p>
You can see from the animation that after about 10 time units, the solution is not changing further, suggesting steady state has been reached.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Modeling-a-transient-plug-flow-reactor.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/06/Modeling-a-transient-plug-flow-reactor#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Integrating-the-Fermi-distribution-to-compute-entropy"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy/" rel="bookmark" title="Permanent Link to Integrating the Fermi distribution to compute entropy">Integrating the Fermi distribution to compute entropy</a></h2>
      <p><small><span class="blog_post_date">Posted March 06, 2013 at 09:39 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/gotcha/'>gotcha</a>, <a href='/blog/category/integration/'>integration</a>, <a href='/blog/category/dft/'>dft</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 09:47 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
The Fermi distribution is defined by \(f(\epsilon) = \frac{1}{e^{(\epsilon - \mu)/(k T)} + 1}\). This function describes the occupation of energy levels at temperatures above absolute zero. We use this function to compute electronic entropy in a metal, which contains an integral of \(\int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon\), where \(n(\epsilon)\) is the electronic density of states. Here we plot the Fermi distribution function. It shows that well below the Fermi level the states are fully occupied, and well above the Fermi level, they are unoccupied. Near the Fermi level, the states go from occupied to unoccupied smoothly.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0
k = 8.6e-5
T = 1000

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.linspace(-10, 10, 200)
plt.plot(espan, f(espan))
plt.ylim([-0.1, 1.1])
plt.savefig(<span style="color: #228b22;">'images/fermi-entropy-integrand-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/fermi-entropy-integrand-1.png"><p>

<p>
Let us consider a simple density of states function, just a parabola. This could represent a s-band for example. We will use this function to explore the integral.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0
k = 8.6e-5
T = 1000

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dos</span>(e):
    d = (np.ones(e.shape) - 0.03 * e**2) 
    <span style="color: #8b0000;">return</span> d * (d &gt; 0)
espan = np.linspace(-10, 10)

plt.plot(espan, dos(espan), label=<span style="color: #228b22;">'Total dos'</span>)
plt.plot(espan, f(espan) * dos(espan), label=<span style="color: #228b22;">'Occupied states'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/fermi-entropy-integrand-2.png'</span>)
</pre>
</div>

<p>
<p><img src="/img/./images/fermi-entropy-integrand-2.png"><p>
Now, we consider the integral to compute the electronic entropy. The entropy is proportional to this integral.
</p>

<p>
\( \int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon \)
</p>

<p>
It looks straightforward to compute, but it turns out there is a wrinkle. Evaluating the integrand leads to <code>nan</code> elements because the ln(0) is -&infin;. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
mu = 0
k = 8.6e-5
T = 100

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fermi</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.array([-20, -10, -5, 0.0, 5, 10])
f = fermi(espan)

<span style="color: #8b0000;">print</span> f * np.log(f)
<span style="color: #8b0000;">print</span> (1 - f) * np.log(1 - f)
</pre>
</div>

<pre class="example">
[  0.00000000e+000   0.00000000e+000   0.00000000e+000  -3.46573590e-001
  -1.85216532e-250               nan]
[        nan         nan         nan -0.34657359  0.          0.        ]
</pre>

<p>
In this case, these <code>nan</code> elements should be equal to zero (x ln(x) goes to zero as x goes to zero). So, we can just ignore those elements in the integral. Here is how to do that.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0
k = 8.6e-5
T = 1000

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fermi</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dos</span>(e):
    d = (np.ones(e.shape) - 0.03 * e**2) 
    <span style="color: #8b0000;">return</span> d * (d &gt; 0)

espan = np.linspace(-20, 10)
f = fermi(espan)
n = dos(espan)

g = n * (f * np.log(f) + (1 - f) * np.log(1 - f))

<span style="color: #8b0000;">print</span> np.trapz(espan, g) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">nan because of the nan in the g vector</span>
<span style="color: #8b0000;">print</span> g

plt.plot(espan, g)
plt.savefig(<span style="color: #228b22;">'images/fermi-entropy-integrand-3.png'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find the elements that are not nan</span>
ind = np.logical_not(np.isnan(g))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">evaluate the integrand for only those points</span>
<span style="color: #8b0000;">print</span> np.trapz(espan[ind], g[ind])
</pre>
</div>

<pre class="example">
nan
[             nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
  -9.75109643e-14  -1.05987106e-10  -1.04640574e-07  -8.76265644e-05
  -4.92684641e-02  -2.91047740e-01  -7.75652579e-04  -1.00962241e-06
  -1.06972936e-09  -1.00527877e-12  -8.36436686e-16  -6.48930917e-19
  -4.37946336e-22  -2.23285389e-25  -1.88578082e-29   0.00000000e+00
   0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00
   0.00000000e+00   0.00000000e+00]
0.208886080897
</pre>

<p><img src="/img/./images/fermi-entropy-integrand-3.png"><p>

<p>
The integrand is pretty well behaved in the figure above. You do not see the full range of the x-axis, because the integrand evaluates to <code>nan</code> for very negative numbers. This causes the <code>trapz</code> function to return <code>nan</code> also. We can solve the problem by only integrating the parts that are not <code>nan</code>. We have to use numpy.logical<sub>not</sub> to get an element-wise array of which elements are not <code>nan</code>. In this example, the integrand is not well sampled, so the area under that curve may not be very accurate. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="An-index-function-for-strings-in-emacs-lisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp/" rel="bookmark" title="Permanent Link to An index function for strings in emacs-lisp">An index function for strings in emacs-lisp</a></h2>
      <p><small><span class="blog_post_date">Posted March 05, 2013 at 07:28 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs-lisp/'>emacs-lisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated March 05, 2013 at 07:28 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
I could not find an index function for strings in emacs-lisp. The <code>position</code> function seems to work for numbers, but not strings. Here is a version that works on strings.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">index</span> (item list)
  <span style="color: #228b22;">"return index of item in list or nil"</span>
  (<span style="color: #8b0000;">let</span> ((counter 0)
        (found nil))
    (<span style="color: #8b0000;">dolist</span> (listelement list counter)
      (<span style="color: #8b0000;">if</span> (string= item listelement)
        (<span style="color: #8b0000;">progn</span> 
          (setq found t)
          (<span style="color: #8b0000;">return</span> counter)) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">exit the loop</span>
        <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">else increment counter</span>
        (incf counter)))
    <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">if we found it return counter otherwise return nil</span>
    (<span style="color: #8b0000;">if</span> found counter nil)))
</pre>
</div>

<pre class="example">
index
</pre>

<p>
Here are some example uses:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(index <span style="color: #228b22;">"test"</span> '(<span style="color: #228b22;">"a"</span> <span style="color: #228b22;">"test"</span> <span style="color: #228b22;">"y"</span>))
</pre>
</div>

<pre class="example">
1
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(index <span style="color: #228b22;">"z"</span> '(<span style="color: #228b22;">"a"</span> <span style="color: #228b22;">"b"</span> <span style="color: #228b22;">"z"</span>))
</pre>
</div>

<pre class="example">
2
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(index <span style="color: #228b22;">"testy"</span> '(<span style="color: #228b22;">"a"</span> <span style="color: #228b22;">"test"</span> <span style="color: #228b22;">"y"</span>))
</pre>
</div>

<pre class="example">
nil
</pre>

<p>
This raises an error because we use string=.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(index 1 '(<span style="color: #228b22;">"a"</span> <span style="color: #228b22;">"test"</span> <span style="color: #228b22;">"y"</span> 1))
</pre>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/05/An-index-function-for-strings-in-emacs-lisp.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../84">« Previous Page</a>
  --  
 <a href="../86">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis/">A differentiable ODE integrator for sensitivity analysis</a></li>
      <li><a href="/blog/2018/10/10/Autograd-and-the-derivative-of-an-integral-function/">Autograd and the derivative of an integral function</a></li>
      <li><a href="/blog/2018/10/09/Compressibility-variation-from-an-implicit-equation-of-state/">Compressibility variation from an implicit equation of state</a></li>
      <li><a href="/blog/2018/10/08/Getting-derivatives-from-implicit-functions-with-autograd/">Getting derivatives from implicit functions with autograd</a></li>
      <li><a href="/blog/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches/">Compressibility factor variation from the van der Waals equation by three different approaches</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



