

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications/index.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Getting-a-WOS-Accession-number-from-a-DOI"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/" rel="bookmark" title="Permanent Link to Getting a WOS Accession number from a DOI">Getting a WOS Accession number from a DOI</a></h2>
      <p><small><span class="blog_post_date">Posted June 08, 2015 at 11:23 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/orgmode/'>orgmode</a>, <a href='/blog/category/ref/'>ref</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated June 09, 2015 at 07:25 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.
</p>

<p>
In a previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/">post</a> we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j</a> is redirected to
<a href="http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44">http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44</a> . You can see the <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">wos:000225079300029</a> in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cdr (assoc <span style="color: #008000;">"KeyUT"</span> (url-parse-query-string (url-filename (url-generic-parse-url  <span style="color: #008000;">"http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&amp;SrcApp=PARTNER_APP&amp;SrcAuth=LinksAMR&amp;KeyUT=WOS:000225079300029&amp;DestLinkType=FullRecord&amp;DestApp=ALL_WOS&amp;UsrCustomerID=8703b88d69db6b417a9c0dc510538f44"</span>)))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><a href="000225079300029">000225079300029</a></td>
</tr>
</tbody>
</table>

<p>
It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-redirect*</span> nil)
(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-waiting*</span> nil)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-get-wos-redirect</span> (url)
  <span style="color: #036A07;">"Return final redirect url for open-url"</span>
  (<span style="color: #0000FF;">setq</span> *wos-waiting* t)
  (url-retrieve
   url
   (<span style="color: #0000FF;">lambda</span> (status)
     (<span style="color: #0000FF;">setq</span> *wos-redirect* (car (last status)))
     (<span style="color: #0000FF;">setq</span> *wos-waiting* nil)))
  (<span style="color: #0000FF;">while</span> *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-doi-to-accession-number</span> (doi)
  <span style="color: #036A07;">"Return a WOS Accession number for a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((open-url (concat <span style="color: #008000;">"http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&amp;rft_id=info:doi/"</span> doi))
         (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
                 (assoc
                  <span style="color: #008000;">"KeyUT"</span>
                  (url-parse-query-string
                   (url-filename
                    (url-generic-parse-url redirect)))))
    4)))

(concat <span style="color: #008000;">"wos:"</span> (wos-doi-to-accession-number <span style="color: #008000;">"10.1021/jp047349j"</span>))
</pre>
</div>

<pre class="example">
wos:000225079300029
</pre>

<p>
I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:
</p>

<p>
<a href="http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029">http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029</a> 
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029</a> 
</p>

<p>
That might turn out to be handy at some point.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Getting-a-Scopus-EID-from-a-DOI"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/" rel="bookmark" title="Permanent Link to Getting a Scopus EID from a DOI">Getting a Scopus EID from a DOI</a></h2>
      <p><small><span class="blog_post_date">Posted June 07, 2015 at 04:29 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/orgmode/'>orgmode</a>, <a href='/blog/category/ref/'>ref</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated June 07, 2015 at 04:54 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://www.scopus.com">Scopus</a> is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: <a href="http://dev.elsevier.com/myapikey.html">http://dev.elsevier.com/myapikey.html</a> and set <b>scopus-api-key</b> in Emacs to use this code.
</p>

<p>
Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:
</p>

<p>
Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial &amp; Engineering Chemistry Research, 52:10788-10794 (2013)
</p>

<p>
With the EID, we can construct a URL to the Scopus document page:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/record/display.url?eid=%s&amp;origin=resultslist"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&amp;origin=resultslist
</pre>

<p>
We can construct a URL to citing documents:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=%s&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=2-s2.0-84881394200&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage
</pre>

<p>
And there are three types of related document urls we can create: by author, keyword or references.
</p>

<p>
By authors:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=aut&amp;zone=relatedDocuments"</span>)
            eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments</a> 
</p>

<p>
By keywords:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=key&amp;zone=relatedDocuments"</span>)
          eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments</a> 
</p>

<p>
And by references:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat  <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url?"</span>
                   <span style="color: #008000;">"eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                   <span style="color: #008000;">"&amp;method=ref&amp;zone=relatedDocuments"</span>)
           eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments</a> 
</p>

<p>
We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, <i>not</i> the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is <a href="http://dx.doi.org/10.1021/ie400582a">doi:10.1021/ie400582a</a>.
</p>

<p>
The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.
</p>

<p>
I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (json-object-type 'plist)
       (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                    (json-read-from-string
                     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid-json</span> (doi)
  <span style="color: #036A07;">"Return a parsed xml from the Scopus article retrieval api for DOI.</span>
<span style="color: #036A07;">This does not always seem to work for the most recent DOIs."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (json-object-type 'plist)
         (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                      (json-read-from-string
                       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>)))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<p>
XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
              (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
Now we wrap this in a function for reusability.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid</span> (doi)
  <span style="color: #036A07;">"Get a Scopus eid from a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max))))
         (results (car xml))
         (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
This code is wrapped up in <a href="https://github.com/jkitchin/org-ref/blob/master/scopus.el">org-ref/scopus.el</a> . It provides a new org-mode eid link, e.g. <a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist">eid:2-s2.0-84881394200</a> which is functional and provides access to the citing and related article Scopus pages for that eid.
</p>

<p>
There are also new links and functions for a <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=b&sdt=b&sl=35&s=TITLE-ABS-KEY%28alloy%20Au%20segregation%29&origin=searchbasic">alloy Au segregation</a> and <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=a&sdt=a&sl=48&s=auth%28kitchin%29%20and%20title%28segregation%29&origin=searchadvanced">auth(kitchin) and title(segregation)</a>.
</p>

<p>
Let's not forget the <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a> link to Scopus Author pages.
</p>

<p>
Now you can use org-mode for reproducible scientific literature searching in Scopus!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/07/Getting-a-Scopus-EID-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-in-ACS-Catalysis-on-data-sharing-practices"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices/" rel="bookmark" title="Permanent Link to New publication in ACS Catalysis on data sharing practices">New publication in ACS Catalysis on data sharing practices</a></h2>
      <p><small><span class="blog_post_date">Posted May 17, 2015 at 02:22 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/news/'>news</a>, <a href='/blog/category/publication/'>publication</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated July 12, 2015 at 06:57 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In this perspective we show an example of data sharing practices we have developed. We use the supporting information file from <a href="#boes-2015-estim-bulk">boes-2015-estim-bulk</a> to show how one can extract the data from our paper and reuse it for new purposes. We illustrate this for both computational and experimental data. We use org-mode for doing this, but we also show that data in the supporting information can be extracted using Python, and independently of Emacs, so that org-mode is not critical for people who do not use it.
</p>

<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
<div class='altmetric-embed' data-doi="10.1021/acscatal.5b00538"></div>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">kitchin-2015-examp</span>,
  <span style="color: #BA36A5;">author</span> =       {Kitchin, John R.},
  <span style="color: #BA36A5;">title</span> =        {Examples of Effective Data Sharing in Scientific Publishing},
  <span style="color: #BA36A5;">journal</span> =      {ACS Catalysis},
  <span style="color: #BA36A5;">volume</span> =       {5},
  <span style="color: #BA36A5;">number</span> =       {6},
  <span style="color: #BA36A5;">pages</span> =        {3894-3899},
  <span style="color: #BA36A5;">year</span> =         2015,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1021/acscatal.5b00538</span>},
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;"> http://dx.doi.org/10.1021/acscatal.5b00538 </span>},
  <span style="color: #BA36A5;">eprint</span> =       { http://dx.doi.org/10.1021/acscatal.5b00538 },
}
</pre>
</div>

<p>
The published version of this manuscript doesn't look exactly like the version I generated, for example, the output from the source blocks is missing. Hopefully that will make it into a supporting information file. Until then, you may be interested in the org file and version I submitted below.
</p>

<p>
Org source: <a href="/media/2015-05-17-New-publication-in-ACS-Catalysis-on-data-sharing-practices/acs-cat-manuscript.org">acs-cat-manuscript.org</a> 
</p>

<p>
References: <a href="/media/2015-05-17-New-publication-in-ACS-Catalysis-on-data-sharing-practices/acs-cat-references.bib">acs-cat-references.bib</a> 
</p>

<p>
Manuscript: <a href="/media/2015-05-17-New-publication-in-ACS-Catalysis-on-data-sharing-practices/acs-cat-manuscript-2015-05-07.zip">acs-cat-manuscript-2015-05-07.zip</a> 
</p>


<p>
<h1>Bibliography</h1>
<ul><li><a id="boes-2015-estim-bulk">[boes-2015-estim-bulk] Jacob Boes, Gamze Gumuslu, James Miller, Andrew, Gellman & John Kitchin, Estimating Bulk-Composition-Dependent \ceH2 Adsorption  Energies on \ceCu_xPd_1-x Alloy (111) Surfaces, <i>ACS Catalysis</i>, <b>5</b>, 1020-1026 (2015). <a href="http://dx.doi.org/10.1021/cs501585k">link</a>. <a href="http://dx.doi.org/10.1021/cs501585k">doi</a>.</a></li>
</ul></p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="New-publication-in-Surface-Science-on-data-sharing"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/05/17/New-publication-in-Surface-Science-on-data-sharing/" rel="bookmark" title="Permanent Link to New publication in Surface Science on data sharing">New publication in Surface Science on data sharing</a></h2>
      <p><small><span class="blog_post_date">Posted May 17, 2015 at 09:10 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/news/'>news</a>, <a href='/blog/category/publication/'>publication</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-Surface-Science-on-data-sharing#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated May 17, 2015 at 01:48 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
In this perspective we illustrate how we use org-mode to prepare manuscripts and supporting information files that are rich in data, and that make it easy to share the code we use for our analysis. We use the supporting information file from <a href="#boes-2015-core-cu">boes-2015-core-cu</a> to show examples of how to extract the data, and reuse it in new analyses. This approach works for both computational and experimental data. You can see the manuscript I submitted here: <a href="/media/2015-05-17-New-publication-in-Surface-Science-on-data-sharing/ss-manuscript-2015-05-07.zip">ss-manuscript-2015-05-07.zip</a> , and the org file that generated it here: <a href="/media/2015-05-17-New-publication-in-Surface-Science-on-data-sharing/ss-manuscript.org">ss-manuscript.org</a> . The references from the manuscript are contained here <a href="/media/2015-05-17-New-publication-in-Surface-Science-on-data-sharing/ss-manuscript.bib">ss-manuscript.bib</a> 
</p>

<p>
<a href="http://www.sciencedirect.com/science/article/pii/S0039602815001326">http://www.sciencedirect.com/science/article/pii/S0039602815001326</a> 
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">kitchin-2015-data-surfac-scien</span>,
  <span style="color: #BA36A5;">author</span> =       "John R. Kitchin",
  <span style="color: #BA36A5;">title</span> =        {Data Sharing in Surface Science},
  <span style="color: #BA36A5;">journal</span> =      "Surface Science ",
  <span style="color: #BA36A5;">number</span> =       0,
  <span style="color: #BA36A5;">pages</span> =        " - ",
  <span style="color: #BA36A5;">year</span> =         2015,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1016/j.susc.2015.05.007</span>},
  <span style="color: #BA36A5;">url</span> =
                  "http://www.sciencedirect.com/science/article/pii/S0039602815001326",
  <span style="color: #BA36A5;">issn</span> =         "0039-6028",
  <span style="color: #BA36A5;">keywords</span> =     "Data sharing ",
}
</pre>
</div>

<p>
<h1>Bibliography</h1>
<ul><li><a id="boes-2015-core-cu">[boes-2015-core-cu] "Jacob Boes, Peter Kondratyuk, Chunrong Yin, James, Miller, Andrew Gellman & John Kitchin", Core Level Shifts in Cu-Pd Alloys As a Function of Bulk  Composition and Structure, <i>"Surface Science "</i>, <b>(0)</b>,  -  (2015). <a href="http://www.sciencedirect.com/science/article/pii/S0039602815000461">link</a>. <a href="http://dx.doi.org/10.1016/j.susc.2015.02.011">doi</a>.</a></li>
</ul></p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/17/New-publication-in-Surface-Science-on-data-sharing.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-Surface-Science-on-data-sharing#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Python-data-structures-to-lisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2015/05/16/Python-data-structures-to-lisp/" rel="bookmark" title="Permanent Link to Python data structures to lisp">Python data structures to lisp</a></h2>
      <p><small><span class="blog_post_date">Posted May 16, 2015 at 10:47 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/python/'>python</a>, <a href='/blog/category/lisp/'>lisp</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2015/05/16/Python-data-structures-to-lisp#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I have an idea in mind that would use the output of python scripts in lisp functions. Xah Lee posted an <a href="http://ergoemacs.org/emacs/elisp_perl_wrapper.html">idea for writing emacs commands in scripting languages</a> . In this post I want to explore an extension of the idea, where a Python script will return output that can be read in Lisp, e.g. we can convert a Python list to a lisp list, or a dictionary to an a-list or p-list. I can already see that simple data structures will be "simple", and arbitrary data structures will offer a lot of challenges, e.g. nested lists or dictionaries&#x2026;
</p>

<p>
If I could add some custom functions to the basic builtin types in Python, then I could use another approach to format python objects as lisp data types. This isn't recommended by Pythonistas, but I guess they don't want to use lisp as much as I do ;) I found this approach to modifying builtins:
</p>

<p>
<a href="http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a">http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a</a> 
</p>

<p>
We use that almost verbatim here to get what I want. This is a super low level way to add functions to the builtins. I add some simple formatting to floats, ints and strings. I add a more complex recursive formatting function to lists, tuples and dictionaries. A dictionary can be represented as an alist or plist. Both examples are shown, but I leave the alist version commented out. Finally, we add a lispify function to numpy arrays.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> ctypes <span style="color: #0000FF;">as</span> c

<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">PyObject_HEAD</span>(c.Structure):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">_fields_</span> = [(<span style="color: #008000;">'HEAD'</span>, c.c_ubyte * (<span style="color: #006FE0;">object</span>.__basicsize__ -
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     c.sizeof(c.c_void_p))),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   (<span style="color: #008000;">'ob_type'</span>, c.c_void_p)]

<span style="color: #BA36A5;">_get_dict</span> = c.pythonapi._PyObject_GetDictPtr
<span style="color: #BA36A5;">_get_dict.restype</span> = c.POINTER(c.py_object)
<span style="color: #BA36A5;">_get_dict.argtypes</span> = [c.py_object]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_dict</span>(<span style="color: #006FE0;">object</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> _get_dict(<span style="color: #006FE0;">object</span>).contents.value

get_dict(<span style="color: #006FE0;">str</span>)[<span style="color: #008000;">'lisp'</span>] = <span style="color: #0000FF;">lambda</span> s:<span style="color: #008000;">'"{}"'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">str</span>(s))
get_dict(<span style="color: #006FE0;">float</span>)[<span style="color: #008000;">'lisp'</span>] = <span style="color: #0000FF;">lambda</span> f:<span style="color: #008000;">'{}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">str</span>(f))
get_dict(<span style="color: #006FE0;">int</span>)[<span style="color: #008000;">'lisp'</span>] = <span style="color: #0000FF;">lambda</span> f:<span style="color: #008000;">'{}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">str</span>(f))

<span style="color: #0000FF;">import</span> collections
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">lispify</span>(L):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Convert a Python object L to a lisp representation."</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> (<span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">str</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">float</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">int</span>)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> L.lisp()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">elif</span> (<span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">list</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">tuple</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, np.ndarray)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = []
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> element <span style="color: #0000FF;">in</span> L:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> += [element.lisp()]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">'('</span> + <span style="color: #008000;">' '</span>.join(s) + <span style="color: #008000;">')'</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">elif</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">dict</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = []
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> key <span style="color: #0000FF;">in</span> L:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">alist format</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">s += ["({0} . {1})".format(key, L[key].lisp())]</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plist</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> += [<span style="color: #008000;">":{0} {1}"</span>.<span style="color: #006FE0;">format</span>(key, L[key].lisp())]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">'('</span> + <span style="color: #008000;">' '</span>.join(s) + <span style="color: #008000;">')'</span>

get_dict(<span style="color: #006FE0;">list</span>)[<span style="color: #008000;">'lisp'</span>] = lispify
get_dict(<span style="color: #006FE0;">tuple</span>)[<span style="color: #008000;">'lisp'</span>] = lispify
get_dict(<span style="color: #006FE0;">dict</span>)[<span style="color: #008000;">'lisp'</span>] = lispify
get_dict(np.ndarray)[<span style="color: #008000;">'lisp'</span>] = lispify
</pre>
</div>

<p>
Let us test these out.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">from</span> pylisp <span style="color: #0000FF;">import</span> *
<span style="color: #BA36A5;">a</span> = 4.5
<span style="color: #0000FF;">print</span> <span style="color: #006FE0;">int</span>(a).lisp()
<span style="color: #0000FF;">print</span> a.lisp()
<span style="color: #0000FF;">print</span> <span style="color: #008000;">"test"</span>.lisp()

<span style="color: #0000FF;">print</span> [1, 2, 3].lisp()
<span style="color: #0000FF;">print</span> (1, 2, 3).lisp()

<span style="color: #0000FF;">print</span> [[1, 3], (5, 6)].lisp()

<span style="color: #0000FF;">print</span> {<span style="color: #008000;">"a"</span>: 5}.lisp()
<span style="color: #0000FF;">print</span> [[1, 3], (5, 6), {<span style="color: #008000;">"a"</span>: 5, <span style="color: #008000;">"b"</span>: <span style="color: #008000;">"test"</span>}].lisp()


<span style="color: #BA36A5;">A</span> = np.array([1, 3, 4])
<span style="color: #0000FF;">print</span> A.lisp()
<span style="color: #0000FF;">print</span> ({<span style="color: #008000;">"tree"</span>: [5, 6]}, [<span style="color: #008000;">"a"</span>, 4, <span style="color: #008000;">"list"</span>], 5, 2.0 / 3.0).lisp()
</pre>
</div>

<pre class="example">
4
4.5
"test"
(1 2 3)
(1 2 3)
((1 3) (5 6))
(:a 5)
((1 3) (5 6) (:a 5 :b "test"))
(1 3 4)
((:tree (5 6)) ("a" 4 "list") 5 0.666666666667)
</pre>


<p>
Now, is that better than a single lisp function with a lot of conditionals to handle each type? I am not sure. This seems to work pretty well.
</p>


<p>
Here is how I imagine using this idea. We would have some emacs-lisp variables and use them to dynamically generate a python script. We run the python script, capturing the output, and read it back in as a lisp data structure. Here is a simple kind of example that generates a dictionary.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((elisp-var 6)
       (result)
      (script (format <span style="color: #008000;">"</span>
<span style="color: #008000;">from pylisp import *</span>
<span style="color: #008000;">print {x: [2*y for y in range(x)] for x in range(1, %s)}.lisp()</span>
<span style="color: #008000;">"</span> elisp-var)))

  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">start a python process</span>
  (run-python)
  (<span style="color: #0000FF;">setq</span> result (read (python-shell-send-string-no-output
   script)))
  (plist-get result <span style="color: #006FE0;">:5</span>))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(0 2 4 6 8)
</pre>
</div>

<p>
That seems to work pretty well. One alternative idea to this is <a href="https://github.com/pinard/Pymacs">Pymacs</a> , which I have written about <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/10/19/Using-Pymacs-to-integrate-Python-into-Emacs/">before</a> . This project isn't currently under active development, and I ran into some difficulties with it before.
</p>

<p>
Here we can solve the problem I previously posed and get the result back as an elisp float, and then reuse the result
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((myvar 3)
       (script (format <span style="color: #008000;">"from pylisp import *</span>
<span style="color: #008000;">from scipy.optimize import fsolve</span>
<span style="color: #008000;">def objective(x):</span>
<span style="color: #008000;">    return x - 5</span>

<span style="color: #008000;">ans, = fsolve(objective, %s)</span>
<span style="color: #008000;">print ans.lisp()"</span> myvar)))
  (run-python)
  (<span style="color: #0000FF;">setq</span> result (read (python-shell-send-string-no-output
                       script)))
  (- 5 result))
</pre>
</div>

<pre class="example">
0.0
</pre>

<p>
Bottom line: we can write python code in lisp functions that are dynamically updated, execute them, and get lisp data structures back for simple data types. I think that could be useful in some applications, where it is easier to do parsing/analysis in Python, but you want to do something else that is easier in Lisp.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/16/Python-data-structures-to-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2015/05/16/Python-data-structures-to-lisp#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../14">« Previous Page</a>
  --  
 <a href="../16">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2016/03/18/Org-teleport-headlines/">Org teleport headlines</a></li>
      <li><a href="/blog/2016/03/16/Getting-graphical-feedback-as-tooltips-in-Emacs/">Getting graphical feedback as tooltips in Emacs</a></li>
      <li><a href="/blog/2016/03/03/New-publication-in-International-Journal-of-Quantum-Chemistry/">New publication in International Journal of Quantum Chemistry</a></li>
      <li><a href="/blog/2016/02/26/Adding-captions-and-attributes-to-figures-and-tables-from-code-blocks-in-org-mode/">Adding captions and attributes to figures and tables from code blocks in org-mode</a></li>
      <li><a href="/blog/2016/02/25/Pycse-is-now-using-Python3/">Pycse is now using Python3</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2016
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



