

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Language-specific-default-headers-for-code-blocks-in-org-mode"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode/" rel="bookmark" title="Permanent Link to Language specific default headers for code blocks in org-mode">Language specific default headers for code blocks in org-mode</a></h2>
      <p><small><span class="blog_post_date">Posted January 26, 2014 at 12:06 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs-lisp/'>emacs-lisp</a>, <a href='/blog/category/org-mode/'>org-mode</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I use code blocks in org-mode <i>a lot</i>. I usually code in Python, and
in Python I usually write code that prints output which I want to see. So I almost always
want the code blocks to return the output, and not the value of the
last function. I have set my default header args like this:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">org-babel-default-header-args
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">(:exports . both)</td>
<td class="left">(:results . replace output)</td>
<td class="left">(:session . none)</td>
<td class="left">(:cache . no)</td>
<td class="left">(:noweb . no)</td>
<td class="left">(:hlines . no)</td>
<td class="left">(:tangle . no)</td>
</tr>
</tbody>
</table>

<p>
However, I would prefer that emacs-lisp blocks use value for the
results. I know I can get that by putting  <code>:results value</code>  in the
code block header, but that annoys me. I learned today from
<a href="http://orgmode.org/worg/org-contrib/babel/header-args.html">http://orgmode.org/worg/org-contrib/babel/header-args.html</a> that you
can make language specific default headers!
</p>

<p>
This code in my init file sets emacs-lisp specific default headers:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq org-babel-default-header-args:emacs-lisp 
      (cons '(<span style="color: #cd0000;">:results</span> . <span style="color: #228b22;">"value"</span>)
            (assq-delete-all <span style="color: #cd0000;">:results</span> org-babel-default-header-args)))
</pre>
</div>

<p>
That way I do not have type <code>:results value</code> at the top of every elisp
block. Of course, if I want the output I could specify <code>:results
output</code> in the block.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">org-babel-default-header-args:emacs-lisp
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">(:results . value)</td>
<td class="left">(:exports . both)</td>
<td class="left">(:session . none)</td>
<td class="left">(:cache . no)</td>
<td class="left">(:noweb . no)</td>
<td class="left">(:hlines . no)</td>
<td class="left">(:tangle . no)</td>
</tr>
</tbody>
</table>

<p>
Problem solved!
</p>

<p>
On a related note, I find I write so many blocks of python and elisp I
added these templates:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">add &lt;p for python expansion</span>
(add-to-list 'org-structure-template-alist
             '(<span style="color: #228b22;">"p"</span> <span style="color: #228b22;">"#+BEGIN_SRC python\n?\n#+END_SRC"</span> <span style="color: #228b22;">"&lt;src lang=\"python\"&gt;\n?\n&lt;/src&gt;"</span>))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">add &lt;el for emacs-lisp expansion</span>
(add-to-list 'org-structure-template-alist
             '(<span style="color: #228b22;">"el"</span> <span style="color: #228b22;">"#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"</span> <span style="color: #228b22;">"&lt;src lang=\"emacs-lisp\"&gt;\n?\n&lt;/src&gt;"</span>))
</pre>
</div>

<p>
I probably could have also coded the :results header into those
too. They add a tidbit of convenience so I do not have to type python
or emacs-lisp after expanding a source block with &lt;s.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.5g</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/01/26/Language-specific-default-headers-for-code-blocks-in-org-mode#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Another-alternative-to-string-templates"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/01/26/Another-alternative-to-string-templates/" rel="bookmark" title="Permanent Link to Another alternative to string templates">Another alternative to string templates</a></h2>
      <p><small><span class="blog_post_date">Posted January 26, 2014 at 09:56 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs-lisp/'>emacs-lisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/01/26/Another-alternative-to-string-templates#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
In the <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/">last post</a> I explored a way to expand a string template that was
more readable than the usual format. Today I look at another approach
where I use sexp expansions to accomplish the same thing. The idea is
to embed lisp expressions and replace them by what they evaluate to.
</p>

<p>
In emacs-lisp, if we have a command in a string, we can "read" it, and
then eval it. 
</p>

<p>
Here we get the user-full-name:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval (read <span style="color: #228b22;">"user-full-name"</span>))
</pre>
</div>

<pre class="example">
John Kitchin
</pre>

<p>
We can use this on variables too.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq some-variable <span style="color: #228b22;">"test"</span>)
(eval (read <span style="color: #228b22;">"some-variable"</span>))
</pre>
</div>

<pre class="example">
test
</pre>

<p>
So, if we use a syntax to identify what to replace, we can substitute
in the values. Let us try %() as the syntax.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s)
  <span style="color: #228b22;">"expand a template containing %() with the eval of its contents"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"%(</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">)]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">)"</span>
                            (<span style="color: #8b0000;">lambda</span> (arg)
                              (format <span style="color: #228b22;">"%s"</span> (eval (read (substring arg 2 -1))))) s))


(<span style="color: #8b0000;">let</span> ((key <span style="color: #228b22;">"kitchin-2014"</span>)
      (author <span style="color: #228b22;">"Kitchin, J. R."</span>)
      (journal <span style="color: #228b22;">"HACS"</span>)
      (year <span style="color: #228b22;">"2014"</span>)
      (volume <span style="color: #228b22;">"1"</span>)
      (pages <span style="color: #228b22;">"1--10"</span>)
      (doi <span style="color: #228b22;">"10.1.1.109/hacs.1.10"</span>)
      (url <span style="color: #228b22;">"http://hacs.org/10.1.1.109/hacs.1.10"</span>)
      (pdf-dir <span style="color: #228b22;">"/home/jkitchin/pdfs"</span>)
      (template <span style="color: #228b22;">"</span>
<span style="color: #228b22;"> :PROPERTIES:</span>
<span style="color: #228b22;">  :Custom_ID: %(key)</span>
<span style="color: #228b22;">  :AUTHOR: %(author</span>
<span style="color: #228b22;">  :JOURNAL: %(journal)</span>
<span style="color: #228b22;">  :YEAR: %(year)</span>
<span style="color: #228b22;">  :VOLUME: %(volume)</span>
<span style="color: #228b22;">  :PAGES: %(pages)</span>
<span style="color: #228b22;">  :DOI: %(doi)</span>
<span style="color: #228b22;">  :URL: %(url)</span>
<span style="color: #228b22;"> :END:</span>
<span style="color: #ff0000; font-weight: bold;">[</span><span style="color: #228b22;">[cite:%(key)]] [[file:%(pdf-dir)/%(key).pdf][pdf]]\n\n"</span>))

(expand-template template))
</pre>
</div>

<pre class="example">
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
</pre>

<p>
That is pretty nice. I like it better than the plist expansion I used
before. Presumably these variables would already be defined somewhere
in your code.
</p>

<p>
I thought of trying this on a more complex expansion, and discovered a
weakness in the regexp that finds the expansion values. It turns out
to be simpler to use %{} as the delimiter than %(), because you may
want nested parentheses. The regexp above does not correctly match
sets of parentheses.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s)
  <span style="color: #228b22;">"expand a template containing %{} with the eval of its contents"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"%{</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">}]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">}"</span>
                            (<span style="color: #8b0000;">lambda</span> (arg)
                              (<span style="color: #8b0000;">let</span> ((sexp (substring arg 2 -1)))
                                (format <span style="color: #228b22;">"%s"</span> (eval (read sexp))))) s))

(expand-template <span style="color: #228b22;">"2 * 2 = %{(* 2 2)}"</span>)
</pre>
</div>

<pre class="example">
2 * 2 = 4
</pre>


<p>
I am not sure this is a desirable way to make a template, with
multiline code to be expanded, but at least this works!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s)
  <span style="color: #228b22;">"expand a template containing %{} with the eval of its contents"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"%{</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">}]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">}"</span>
                            (<span style="color: #8b0000;">lambda</span> (arg)
                              (<span style="color: #8b0000;">let</span> ((sexp (substring arg 2 -1)))
                                (format <span style="color: #228b22;">"%s"</span> (eval (read sexp))))) s))

(expand-template <span style="color: #228b22;">"The result is %{(progn</span>
<span style="color: #228b22;">  (if (&gt; 4 3)</span>
<span style="color: #228b22;">      'true</span>
<span style="color: #228b22;">    'false))}"</span>)
</pre>
</div>

<pre class="example">
The result is true
</pre>

<p>
The regexp used in the expansion is not very robust. In particular if
there is a } in the code, it will probably fail because the regexp
does not match closing } correctly. Fixing that is beyond me right
now!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/26/Another-alternative-to-string-templates.org">org-mode source</a><p><p>Org-mode version = 8.2.5g</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/01/26/Another-alternative-to-string-templates#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Alternatives-to-long-complex-format-statements-in-emacs-lisp"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/" rel="bookmark" title="Permanent Link to Alternatives to long complex format statements in emacs-lisp">Alternatives to long complex format statements in emacs-lisp</a></h2>
      <p><small><span class="blog_post_date">Posted January 20, 2014 at 09:50 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs-lisp/'>emacs-lisp</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
At one point I had a string I wanted to fill in with a bunch of variables. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(insert (format<span style="color: #228b22;">"</span>
<span style="color: #228b22;"> :PROPERTIES:</span>
<span style="color: #228b22;">  :Custom_ID: %s</span>
<span style="color: #228b22;">  :AUTHOR: %s</span>
<span style="color: #228b22;">  :JOURNAL: %s</span>
<span style="color: #228b22;">  :YEAR: %s</span>
<span style="color: #228b22;">  :VOLUME: %s</span>
<span style="color: #228b22;">  :PAGES: %s</span>
<span style="color: #228b22;">  :DOI: %s</span>
<span style="color: #228b22;">  :URL: %s</span>
<span style="color: #228b22;"> :END:</span>
<span style="color: #228b22; font-weight: bold;">[</span><span style="color: #228b22;">[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"</span>
key author journal year volume pages doi url key jorg-bib-pdf-directory key ))
</pre>
</div>

<p>
I find that very difficult to use, because it is tedious to make sure all the variables are in the right order, and it is difficult to change later. In Python, you would be able to put named expansions in, e.g. {author} and then used named arguments. That does not exist as far as I know in emacs-lisp.
</p>

<p>
Below is an alternatme approach that uses concat to construct this string.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((key <span style="color: #228b22;">"kitchin-2014"</span>)
      (author <span style="color: #228b22;">"Kitchin, J. R."</span>)
      (journal <span style="color: #228b22;">"HACS"</span>)
      (year <span style="color: #228b22;">"2014"</span>)
      (volume <span style="color: #228b22;">"1"</span>)
      (pages <span style="color: #228b22;">"1--10"</span>)
      (doi <span style="color: #228b22;">"10.1.1.109/hacs.1.10"</span>)
      (url <span style="color: #228b22;">"http://hacs.org/10.1.1.109/hacs.1.10"</span>)
      (jorg-bib-pdf-directory <span style="color: #228b22;">"/home/jkitchin/pdfs"</span>))

(concat <span style="color: #228b22;">"</span>
<span style="color: #228b22;"> :PROPERTIES:</span>
<span style="color: #228b22;">  :Custom_ID: "</span> key <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :AUTHOR: "</span> author <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :JOURNAL: "</span> journal <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :YEAR: "</span> year <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :VOLUME: "</span> volume <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :PAGES: "</span> pages <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :DOI: "</span> doi <span style="color: #228b22;">"</span>
<span style="color: #228b22;">  :URL: "</span> url <span style="color: #228b22;">"</span>
<span style="color: #228b22;"> :END:</span>
<span style="color: #228b22; font-weight: bold;">[</span><span style="color: #228b22;">[cite:"</span> key <span style="color: #228b22;">"]] [[file:"</span> jorg-bib-pdf-directory <span style="color: #228b22;">"/"</span> key <span style="color: #228b22;">".pdf][pdf]]\n\n"</span>))
</pre>
</div>

<pre class="example">
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
</pre>

<p>
That is kind of interesting. It is a little tedious to use all the quotes. It seems like there should be soemthing like named expansions. Let us write one of our own. We will use a regular expression to find {:keyword} and a plist. There is a regexp to match this, and then we can take the characters from position 1 to the second to last character as the keyword. That is not beautiful to me, but it works here. Then we just get the keyword from the plist. The keywords in a plist are symbols, and we will have strings. We have to use the <code>intern</code> function to convert them to symbols.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s plist)
  <span style="color: #228b22;">"expand a template containing {:keyword} with the definitions in plist"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"{</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">:[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">}]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">}"</span> 
                            (<span style="color: #8b0000;">lambda</span> (arg) 
                              (<span style="color: #8b0000;">let</span> ((keyword (intern (substring arg 1 -1))))
                                (format <span style="color: #228b22;">"%s"</span> (plist-get plist keyword)))) s))

(<span style="color: #8b0000;">let</span> ((template <span style="color: #228b22;">"</span>
<span style="color: #228b22;"> :PROPERTIES:</span>
<span style="color: #228b22;">  :Custom_ID: {:key}</span>
<span style="color: #228b22;">  :AUTHOR: {:author}</span>
<span style="color: #228b22;">  :JOURNAL: {:journal}</span>
<span style="color: #228b22;">  :YEAR: {:year}</span>
<span style="color: #228b22;">  :VOLUME: {:volume}</span>
<span style="color: #228b22;">  :PAGES: {:pages}</span>
<span style="color: #228b22;">  :DOI: {:doi}</span>
<span style="color: #228b22;">  :URL: {:url}</span>
<span style="color: #228b22;"> :END:</span>
<span style="color: #228b22; font-weight: bold;">[</span><span style="color: #228b22;">[cite:{:key}]] [[file:{:pdf-dir}/{:key}.pdf][pdf]]\n\n"</span>))

(expand-template template
                 '(<span style="color: #cd0000;">:key</span> <span style="color: #228b22;">"kitchin-2014"</span>
                        <span style="color: #cd0000;">:author</span> <span style="color: #228b22;">"Kitchin, J. R."</span>
                        <span style="color: #cd0000;">:journal</span> <span style="color: #228b22;">"HACS"</span>
                        <span style="color: #cd0000;">:year</span> 2014
                        <span style="color: #cd0000;">:volume</span> 1
                        <span style="color: #cd0000;">:pages</span> <span style="color: #228b22;">"1--10"</span>
                        <span style="color: #cd0000;">:doi</span> <span style="color: #228b22;">"10.1.1.109/hacs.1.10"</span>
                        <span style="color: #cd0000;">:url</span> <span style="color: #228b22;">"http://hacs.org/10.1.1.109/hacs.1.10"</span>
                        <span style="color: #cd0000;">:pdf-dir</span> <span style="color: #228b22;">"/home/jkitchin/pdfs"</span>)))
</pre>
</div>

<pre class="example">
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
</pre>

<p>
That is pretty close to what I am used to from python! I am surprised there aren't other solutions for this around. I looked, and couldn't find them.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.5f</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Making-org-mode-links-to-files-in-Emacs-packages"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/01/19/Making-org-mode-links-to-files-in-Emacs-packages/" rel="bookmark" title="Permanent Link to Making org-mode links to files in Emacs packages">Making org-mode links to files in Emacs packages</a></h2>
      <p><small><span class="blog_post_date">Posted January 19, 2014 at 12:42 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/org-mode/'>org-mode</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/01/19/Making-org-mode-links-to-files-in-Emacs-packages#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated January 19, 2014 at 03:27 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Today I will make a new org-mode link that lets me make links to files inside of Emacs packages. These files may be installed in different places on different systems (e.g. in the system directory, in ELPA directories, or in custom directories), so we need a way to construct paths to them. The application of this is eventually I hope to have some emacs packages of documentation, and I would like to have links between the packages that work no matter how they are installed.
</p>

<p>
I want a syntax that looks like pkg:rainbow-mode==rainbow-mode-pkg.el. We will have a function that parses that to get the package, and the path to the file in the package. Emacs has a function to find the path to the file that defines a library. I chose == because it seems unlikely that would be a string in a package or path. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(locate-library <span style="color: #228b22;">"rainbow-mode"</span>)
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode.elc
</pre>

<p>
We can use that to construct the path to where we want. Say we want the file named "rainbow-mode-pkg.el"
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(expand-file-name
 <span style="color: #228b22;">"rainbow-mode-pkg.el"</span>
 (file-name-directory (locate-library <span style="color: #228b22;">"rainbow-mode"</span>)))
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode-pkg.el
</pre>

<p>
In org-mode links, the link path gets passed to a function. We can split the string like this to get the package and relative path we are referring to.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(split-string <span style="color: #228b22;">"rainbow-mode==rainbow-mode-pkg.el"</span> <span style="color: #228b22;">"=="</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">rainbow-mode</td>
<td class="left">rainbow-mode-pkg.el</td>
</tr>
</tbody>
</table>

<p>
That is all of the pieces we need to construct the link function. Here it is.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type 
 <span style="color: #228b22;">"pkg"</span>
 (<span style="color: #8b0000;">lambda</span> (path)
   (<span style="color: #8b0000;">let</span> ((pkg) (relpath)
         (splitpath (split-string path <span style="color: #228b22;">"=="</span>)))
     (setq pkg (car splitpath))
     (setq relpath (nth 1 splitpath))
     (find-file (expand-file-name 
                 relpath 
                 (file-name-directory (locate-library pkg)))))))
</pre>
</div>

<p>
pkg:rainbow-mode==rainbow-mode-pkg.el  
</p>

<p>
This works too, but you have to use auctex-pkg as the package name. 
</p>

<p>
pkg:auctex-pkg==doc/intro.texi 
</p>

<p>
I think that is because locate-library looks for the <i>file</i> a library is defined in. That is not quite the same as the root directory of a package. It turns out to be a little more complicated to find that. Below is some code I hacked up looking at the package.el code. First let us examine some pieces.
</p>

<p>
This gives us information about an installed package. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(assq 'auctex package-alist)
</pre>
</div>

<pre class="example">
(auctex . [(11 87 2) nil Integrated environment for *TeX*])
</pre>

<p>
We can get the version of the package like this
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(package-version-join (package-desc-vers (cdr (assq 'auctex package-alist))))
</pre>
</div>

<pre class="example">
11.87.2
</pre>

<p>
Ok, finally, we get the directory where it is installed like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(package--dir <span style="color: #228b22;">"auctex"</span> <span style="color: #228b22;">"11.87.2"</span>)
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2
</pre>

<p>
Note that in some places we use a package symbol, and in other places a string name.Putting that together, we have this block to get the install-dir of a package. If we have a package symbol we can get the path like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let*</span> ((pkg 'auctex)
       (pkg-name (symbol-name pkg)) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">convert symbol to string</span>
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2
</pre>

<p>
Usually, we will have a string though. We just have to make it a symbol with the <code>intern</code> function. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq pkg-name <span style="color: #228b22;">"auctex"</span>)
(setq pkg (intern pkg-name))
(setq desc (cdr (assq pkg package-alist)))
</pre>
</div>

<pre class="example">
[(11 87 2) nil "Integrated environment for *TeX*"]
</pre>

<p>
Now, we have all the pieces to get the path from a package name in a string:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let*</span> ((pkg-name <span style="color: #228b22;">"auctex"</span>)
       (pkg (intern pkg-name))
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2
</pre>

<p>
Let us use that to rewrite the link, and address a few other limitations. We will  use <code>org-open-link-from-string</code> so we can use org-link syntax in the path part of the link, e.g. to open a file at a line, or headline. Here is our new link.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type 
 <span style="color: #228b22;">"pkg2"</span>
 (<span style="color: #8b0000;">lambda</span> (path)
   (<span style="color: #8b0000;">let</span> ((pkg) (relpath) (pkg-dir) (link-string)
         (splitpath (split-string path <span style="color: #228b22;">"=="</span>)))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (<span style="color: #8b0000;">let*</span> ((pkg-symbol (intern pkg-name)) <span style="color: #ff0000; font-weight: bold;">;</span><span style="color: #ff0000; font-weight: bold;">convert string to pkg                   </span>
                          (desc (cdr (assq pkg-symbol package-alist)))
                          (version (package-version-join (package-desc-vers desc)))
                          (pkg-dir (package--dir pkg-name version)))
                     pkg-dir))
     (setq link-string (format <span style="color: #228b22;">"[[file:%s/%s]]"</span> pkg-dir relpath))
     (message <span style="color: #228b22;">"link: %s"</span> link-string)
     (org-open-link-from-string link-string))))
</pre>
</div>

<p>
Now, we can do all of these: 
pkg2:auctex==doc/faq.texi   
pkg2:auctex==doc/faq.texi::should 
pkg2:auctex==doc/faq.texi::10 
<pre>pkg2:auctex==doc/faq.texi::first place</pre> 
</p>

<p>
Awesome!
</p>

<p>
Just for fun, I made a toy package called <code>package1</code> in my elpa directory. That package has an org file in it. Now, I can test out the following links:
</p>

<p>
pkg2:package1==intro.org 
</p>

<p>
pkg2:package1==intro.org::*Miscellaneous
</p>

<p>
<pre>pkg2:package1==intro.org::*subheading with words</pre> 
</p>

<p>
pkg2:package1==intro.org::#install-section
</p>

<p>
pkg2:package1==intro.org::intro-target
</p>

<p>
They all work! That works for packages installed via the package manager. However, when I try this with my custom installed org-mode, it does not work. If I run (describe-package 'org) I see that org is a build in package, and that there is an alternate version available. It does not point to my org-installation.
</p>

<p>
pkg2:org==doc/library-of-babel.org 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(princ (locate-library <span style="color: #228b22;">"org"</span>))
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/org.elc
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(princ (package-installed-p <span style="color: #228b22;">"org"</span>))
</pre>
</div>

<pre class="example">
nil
</pre>

<p>
Obviously, we need to check if the package is installed via package.el, or if we should look somewhere else. Let us take a final stab at this. Let us review the challenge. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(print (locate-library <span style="color: #228b22;">"auctex"</span>))
(print (locate-library <span style="color: #228b22;">"auctex-autoloads"</span>))
</pre>
</div>

<pre class="example">
nil

"c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/auctex-autoloads.el"
</pre>

<p>
We may have to check for a package-autoloads. Ww can wrap that in an <code>or</code> macro, which will return the first non-nil result.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((pkg-name <span style="color: #228b22;">"auctex"</span>))
   (file-name-directory 
    (or (locate-library pkg-name)
        (locate-library (format <span style="color: #228b22;">"%s-autoloads"</span> pkg-name)))))
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/
</pre>

<p>
Doing this on the org package shows that this points to a lisp directory. 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((pkg-name <span style="color: #228b22;">"org"</span>))
   (file-name-directory 
    (or (locate-library pkg-name)
        (locate-library (format <span style="color: #228b22;">"%s-autoloads"</span> pkg-name)))))
</pre>
</div>

<pre class="example">
c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/
</pre>

<p>
So, let's try a final link function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type 
 <span style="color: #228b22;">"pkg3"</span>
 (<span style="color: #8b0000;">lambda</span> (path)
   (<span style="color: #8b0000;">let</span> ((pkg-name) (relpath)(pkg-dir) (link-string)
         (splitpath (split-string path <span style="color: #228b22;">"=="</span>)))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (file-name-directory 
                    (or (locate-library pkg-name)
                        (locate-library (format <span style="color: #228b22;">"%s-autoloads"</span> pkg-name)))))
(setq link-string (format <span style="color: #228b22;">"[[file:%s/%s]]"</span> pkg-dir relpath))
     (message <span style="color: #228b22;">"link: %s"</span> link-string)
     (org-open-link-from-string link-string))))
</pre>
</div>

<p>
Now, we just have to make sure to use the right relative path. This link opens up an org-file in my installed version of org-mode: <pre>pkg3:org==../doc/library-of-babel.org</pre> 
</p>

<p>
I don't know if there is a more clever way to create these links. There are two parts to them: 1) the package, and 2) the relative path. The link syntax isn't that rich to do it without parsing the linkpath.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/19/Making-org-mode-links-to-files-in-Emacs-packages.org">org-mode source</a><p><p>Org-mode version = 8.2.5f</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/01/19/Making-org-mode-links-to-files-in-Emacs-packages#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Send-email-to-a-list-of-users"></div>
      <h2 class="blog_post_title"><a href="/blog/2014/01/13/Send-email-to-a-list-of-users/" rel="bookmark" title="Permanent Link to Send email to a list of users">Send email to a list of users</a></h2>
      <p><small><span class="blog_post_date">Posted January 13, 2014 at 06:41 PM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs-lisp/'>emacs-lisp</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2014/01/13/Send-email-to-a-list-of-users#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated January 13, 2014 at 06:42 PM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapcar to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">send-mail</span> (userid password)
  <span style="color: #228b22;">"send email to userid@andrew.cmu.edu containing their password"</span>
  (interactive)
  (mail)
  (mail-to)
  (insert (format <span style="color: #228b22;">"%s@andrew.cmu.edu"</span> userid))
  (mail-subject)
  (insert <span style="color: #228b22;">"[06-640] account information"</span>)
  (mail-text)
  (insert (format <span style="color: #228b22;">"</span>
<span style="color: #228b22;">An account has been created on gilgamesh.cheme.cmu.edu</span>
<span style="color: #228b22;">userid: %s</span>
<span style="color: #228b22;">password: %s"</span> userid password))
  (mail-send-and-exit))

(send-mail <span style="color: #228b22;">"jkitchin"</span> <span style="color: #228b22;">"trustme99"</span>)
</pre>
</div>

<p>
That worked well. I ran the block and got the email. 
</p>

<p>
Now, suppose I have this data:
</p>
<table id="users" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">userid</th>
<th scope="col" class="left">password</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">user1</td>
<td class="left">trustme99</td>
</tr>

<tr>
<td class="left">user2</td>
<td class="left">foolme99</td>
</tr>

<tr>
<td class="left">user3</td>
<td class="left">blameme99</td>
</tr>
</tbody>
</table>

<p>
We can pass that to a source block as a list of lists that will look like this:
</p>
<pre class="example">
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
</pre>

<p>
Then, we can use a mapcar to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">fun</span> (a b)
  (princ (format <span style="color: #228b22;">"user: %s\npassword: %s\n"</span> a b)))

(mapcar (<span style="color: #8b0000;">lambda</span> (x) (fun (car x) (cadr x))) data)
</pre>
</div>

<pre class="example">
user: user1
password: trustme99
user: user2
password: foolme99
user: user3
password: blameme99
</pre>

<p>
I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">fun</span> (a b)
  (princ (format <span style="color: #228b22;">"user: %s\npassword: %s\n"</span> a b)))

(mapcar (<span style="color: #8b0000;">lambda</span> (x) (fun (nth 0 x) (nth 1 x))) data)
</pre>
</div>

<pre class="example">
user: user1
password: trustme99
user: user2
password: foolme99
user: user3
password: blameme99
</pre>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/13/Send-email-to-a-list-of-users.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2014/01/13/Send-email-to-a-list-of-users#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../62">« Previous Page</a>
  --  
 <a href="../64">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/01/27/New-publication-in-Topics-in-Catalysis/">New publication in Topics in Catalysis</a></li>
      <li><a href="/blog/2018/01/03/New-publication-in-Molecular-Simulation/">New publication in Molecular Simulation</a></li>
      <li><a href="/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group/">2017 in a nutshell for the Kitchin Research group</a></li>
      <li><a href="/blog/2017/11/29/Solving-an-eigenvalue-differential-equation-with-a-neural-network/">Solving an eigenvalue differential equation with a neural network</a></li>
      <li><a href="/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd/">Solving ODEs with a neural network and autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



