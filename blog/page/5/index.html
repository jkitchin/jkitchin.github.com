

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>
      <li><a href="/group.html">Group</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Zeromq-bindings-for-Emacs-via-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules/" rel="bookmark" title="Permanent Link to Zeromq bindings for Emacs via dynamic modules">Zeromq bindings for Emacs via dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 12, 2017 at 07:38 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
I do a lot of scientific programming, and it is one of the reasons I have been learning to extend Emacs with dynamic modules. They have allowed me to add physical constants, numerical integration, root finding and linear algebra from established c-libraries to Emacs. Today I am taking a break from that and finally getting to another one of the reasons I started playing around with dynamic modules: <a href="http://zguide.zeromq.org/">zeromq</a>. Zeromq is a messaging library that <a href="http://jupyter-client.readthedocs.io/en/latest/messaging.html">Jupyter</a> uses to communicate with kernels. I thought we might get a smoother integration with Emacs and Jupyter if we could use zeromq directly to communicate between org-mode and the kernel. Currently we have to run a web server that does the communication for us via http requests. We won't solve the Jupyter problem today, but we will look at communicating with a Zeromq server from Emacs.
</p>

<p>
This might have lots of other useful applications. Suppose Emacs could communicate directly with other zeromq servers to retrieve data from, perhaps scientific data. It might even be possible for Emacs to run its own zeromq server, and other instances of Emacs could then communicate with it. Collaborative editing anyone? 
</p>

<p>
Here we just implement the "Hello world" client example in the <a href="http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive">zeromq guide</a>. The code for the server, a c-client, the mod-zmq library, a makefile and tests can be found at <a href="https://github.com/jkitchin/emacs-modules/tree/master/zeromq">https://github.com/jkitchin/emacs-modules/tree/master/zeromq</a>. All the server does is receive a string, and then send a response (in this case just the string "World") back to the client. 
</p>

<p>
To run this, make sure to run the hwserver executable in a terminal. I wrapped the  zeromq commands required to implement the client into a dynamic module. Since this example focuses on strings, the module returns strings to Emacs. I am not sure if that is always the right thing to do, as zeromq more generically uses bytes, but I will have to wait until I know more about zeromq to know if this is an issue. 
</p>

<p>
This dynamic module uses a new feature that none of the previous posts used, and that is the user_ptr. These allow you to essentially return a reference pointer back to emacs that you can pass back to another function. That way they stay alive between function calls. For example, here we have to create a context and socket and pass these items to functions like zmq_send and zmq_recv.
</p>

<p>
The directory this library is in is not on my path, so we load it like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">mod-zmq</span>)
</pre>
</div>

<p>
Here are the functions and their signatures that have been implemented so far. I only implemented the ones I needed for the client. The signatures may change in the future; this is just a proof of concept for now for the purpose of building the client.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos-command <span style="color: #008000;">"zmq*"</span> t)
(<span style="color: #0000FF;">with-current-buffer</span> <span style="color: #008000;">"*Apropos*"</span> (buffer-string))
</pre>
</div>

<pre class="example">
Type RET on a type label to view its full documentation.

zmq-close
  Function: (zmq-close SOCKET)
zmq-connect
  Function: (zmq-connect SOCKET ENDPOINT)
zmq-ctx-destroy
  Function: (zmq-ctx-destroy CONTEXT)
zmq-ctx-new
  Function: (zmq-ctx-new)
zmq-recv
  Function: (zmq-recv SOCKET LEN FLAGS)
zmq-send
  Function: (zmq-send SOCKET BUF FLAGS)
zmq-socket
  Function: (zmq-socket CONTEXT TYPE)
</pre>

<p>
You can see the c code for the client here: <a href="/media/hwclient.c">hwclient.c</a> . Here is a simple elisp version of the hwclient that basically does the same thing! The main difference is I added a while loop around the zmq-recv because sometimes it returns -1 and no result. So, here we loop until the return result is not -1. That seems to do the right thing.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((context (zmq-ctx-new))
       (socket (zmq-socket context ZMQ-REQ))
       (recv-ret -1)
       (result))

  (zmq-connect socket <span style="color: #008000;">"tcp://localhost:5555"</span>)
  (zmq-send socket <span style="color: #008000;">"Hello"</span> 0)

  (<span style="color: #0000FF;">while</span> (= recv-ret -1)
    (<span style="color: #0000FF;">setq</span> result (zmq-recv socket 10 0)
          recv-ret (second result)))

  (print result)

  (zmq-close socket)
  (zmq-ctx-destroy context))
</pre>
</div>

<pre class="example">

("World" 5)

</pre>

<p>
Basically this creates the context, then the socket, and connects to it on port 5555 of the localhost where the server is running. Then we send the string "Hello". The server returns the string "World" and tells us it sent 5 bytes. Then we close the socket and destroy the context. There is a lot of code in the module to make this happen. A lot of it is converting args in emacs functions to things we can use in c, running a few lines of zmq commands, and then code to convert those results back to emacs values. Finally, there is code to register each function and define docstrings for them. I am not totally convinced this is the best way to do this, but it does work! An alternative might be <a href="https://github.com/tromey/emacs-ffi">emacs-ffi</a>, which might enable most of this to be developed in just elisp. 
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/12/Zeromq-bindings-for-Emacs-via-dynamic-modules#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules/" rel="bookmark" title="Permanent Link to Adding linear algebra to Emacs with the GSL and dynamic modules">Adding linear algebra to Emacs with the GSL and dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 11, 2017 at 10:27 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The goal of this post is to be able to solve equations like this one:
</p>

<p>
\[\left(\begin{array}{cccc}
 0.18& 0.60& 0.57& 0.96 \\
 0.41& 0.24& 0.99& 0.58 \\
 0.14& 0.30& 0.97& 0.66 \\
 0.51& 0.13& 0.19& 0.85 \end{array} \right ) 
\left ( \begin{array}{c} x_0 \\ x_1 \\ x_2 \\ x_3 \end{array} \right )
= \left ( \begin{array}{c} 1.0 \\ 2.0 \\ 3.0 \\ 4.0 \end{array} \right ) \]
</p>

<p>
The answer is <a href="https://www.gnu.org/software/gsl/doc/html/linalg.html#examples:">given</a> as
</p>

<p>
\[x = \left ( \begin{array}{c} -4.05205 \\ -12.6056 \\ 1.66091 \\ 8.69377 \end{array} \right ) \]
</p>

<p>
The syntax we want to use is shown below, and we want it to return a vector containing the solution:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((A [[0.18 0.60 0.57 0.96]
          [0.41 0.24 0.99 0.58]
          [0.14 0.30 0.97 0.66]
          [0.51 0.13 0.19 0.85]])
      (b [1.0 2.0 3.0 4.0]))
  (gsl-linalg-LU-solve A b))
</pre>
</div>

<p>
Rather than put all the code in here like I have for the past several posts, I started a git repo at <a href="https://github.com/jkitchin/emacs-modules">https://github.com/jkitchin/emacs-modules</a> that contains this code. 
</p>


<p>
The module for this post can be found here: <a href="https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c">https://github.com/jkitchin/emacs-modules/blob/master/gsl-linalg.c</a>. There are a few notable features in it. First, I started writing/collecting <a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c">some helper functions</a> to make these modules simpler to write. For example, look how nice this looks to declare the functions and provide the feature.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  DEFUN(<span style="color: #008000;">"gsl-linalg-LU-solve"</span>, Fgsl_linalg_LU_solve, 2, 2,
        <span style="color: #008000;">"(gsl-linalg-LU-solve A b).\n"</span> \
        <span style="color: #008000;">"Solve A x = b for x.\n"</span> \
        <span style="color: #008000;">"Returns a vector containing the solution x."</span>,
        <span style="color: #D0372D;">NULL</span>);
  provide(env, <span style="color: #008000;">"gsl-linalg"</span>);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
The DEFUN and provide function are defined in <a href="https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c">https://github.com/jkitchin/emacs-modules/blob/master/emacs-module-helpers.c</a>.
</p>

<p>
Within the module itself, we have to loop over the inputs to create the arrays that GSL wants to solve this problem. Second, after the solution is obtained, we have to build up a vector to return. The solution is in a gsl_vector, and we need to create an array of emacs_value elements containing each element of the gsl_vector as a float, and then create a vector to return to emacs. I use vectors here because it was easy to get the size of the b vector, which is also related to the size of the A matrix.
</p>

<p>
The repo has a Makefile in it, so we can build this module with:
</p>

<div class="org-src-container">
<pre class="src src-sh">make gsl-linalg.so
</pre>
</div>

<p>
Once it is compiled, we load it like this. In this post we are in the emacs-modules directory where the gsl-linalg.so library is, and it is not on my load-path, so I add it here.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"."</span>))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-linalg</span>)
</pre>
</div>

<pre class="example">
gsl-linalg

</pre>

<p>
Here is one function in the module:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'gsl-linalg-LU-solve)
</pre>
</div>

<pre class="example">
gsl-linalg-LU-solve is a Lisp function.

(gsl-linalg-LU-solve &amp;rest ARGS)

For more information check the manuals.

(gsl-linalg-LU-solve A b).
Solve A x = b for x.
Returns a vector containing the solution x.

</pre>

<p>
Now, we can solve linear equations like this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-linalg-LU-solve
 [[0.18 0.60 0.57 0.96]
  [0.41 0.24 0.99 0.58]
  [0.14 0.30 0.97 0.66]
  [0.51 0.13 0.19 0.85]]
 [1.0 2.0 3.0 4.0])
</pre>
</div>

<pre class="example">
[-4.052050229573973 -12.605611395906903 1.6609116267088417 8.693766928795227]

</pre>


<p>
We have a limited ability to confirm this answer. I have written a function that uses blas for multiplication of 2d vectors. You can see from this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-blas-dgemm [[0.18 0.60 0.57 0.96]
                 [0.41 0.24 0.99 0.58]
                 [0.14 0.30 0.97 0.66]
                 [0.51 0.13 0.19 0.85]]
                [[-4.052050229573973]
                 [-12.605611395906903]
                 [1.6609116267088417]
                 [8.693766928795227]])
</pre>
</div>

<pre class="example">
[[1.0] [1.9999999999999991] [2.9999999999999996] [4.0]]

</pre>

<p>
That within float that indeed \(A x = b\).
</p>

<p>
The main limitation of this module at the moment is that you have to use vectors; you cannot put in a list of numbers. It is possible to make it take lists and vectors, but for now I am leaving it at vectors. Also, it only produces solutions of float numbers (not integers).
</p>

<p>
The module does not handle 1d vectors well,, e.g. in gsl-linalg-LU-solve example, the right hand side is implied to be a column vector, and we don't have the array broadcasting features of Python yet. Those are doable things for some future day perhaps. For now I am happy to have figured out how to handle arrays!
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/11/Adding-linear-algebra-to-Emacs-with-the-GSL-and-dynamic-modules#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-GSL-constants-to-Emacs-in-a-dynamic-module"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module/" rel="bookmark" title="Permanent Link to Adding GSL constants to Emacs in a dynamic module">Adding GSL constants to Emacs in a dynamic module</a></h2>
      <p><small><span class="blog_post_date">Posted July 10, 2017 at 09:38 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module#disqus_thread">View Comments</a>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The GNU Scientific Library defines a lot of <a href="https://www.gnu.org/software/gsl/doc/html/const.html">physical constants</a>. Since we are exploring how to make Emacs a more scientific environment to work in, it would be nice to import these constants to elisp. We do that through a dynamic module. This turned out to be tricky. I thought we could just use a funcall to defconst or defvar, but these are special forms and you cannot funcall them. @polizta on Stackoverflow <a href="https://emacs.stackexchange.com/questions/34049/how-do-you-define-constants-in-an-emacs-dynamic-module/34063#34063">pointed me to the path</a> that led to success: You make a list like '(defconst sym val doc) and then eval it. That can be funcall'd, and it works nicely in the module below. It is a growing theme that it takes much hacking around to figure out how to do things like this.
</p>

<p>
The only other notable feature of this module is that I created a defconst function to make adding multiple constants less verbose. Here I only add two constants. There are about 408 constants defined in gsl_const_*.h, so brevity might be a good idea! Here is the module.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_const_mksa.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;string.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">I assume here that all values will be double. I can't think of any that would</span>
<span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">be ints</span>
<span style="color: #0000FF;">static</span> <span style="color: #6434A3;">void</span> <span style="color: #006699;">defconst</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">name</span>, <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">value</span>, <span style="color: #0000FF;">const</span> <span style="color: #6434A3;">char</span> *<span style="color: #BA36A5;">doc</span>)
{
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">These are functions we will call</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">eval</span> = env-&gt;intern(env, <span style="color: #008000;">"eval"</span>);  
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">list</span> = env-&gt;intern(env, <span style="color: #008000;">"list"</span>);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">These will make up the list we will eventally eval</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fdefconst</span> = env-&gt;intern(env, <span style="color: #008000;">"defconst"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">sym</span> = env-&gt;intern(env, name);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">val</span> = env-&gt;make_float(env, value);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">sdoc</span> = env-&gt;make_string(env, doc, strlen(doc));

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">make a list of (defconst sym val doc)</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">largs</span>[] = {fdefconst, sym, val, sdoc};
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">qlist</span> = env-&gt;funcall(env, list, 4, &amp;largs);   

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">now eval the list of symbols</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[] = { qlist };  
  env-&gt;funcall(env, eval, 1, &amp;args);
}

<span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);

  defconst(env, <span style="color: #008000;">"GSL-CONST-MKSA-SPEED-OF-LIGHT"</span>,
           GSL_CONST_MKSA_SPEED_OF_LIGHT,
           <span style="color: #008000;">"Speed of light in vacuum (m/s)."</span>);
  
  defconst(env, <span style="color: #008000;">"GSL-CONST-MKSA-PLANCKS-CONSTANT-H"</span>,
           GSL_CONST_MKSA_PLANCKS_CONSTANT_H,
           <span style="color: #008000;">"Plank's constant, h"</span>);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">This is what allows the shared library to provide a feature </span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide</span> = env-&gt;intern(env, <span style="color: #008000;">"provide"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide_args</span>[] = { env-&gt;intern(env, <span style="color: #008000;">"gsl-constants"</span>) };
  env-&gt;funcall(env, provide, 1, provide_args);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>


<p>
Regular gcc will work to compile this module. 
</p>

<div class="org-src-container">
<pre class="src src-sh">rm -f gsl-constants.so gsl-constants.o
gcc -Wall -I/usr/local/include -fPIC -c gsl-constants.c
gcc -shared -L/usr/local/include -lgsl -o gsl-constants.so gsl-constants.o
</pre>
</div>

<p>
Here is in action. 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #008000;">"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-constants</span>)
GSL-CONST-MKSA-SPEED-OF-LIGHT
</pre>
</div>

<pre class="example">
299792458.0

</pre>

<p>
We can see there is a docstring on that constant:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-variable 'GSL-CONST-MKSA-SPEED-OF-LIGHT)
</pre>
</div>

<pre class="example">
GSL-CONST-MKSA-SPEED-OF-LIGHT's value is 299792458.0


  This variable can be risky when used as a file-local variable.

Documentation:
Speed of light in vacuum (m/s).

For more information check the manuals.

</pre>


<p>
It is worth thinking about what we accomplished here. The value of each constant in GSL is stored in a header file. The units are stored in a comment next to the value, and the documentation is in an html page somewhere. It is not easy to introspect that! Getting it all into an Emacs variable makes that more introspectable, and findable. That means while typing elisp code you will get completion on these variables. Check this out:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(apropos-variable <span style="color: #008000;">"GSL-*"</span>)
(<span style="color: #0000FF;">with-current-buffer</span> <span style="color: #008000;">"*Apropos*"</span> (buffer-string))
</pre>
</div>

<pre class="example">
Type RET on a type label to view its full documentation.

GSL-CONST-MKSA-PLANCKS-CONSTANT-H
  Variable: Plank's constant, h
GSL-CONST-MKSA-SPEED-OF-LIGHT
  Variable: Speed of light in vacuum (m/s).

</pre>

<p>
It seems like it might be possible to partially automate creation of this module by parsing the gsl_const*.h files. There is no automating adding the doc strings though, I am pretty sure that will have to be done by hand ;(
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/10/Adding-GSL-constants-to-Emacs-in-a-dynamic-module#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module/" rel="bookmark" title="Permanent Link to Adding a GSL integration function to Emacs with a dynamic module">Adding a GSL integration function to Emacs with a dynamic module</a></h2>
      <p><small><span class="blog_post_date">Posted July 09, 2017 at 07:22 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/dynamic-module/'>dynamic-module</a>, <a href='/blog/category/integration/'>integration</a>, <a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated July 11, 2017 at 07:37 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
Here we work out how to run this program: <a href="https://www.gnu.org/software/gsl/doc/html/integration.html#adaptive-integration-example">https://www.gnu.org/software/gsl/doc/html/integration.html#adaptive-integration-example</a> in a dynamic module in emacs. The goal is to be able to evaluate \(\int_0^1 x^{-1/2} \log(x) dx\). According to the example page the answer is -4. We will define an integration function that takes at least a function and integration bounds as arguments, and several optional arguments to specify tolerances and limits. In other words we want to evaluate integrals of the form:
</p>

<p>
\(\int_a^b f(x; params) dx\)
</p>

<p>
I want that to happen in an elisp function with a signature like:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) body) a b <span style="color: #6434A3;">&amp;optional</span> params epsabs epsrel limit)
</pre>
</div>

<p>
And that function will return a list containing (result error-estimate). Here is the C-code that makes this happen. It is more complex that the <a href="http://kitchingroup.cheme.cmu.edu/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/">last example</a>, and only compiles with gcc that allows nested functions. I don't know how to write this without that feature. This is more complex also because you have to create a workspace to do the integration inside the function that does the integration. The C-module also has extra code in it to allow for optional arguments.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_integration.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #0000FF;">static</span> <span style="color: #6434A3;">emacs_value</span> <span style="color: #006699;">F_gsl_integrate</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #6434A3;">ptrdiff_t</span> <span style="color: #BA36A5;">nargs</span>, <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[], <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">data</span>)
{
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">nested function - only supported as an extension in gcc</span>
  <span style="color: #6434A3;">double</span> <span style="color: #006699;">f</span> (<span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span>, <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">params</span>) 
  {
    <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fn</span> = args[0];  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">function we will integrate</span>
    <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">x2</span>[] = { env-&gt;make_float(env, x), params };
    <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">y</span> = env-&gt;funcall(env, fn, 2, &amp;x2);   
    
    <span style="color: #0000FF;">return</span> env-&gt;extract_float (env, y);
  }

  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">a</span> = env-&gt;extract_float (env, args[1]);
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">b</span> = env-&gt;extract_float (env, args[2]);

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">default values for optional arguments</span>
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">epsabs</span> = 0.0;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">epsrel</span> = 1e-7;
  <span style="color: #6434A3;">size_t</span> <span style="color: #BA36A5;">limit</span> = 1000;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">result</span>, <span style="color: #BA36A5;">error</span>; 

  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Here is how I handle the optional arguments</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">(gsl-integrate func a b params epsabs epsrel limit)</span>
  <span style="color: #6434A3;">gsl_function</span> <span style="color: #BA36A5;">F</span>;
  F.function = &amp;f;
  <span style="color: #0000FF;">if</span> (nargs &gt;= 4) {F.params = args[3];}
  <span style="color: #0000FF;">if</span> (nargs &gt;= 5 &amp;&amp; env-&gt;is_not_nil(env, args[4])) {epsabs = env-&gt;extract_float(env, args[4]);}
  <span style="color: #0000FF;">if</span> (nargs &gt;= 6 &amp;&amp; env-&gt;is_not_nil(env, args[5])) {epsrel = env-&gt;extract_float(env, args[5]);}
  <span style="color: #0000FF;">if</span> (nargs &gt;= 7 &amp;&amp; env-&gt;is_not_nil(env, args[6])) {limit = env-&gt;extract_integer(env, args[6]);}

  <span style="color: #6434A3;">gsl_integration_workspace</span> * <span style="color: #BA36A5;">w</span> = gsl_integration_workspace_alloc (limit);

  gsl_integration_qags (&amp;F, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">gsl_function pointer</span>
                        a, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">lower integration bound</span>
                        b, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">upper integration bound</span>
                        epsabs, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">absolute error tolerance</span>
                        epsrel, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">relative error tolerance</span>
                        limit, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">max number of subintervals for integration</span>
                        w, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">the workspace</span>
                        <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">pointers to put results and error in</span>
                        &amp;result, &amp;error);

  gsl_integration_workspace_free (w);
    
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">make a list of (result error) to return</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qlist</span> = env-&gt;intern(env, <span style="color: #008000;">"list"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qresult</span> = env-&gt;make_float (env, result);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qerror</span> = env-&gt;make_float (env, error);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">list_args</span>[] = { Qresult, Qerror };
  <span style="color: #0000FF;">return</span> env-&gt;funcall(env, Qlist, 2, list_args);
}

<span style="color: #6434A3;">int</span> <span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
  <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">Here we create the function.</span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fset</span> = env-&gt;intern(env, <span style="color: #008000;">"fset"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[2];
  args[0] = env-&gt;intern(env, <span style="color: #008000;">"gsl-integration-qags"</span>); <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">symbol to create for function</span>
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">The function we set that symbol to.</span>
  args[1] = env-&gt;make_function(env,
                               3, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">min nargs</span>
                               7, <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">max nargs</span>
                               F_gsl_integrate,
                               <span style="color: #008000;">"(gsl-integration-qags F A B &amp;optional PARAMS EPSABS EPSREL LIMIT)\n"</span> \
                               <span style="color: #008000;">"Integrate F(x; params) from A to B.\n"</span> \
                               <span style="color: #008000;">"F is a function of a single variable and parameters.\n"</span> \
                               <span style="color: #008000;">"A is the lower bound of integration\n"</span>  \
                               <span style="color: #008000;">"B is the upper bound of integration.\n"</span> \
                               <span style="color: #008000;">"Optional parameters:\n"</span>\
                               <span style="color: #008000;">"PARAMS is a list of params to pass to F.\n"</span> \
                               <span style="color: #008000;">"EPSABS is a float (default 0.0) and is the absolute error tolerance.\n"</span> \
                               <span style="color: #008000;">"EPSREL is a float (default 1e-7) and is the relative error tolerance.\n"</span> \
                               <span style="color: #008000;">"LIMIT is the maximum number of subintervals for the integration (default 1000).\n"</span> \
                               <span style="color: #008000;">"Returns (list result error-estimate).\n"</span> \
                               <span style="color: #008000;">"See https://www.gnu.org/software/gsl/manual/html_node/QAGS-adaptive-integration-with-singularities.html."</span>,
                               0);
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">This is basically (fset 'gsl-integration-qags (lambda func))</span>
  env-&gt;funcall(env, fset, 2, args);
  
  <span style="color: #8D8D84;">// </span><span style="color: #8D8D84; font-style: italic;">This is what allows the shared library to provide a feature </span>
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide</span> = env-&gt;intern(env, <span style="color: #008000;">"provide"</span>);
  <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide_args</span>[] = { env-&gt;intern(env, <span style="color: #008000;">"gsl-integration"</span>) };
  env-&gt;funcall(env, provide, 1, provide_args);
  
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
Building this was moderately tricky. It appears the first gcc on my path uses clang which does not support nested functions in C. I don't know enough C to figure out how to do this without a nested function though, since the function has to be defined at run-time based on the emacs env and args. gcc does support inline functions, so the code below uses a gcc that does compile it.
</p>

<div class="org-src-container">
<pre class="src src-sh">rm -f gsl-integration.so gsl-integration.o
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6 -Wall -I/usr/local/include -fPIC -c gsl-integration.c
/usr/local/Cellar/gcc/6.1.0/bin/gcc-6  -shared -L/usr/local/include -lgsl -o gsl-integration.so gsl-integration.o
</pre>
</div>

<p>
Now we add this directory to our path since it is not on it and require our new module.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #008000;">"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-integration</span>)
</pre>
</div>

<pre class="example">
gsl-integration

</pre>

<p>
Let us see our new function in action. We evaluate \(\int_0^1 x^{-1/2} \log(x) dx\). According to the example page the answer is -4. Here is an example where we ignore the parameters. You have to be careful; Emacs sometimes segfaults and crashes if you use an integer or float argument when it expects the other type.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (/ (log x) (sqrt x))) 0.0 1.0)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">-4.000000000000085</td>
<td class="org-right">1.354472090042691e-13</td>
</tr>
</tbody>
</table>

<p>
Here are some optional arguments. 
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (/ (log x) (sqrt x))) 0.0 1.0 nil nil 0.01)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">-4.000000000000075</td>
<td class="org-right">0.019526557540360034</td>
</tr>
</tbody>
</table>

<p>
Nice, with a larger epsrel argument we get a larger error. Note the arguments are positional, so we have to include them all just to set the epsrel argument. How about an easier example with parameters that we actually use. Here we integrate a constant, and set the value of the constant from the params arg. The integral should be the area of a rectangle of length 1 and width of the param we use.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(list
 (gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (first params)) 0.0 1.0 '(1.0))
 (gsl-integration-qags (<span style="color: #0000FF;">lambda</span> (x params) (first params)) 0.0 1.0 '(0.5)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1.0</td>
<td class="org-right">1.1102230246251565e-14</td>
</tr>

<tr>
<td class="org-right">0.5</td>
<td class="org-right">5.551115123125783e-15</td>
</tr>
</tbody>
</table>

<p>
Wow! It actually works!!! That was harder won success than usual for me. I am claiming victory for now and leaving the following notes to future me:
</p>

<ol class="org-ol">
<li>It would be nice to have optional keyword arguments. This would take some handling of the arguments beyond what I know how to do for now, unless it is possible to pull in something like plist-get the way we pull in fset, provide and list in this example.</li>
<li>Error checking on types would be helpful. It is not good for Emacs to crash because 0 is not 0.0!</li>
<li>In numpy there is often a feature to get full_output. Here, the workspace created in the function has more information available in a struct that might be helpful to have access to at times. It seems like it might be possible to get that here too.</li>
</ol>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/09/Adding-a-GSL-integration-function-to-Emacs-with-a-dynamic-module#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Adding-numerical-methods-to-emacs-with-dynamic-modules"></div>
      <h2 class="blog_post_title"><a href="/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules/" rel="bookmark" title="Permanent Link to Adding numerical methods to emacs with dynamic modules">Adding numerical methods to emacs with dynamic modules</a></h2>
      <p><small><span class="blog_post_date">Posted July 08, 2017 at 10:12 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/emacs/'>emacs</a></span> | tags: 
        | <a href="http://jkitchin.github.io/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules#disqus_thread">View Comments</a>
      <p><small><span class="blog_post_date">Updated July 09, 2017 at 07:31 AM</span>
      </small></p>
    </header>
    <div class="post_prose">
      



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org35cb5dc">1. Using the GSL to calculate a Bessel function value</a></li>
<li><a href="#orgfee9627">2. A GSL dynamic module for a Bessel function</a></li>
<li><a href="#orgfedab6e">3. Summary</a></li>
</ul>
</div>
</div>
<p>
There is a relatively new feature in Emacs 25 that allows you to extend Emacs using compiled libraries (<a href="http://diobla.info/blog-archive/modules-tut.html">http://diobla.info/blog-archive/modules-tut.html</a>). This could be very helpful in a few ways:
</p>

<ol class="org-ol">
<li>To add functionality that exists in other libraries, e.g.
<ol class="org-ol">
<li><a href="https://github.com/syohex/emacs-libyaml">libyaml</a></li>
<li><a href="https://github.com/syohex/emacs-memcached">libmemcached</a></li>
<li><a href="https://github.com/syohex/emacs-mruby-test">Embedding Ruby in Emacs</a></li>
</ol></li>
<li>Interface Emacs with hardware, e.g. <a href="http://nullprogram.com/blog/2016/11/05/">a joystick</a>, or <a href="https://github.com/syohex/emacs-eject">ejecting a CD</a>.</li>
<li>To speed up slow elisp functions
<ol class="org-ol">
<li>A c implementation of a fibonacci function is 150 times faster than an elisp version <a href="https://coldnew.github.io/2d16cc25/">here</a>.</li>
<li>This <a href="https://github.com/syohex/emacs-parson">json parser</a> is up to 4 times faster than the json.el library for some operations.</li>
</ol></li>
</ol>

<p>
I am interested in this in particular to bring numerical methods into Emacs. It is fair to ask why. Even I think the numpy/scipy/matplotlib Python stack is currently unparalleled in functionality for scientific programming. But I like writing elisp code so much more! So, we will take a look today at a simple example of integrating a function from the GNU Scientific Library into Emacs.
</p>

<div id="outline-container-org35cb5dc" class="outline-2">
<h2 id="org35cb5dc"><span class="section-number-2">1</span> Using the GSL to calculate a Bessel function value</h2>
<div class="outline-text-2" id="text-1">
<p>
A canonical example of using the GSL is given at <a href="https://www.gnu.org/software/gsl/manual/html_node/An-Example-Program.html">https://www.gnu.org/software/gsl/manual/html_node/An-Example-Program.html</a>. Here it is for reference. It just calculates a value for a Bessel function. We save this program in a file called example.c.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;stdio.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_sf_bessel.h&gt;</span>

<span style="color: #6434A3;">int</span>
<span style="color: #006699;">main</span> (<span style="color: #6434A3;">void</span>)
{
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span> = 5.0;
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">y</span> = gsl_sf_bessel_J0 (x);
  printf (<span style="color: #008000;">"J0(%g) = %.18e\n"</span>, x, y);
  <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
We have to compile and run this program. Here are the commands to do that.
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -Wall -I/usr/local/include/ -c example.c
gcc -L/usr/local/include -lgsl example.o 
./a.out
</pre>
</div>

<p>
That is a lot of code and steps to get one number. 
</p>

<p>
What I would like to do instead is this:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-sf-bessel</span>)
(gsl-sf-bessel-J0 5)
</pre>
</div>

<p>
So, enter the dynamic module!
</p>
</div>
</div>

<div id="outline-container-orgfee9627" class="outline-2">
<h2 id="orgfee9627"><span class="section-number-2">2</span> A GSL dynamic module for a Bessel function</h2>
<div class="outline-text-2" id="text-2">
<p>
To create the dynamic module we need a small c file that wraps the GSL function and adds it to the Emacs environment. Here is the smallest example I could come up with for this one function.  Basically, we create a function that takes the emacs environment and arguments, extract what we want from them, and use that to calculate what we need and return it to the environment. Then we register that function  and define what the module provides in emacs_module_init.
</p>

<div class="org-src-container">
<pre class="src src-c"><span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;assert.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">&lt;gsl/gsl_sf_bessel.h&gt;</span>
<span style="color: #808080;">#include</span> <span style="color: #008000;">"emacs-module.h"</span>

<span style="color: #6434A3;">int</span> <span style="color: #BA36A5;">plugin_is_GPL_compatible</span>;

<span style="color: #0000FF;">static</span> <span style="color: #6434A3;">emacs_value</span>
<span style="color: #006699;">F_gsl_sf_bessel_J0</span> (<span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span>, <span style="color: #6434A3;">ptrdiff_t</span> <span style="color: #BA36A5;">nargs</span>, <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">args</span>[], <span style="color: #6434A3;">void</span> *<span style="color: #BA36A5;">data</span>)
{
  assert (nargs == 1);
  <span style="color: #6434A3;">double</span> <span style="color: #BA36A5;">x</span> = env-&gt;extract_float (env, args[0]);
  <span style="color: #0000FF;">return</span> env-&gt;make_float (env, gsl_sf_bessel_J0 (x));
}

<span style="color: #6434A3;">int</span>
<span style="color: #006699;">emacs_module_init</span>(<span style="color: #0000FF;">struct</span> <span style="color: #6434A3;">emacs_runtime</span> *<span style="color: #BA36A5;">ert</span>)
{
        <span style="color: #6434A3;">emacs_env</span> *<span style="color: #BA36A5;">env</span> = ert-&gt;get_environment(ert);

        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">gsl_sf_bessel_J0_fn</span> = env-&gt;make_function(env, 1, 1, F_gsl_sf_bessel_J0, <span style="color: #008000;">"Regular cylindrical Bessel function of zeroth order, J_0(x)"</span>, <span style="color: #D0372D;">NULL</span>);

        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qfset</span> = env-&gt;intern(env, <span style="color: #008000;">"fset"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Q_gsl_sf_bessel_J0</span> = env-&gt;intern(env, <span style="color: #008000;">"gsl-sf-bessel-J0"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">fset_args</span>[] = { Q_gsl_sf_bessel_J0, gsl_sf_bessel_J0_fn };
        env-&gt;funcall(env, Qfset, 2, fset_args);

        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Qprovide</span> = env-&gt;intern(env, <span style="color: #008000;">"provide"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">Q_gsl_sf_bessel</span> = env-&gt;intern(env, <span style="color: #008000;">"gsl-sf-bessel"</span>);
        <span style="color: #6434A3;">emacs_value</span> <span style="color: #BA36A5;">provide_args</span>[] = { Q_gsl_sf_bessel };
        env-&gt;funcall(env, Qprovide, 1, provide_args);

        <span style="color: #0000FF;">return</span> 0;
}
</pre>
</div>

<p>
Now we compile it into a shared library.
</p>

<div class="org-src-container">
<pre class="src src-sh">gcc -Wall -I/usr/local/include -fPIC -c gsl-sf-bessel.c
gcc -shared -L/usr/local/include -lgsl -o gsl-sf-bessel.so gsl-sf-bessel.o
</pre>
</div>

<p>
That creates our shared library in gsl-sf-bessel.so.
</p>

<div class="org-src-container">
<pre class="src src-sh">ls *.so
</pre>
</div>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(add-to-list 'load-path <span style="color: #008000;">"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/dynamic-module/"</span>)
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">gsl-sf-bessel</span>)
(gsl-sf-bessel-J0 5.0)
</pre>
</div>

<pre class="example">
-0.17759677131433826

</pre>

<p>
That is the same answer as we got before. Here is the documentation we defined. It could use some improvement, e.g. to note that the argument has to be a float, and that only one argument is allowed. I am not sure why the signature doesn't show a single argument.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(describe-function 'gsl-sf-bessel-J0)
</pre>
</div>

<pre class="example">
gsl-sf-bessel-J0 is a Lisp function.

(gsl-sf-bessel-J0 &amp;rest ARGS)

For more information check the manuals.

Regular cylindrical Bessel function of zeroth order, J_0(x)

</pre>

<p>
I am not a very skilled C-programmer yet, so I don't know how hard it would be to make this function accept integers as well, or to vectorize it so you could have an arbitrary number of args to it and return a list.
</p>
</div>
</div>


<div id="outline-container-orgfedab6e" class="outline-2">
<h2 id="orgfedab6e"><span class="section-number-2">3</span> Summary</h2>
<div class="outline-text-2" id="text-3">
<p>
Dynamic modules look promising to extend Emacs with. This example is about the simplest function from the GSL there is. There are many more (<a href="https://www.gnu.org/software/gsl/doc/html/index.html">https://www.gnu.org/software/gsl/doc/html/index.html</a>) functions that do linear algebra on arrays, integration or optimization of functions, interpolation of data, etc. I don't have a sense yet of how easy it will be to integrate these into a module.
</p>

<p>
It looks like you are not limited to writing these in C. There is an example of a plugin written in Rust <a href="https://github.com/lunaryorn/emacs-module.rs/blob/master/src/lib.rs">here</a>, and a framework to write them in <a href="https://github.com/sigma/go-emacs/">Go</a>. Maybe any language that can make a shared library with the required plugin_is_GPL_compatible symbol and emacs_module_init function would work. Those examples do not look significantly easier to write than the C versions though since I am not that fluent in those languages either.
</p>

<p>
There are some challenges to figure out in developing and using dynamic modules. Here are a few:
</p>

<ol class="org-ol">
<li>The documentation on what is possible is not that great yet, so there is a lot of exploring to do. There are a fair number of examples out there though to learn from (<a href="https://github.com/emacs-pe/emacs-modules">https://github.com/emacs-pe/emacs-modules</a>). The <a href="https://github.com/emacs-mirror/emacs/tree/emacs-25/modules/mod-test">official example</a> shows a lot of the functionality.</li>
<li>I guess it will be tricky to distribute these. I don't know how easy it would be to build all the libraries for each platform for distribution on MELPA for example. I don't think there is a standard way to incorporate a compile step in elisp package installation. Also, you need an Emacs version of at least 25 with the dynamic module feature compiled in. It is not yet a default enabled option. The required emacs-module.h should be gotten from the emacs build, so people with binaries might not be able to build it anyway.</li>
<li>Users will need the libraries the dynamic module uses. In this example, they will need libgsl.</li>
<li>Once you require the module, it does not seem possible to modify it, rebuild it, and reload it. It appears you have to close Emacs and reload it. That is tedious.</li>
</ol>

<p>
It would be nice to have a more generic foreign function interface that would allow you to develop more on the elisp side. One effort in that direction is <a href="https://github.com/tromey/emacs-ffi">https://github.com/tromey/emacs-ffi</a>. It looks like it might be a lot simpler to use than creating a dynamic module. Once it is installed, it looks like you can write elisp code to wrap the library functions. I will write about this on another day.
</p>
</div>
</div>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules.org">org-mode source</a></p>
<p>Org-mode version = 9.0.7</p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <div class="after_post"><a href="http://jkitchin.github.io/blog/2017/07/08/Adding-numerical-methods-to-emacs-with-dynamic-modules#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../4">« Previous Page</a>
  --  
 <a href="../6">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2018/01/27/New-publication-in-Topics-in-Catalysis/">New publication in Topics in Catalysis</a></li>
      <li><a href="/blog/2018/01/03/New-publication-in-Molecular-Simulation/">New publication in Molecular Simulation</a></li>
      <li><a href="/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group/">2017 in a nutshell for the Kitchin Research group</a></li>
      <li><a href="/blog/2017/11/29/Solving-an-eigenvalue-differential-equation-with-a-neural-network/">Solving an eigenvalue differential equation with a neural network</a></li>
      <li><a href="/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd/">Solving ODEs with a neural network and autograd</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
        <a href="http://kitchinresearchgroup.disqus.com/latest.rss">Comments RSS Feed</a>.
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2018
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>
  <script>
  (function() {
      var links = document.getElementsByTagName('a');
      var query = '?';
      for(var i = 0; i < links.length; i++) {
          if(links[i].href.indexOf('#disqus_thread') >= 0) {
              query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
          }
      }
      document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/kitchinresearchgroup/get_num_replies.js' + query + '"></' + 'script>');
  })();
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



