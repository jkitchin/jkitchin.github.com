

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-CSTR-design-equations"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/18/Solving-CSTR-design-equations/" rel="bookmark" title="Permanent Link to Solving CSTR design equations">Solving CSTR design equations</a></h2>
      <p><small><span class="blog_post_date">Posted February 18, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 04:29 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
Given a continuously stirred tank reactor with a volume of 66,000 dm^3 where the reaction \(A \rightarrow B\) occurs, at a rate of \(-r_A = k C_A^2\) (\(k=3\) L/mol/h), with an entering molar flow of F_{A0} = 5 mol/h and a volumetric flowrate of 10 L/h, what is the exit concentration of A?
</p>

<p>
From a mole balance we know that at steady state \(0 = F_{A0} - F_A + V r_A\). That equation simply states the sum of the molar flow of A in in minus the molar flow of A out  plus the molar rate A is generated is equal to zero at steady state. This is directly the equation we need to solve. We need the following relationship:
</p>

<ol>
<li>\(F_A = v0 C_A\)
</li>
</ol>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

Fa0 = 5.0
v0 = 10.

V = 66000.0  <span style="color: #ff0000; font-weight: bold;"># reactor volume L^3</span>
k = 3.0      <span style="color: #ff0000; font-weight: bold;"># rate constant L/mol/h</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Ca):
    <span style="color: #228b22;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
    Fa = v0 * Ca     <span style="color: #ff0000; font-weight: bold;"># exit molar flow of A</span>
    ra = -k * Ca**2  <span style="color: #ff0000; font-weight: bold;"># rate of reaction of A L/mol/h</span>
    <span style="color: #8b0000;">return</span> Fa0 - Fa + V * ra

<span style="color: #ff0000; font-weight: bold;"># CA guess that that 90 % is reacted away</span>
CA_guess = 0.1 * Fa0 / v0
CA_sol, = fsolve(func, CA_guess)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The exit concentration is {0} mol/L'</span>.format(CA_sol)
</pre>
</div>

<pre class="example">
The exit concentration is 0.005 mol/L
</pre>

<p>
It is a little confusing why it is necessary to put a comma after the CA_sol in the fsolve command. If you do not put it there, you get brackets around the answer.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Solving-CSTR-design-equations.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/02/18/Solving-CSTR-design-equations">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Integrating-the-batch-reactor-mole-balance"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/18/Integrating-the-batch-reactor-mole-balance/" rel="bookmark" title="Permanent Link to Integrating the batch reactor mole balance">Integrating the batch reactor mole balance</a></h2>
      <p><small><span class="blog_post_date">Posted February 18, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
      <p><small><span class="blog_post_date">Updated March 03, 2013 at 10:36 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
An alternative approach of evaluating an integral is to integrate a differential equation. For the batch reactor, the differential equation that describes conversion as a function of time is:
</p>

<p>
\(\frac{dX}{dt} = -r_A V/N_{A0}\).
</p>

<p>
Given a value of initial concentration, or volume and initial number of moles of A, we can integrate this ODE to find the conversion at some later time. We assume that \(X(t=0)=0\). We will integrate the ODE over a time span of 0 to 10,000 seconds.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

k = 1.0e-3
Ca0 = 1.0  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">mol/L</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(X, t):
    ra = -k * (Ca0 * (1 - X))**2
    <span style="color: #8b0000;">return</span> -ra / Ca0

X0 = 0
tspan = np.linspace(0,10000)

sol = odeint(func, X0, tspan)
plt.plot(tspan,sol)
plt.xlabel(<span style="color: #228b22;">'Time (sec)'</span>)
plt.ylabel(<span style="color: #228b22;">'Conversion'</span>)
plt.savefig(<span style="color: #228b22;">'images/2013-01-06-batch-conversion.png'</span>)
</pre>
</div>

<p><img src="/img/./images/2013-01-06-batch-conversion.png"><p>

<p>
You can read off of this figure to find the time required to achieve a particular conversion.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Integrating-the-batch-reactor-mole-balance.org">org-mode source</a><p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/02/18/Integrating-the-batch-reactor-mole-balance">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Numerical-propagation-of-errors"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/16/Numerical-propagation-of-errors/" rel="bookmark" title="Permanent Link to Numerical propagation of errors">Numerical propagation of errors</a></h2>
      <p><small><span class="blog_post_date">Posted February 16, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated March 07, 2013 at 08:46 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/05/numerical-propogation-of-errors/" >Matlab post</a>
</p>

<p>
Propagation of errors is essential to understanding how the uncertainty in a parameter affects computations that use that parameter. The uncertainty propagates by a set of rules into your solution. These rules are not easy to remember, or apply to complicated situations, and are only approximate for equations that are nonlinear in the parameters.
</p>

<p>
We will use a Monte Carlo simulation to illustrate error propagation. The idea is to generate a distribution of possible parameter values, and to evaluate your equation for each parameter value. Then, we perform statistical analysis on the results to determine the standard error of the results.
</p>

<p>
We will assume all parameters are defined by a normal distribution with known mean and standard deviation.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Addition and subtraction</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

N = 1e6 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of samples of parameters</span>

A_mu = 2.5; A_sigma = 0.4
B_mu = 4.1; B_sigma = 0.3

A = np.random.normal(A_mu, A_sigma, size=(1, N))
B = np.random.normal(B_mu, B_sigma, size=(1, N))

p = A + B
m = A - B

<span style="color: #8b0000;">print</span> np.std(p)
<span style="color: #8b0000;">print</span> np.std(m)

<span style="color: #8b0000;">print</span> np.sqrt(A_sigma**2 + B_sigma**2) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the analytical std dev</span>
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.500505424616
0.500113385681
&gt;&gt;&gt; 0.5
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Multiplication</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python">F_mu = 25.0; F_sigma = 1;
x_mu = 6.4; x_sigma = 0.4;

F = np.random.normal(F_mu, F_sigma, size=(1, N))
x = np.random.normal(x_mu, x_sigma, size=(1, N))

t = F * x
<span style="color: #8b0000;">print</span> np.std(t)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu * x_mu
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 11.8900166284
11.8726576637
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Division</h2>
<div class="outline-text-2" id="text-3">
<p>
This is really like multiplication: F / x = F * (1 / x).
</p>

<div class="org-src-container">

<pre class="src src-python">d = F / x
<span style="color: #8b0000;">print</span> np.std(d)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu / x_mu
</pre>
</div>

<pre class="example">
0.293757533168
0.289859806243
</pre>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> exponents</h2>
<div class="outline-text-2" id="text-4">
<p>
This rule is different than multiplication (A^2 = A*A) because in the previous examples we assumed the errors in A and B for A*B were uncorrelated. in A*A, the errors are not uncorrelated, so there is a different rule for error propagation.
</p>

<div class="org-src-container">

<pre class="src src-python">t_mu = 2.03; t_sigma = 0.01*t_mu; <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1% error</span>
A_mu = 16.07; A_sigma = 0.06;

t = np.random.normal(t_mu, t_sigma, size=(1, N))
A = np.random.normal(A_mu, A_sigma, size=(1, N))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Compute t^5 and sqrt(A) with error propagation</span>
<span style="color: #8b0000;">print</span> np.std(t**5)
<span style="color: #8b0000;">print</span> (5 * t_sigma / t_mu) * t_mu**5
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... 1.72454836176
1.72365440621
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">print</span> np.std(np.sqrt(A))
<span style="color: #8b0000;">print</span> 1.0 / 2.0 * A_sigma / A_mu * np.sqrt(A_mu)
</pre>
</div>

<pre class="example">
0.00748903477329
0.00748364738749
</pre>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> the chain rule in error propagation</h2>
<div class="outline-text-2" id="text-5">
<p>
let v = v0 + a*t, with uncertainties in vo,a and t
</p>

<div class="org-src-container">

<pre class="src src-python">vo_mu = 1.2; vo_sigma = 0.02;
a_mu = 3.0;  a_sigma  = 0.3;
t_mu = 12.0; t_sigma  = 0.12;

vo = np.random.normal(vo_mu, vo_sigma, (1, N))
a = np.random.normal(a_mu, a_sigma, (1, N))
t = np.random.normal(t_mu, t_sigma, (1, N))

v = vo + a*t

<span style="color: #8b0000;">print</span> np.std(v)
<span style="color: #8b0000;">print</span> np.sqrt(vo_sigma**2 + t_mu**2 * a_sigma**2 + a_mu**2 * t_sigma**2)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 3.62232509326
3.61801050303
</pre>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">

<p>
You can numerically perform error propagation analysis if you know the underlying distribution of errors on the parameters in your equations. One benefit of the numerical propogation is you do not have to remember the error propagation rules, and you directly look at the distribution in nonlinear cases. Some limitations of this approach include
</p>

<ol>
<li>You have to know the distribution of the errors in the parameters
</li>
<li>You have to assume the errors in parameters are uncorrelated.
</li>
</ol>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/16/Numerical-propagation-of-errors.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/02/16/Numerical-propagation-of-errors">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Numerical-propogation-of-errors"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/16/Numerical-propogation-of-errors/" rel="bookmark" title="Permanent Link to Numerical propogation of errors">Numerical propogation of errors</a></h2>
      <p><small><span class="blog_post_date">Posted February 16, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/statistics/'>statistics</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated February 27, 2013 at 02:36 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/05/numerical-propogation-of-errors/" >Matlab post</a>
</p>

<p>
Propagation of errors is essential to understanding how the uncertainty in a parameter affects computations that use that parameter. The uncertainty propogates by a set of rules into your solution. These rules are not easy to remember, or apply to complicated situations, and are only approximate for equations that are nonlinear in the parameters.
</p>

<p>
We will use a Monte Carlo simulation to illustrate error propogation. The idea is to generate a distribution of possible parameter values, and to evaluate your equation for each parameter value. Then, we perform statistical analysis on the results to determine the standard error of the results.
</p>

<p>
We will assume all parameters are defined by a normal distribution with known mean and standard deviation.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Addition and subtraction</h2>
<div class="outline-text-2" id="text-1">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

N = 1e6 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of samples of parameters</span>

A_mu = 2.5; A_sigma = 0.4
B_mu = 4.1; B_sigma = 0.3

A = np.random.normal(A_mu, A_sigma, size=(1, N))
B = np.random.normal(B_mu, B_sigma, size=(1, N))

p = A + B
m = A - B

<span style="color: #8b0000;">print</span> np.std(p)
<span style="color: #8b0000;">print</span> np.std(m)

<span style="color: #8b0000;">print</span> np.sqrt(A_sigma**2 + B_sigma**2) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the analytical std dev</span>
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.500505424616
0.500113385681
&gt;&gt;&gt; 0.5
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Multiplication</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python">F_mu = 25.0; F_sigma = 1;
x_mu = 6.4; x_sigma = 0.4;

F = np.random.normal(F_mu, F_sigma, size=(1, N))
x = np.random.normal(x_mu, x_sigma, size=(1, N))

t = F * x
<span style="color: #8b0000;">print</span> np.std(t)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu * x_mu
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 11.8900166284
11.8726576637
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Division</h2>
<div class="outline-text-2" id="text-3">
<p>
This is really like multiplication: F / x = F * (1 / x).
</p>

<div class="org-src-container">

<pre class="src src-python">d = F / x
<span style="color: #8b0000;">print</span> np.std(d)
<span style="color: #8b0000;">print</span> np.sqrt((F_sigma / F_mu)**2 + (x_sigma / x_mu)**2) * F_mu / x_mu
</pre>
</div>

<pre class="example">
0.293757533168
0.289859806243
</pre>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> exponents</h2>
<div class="outline-text-2" id="text-4">
<p>
This rule is different than multiplication (A^2 = A*A) because in the previous examples we assumed the errors in A and B for A*B were uncorrelated. in A*A, the errors are not uncorrelated, so there is a different rule for error propagation.
</p>

<div class="org-src-container">

<pre class="src src-python">t_mu = 2.03; t_sigma = 0.01*t_mu; <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1% error</span>
A_mu = 16.07; A_sigma = 0.06;

t = np.random.normal(t_mu, t_sigma, size=(1, N))
A = np.random.normal(A_mu, A_sigma, size=(1, N))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Compute t^5 and sqrt(A) with error propogation</span>
<span style="color: #8b0000;">print</span> np.std(t**5)
<span style="color: #8b0000;">print</span> (5 * t_sigma / t_mu) * t_mu**5
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... 1.72454836176
1.72365440621
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">print</span> np.std(np.sqrt(A))
<span style="color: #8b0000;">print</span> 1.0 / 2.0 * A_sigma / A_mu * np.sqrt(A_mu)
</pre>
</div>

<pre class="example">
0.00748903477329
0.00748364738749
</pre>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> the chain rule in error propogation</h2>
<div class="outline-text-2" id="text-5">
<p>
let v = v0 + a*t, with uncertainties in vo,a and t
</p>

<div class="org-src-container">

<pre class="src src-python">vo_mu = 1.2; vo_sigma = 0.02;
a_mu = 3.0;  a_sigma  = 0.3;
t_mu = 12.0; t_sigma  = 0.12;

vo = np.random.normal(vo_mu, vo_sigma, (1, N))
a = np.random.normal(a_mu, a_sigma, (1, N))
t = np.random.normal(t_mu, t_sigma, (1, N))

v = vo + a*t

<span style="color: #8b0000;">print</span> np.std(v)
<span style="color: #8b0000;">print</span> np.sqrt(vo_sigma**2 + t_mu**2 * a_sigma**2 + a_mu**2 * t_sigma**2)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 3.62232509326
3.61801050303
</pre>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">

<p>
You can numerically perform error propogation analysis if you know the underlying distribution of errors on the parameters in your equations. One benefit of the numerical propogation is you do not have to remember the error propogation rules, and you directly look at the distribution in nonlinear cases. Some limitations of this approach include
</p>

<ol>
<li>You have to know the distribution of the errors in the parameters
</li>
<li>You have to assume the errors in parameters are uncorrelated.
</li>
</ol>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/16/Numerical-propogation-of-errors.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/02/16/Numerical-propogation-of-errors">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Plane-Poiseuille-flow-BVP-solve-by-shooting-method"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/02/15/Plane-Poiseuille-flow-BVP-solve-by-shooting-method/" rel="bookmark" title="Permanent Link to Plane Poiseuille flow - BVP solve by shooting method">Plane Poiseuille flow - BVP solve by shooting method</a></h2>
      <p><small><span class="blog_post_date">Posted February 15, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/bvp/'>bvp</a></span> | tags: <a href='/blog/tag/fluids/'>fluids</a>
      <p><small><span class="blog_post_date">Updated March 08, 2013 at 10:08 AM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/08/plane-poiseuille-flow-bvp-solve-by-shooting-method/" >Matlab post</a>
</p>

<p>
One approach to solving BVPs is to use the shooting method. The reason we cannot use an initial value solver for a BVP is that there is not enough information at the initial value to start. In the shooting method, we take the function value at the initial point, and guess what the function derivatives are so that we can do an integration. If our guess was good, then the solution will go through the known second boundary point. If not, we guess again, until we get the answer we need. In this example we repeat the pressure driven flow example, but illustrate the shooting method.
</p>

<p>
In the pressure driven flow of a fluid with viscosity \(\mu\) between two stationary plates separated by distance \(d\) and driven by a pressure drop \(\Delta P/\Delta x\), the governing equations on the velocity \(u\) of the fluid are (assuming flow in the x-direction with the velocity varying only in the y-direction):
</p>

<p>
$$\frac{\Delta P}{\Delta x} = \mu \frac{d^2u}{dy^2}$$
</p>

<p>
with boundary conditions \(u(y=0) = 0\) and \(u(y=d) = 0\), i.e. the no-slip condition at the edges of the plate.
</p>

<p>
we convert this second order BVP to a system of ODEs by letting \(u_1 = u\), \(u_2 = u_1'\) and then \(u_2' = u_1''\). This leads to:
</p>

<p>
\(\frac{d u_1}{dy} = u_2\)
</p>

<p>
\(\frac{d u_2}{dy} = \frac{1}{\mu}\frac{\Delta P}{\Delta x}\)
</p>

<p>
with boundary conditions \(u_1(y=0) = 0\) and \(u_1(y=d) = 0\).
</p>

<p>
for this problem we let the plate separation be d=0.1, the viscosity \(\mu = 1\), and \(\frac{\Delta P}{\Delta x} = -100\).
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> First guess</h2>
<div class="outline-text-2" id="text-1">
<p>
We need u_1(0) and u_2(0), but we only have u_1(0). We need to guess a value for u_2(0) and see if the solution goes through the u_2(d)=0 boundary value.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    mu = 1
    Pdrop = -100
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

u1_0 = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">known</span>
u2_0 = 1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">guessed</span>

dspan = np.linspace(0, d)

U = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0])
plt.plot([d],[0], <span style="color: #228b22;">'ro'</span>)
plt.xlabel(<span style="color: #228b22;">'d'</span>)
plt.ylabel(<span style="color: #228b22;">'$u_1$'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-1.png"><p>

<p>
Here we have undershot the boundary condition. Let us try a larger guess.
</p>
</div>
</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Second guess</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    mu = 1
    Pdrop = -100
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

u1_0 = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">known</span>
u2_0 = 10 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">guessed</span>

dspan = np.linspace(0, d)

U = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0])
plt.plot([d],[0], <span style="color: #228b22;">'ro'</span>)
plt.xlabel(<span style="color: #228b22;">'d'</span>)
plt.ylabel(<span style="color: #228b22;">'$u_1$'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-2.png"><p>

<p>
Now we have clearly overshot. Let us now make a function that will iterate for us to find the right value.
</p>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Let fsolve do the work</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>
Pdrop = -100
mu = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

u1_0 = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">known</span>
dspan = np.linspace(0, d)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(u2_0):
    dspan = np.linspace(0, d)
    U = odeint(odefun, [u1_0, u2_0], dspan)
    u1 = U[:,0]
    <span style="color: #8b0000;">return</span> u1[-1]

u2_0, = fsolve(objective, 1.0)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now solve with optimal u2_0</span>
U = odeint(odefun, [u1_0, u2_0], dspan)

plt.plot(dspan, U[:,0], label=<span style="color: #228b22;">'Numerical solution'</span>)
plt.plot([d],[0], <span style="color: #228b22;">'ro'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plot an analytical solution</span>
u = -(Pdrop) * d**2 / 2 / mu * (dspan / d - (dspan / d)**2)
plt.plot(dspan, u, <span style="color: #228b22;">'r--'</span>, label=<span style="color: #228b22;">'Analytical solution'</span>)


plt.xlabel(<span style="color: #228b22;">'d'</span>)
plt.ylabel(<span style="color: #228b22;">'$u_1$'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-3.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-3.png"><p>

<p>
You can see the agreement is excellent!
</p>

<p>
This also seems like a useful bit of code to not have to reinvent regularly, so it has been added to pycse as BVP_sh. Here is an example usage.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> BVP_sh
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

d = 0.1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plate thickness</span>
Pdrop = -100
mu = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefun</span>(U, y):
    u1, u2 = U
    du1dy = u2
    du2dy = 1.0 / mu * Pdrop
    <span style="color: #8b0000;">return</span> [du1dy, du2dy]

x1 = 0.0; alpha = 0.0
x2 = 0.1; beta = 0.0
init = 2.0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guess of slope at x=0</span>

X,Y = BVP_sh(odefun, x1, x2, alpha, beta, init)
plt.plot(X, Y[:,0])
plt.ylim([0, 0.14])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plot an analytical solution</span>
u = -(Pdrop) * d**2 / 2 / mu * (X / d - (X / d)**2)
plt.plot(X, u, <span style="color: #228b22;">'r--'</span>, label=<span style="color: #228b22;">'Analytical solution'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-shooting-4.png'</span>)
plt.show()
</pre>
</div>

<p><img src="/img/./images/bvp-shooting-4.png"><p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/15/Plane-Poiseuille-flow---BVP-solve-by-shooting-method.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/02/15/Plane-Poiseuille-flow-BVP-solve-by-shooting-method">Discuss on Twitter</a>

  <hr class="interblog" />
 <a href="../105">« Previous Page</a>
  --  
 <a href="../107">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2023/02/01/Caching-expensive-function-calls-so-you-don-t-have-to-rerun-them/">Caching expensive function calls so you don't have to rerun them</a></li>
      <li><a href="/blog/2023/01/01/2022-in-a-nutshell/">2022 in a nutshell</a></li>
      <li><a href="/blog/2022/09/29/New-publication-Identifying-limitations-in-screening-high-throughput-photocatalytic-bimetallic-nanoparticles-with-machine-learned-hydrogen-adsorptions/">New publication - Identifying limitations in screening high-throughput photocatalytic bimetallic nanoparticles with machine-learned hydrogen adsorptions</a></li>
      <li><a href="/blog/2022/09/12/New-publication-Neural-network-embeddings-based-similarity-search-method-for-atomistic-systems/">New publication - Neural network embeddings based similarity search method for atomistic systems</a></li>
      <li><a href="/blog/2022/03/07/New-publication-Evaluation-of-the-Degree-of-Rate-Control-via-Automatic-Differentiation/">New publication - Evaluation of the Degree of Rate Control via Automatic Differentiation</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2023
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
  <script>
      var _gaq=[['_setAccount','UA-35731398-1'],['_trackPageview']];
      (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
      g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g,s)}(document,'script'));
  </script>

  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



