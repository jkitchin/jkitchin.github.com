<?xml version="1.0" encoding="UTF-8"?>

<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
  >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2018-05-21T17:02:08Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Literate programming with python doctests]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/05/17/Literate-programming-with-python-doctests" />
    <id>http://jkitchin.github.io/blog/2018/05/17/Literate-programming-with-python-doctests</id>
    <updated>2018-05-18T15:07:13Z</updated>
    <published>2018-05-17T16:41:19Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="noweb" />
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <summary type="html"><![CDATA[Literate programming with python doctests]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/05/17/Literate-programming-with-python-doctests"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org91f890f"&gt;1. Add a way to run the tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4759a84"&gt;2. Tangle the file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8727607"&gt;3. Run the tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5a82a2f"&gt;4. The noweb doctest block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
On the org-mode mailing list we had a nice discussion about using noweb and org-mode in literate programming. The results of that discussion were blogged about &lt;a href="http://kdr2.com/tech/emacs/1805-approach-org-ref-code-to-text.html"&gt;here&lt;/a&gt;. I thought of a different application of this for making &lt;a href="https://pymotw.com/3/doctest/"&gt;doctests&lt;/a&gt; in Python functions. I have to confess I have never liked these because I have always thought they were a pain to write since you basically have to put code and results into a docstring. The ideas developed in the discussion above led me to think of a new way to write these that seems totally reasonable.
&lt;/p&gt;

&lt;p&gt;
The idea is just to put noweb placeholders in the function docstring for the doctests. The placeholders will be expanded when you tangle the file, and they will get their contents from other src-blocks where you have written and run examples to test them.
&lt;/p&gt;

&lt;p&gt;
This video might make the rest of this post easier to follow:
&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/u8CWbedVV9Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;
I will illustrate the idea using org-mode and the ob-ipython I have in scimax. The defaults of my ob-ipython setup are not useful for this example because it puts the execution count and mime types of output in the output. These are not observed in a REPL, and so we turn this off by setting these variables.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ob-ipython-suppress-execution-count t
      ob-ipython-show-mime-types nil)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we make an example function that takes a single argument and returns one divided by that argument. This block is runnable, and the function is then defined in the jupyter kernel. The docstring contains several noweb references to doctest blocks we define later. For now, they don't do anything. See &lt;a href="#org5a82a2f"&gt;The noweb doctest block&lt;/a&gt; section for the block that is used to expand these. This block also has a tangle header which indicates the file to tangle the results to. When I run this block, it is sent to a Jupyter kernel and saved in memory for use in subsequent blocks.
&lt;/p&gt;

&lt;p&gt;
Here is the block with no noweb expansion. Note that this is easier to read in the original org source than it is to read in the published blog format.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;func&lt;/span&gt;(a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"""A function to divide one by a.&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   &amp;lt;&amp;lt;doctest("doctest-1")&amp;gt;&amp;gt;&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   &amp;lt;&amp;lt;doctest("doctest-2")&amp;gt;&amp;gt;&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   &amp;lt;&amp;lt;doctest("doctest-3")&amp;gt;&amp;gt;&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   Returns: 1 / a.&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   """&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 / a

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we can write a series of named blocks that define various tests we might want to use as doctests. You can run these blocks here, and verify they are correct. Later, when we tangle the document, these will be incorporated into the tangled file in the docstring we defined above.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org4eaeeaf"&gt;func(5) == 0.2
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
True

&lt;/pre&gt;



&lt;p&gt;
This next test will raise an Exception, and we just run it to make sure it does.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org560fcaf"&gt;func(0)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

ZeroDivisionErrorTraceback (most recent call last)
&amp;lt;ipython-input-6-ba0cd5a88f0a&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 func(0)

&amp;lt;ipython-input-1-eafd354a3163&amp;gt; in func(a)
     18     Returns: 1 / a.
     19     """
---&amp;gt; 20     return 1 / a

ZeroDivisionError: division by zero

&lt;/pre&gt;



&lt;p&gt;
This is just a doctest with indentation to show how it is used.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org968debf"&gt;&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; i &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(1, 4):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(func(i))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1.0
0.5
0.3333333333333333


&lt;/pre&gt;



&lt;p&gt;
That concludes the examples I want incorporated into the doctests. Each one of these blocks has a name, which is used as an argument to the noweb references in the function docstring.
&lt;/p&gt;

&lt;div id="outline-container-org91f890f" class="outline-2"&gt;
&lt;h2 id="org91f890f"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Add a way to run the tests&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This is a common idiom to enable easy running of the doctests. This will get tangled out to the file.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;__name__&lt;/span&gt; == &lt;span style="color: #008000;"&gt;"__main__"&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; doctest
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   doctest.testmod()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4759a84" class="outline-2"&gt;
&lt;h2 id="org4759a84"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Tangle the file&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
So far, the Python code we have written only exists in the org-file, and in memory. Tangling is the extraction of the code into a code file.
&lt;/p&gt;

&lt;p&gt;
We run this command, which extracts the code blocks marked for tangling, and expands the noweb references in them.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-babel-tangle)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;test.py&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here is what we get:
&lt;/p&gt;

&lt;pre class="example"&gt;
def func(a):
    """A function to divide one by a.

    &amp;gt;&amp;gt;&amp;gt; func(5) == 0.2
    True

    &amp;gt;&amp;gt;&amp;gt; func(0)
    Traceback (most recent call last):
    ZeroDivisionError: division by zero

    &amp;gt;&amp;gt;&amp;gt; for i in range(1, 4):
    ...     print(func(i))
    1.0
    0.5
    0.3333333333333333


    Returns: 1 / a.
    """
    return 1 / a

if __name__ == "__main__":
    import doctest
    doctest.testmod()

&lt;/pre&gt;

&lt;p&gt;
That looks like a reasonable python file. You can see the doctest blocks have been inserted into the docstring, as desired. The proof of course is that we can run these doctests, and use the python module. We show that next.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org8727607" class="outline-2"&gt;
&lt;h2 id="org8727607"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Run the tests&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Now, we can check if the tests pass in a fresh run (i.e. not using the version stored in the jupyter kernel.) The standard way to run the doctests is like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;python test.py -v
&lt;/pre&gt;
&lt;/div&gt;




&lt;p&gt;
Well, that's it! It worked fine. Now we have a python file we can import and reuse, with some doctests that show how it works. For example, here it is in a small Python script.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; test &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; func
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(func(3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0.3333333333333333

&lt;/pre&gt;



&lt;p&gt;
There are surely some caveats to keep in mind here. This was just a simple proof of concept idea that isn't tested beyond this example. I don't know how many complexities would arise from more complex doctests. But, it seems like a good idea to continue pursuing if you like using doctests, and like using org-mode and interactive/literate programming techniques.
&lt;/p&gt;

&lt;p&gt;
It is definitely an interesting way to use noweb to build up better code files in my opinion.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5a82a2f" class="outline-2"&gt;
&lt;h2 id="org5a82a2f"&gt;&lt;a id="ID-D4437A03-A9D0-4B6D-B254-5F03CFB25F95"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; The noweb doctest block&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
These blocks are used in the noweb expansions. Each block takes a variable which is the name of a block. This block grabs the body of the named src block and formats it as if it was in a REPL.
&lt;/p&gt;

&lt;p&gt;
We also grab the results of the named block and format it for the doctest. We use a heuristic to detect Tracebacks and modify the output to be consistent with it. In that case we assume the relevant Traceback is on the last line.
&lt;/p&gt;

&lt;p&gt;
Admittedly, this does some fragile feeling things, like trimming whitespace here and there to remove blank lines, and quoting quotes (which was not actually used in this example), and removing the ": " pieces of ob-ipython results. Probably other ways of running the src-blocks would not be that suitable for this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org52486c2"&gt;(org-babel-goto-named-src-block name)
(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((src (s-trim-right (org-element-property &lt;span style="color: #006FE0;"&gt;:value&lt;/span&gt; (org-element-context))))
       (src-lines (split-string src &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;))
       body result)
  (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; body
        (s-trim-right
         (s-concat &lt;span style="color: #008000;"&gt;"&amp;gt;&amp;gt;&amp;gt; "&lt;/span&gt; (car src-lines) &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;
                   (s-join &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                                          (concat &lt;span style="color: #008000;"&gt;"... "&lt;/span&gt; s))
                                        (cdr src-lines))))))
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now the results&lt;/span&gt;
  (org-babel-goto-named-result name)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((result (org-element-context)))
    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; result
          (&lt;span style="color: #0000FF;"&gt;thread-last&lt;/span&gt;
              (buffer-substring (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-begin&lt;/span&gt; result)
                                (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-end&lt;/span&gt; result))
            (s-trim)
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;remove ": " from beginning of lines&lt;/span&gt;
            (replace-regexp-in-string &lt;span style="color: #008000;"&gt;"^: *"&lt;/span&gt; &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;quote quotes&lt;/span&gt;
            (replace-regexp-in-string &lt;span style="color: #008000;"&gt;"\\\""&lt;/span&gt; &lt;span style="color: #008000;"&gt;"\\\\\""&lt;/span&gt;)))
    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (string-match &lt;span style="color: #008000;"&gt;"Traceback"&lt;/span&gt; result)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; result (format
                    &lt;span style="color: #008000;"&gt;"Traceback (most recent call last):\n%s"&lt;/span&gt;
                    (car (last (split-string result &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;))))))
    (concat body &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; result)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/17/Literate-programming-with-python-doctests.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[f-strings in emacs-lisp]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/05/14/f-strings-in-emacs-lisp" />
    <id>http://jkitchin.github.io/blog/2018/05/14/f-strings-in-emacs-lisp</id>
    <updated>2018-05-14T17:27:42Z</updated>
    <published>2018-05-14T17:27:42Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="elisp" />
    <summary type="html"><![CDATA[f-strings in emacs-lisp]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/05/14/f-strings-in-emacs-lisp"><![CDATA[


&lt;p&gt;
I am a big fan of f-strings in Python 3. They let you put variable names and expressions in a string template that get expanded to create new strings. Here is a simple example of using those:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;username&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'John Kitchin'&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;somevar&lt;/span&gt; = 5**0.5
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{username:30s}{somevar:1.2f}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24


&lt;/pre&gt;

&lt;p&gt;
String formatting in emacs-lisp is by comparison not as fun and easy. Out of the box we have:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (format &lt;span style="color: #008000;"&gt;"%-30s%1.2f"&lt;/span&gt; username somevar))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24

&lt;/pre&gt;

&lt;p&gt;
That is still three lines of code, but it is ugly and hard to read like the old python code:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'%-30s%1.2f'&lt;/span&gt; % (username, somevar))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24


&lt;/pre&gt;


&lt;p&gt;
My experience has shown that this gets harder to figure out as the strings get larger, and f-strings are easier to read.
&lt;/p&gt;

&lt;p&gt;
The wonderful &lt;a href="https://github.com/magnars/s.el"&gt;'s&lt;/a&gt; library provides some salvation for emacs-lisp, if you don't want the format fields. You can refer to variables in a lexical environment like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (&lt;span style="color: #0000FF;"&gt;s-lex-format&lt;/span&gt; &lt;span style="color: #008000;"&gt;"${username}${somevar}"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin2.23606797749979

&lt;/pre&gt;

&lt;p&gt;
Today, I decided to do something about this, and wrote this little macro. It is a variation on s-lex-format that introduces a slightly new syntax. You can now add an optional format field separated from the variable name by a space.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;f-string&lt;/span&gt; (fmt)
  &lt;span style="color: #036A07;"&gt;"Like `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;s-format&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' but with format fields in it.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;FMT is a string to be expanded against the current lexical&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;environment. It is like what is used in `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;s-lex-format&lt;/span&gt;&lt;span style="color: #036A07;"&gt;', but has&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;an expanded syntax to allow format-strings. For example:&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;${user-full-name 20s} will be expanded to the current value of&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;the variable `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;user-full-name&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' in a field 20 characters wide.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  (let ((f (sqrt 5)))  (f-string \"${f 1.2f}\"))&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  will render as: 2.24&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;This function is inspired by the f-strings in Python 3.6, which I&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;enjoy using a lot.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;"&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((matches (s-match-strings-all&lt;span style="color: #008000;"&gt;"${&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?3:&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?1:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt;} ]+&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt; *&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?2:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt;}]*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;}"&lt;/span&gt; fmt))
         (agetter (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for (m0 m1 m2 m3) in matches
                        collect `(,m3 .  ,(format (format &lt;span style="color: #008000;"&gt;"%%%s"&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (string= m2 &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                                                     (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; s-lex-value-as-lisp &lt;span style="color: #008000;"&gt;"S"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"s"&lt;/span&gt;)
                                                                   m2))
                                                  (symbol-value (intern m1)))))))

    `&lt;span style="color: #D0372D;"&gt;(s-format ,fmt &lt;/span&gt;'aget ',agetter)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
f-string

&lt;/pre&gt;

&lt;p&gt;
Here it is in action.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (&lt;span style="color: #0000FF;"&gt;f-string&lt;/span&gt; &lt;span style="color: #008000;"&gt;"${username -30s}${somevar 1.2f}"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24

&lt;/pre&gt;

&lt;p&gt;
It still lacks some of the capability of f-strings in python, e.g. in Python, arguments inside the template to be expanded get evaluated. The solution used above is too simple for that, since it just used a regexp and is limited to the value of variables in the lexical environment.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{5**0.5:1.3f}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2.236


&lt;/pre&gt;

&lt;p&gt;
Nevertheless, this simple solution matches what I do most of the time anyway, so I still consider it an improvement!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/14/f-strings-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Making it easier to extend the export of org-mode links with generic functions]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions" />
    <id>http://jkitchin.github.io/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions</id>
    <updated>2018-05-09T19:49:14Z</updated>
    <published>2018-05-09T19:49:14Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Making it easier to extend the export of org-mode links with generic functions]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions"><![CDATA[


&lt;p&gt;
I am a big fan of org-mode links. Lately, I have had a need to modify how some links are exported, e.g. defining new exports for different backends, or fine-tuning a particular backend. This can be difficult, depending on how the link was set up. Here is a typical setup I am used to using, where the different options for the backends are handled in a conditional statement in a single function. I will just use a link that just serves to illustrate the issues here. These links are just sytactic sugar for markup, they don't do anything else. We start with an example that just converts text to italic text for different backends like html or latex.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-export&lt;/span&gt; (path desc backend)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq 'html backend)
    (format &lt;span style="color: #008000;"&gt;"&amp;lt;em&amp;gt;%s&amp;lt;/em&amp;gt;"&lt;/span&gt; path))
   ((eq 'latex backend)
    (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;fall-through case for everything else&lt;/span&gt;
   (t
    path)))

(org-link-set-parameters &lt;span style="color: #008000;"&gt;"italic"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'italic-link-export)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;:export&lt;/td&gt;
&lt;td class="org-left"&gt;italic-link-export&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'html t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;p&amp;gt;
&amp;lt;em&amp;gt;text&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'latex t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
\textit{text}

&lt;/pre&gt;

&lt;p&gt;
This falls through though to the default case.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ox-md&lt;/span&gt;)
(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'md t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

# Table of Contents



text


&lt;/pre&gt;

&lt;p&gt;
The point I want to make here is that this is not easy to extend as a user. You have to either modify the italic-link-export function, advise it, or monkey-patch it. None of these are especially nice.
&lt;/p&gt;

&lt;p&gt;
I could define italic-link-export in a way that it retrieves the function to use from an alist or hash-table using the backend, but then you have to do two things to modify the behavior: define a backend specific function &lt;i&gt;and&lt;/i&gt; register it in the lookup variable. It is also possible to just look up a function by a derived symbol, e.g. using fboundp, and then using funcall to execute it. This looks something like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;a user definable function for exporting to latex&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-export-latex&lt;/span&gt; (path desc backend)
  (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;generic export function that looks up functions or defaults to&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-exporter&lt;/span&gt; (path desc backend)
  &lt;span style="color: #036A07;"&gt;"Run `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;italic-link-export-BACKEND&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' if it exists, or return path."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((func (intern-soft (format &lt;span style="color: #008000;"&gt;"italic-link-export-%s"&lt;/span&gt; backend))))
    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (fboundp func)
        (funcall func path desc backend)
      path)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This has some indirection, but allows you to just define new functions to add new export backends, or replace single backend exports. It isn't bad, but there is room for improvement.
&lt;/p&gt;

&lt;p&gt;
In this &lt;a href="https://github.com/jkitchin/org-ref/issues/492#issuecomment-387806180"&gt;comment&lt;/a&gt; in org-ref, I saw a new opportunity to address this issue using generic functions in elisp! The idea is to define a generic function that handles the general export case, and then define additional functions for each specific backend based on the signature of the export function. I will switch to bold markup for this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defgeneric&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; (path desc backend)
 &lt;span style="color: #036A07;"&gt;"Generic function to export a bold link."&lt;/span&gt;
 path)

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this one runs when the backend is equal to html&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; ((path t) (desc t) (backend (eql html)))
 (format &lt;span style="color: #008000;"&gt;"&amp;lt;b&amp;gt;%s&amp;lt;/b&amp;gt;"&lt;/span&gt; path))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this one runs when the backend is equal to latex&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; ((path t) (desc t) (backend (eql latex)))
 (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))

(org-link-set-parameters &lt;span style="color: #008000;"&gt;"bold"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'bold-link-export)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;:export&lt;/td&gt;
&lt;td class="org-left"&gt;bold-link-export&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here it is in action:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'html t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;p&amp;gt;
some &amp;lt;b&amp;gt;text&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'latex t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This uses the generic function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ox-md&lt;/span&gt;)
(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'md t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

# Table of Contents



some text


&lt;/pre&gt;

&lt;p&gt;
The syntax for defining the generic function is pretty similar to a regular function. The specific methods are a little different since they have to provide the specific "signature" that triggers each method. Here we only differentiate on the type of the backend. It is nice these are all separate functions though. It makes it trivial to add new ones, and less intrusive to replace in my opinion.
&lt;/p&gt;

&lt;p&gt;
Generic functions have many other potential applications to replace functions that use lots of conditions to control flow, with a fall-through option at the end. You can learn more about them here: &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html"&gt;https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html&lt;/a&gt;. There is a lot more to them than I have illustrated here.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Nature Catalysis]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/04/16/New-publication-in-Nature-Catalysis" />
    <id>http://jkitchin.github.io/blog/2018/04/16/New-publication-in-Nature-Catalysis</id>
    <updated>2018-04-16T12:55:36Z</updated>
    <published>2018-04-16T12:53:52Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Nature Catalysis]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/04/16/New-publication-in-Nature-Catalysis"><![CDATA[


&lt;p&gt;
Machine learning (ML) is impacting many fields, including catalysis. In this comment, I briefly discuss the major directions that ML is influencing the field of catalysis, along with some outlook on future directions. There were strict word and reference limits, so apologies in advance if I left out your work!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;kitchin-2018-machin-learn-catal&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {John R. Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Machine Learning in Catalysis},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Nature Catalysis},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       1,
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       4,
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        {230-232},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2018,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1038/s41929-018-0056-y&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1038/s41929-018-0056-y&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;DATE_ADDED&lt;/span&gt; =   {Mon Apr 16 12:50:43 2018},
}
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
You can see a read-only version of the paper here: &lt;a href="https://rdcu.be/LGrM"&gt;https://rdcu.be/LGrM&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1038/s41929-018-0056-y'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/04/16/New-publication-in-Nature-Catalysis.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Caching searches using biblio and only seeing new results]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results" />
    <id>http://jkitchin.github.io/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results</id>
    <updated>2018-04-11T20:46:56Z</updated>
    <published>2018-04-11T20:46:56Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="arxiv" />
    <category scheme="http://jkitchin.github.io/blog" term="biblio" />
    <category scheme="http://jkitchin.github.io/blog" term="elisp" />
    <summary type="html"><![CDATA[Caching searches using biblio and only seeing new results]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results"><![CDATA[


&lt;p&gt;
In this &lt;a href="https://github.com/jkitchin/scimax/issues/196"&gt;issue&lt;/a&gt; in scimax, Robert asked if it was possible to save searches, and then to repeat them every so often and only see the new results. This needs some persistent caching of the records, and a comparison of the current search results with the previous search results.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://github.com/cpitclaudel/biblio.el"&gt;biblio&lt;/a&gt; provides a nice interface to searching a range of resources for bibliographic references. In this post, I will focus on arxiv. Out of the box, biblio does not seem to support this use case, but as you will see, it has many of the pieces required to achieve it. Let's start picking those pieces apart.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;biblio&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
biblio

&lt;/pre&gt;

&lt;p&gt;
Here is the first piece we need: a way to run a query, and get results back as a data structure. Here we just look at the first result.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((query &lt;span style="color: #008000;"&gt;"alloy segregration"&lt;/span&gt;)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; cb
                  (funcall backend 'parse-buffer))))
  (car results))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;((doi . &lt;span style="color: #008000;"&gt;"10.1103/PhysRevB.76.014112"&lt;/span&gt;)
 (identifier . &lt;span style="color: #008000;"&gt;"0704.2752v2"&lt;/span&gt;)
 (year . &lt;span style="color: #008000;"&gt;"2007"&lt;/span&gt;)
 (title . &lt;span style="color: #008000;"&gt;"Modelling Thickness-Dependence of Ferroelectric Thin Film Properties"&lt;/span&gt;)
 (authors nil nil nil nil nil nil nil nil nil nil nil nil nil &lt;span style="color: #008000;"&gt;"L. Palova"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;"P. Chandra"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;"K. M. Rabe"&lt;/span&gt; nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)
 (container . &lt;span style="color: #008000;"&gt;"PRB 76, 014112 (2007)"&lt;/span&gt;)
 (category . &lt;span style="color: #008000;"&gt;"cond-mat.mtrl-sci"&lt;/span&gt;)
 (references &lt;span style="color: #008000;"&gt;"10.1103/PhysRevB.76.014112"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"0704.2752v2"&lt;/span&gt;)
 (type . &lt;span style="color: #008000;"&gt;"eprint"&lt;/span&gt;)
 (url . &lt;span style="color: #008000;"&gt;"https://doi.org/10.1103/PhysRevB.76.014112"&lt;/span&gt;)
 (direct-url . &lt;span style="color: #008000;"&gt;"http://arxiv.org/pdf/0704.2752v2"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next, we need a database to store the results in. I will just use a flat file database with a file for each record. The filename will be the md5 hash of the doi or the record itself. Why is that a good idea? Well, the doi is a constant, so if it exists the md5 will also be a constant. The doi itself is not a good filename in general, but the md5 is. The md5 of the record itself will be fragile to any changes, so if it has a doi, we should use it. If it doesn't and later gets one, we should see it again since that could mean it has been published. Also, if it changes because of some new version we might want to see it again. In any case, the existence of that file will be evidence we have seen that record before, and will indicate we need to remove it from the current view.
&lt;/p&gt;

&lt;p&gt;
The flat file database is not super inspired. It is modeled a little after elfeed, but other solutions might work better for large sets of records, but this approach will work fine for this post.
&lt;/p&gt;

&lt;p&gt;
Here is a function that returns nil if the record has been seen, and if not, saves the record and returns it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;db-dir&lt;/span&gt; &lt;span style="color: #008000;"&gt;"~/.arxiv-db/"&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; (f-dir? db-dir) (make-directory db-dir t))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;unseen-record-p&lt;/span&gt; (record)
  &lt;span style="color: #036A07;"&gt;"Given a RECORD return it if it is unseen.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;Also, save the record so next time it will be marked seen. A&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;record is seen if we have seen the DOI or the record as a string&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;before."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((doi (cdr (assoc 'doi record)))
         (contents (&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
                     (prin1 record (current-buffer))
                     (buffer-string)))
         (hash (md5 (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; doi contents)))
         (fname (expand-file-name hash db-dir)))

    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (f-exists? fname)
        nil
      (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; fname
        (insert contents))
      record)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
unseen-record-p

&lt;/pre&gt;

&lt;p&gt;
Now we can use that as a filter that saves records by side effect.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-arxiv&lt;/span&gt; (query)
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Query: "&lt;/span&gt;)

  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((backend 'biblio-arxiv-backend)
         (cb (url-retrieve-synchronously (funcall backend 'url query)))
         (results (-filter 'unseen-record-p (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; cb
                                              (funcall backend 'parse-buffer))))
         (results-buffer (biblio--make-results-buffer (current-buffer) query backend)))
    (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; results-buffer
      (biblio-insert-results results &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))
    (pop-to-buffer results-buffer)))

(scimax-arxiv &lt;span style="color: #008000;"&gt;"alloy segregation"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
#&amp;lt;buffer *arXiv search*&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
Now, when I run that once I see something like this:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-11-04-2018-time-20-19-52.png"&gt;
&lt;/p&gt;


&lt;p&gt;
and if I run it again:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(scimax-arxiv &lt;span style="color: #008000;"&gt;"alloy segregation"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
#&amp;lt;buffer *arXiv search*&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
Then the buffer is empty, since we have seen all the entries before.
&lt;/p&gt;


&lt;p&gt;
&lt;img src="/media/date-11-04-2018-time-20-20-37.png"&gt;
&lt;/p&gt;

&lt;p&gt;
Here are the files in our database:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;ls ~/.arxiv-db/
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are the contents of one of those files:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
 (insert-file-contents &lt;span style="color: #008000;"&gt;"~/.arxiv-db/18085fe2512e15d66addc7dfb71f7cd2"&lt;/span&gt;)
 (read (buffer-string)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
((doi) (identifier . 1101.3464v3) (year . 2011) (title . Characterizing Solute Segregation and Grain Boundary Energy in a Binary
  Alloy Phase Field Crystal Model) (authors nil nil nil nil nil nil nil nil nil nil nil nil nil Jonathan Stolle nil Nikolas Provatas nil nil nil nil nil nil nil nil nil nil nil) (container) (category . cond-mat.mtrl-sci) (references nil 1101.3464v3) (type . eprint) (url . http://arxiv.org/abs/1101.3464v3) (direct-url . http://arxiv.org/pdf/1101.3464v3))

&lt;/pre&gt;

&lt;p&gt;
So, if you need to read this in again later, no problem.
&lt;/p&gt;

&lt;p&gt;
Now, what could go wrong? I don't know much about how the search results from arxiv are returned. For example, this query returns 10 hits.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((query &lt;span style="color: #008000;"&gt;"alloy segregration"&lt;/span&gt;)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; cb
                  (funcall backend 'parse-buffer))))
  (length results))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
10

&lt;/pre&gt;

&lt;p&gt;
There is just no way there are only 10 hits for this query. So, there must be a bunch more that you get by either changing the requested number in some argument, or by using subsequent queries to get the rest of them. I don't know if there are more advanced query options with biblio, e.g. to find entries newer than the last time it was run. On the advanced search &lt;a href="https://arxiv.org/find"&gt;page&lt;/a&gt; for arxiv, it looks like there is only a by year option.
&lt;/p&gt;

&lt;p&gt;
This is still a good idea, and a lot of the pieces are here,
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;
]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Zhitao Guo receives the 2017-2018 James C. Meade Fellowship in Chemical Engineering]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/04/09/Zhitao-Guo-receives-the-2017-2018-James-C-Meade-Fellowship-in-Chemical-Engineering" />
    <id>http://jkitchin.github.io/blog/2018/04/09/Zhitao-Guo-receives-the-2017-2018-James-C-Meade-Fellowship-in-Chemical-Engineering</id>
    <updated>2018-04-09T18:18:40Z</updated>
    <published>2018-04-09T18:18:40Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <summary type="html"><![CDATA[Zhitao Guo receives the 2017-2018 James C. Meade Fellowship in Chemical Engineering]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/04/09/Zhitao-Guo-receives-the-2017-2018-James-C-Meade-Fellowship-in-Chemical-Engineering"><![CDATA[


&lt;p&gt;
The James C. Meade Fellowship was made possible by a generous donation by James Meade. This will help support Zhitao during his research this year. Zhitao is a first year PhD student who is co-advised by Andy Gellman and myself (John Kitchin), and is working on segregation in ternary alloy thin films.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-09-04-2018-time-18-17-59.png"&gt; 
&lt;/p&gt;



&lt;p&gt;
Zhitao joined us from Tsinghua University in Beijing, China, where he studied chemical engineering and double majored in economics.
&lt;/p&gt;

&lt;p&gt;
Congratulations Zhitao!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/04/09/Zhitao-Guo-receives-the-2017-2018-James-C.-Meade-Fellowship-in-Chemical-Engineering.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Catalysis Today]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/04/01/New-publication-in-Catalysis-Today" />
    <id>http://jkitchin.github.io/blog/2018/04/01/New-publication-in-Catalysis-Today</id>
    <updated>2018-04-01T19:07:10Z</updated>
    <published>2018-04-01T19:07:10Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Catalysis Today]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/04/01/New-publication-in-Catalysis-Today"><![CDATA[


&lt;p&gt;
In this paper we continue our exploration of using high-dimensional neural networks (NN) to model metal surface properties. Our first work started with modeling Au in a variety of structures using ReaxFF and a NN &lt;a class='org-ref-reference' href="#boes-2016-neural-networ"&gt;boes-2016-neural-networ&lt;/a&gt;. We then modeled atomic oxygen adsorbates on a Pd (111) surface &lt;a class='org-ref-reference' href="#boes-2017-neural-networ"&gt;boes-2017-neural-networ&lt;/a&gt;, and segregation of an Au-Pd alloy surface &lt;a class='org-ref-reference' href="#boes-2017-model-segreg"&gt;boes-2017-model-segreg&lt;/a&gt;. Our goal throughout this work has been to systematically build up complexity in the systems we are modeling, and to explore the limitations of these potentials for modeling surfaces. This current work happened in parallel with those works, and focused on modeling Pd adatom diffusion on Pd(111) surfaces. We show another example of how to train a neural network, and then to use it model the temperature dependent diffusion of adatoms on a metal surface using molecular dynamics and Arrhenius analysis.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;gao-2018-model-pallad&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Tianyu Gao and John R. Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Modeling Palladium Surfaces With Density Functional Theory,
                  Neural Networks and Molecular Dynamics},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Catalysis Today},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2018,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1016/j.cattod.2018.03.045&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1016/j.cattod.2018.03.045&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;DATE_ADDED&lt;/span&gt; =   {Sun Apr 1 18:47:55 2018},
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.cattod.2018.03.045'&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;h1 class='org-ref-bib-h1'&gt;Bibliography&lt;/h1&gt;
&lt;ul class='org-ref-bib'&gt;&lt;li&gt;&lt;a id="boes-2016-neural-networ"&gt;[boes-2016-neural-networ]&lt;/a&gt; &lt;a name="boes-2016-neural-networ"&gt;Jacob Boes, Mitchell Groenenboom, John Keith, &amp; John Kitchin, Neural Network and Reaxff Comparison for Au Properties, &lt;i&gt;Int. J. Quantum Chem.&lt;/i&gt;, &lt;b&gt;116(13)&lt;/b&gt;, 979-987 (2016). &lt;a href="https://doi.org/10.1002/qua.25115"&gt;link&lt;/a&gt;. &lt;a href="https://doi.org/10.1002/qua.25115"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a id="boes-2017-neural-networ"&gt;[boes-2017-neural-networ]&lt;/a&gt; &lt;a name="boes-2017-neural-networ"&gt;Jacob Boes &amp; John Kitchin, Neural Network Predictions of Oxygen Interactions on a Dynamic  Pd Surface, &lt;i&gt;Molecular Simulation&lt;/i&gt;, &lt;b&gt;&lt;/b&gt;, 1-9 (2017). &lt;a href="https://doi.org/10.1080/08927022.2016.1274984"&gt;link&lt;/a&gt;. &lt;a href="https://doi.org/10.1080/08927022.2016.1274984"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a id="boes-2017-model-segreg"&gt;[boes-2017-model-segreg]&lt;/a&gt; &lt;a name="boes-2017-model-segreg"&gt;Boes &amp; Kitchin, Modeling Segregation on AuPd(111) Surfaces With Density  Functional Theory and Monte Carlo Simulations, &lt;i&gt;The Journal of Physical Chemistry C&lt;/i&gt;, &lt;b&gt;121(6)&lt;/b&gt;, 3479-3487 (2017). &lt;a href="https://doi.org/10.1021/acs.jpcc.6b12752"&gt;link&lt;/a&gt;. &lt;a href="https://doi.org/10.1021/acs.jpcc.6b12752"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/04/01/New-publication-in-Catalysis-Today.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;
]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Topics in Catalysis]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/01/27/New-publication-in-Topics-in-Catalysis" />
    <id>http://jkitchin.github.io/blog/2018/01/27/New-publication-in-Topics-in-Catalysis</id>
    <updated>2018-04-01T18:49:28Z</updated>
    <published>2018-01-27T16:39:35Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Topics in Catalysis]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/01/27/New-publication-in-Topics-in-Catalysis"><![CDATA[


&lt;p&gt;
Single atom alloys are alloys in the extreme dilute limit, where single atoms of a reactive metal are surrounded by comparatively unreactive metals. This makes the single reactive atoms like single atom sites where reactions can occur. These sites are interesting because they are metallic, but their electronic structure is different than the atoms in more concentrated alloys. This means there is the opportunity for different, perhaps better catalytic performance for the single atom alloys. In this paper, we studied the electronic structure and some representative reaction pathways on a series of single atom alloy surfaces.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;Thirumalai2018&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       "Thirumalai, Hari and Kitchin, John R.",
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        "Investigating the Reactivity of Single Atom Alloys Using
                  Density Functional Theory",
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      "Topics in Catalysis",
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         "2018",
  &lt;span style="color: #BA36A5;"&gt;month&lt;/span&gt; =        "Jan",
  &lt;span style="color: #BA36A5;"&gt;day&lt;/span&gt; =          "25",
  &lt;span style="color: #BA36A5;"&gt;abstract&lt;/span&gt; =     "Single atom alloys are gaining importance as atom-efficient
                  catalysts which can be extremely selective and active towards
                  the formation of desired products. They possess such desirable
                  characteristics because of the presence of a highly reactive
                  single atom in a less reactive host surface. In this work, we
                  calculated the electronic structure of several representative
                  single atom alloys. We examined single atom alloys of gold,
                  silver and copper doped with single atoms of platinum,
                  palladium, iridium, rhodium and nickel in the context of the
                  d-band model of Hammer and N{\o}rskov. The reactivity of these
                  alloys was probed through the dissociation of water and nitric
                  oxide and the hydrogenation of acetylene to ethylene. We
                  observed that these alloys exhibit a sharp peak in their atom
                  projected d-band density of states, which we hypothesize could
                  be the cause of high surface reactivity. We found that the
                  d-band centers and d-band widths of these systems correlated
                  linearly as with other alloys, but that the energy of
                  adsorption of a hydrogen atom on these surfaces could not be
                  correlated with the d-band center, or the average reactivity
                  of the surface. Finally, the single atom alloys, with the
                  exception of copper--palladium showed good catalytic behavior
                  by activating the reactant molecules more strongly than the
                  bulk atom behavior and showing favorable reaction pathways on
                  the free energy diagrams for the reactions investigated.",
  &lt;span style="color: #BA36A5;"&gt;issn&lt;/span&gt; =         "1572-9028",
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          "&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1007/s11244-018-0899-0&lt;/span&gt;",
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          "&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1007/s11244-018-0899-0&lt;/span&gt;"
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1007/s11244-018-0899-0'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/01/27/New-publication-in-Topics-in-Catalysis.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Molecular Simulation]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2018/01/03/New-publication-in-Molecular-Simulation" />
    <id>http://jkitchin.github.io/blog/2018/01/03/New-publication-in-Molecular-Simulation</id>
    <updated>2018-01-03T06:28:21Z</updated>
    <published>2018-01-03T06:28:21Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Molecular Simulation]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2018/01/03/New-publication-in-Molecular-Simulation"><![CDATA[


&lt;p&gt;
This paper is our latest work using neural networks in molecular simulation. In this work, we build a Behler-Parinello neural network potential of bulk zirconia. The potential can describe several polymorphs of zirconia, as well as oxygen vacancy defect formation energies and diffusion barriers. We show that we can use the potential to model oxygen vacancy diffusion using molecular dynamics at different temperatures, and to use that data to estimate the effective diffusion activation energy. This is further evidence of the general utility of the neural network-based potential for molecular simulations with DFT accuracy.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;wang-2018-densit-funct&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Chen Wang and Akshay Tharval and John R. Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {A Density Functional Theory Parameterised Neural Network Model
                  of Zirconia},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Molecular Simulation},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       0,
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       0,
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        {1-8},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2018,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1080/08927022.2017.1420185&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1080/08927022.2017.1420185&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;eprint&lt;/span&gt; =       { https://doi.org/10.1080/08927022.2017.1420185 },
  &lt;span style="color: #BA36A5;"&gt;publisher&lt;/span&gt; =    {Taylor \&amp;amp; Francis},
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927022.2017.1420185'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/01/03/New-publication-in-Molecular-Simulation.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.5&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[2017 in a nutshell for the Kitchin Research group]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group" />
    <id>http://jkitchin.github.io/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group</id>
    <updated>2017-12-31T13:21:59Z</updated>
    <published>2017-12-31T13:21:58Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <summary type="html"><![CDATA[2017 in a nutshell for the Kitchin Research group]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group"><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orga22af1f"&gt;1. Student accomplishments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1a1a81e"&gt;2. Publications&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org372deac"&gt;2.1. Collaborative papers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org59c38bf"&gt;2.2. Papers on neural networks in molecular simulation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org44aee74"&gt;2.3. Papers accepted in 2017 but not yet in press&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org79f134f"&gt;3. New courses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6bb6401"&gt;4. Sabbatical at Google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org29808b7"&gt;5. Emacs and org-mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org16e2c7b"&gt;6. Social media&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgd9b416e"&gt;6.1. kitchingroup.cheme.cmu.edu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga302874"&gt;6.2. Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8c173b0"&gt;6.3. Youtube&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Since the &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/01/01/2016-in-a-nutshell-for-the-Kitchin-Research-group/"&gt;last update&lt;/a&gt; a lot of new things have happened in the Kitchin Research group. Below are some summaries of the group accomplishments, publications and activities for the past year. 
&lt;/p&gt;

&lt;div id="outline-container-orga22af1f" class="outline-2"&gt;
&lt;h2 id="orga22af1f"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Student accomplishments&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Jacob Boes completed his PhD and began postdoctoral work with Thomas Bligaard at SLAC/Suncat at Stanford. Congratulations Jake!
&lt;/p&gt;

&lt;p&gt;
Four new PhD students joined the group:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Jenny Zhan will work on simulation of molten superalloys&lt;/li&gt;
&lt;li&gt;Mingjie Liu will work on the design of single atom alloy catalysts&lt;/li&gt;
&lt;li&gt;Yilin Yang will work on segregation in multicomponent alloys under reaction conditions&lt;/li&gt;
&lt;li&gt;Zhitao Guo is also joining the group and will be co-advised by Prof. Gellman. He will work on multicomponent alloy catalysts.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Welcome to the group!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1a1a81e" class="outline-2"&gt;
&lt;h2 id="org1a1a81e"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Publications&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Our publications and citation counts have continued to grow this year. Here is our current metrics according to &lt;a href="http://www.researcherid.com/rid/A-2363-2010"&gt;Researcher ID&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-30-12-2017-time-20-18-45.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
We have eight new papers that are online, and two that are accepted, but not online yet. There are brief descriptions below.
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-org372deac" class="outline-3"&gt;
&lt;h3 id="org372deac"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; Collaborative papers&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#larsen-2017-atomic-simul"&gt;larsen-2017-atomic-simul&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;This is a modern update on the Atomic Simulation Environment Python software. We have been using and contributing to this software for about 15 years now!&lt;/dd&gt;

&lt;dt&gt;&lt;a class='org-ref-reference' href="#saravanan-2017-alchem-predic"&gt;saravanan-2017-alchem-predic&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;This collaborative effort with the Keith group at UPitt and Anatole von Lilienfeld explored a novel approach to estimating adsorption energies on alloy surfaces.&lt;/dd&gt;

&lt;dt&gt;&lt;a class='org-ref-reference' href="#xu-2017-first-princ"&gt;xu-2017-first-princ&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We used DFT calculations to understand epitaxial stabilization of titania films on strontium titanate surfaces.&lt;/dd&gt;

&lt;dt&gt;&lt;a class='org-ref-reference' href="#wittkamper-2017-compet-growt"&gt;wittkamper-2017-compet-growt&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We previously predicted that tin oxide should be able to form in the columbite phase as an epitaxial film. In this paper our collaborators show that it can be done!&lt;/dd&gt;

&lt;dt&gt;&lt;a class='org-ref-reference' href="#kitchin-2017-autom-data"&gt;kitchin-2017-autom-data&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;This paper finally came out in print. It shows an automated approach to sharing data. Also, it may be the only paper with data hidden inside a picture of a library in the literature.&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org59c38bf" class="outline-3"&gt;
&lt;h3 id="org59c38bf"&gt;&lt;span class="section-number-3"&gt;2.2&lt;/span&gt; Papers on neural networks in molecular simulation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#boes-2017-neural-networ"&gt;boes-2017-neural-networ&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We used neural networks in conjunction with molecular dynamics and Monte Carlo simulations to model the coverage dependent adsorption of oxygen and initial oxidation of a Pd(111) surface.&lt;/dd&gt;

&lt;dt&gt;&lt;a class='org-ref-reference' href="#boes-2017-model-segreg"&gt;boes-2017-model-segreg&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We used neural networks in conjunction with Monte Carlo simulations to model segregation across composition space for a Au-Pd alloy.&lt;/dd&gt;

&lt;dt&gt;&lt;a class='org-ref-reference' href="#geng-2017-first-princ"&gt;geng-2017-first-princ&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We used a cluster expansion with Monte Carlo simulations to resolve some inconsistencies in simulated Cu-Pd phase diagrams. There is an interesting transition from an fcc to bcc to fcc structure across the composition space that is subtle and difficult to compute.&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org44aee74" class="outline-3"&gt;
&lt;h3 id="org44aee74"&gt;&lt;span class="section-number-3"&gt;2.3&lt;/span&gt; Papers accepted in 2017 but not yet in press&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Chen Wang, Akshay Tharval, John R. Kitchin, A density functional theory parameterized neural network model of zirconia, Accepted in Molecular Simulation, July 2017.&lt;/li&gt;

&lt;li&gt;Hari Thirumalai, John R. Kitchin, Investigating the Reactivity of Single Atom Alloys using Density Functional Theory, Topics in Catalysis, Accepted November 2017.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org79f134f" class="outline-2"&gt;
&lt;h2 id="org79f134f"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; New courses&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
After a five year stint of teaching Master's and PhD courses, I taught the undergraduate chemical engineering course again. This was the first time I taught the course using Python. All the lectures and assignments were in Jupyter notebooks. You can find the course here: &lt;a href="https://github.com/jkitchin/s17-06364"&gt;https://github.com/jkitchin/s17-06364&lt;/a&gt;. The whole class basically ran from a browser using a Python Flask app to serve the syllabus, lectures and assignments. Assignments were submitted and returned by email through the Flask app. It was pretty interesting. I did not like it as much as using Emacs/org-mode like I have in the past, but it was easier to get 70 undergraduates up and running.
&lt;/p&gt;

&lt;p&gt;
I did not teach in the Fall, because I was on Sabbatical!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6bb6401" class="outline-2"&gt;
&lt;h2 id="org6bb6401"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Sabbatical at Google&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
In August 2017 I started my first sabbatical! I am spending a year in the &lt;a href="https://research.google.com/teams/gas/"&gt;Accelerated Science&lt;/a&gt; group at Google in Mountain View, California. I am learning about machine learning applications in engineering and science. This is a pivotal year in my research program, so stay tuned for our new work!
&lt;/p&gt;

&lt;p&gt;
It has been great for my family, who moved out here with me. We have been seeing a lot of California. I have been biking to work almost every day, usually 15-20 miles. I have logged over 1200 commuting miles already since August.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org29808b7" class="outline-2"&gt;
&lt;h2 id="org29808b7"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; Emacs and org-mode&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
org-ref remains in the top 15% of downloaded &lt;a href="https://melpa.org/#/org-ref"&gt;MELPA&lt;/a&gt; packages, with more than 24,000 downloads since it was released. It has been pretty stable lately. It remains a cornerstone of my technical writing toolbox.
&lt;/p&gt;

&lt;p&gt;
I have spent some time improving org-mode/ipython interactions including inline images, asynchronous execution and export to jupyter notebooks. It is still a work in progress.
&lt;/p&gt;

&lt;p&gt;
I spent a fair bit of time learning about dynamic modules for writing compiled extensions to Emacs to bring features like linear algebra, numerical methods and database access to it. I wish I had more time to work on this. I think it will be useful to make org-mode even better for  scientific research and documentation. 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org16e2c7b" class="outline-2"&gt;
&lt;h2 id="org16e2c7b"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; Social media&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
I have continued exploring the use of social media to share my work. It still seems like a worthwhile use of time, but we need continued efforts to make this really useful for science. 
&lt;/p&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgd9b416e" class="outline-3"&gt;
&lt;h3 id="orgd9b416e"&gt;&lt;span class="section-number-3"&gt;6.1&lt;/span&gt; kitchingroup.cheme.cmu.edu&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-6-1"&gt;
&lt;p&gt;
I use my blog to share technical knowledge and news about the group. We had 48 blog posts in 2017. A lot of them were on some use of org-mode and Emacs.  I also introduced a new exporter for org-mode to make jupyter notebooks. I spent November exploring automatic differentiation and applications of it to engineering problems. Visits to the site continue to grow. Here is the growth over the past two years. The big spike in Oct 2017 is from this &lt;a href="https://news.ycombinator.com/item?id=15464340"&gt;article on Hacker News&lt;/a&gt; about one of my posts!
&lt;/p&gt;


&lt;p&gt;
&lt;img src="/media/date-30-12-2017-time-20-15-28.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
I continue to think that technical blogging is a valuable way to communicate technical knowledge. It provides an easy way to practice writing, and with comments enabled to get feedback on your ideas. It has taken several years to develop a style for doing this effectively that is useful to me, and to others. I have integrated my blog into Twitter so that new posts are automatically tweeted, which helps publicize the new posts.
&lt;/p&gt;

&lt;p&gt;
It has some limitations, e.g. it is not obvious how to cite them in ways that are compatible with the current bibliometric driven assessment tools used in promotion and tenure. Overall, I find it very complementary to formal publications though, and I wish more people did it.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga302874" class="outline-3"&gt;
&lt;h3 id="orga302874"&gt;&lt;span class="section-number-3"&gt;6.2&lt;/span&gt; Github&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-6-2"&gt;
&lt;p&gt;
I was a little less active on &lt;a href="https://github.com/jkitchin"&gt;Github&lt;/a&gt; this year than last year, especially this fall as I started my sabbatical. Github remains my goto version control service though, and we continue using it for everything from code development and paper writing to course serving.
&lt;/p&gt;


&lt;p&gt;
&lt;img src="/media/date-30-12-2017-time-20-12-03.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
scimax finally has more Github stars than jmax does!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8c173b0" class="outline-3"&gt;
&lt;h3 id="org8c173b0"&gt;&lt;span class="section-number-3"&gt;6.3&lt;/span&gt; Youtube&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-6-3"&gt;
&lt;p&gt;
Another year with over 100,000 minutes of &lt;a href="https://www.youtube.com/analytics?o=U#dt=ty,fe=17165,fr=lw-001,fs=16801;fc=0,fcr=0,r=views,rpg=93"&gt;Youtube watch time&lt;/a&gt; on our videos. &lt;a href="https://www.youtube.com/watch?v=fgizHHd7nOo"&gt;org-mode is awesome&lt;/a&gt; was most popular, with almost 50,000 views. We have six videos with over 2500 views for the past year!
&lt;/p&gt;



&lt;p&gt;
&lt;img src="/media/date-31-12-2017-time-13-08-54.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
I have not made too many new videos this year. Hopefully there will be some new ones on the new features in scimax in the next year.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/12/31/2017-in-a-nutshell-for-the-Kitchin-Research-group.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.3&lt;/p&gt;]]></content>
  </entry>
</feed>
