<?xml version="1.0" encoding="UTF-8"?>

<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
  >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2023-09-21T17:45:49Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog" />
  <id>https://kitchingroup.cheme.cmu.edu/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="https://kitchingroup.cheme.cmu.edu/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[A better manager for supervising Python functions]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/21/A-better-manager-for-supervising-Python-functions" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/09/21/A-better-manager-for-supervising-Python-functions</id>
    <updated>2023-09-21T13:43:17Z</updated>
    <published>2023-09-21T13:42:13Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="programming" />
    <summary type="html"><![CDATA[A better manager for supervising Python functions]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/09/21/A-better-manager-for-supervising-Python-functions"><![CDATA[


&lt;div id="table-of-contents" role="doc-toc"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents" role="doc-toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org0250367"&gt;1. The previous examples with manager&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbc4f0a8"&gt;2. Stateful supervision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5218dd5"&gt;3. Handling exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org677186e"&gt;4. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In the previous &lt;a href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/20/Supervising-Python-functions/index.html"&gt;post&lt;/a&gt; I introduced a supervisor decorator to automate rerunning functions with new arguments to fix issues in them. Almost immediately after posting it, two things started bugging me. First, I thought it was annoying to have two separate arguments for results and exceptions. I would prefer one list of functions that do the right thing. Second, and most annoying, you have to be very careful in writing your checker functions to be consistent with how you called the function so you use exactly the same positional and keyword arguments. That is tedious and limits reusability/flexibility.
&lt;/p&gt;

&lt;p&gt;
So, I wrote a new &lt;code&gt;manager&lt;/code&gt; decorator that solves these two problems. Now, you can write checker functions that work on all the arguments of a function. You decorate the checker functions to indicate if they are for results or exceptions. This was a little more of a rabbit hole than I anticipated, but I persevered, and got to a solution that works for these examples. You can find all the code &lt;a href="https://github.com/jkitchin/pycse/blob/master/pycse/supyrvisor.py#L99"&gt;here&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Here is an example where we have a test function that we want to run with new arguments until we get a positive result. We start in a way that it is possible to get a ZeroDivisionError, and we handle that too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; pycse.supyrvisor &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; manager, check_result, check_exception

&lt;span style="color: #6434A3;"&gt;@check_exception&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;check1&lt;/span&gt;(args, exc):
    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;isinstance&lt;/span&gt;(exc, &lt;span style="color: #6434A3;"&gt;ZeroDivisionError&lt;/span&gt;):
        &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'ooo. caught 1/0, incrementing x'&lt;/span&gt;)
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; {&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;: 1}

&lt;span style="color: #6434A3;"&gt;@check_result&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;check2&lt;/span&gt;(args, result):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(args)
    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; result &amp;lt; 0:
        &lt;span style="color: #BA36A5;"&gt;args&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;] += 1
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; args
        

&lt;span style="color: #6434A3;"&gt;@manager&lt;/span&gt;(checkers=[check1, check2])
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;test&lt;/span&gt;(x, a=1):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a / x

test(-1)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
{'x': -1, 'a': 1}
ooo. caught 1/0, incrementing x
{'x': 1}
1.0
&lt;/p&gt;

&lt;p&gt;
This also works, so you can see this is better than the previous version which would not work if you change the signature.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;test(a=1, x=-1)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
{'x': -1, 'a': 1}
ooo. caught 1/0, incrementing x
{'x': 1}
1.0
&lt;/p&gt;


&lt;div id="outline-container-org0250367" class="outline-2"&gt;
&lt;h2 id="org0250367"&gt;&lt;span class="section-number-2"&gt;1.&lt;/span&gt; The previous examples with manager&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Here is the new syntax with manager.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; minimize

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(x):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(x**2) - 10 * np.exp(x)


&lt;span style="color: #6434A3;"&gt;@check_result&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;maxIterationsExceeded&lt;/span&gt;(args, sol):
    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; sol.message == &lt;span style="color: #008000;"&gt;'Maximum number of iterations has been exceeded.'&lt;/span&gt;:
        args[&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;] *= 2
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; args

&lt;span style="color: #6434A3;"&gt;@manager&lt;/span&gt;(checkers=[maxIterationsExceeded], verbose=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_result&lt;/span&gt;(maxiter=2):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; minimize(objective, 0.0, options={&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: maxiter})

get_result(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="orgc74758e"&gt;
Proposed fix in wrapper: {'maxiter': 4}
Proposed fix in wrapper: {'maxiter': 8}
  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -36.86307468296428
        x: [ 1.662e+00]
      nit: 5
      jac: [-4.768e-07]
 hess_inv: [[ 6.481e-03]]
     nfev: 26
     njev: 13
&lt;/pre&gt;


&lt;p&gt;
It works!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgbc4f0a8" class="outline-2"&gt;
&lt;h2 id="orgbc4f0a8"&gt;&lt;span class="section-number-2"&gt;2.&lt;/span&gt; Stateful supervision&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
In this example, we aim to find the steady state concentrations of two species by integrating a mass balance to steady state. This is visually easy to see below, the concentrations are essentially flat after 10 min or so. Computationally this is somewhat tricky to find though. A way to do it is to compare some windows of integration to see if the values are not changing very fast. For instance you could average the values from 10 to 11, and compare that to the values in 11 to 12, and keep doing that until they are close enough to the same.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;ode&lt;/span&gt;(t, C):
    &lt;span style="color: #BA36A5;"&gt;Ca&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Cb&lt;/span&gt; = C
    &lt;span style="color: #BA36A5;"&gt;dCadt&lt;/span&gt; = -0.2 * Ca + 0.3 * Cb
    &lt;span style="color: #BA36A5;"&gt;dCbdt&lt;/span&gt; = -0.3 * Cb + 0.2 * Ca
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; dCadt, dCbdt

&lt;span style="color: #BA36A5;"&gt;tspan&lt;/span&gt; = (0, 20)

&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; solve_ivp
&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(ode, tspan, (1, 0))

&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
plt.plot(sol.t, sol.y.T)
plt.xlabel(&lt;span style="color: #008000;"&gt;'t (min)'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;)
plt.legend([&lt;span style="color: #008000;"&gt;'A'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B'&lt;/span&gt;]);
sol.y.T[-1]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
array([0.60003278, 0.39996722])
&lt;/pre&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/f3c33e97d249f9a4832ababa88b2ee4e697c9cad.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;


&lt;p&gt;
It is not crucial to use a class here; you could also use global variables, or function attributes. A class is a standard way of encapsulating state though. We just have to make the class callable so it acts like a function when we need it to.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;ReachedSteadyState&lt;/span&gt;:        
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, tolerance=0.01):
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.tolerance = tolerance
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution = &lt;span style="color: #D0372D;"&gt;None&lt;/span&gt;
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.count = 0

    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__str__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; &lt;span style="color: #008000;"&gt;'ReachedSteadyState'&lt;/span&gt;

    &lt;span style="color: #6434A3;"&gt;@check_result&lt;/span&gt;
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__call__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, args, sol):
        &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution &lt;span style="color: #0000FF;"&gt;is&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;None&lt;/span&gt;:
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution = sol
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.count += 1
            args[&lt;span style="color: #008000;"&gt;'C0'&lt;/span&gt;] = sol.y.T[-1]
            &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; args

        &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;we have a previous solution&lt;/span&gt;
        &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #0000FF;"&gt;not&lt;/span&gt; np.allclose(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution.y.mean(axis=1),
                           sol.y.mean(axis=1),
                           rtol=&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.tolerance,
                           atol=&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.tolerance):
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution = sol
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.count += 1
            args[&lt;span style="color: #008000;"&gt;'C0'&lt;/span&gt;] = sol.y.T[-1]
            &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; args

rss = ReachedSteadyState(0.0001)

&lt;span style="color: #6434A3;"&gt;@manager&lt;/span&gt;(checkers=[rss], max_errors=20, verbose=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)        
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_sol&lt;/span&gt;(C0=(1, 0), window=1):
    sol = solve_ivp(ode, t_span=(0, window), y0=C0)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

sol = get_sol((1, 0), window=2)
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Proposed fix in ReachedSteadyState: {'C0': array([0.74716948, 0.25283052]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.65414484, 0.34585516]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.61992776, 0.38007224]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.60733496, 0.39266504]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.60269957, 0.39730043]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.60099346, 0.39900654]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.60036557, 0.39963443]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.60013451, 0.39986549]), 'window': 2}
Proposed fix in ReachedSteadyState: {'C0': array([0.60004949, 0.39995051]), 'window': 2}
&lt;/p&gt;
&lt;pre class="example" id="orgee266a9"&gt;
  message: The solver successfully reached the end of the integration interval.
  success: True
   status: 0
        t: [ 0.000e+00  7.179e-01  2.000e+00]
        y: [[ 6.000e-01  6.000e-01  6.000e-01]
            [ 4.000e-01  4.000e-01  4.000e-01]]
      sol: None
 t_events: None
 y_events: None
     nfev: 14
     njev: 0
      nlu: 0
&lt;/pre&gt;

&lt;p&gt;
We can plot the two solutions to see how different they are. This shows they are close.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
plt.plot(rss.last_solution.t, rss.last_solution.y.T, label=[&lt;span style="color: #008000;"&gt;'A previous'&lt;/span&gt; ,&lt;span style="color: #008000;"&gt;'B previous'&lt;/span&gt;])
plt.plot(sol.t, sol.y.T, &lt;span style="color: #008000;"&gt;'--'&lt;/span&gt;, label=[&lt;span style="color: #008000;"&gt;'A current'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B current'&lt;/span&gt;])
plt.legend()
plt.xlabel(&lt;span style="color: #008000;"&gt;'relative t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/3c544cf4265650554cef24240a0c6272dcc8fdae.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
Those look pretty similar on this graph.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5218dd5" class="outline-2"&gt;
&lt;h2 id="org5218dd5"&gt;&lt;span class="section-number-2"&gt;3.&lt;/span&gt; Handling exceptions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Suppose you have a function that randomly fails. This could be because something does not converge with a randomly chosen initial guess, converges to an unphysical answer, etc. In these cases, it makes sense to simply try again with a new initial guess.
&lt;/p&gt;

&lt;p&gt;
For this example, say we have this objective function with two minima. We will say that any solution above 0.5 is unphysical.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt;(x):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -(np.exp(-50 * (x - 0.25)**2) + 0.5 * np.exp(-100 * (x - 0.75)**2))


&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.linspace(0, 1)
plt.plot(x, f(x))
plt.xlabel(&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'y'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/1749ee4492947f204b2e25cc2f9059edd2929869.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
Here we define a function that takes a guess, and gets a solution. If the solution is unphysical, we raise an exception. We define a custom exception so we can handle it specifically.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;UnphysicalSolution&lt;/span&gt;(&lt;span style="color: #6434A3;"&gt;Exception&lt;/span&gt;):
    &lt;span style="color: #0000FF;"&gt;pass&lt;/span&gt;

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_minima&lt;/span&gt;(guess):
    &lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = minimize(f, guess)

    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; sol.x &amp;gt; 0.5:
        &lt;span style="color: #0000FF;"&gt;raise&lt;/span&gt; UnphysicalSolution
    &lt;span style="color: #0000FF;"&gt;else&lt;/span&gt;:
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

&lt;span style="color: #6434A3;"&gt;@check_exception&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;try_again&lt;/span&gt;(args, exc):
    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;isinstance&lt;/span&gt;(exc, UnphysicalSolution):
        args[&lt;span style="color: #008000;"&gt;'guess'&lt;/span&gt;] = np.random.random()
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; args
  
&lt;span style="color: #6434A3;"&gt;@manager&lt;/span&gt;(checkers=(try_again,), verbose=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)    
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_minima&lt;/span&gt;(guess):
    sol = minimize(f, guess)

    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; sol.x &amp;gt; 0.5:
        &lt;span style="color: #0000FF;"&gt;raise&lt;/span&gt; UnphysicalSolution
    &lt;span style="color: #0000FF;"&gt;else&lt;/span&gt;:
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

get_minima(np.random.random())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="org6d987ce"&gt;
Proposed fix in wrapper: {'guess': 0.03789731690063758}
  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -1.0000000000069411
        x: [ 2.500e-01]
      nit: 4
      jac: [ 0.000e+00]
 hess_inv: [[ 1.000e-02]]
     nfev: 18
     njev: 9
&lt;/pre&gt;


&lt;p&gt;
You can see it took four iterations to find a solution. Other times it might take zero or one, or maybe more, it depends on where the guesses fall.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org677186e" class="outline-2"&gt;
&lt;h2 id="org677186e"&gt;&lt;span class="section-number-2"&gt;4.&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
This solution works as well as &lt;code&gt;supervisor&lt;/code&gt; did. It was a little deeper rabbit hole to go down, mostly because of some subtlety in making the result and exception decorators work for both functions and class methods. I think it is more robust now, as it should not matter how you call the function, and any combination of args and kwargs should be working.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/09/21/A-better-manager-for-supervising-Python-functions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.7-pre&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[Supervising Python functions]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/20/Supervising-Python-functions" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/09/20/Supervising-Python-functions</id>
    <updated>2023-09-21T13:44:28Z</updated>
    <published>2023-09-20T19:55:50Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="programming" />
    <summary type="html"><![CDATA[Supervising Python functions]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/09/20/Supervising-Python-functions"><![CDATA[


&lt;div id="table-of-contents" role="doc-toc"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents" role="doc-toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org4c1f8b0"&gt;1. Stateful supervision&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb670b33"&gt;2. Handling exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5b8b358"&gt;3. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
[UPDATE &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;[2023-09-21 Thu]&lt;/span&gt;&lt;/span&gt;]: See this &lt;a href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/21/A-better-manager-for-supervising-Python-functions/index.html"&gt;new post&lt;/a&gt; for an update and improved version of this post.
&lt;/p&gt;

&lt;p&gt;
In the last &lt;a href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/Using-Custodian-to-help-converge-an-optimization-problem/"&gt;post&lt;/a&gt; I talked about using custodian to supervise Python functions. I noted it felt a little heavy, so I wrote a new decorator that does basically the same thing. TL;DR I am not sure this is less heavy, but I learned some things doing it. The code I used is part of pycse at &lt;a href="https://github.com/jkitchin/pycse/blob/master/pycse/supyrvisor.py"&gt;https://github.com/jkitchin/pycse/blob/master/pycse/supyrvisor.py&lt;/a&gt;. Check out the code to see how this works.
&lt;/p&gt;

&lt;p&gt;
Here is the prototype problem it solves. This code runs, but does not succeed because it exceeds the maximum iterations. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; minimize

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(x):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(x**2) - 10 * np.exp(x)

minimize(objective, 0.0, options={&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: 2})
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="org6c6a887"&gt;
  message: Maximum number of iterations has been exceeded.
  success: False
   status: 1
      fun: -36.86289091418059
        x: [ 1.661e+00]
      nit: 2
      jac: [-2.374e-01]
 hess_inv: [[ 6.889e-03]]
     nfev: 20
     njev: 10
&lt;/pre&gt;

&lt;p&gt;
The solution is simple, you increase the number of iterations. That is tedious to do manually though, and not practical if you do this hundreds of times in a study. Enter &lt;code&gt;pycse.supyrvisor&lt;/code&gt;. It provides a decorator to do this. Similar to custodian, we have to define a function that has arguments to change this. We do this here. This function still does not succeed yet.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_result&lt;/span&gt;(maxiter=2):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; minimize(objective, 0.0, options={&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: maxiter})

get_result(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="org78a23db"&gt;
  message: Maximum number of iterations has been exceeded.
  success: False
   status: 1
      fun: -36.86289091418059
        x: [ 1.661e+00]
      nit: 2
      jac: [-2.374e-01]
 hess_inv: [[ 6.889e-03]]
     nfev: 20
     njev: 10
&lt;/pre&gt;

&lt;p&gt;
Next, we need a "checker" function. The role of this function is to check the output of the function, determine if it is ok, and if not, to return a new set of arguments to run the function with. There are some subtleties in this. You can call your function with a combination of args and kwargs, and you have to write this function in a way that is consistent with how you call the function. In the example above, we called &lt;code&gt;get_result(2)&lt;/code&gt; where the 2 is a positional argument. In this checker function we write it with that in mind. If we detect that the minimizer failed because of exceeding the maximum number of iterations, we get the argument and double it. Then, we return the new args and kwargs. Otherwise this function returns None, indicating the solution is fine as far as this function is concerned.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;maxIterationsExceeeded&lt;/span&gt;(args, kwargs, sol):
    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; sol.message == &lt;span style="color: #008000;"&gt;'Maximum number of iterations has been exceeded.'&lt;/span&gt;:
        maxiter = args[0]
        maxiter *= 2
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; (maxiter,), kwargs
        
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Finally, we get the supervisor decorator, and decorate the function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; pycse.supyrvisor &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; supervisor

&lt;span style="color: #BA36A5;"&gt;get_result&lt;/span&gt; = supervisor(check_funcs=[maxIterationsExceeeded], verbose=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)(get_result)

get_result(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="org8a27ad8"&gt;
Proposed fix in maxIterationsExceeeded: ((4,), {})
Proposed fix in maxIterationsExceeeded: ((8,), {})
  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -36.86307468296428
        x: [ 1.662e+00]
      nit: 5
      jac: [-4.768e-07]
 hess_inv: [[ 6.481e-03]]
     nfev: 26
     njev: 13
&lt;/pre&gt;

&lt;p&gt;
It works!
&lt;/p&gt;

&lt;div id="outline-container-org4c1f8b0" class="outline-2"&gt;
&lt;h2 id="org4c1f8b0"&gt;&lt;span class="section-number-2"&gt;1.&lt;/span&gt; Stateful supervision&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
In this example, we aim to find the steady state concentrations of two species by integrating a mass balance to steady state. This is visually easy to see below, the concentrations are essentially flat after 10 min or so. Computationally this is somewhat tricky to find though. A way to do it is to compare some windows of integration to see if the values are not changing very fast. For instance you could average the values from 10 to 11, and compare that to the values in 11 to 12, and keep doing that until they are close enough to the same.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;ode&lt;/span&gt;(t, C):
    &lt;span style="color: #BA36A5;"&gt;Ca&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Cb&lt;/span&gt; = C
    &lt;span style="color: #BA36A5;"&gt;dCadt&lt;/span&gt; = -0.2 * Ca + 0.3 * Cb
    &lt;span style="color: #BA36A5;"&gt;dCbdt&lt;/span&gt; = -0.3 * Cb + 0.2 * Ca
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; dCadt, dCbdt

&lt;span style="color: #BA36A5;"&gt;tspan&lt;/span&gt; = (0, 20)

&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; solve_ivp
&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(ode, tspan, (1, 0))

&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
plt.plot(sol.t, sol.y.T)
plt.xlabel(&lt;span style="color: #008000;"&gt;'t (min)'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;)
plt.legend([&lt;span style="color: #008000;"&gt;'A'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B'&lt;/span&gt;]);
sol.y.T[-1]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
array([0.60003278, 0.39996722])
&lt;/pre&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/f3c33e97d249f9a4832ababa88b2ee4e697c9cad.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
The goal then is to have a supervisor function that will keep track of the last solution and the current one, and compare the average of them. You could do something more sophisticated, but this is simple enough to try out now. If the difference between two integrations is small enough, we will say we have hit steady state, and if not, we integrate from the end of the last solution forward again. That means we have to store some state information so we can compare a current solution to the last solution.
&lt;/p&gt;

&lt;p&gt;
Let's start by defining a function that returns a solution from some initial condition. Next, we show that if you run it 12ish times, initializing from the last state, we get something that appears steady-stateish in the sense that the y values only changing in the second decimal place. You might consider that close enough to steady state.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_sol&lt;/span&gt;(C0=(1, 0), window=1):
    sol = solve_ivp(ode, t_span=(0, window), y0=C0)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

sol = get_sol()
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol = get_sol(sol.y.T[-1])
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="orgb06e483"&gt;
  message: The solver successfully reached the end of the integration interval.
  success: True
   status: 0
        t: [ 0.000e+00  3.565e-01  1.000e+00]
        y: [[ 6.016e-01  6.014e-01  6.010e-01]
            [ 3.984e-01  3.986e-01  3.990e-01]]
      sol: None
 t_events: None
 y_events: None
     nfev: 14
     njev: 0
      nlu: 0
&lt;/pre&gt;

&lt;p&gt;
That is obviously tedious, so now we devise a supervisor function to do it for us. Since we will save state between calls, I will use a class here. We will define a tolerance that we want the difference of the average of two sequential solutions to be less than. We have to be a little careful here. There are many ways to call get_sol, e.g. all of these are correct, but when the checker function is called, it will get different arguments.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;get_sol()           &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;no args: args=(), kwargs={} &lt;/span&gt;
get_sol((1, 0), 2)  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;all positional args: args=((1, 0), 2), kwargs={}&lt;/span&gt;
get_sol((1, 0))     &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;one positional arg:  args=((1, 0),), kwargs={}&lt;/span&gt;
get_sol((1, 0), window=2) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;a positional and kwarg: args =((1, 0),), kwargs={'window': 2}&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
We have to either assume one of these, or write a function that can handle any of them. I am going to &lt;i&gt;assume&lt;/i&gt; here that args will always just be the initial condition, and anything else will be in kwargs. That is a convention we use for this problem, and if you break the convention, you will have errors. For example, &lt;code&gt;get_sol(C0=(1, 0))&lt;/code&gt; will cause an error because you will not have a positional argument for C0 but instead a keyword argument for C0.
&lt;/p&gt;

&lt;p&gt;
It is not crucial to use a class here; you could also use global variables, or function attributes. A class is a standard way of encapsulating state though. We just have to make the class callable so it acts like a function when we need it to.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;ReachedSteadyState&lt;/span&gt;:        
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, tolerance=0.01):
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.tolerance = tolerance
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution = &lt;span style="color: #D0372D;"&gt;None&lt;/span&gt;
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.count = 0

    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__str__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; &lt;span style="color: #008000;"&gt;'ReachedSteadyState'&lt;/span&gt;
        
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__call__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, args, kwargs, sol):
        &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution &lt;span style="color: #0000FF;"&gt;is&lt;/span&gt; &lt;span style="color: #D0372D;"&gt;None&lt;/span&gt;:
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution = sol
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.count += 1
            C0 = sol.y.T[-1]
            &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; (C0,), kwargs

        &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;we have a previous solution&lt;/span&gt;
        &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #0000FF;"&gt;not&lt;/span&gt; np.allclose(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution.y.mean(axis=1),
                           sol.y.mean(axis=1),
                           rtol=&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.tolerance,
                           atol=&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.tolerance):
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.last_solution = sol
            &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.count += 1
            C0 = sol.y.T[-1]            
            &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; (C0,), kwargs

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we decorate the &lt;code&gt;get_sol&lt;/code&gt; function, and then run it. Since we used a bigger window, it only takes 9 iterations to get to an approximate steady state.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_sol&lt;/span&gt;(C0=(1, 0), window=1):
    sol = solve_ivp(ode, t_span=(0, window), y0=C0)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

rss = ReachedSteadyState(0.0001)
get_sol = supervisor(check_funcs=(rss,), verbose=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;, max_errors=20)(get_sol)
sol = get_sol((1, 0), window=2)
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Proposed fix in ReachedSteadyState: ((array([0.74716948, 0.25283052]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.65414484, 0.34585516]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.61992776, 0.38007224]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.60733496, 0.39266504]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.60269957, 0.39730043]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.60099346, 0.39900654]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.60036557, 0.39963443]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.60013451, 0.39986549]),), {'window': 2})
Proposed fix in ReachedSteadyState: ((array([0.60004949, 0.39995051]),), {'window': 2})
&lt;/p&gt;
&lt;pre class="example" id="org76b54b4"&gt;
  message: The solver successfully reached the end of the integration interval.
  success: True
   status: 0
        t: [ 0.000e+00  7.179e-01  2.000e+00]
        y: [[ 6.000e-01  6.000e-01  6.000e-01]
            [ 4.000e-01  4.000e-01  4.000e-01]]
      sol: None
 t_events: None
 y_events: None
     nfev: 14
     njev: 0
      nlu: 0
&lt;/pre&gt;


&lt;p&gt;
We can plot the two solutions to see how different they are. This shows they are close.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
plt.plot(rss.last_solution.t, rss.last_solution.y.T, label=[&lt;span style="color: #008000;"&gt;'A previous'&lt;/span&gt; ,&lt;span style="color: #008000;"&gt;'B previous'&lt;/span&gt;])
plt.plot(sol.t, sol.y.T, &lt;span style="color: #008000;"&gt;'--'&lt;/span&gt;, label=[&lt;span style="color: #008000;"&gt;'A current'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B current'&lt;/span&gt;])
plt.legend()
plt.xlabel(&lt;span style="color: #008000;"&gt;'relative t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/3c544cf4265650554cef24240a0c6272dcc8fdae.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
Those look pretty similar on this graph.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb670b33" class="outline-2"&gt;
&lt;h2 id="orgb670b33"&gt;&lt;span class="section-number-2"&gt;2.&lt;/span&gt; Handling exceptions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
Suppose you have a function that randomly fails. This could be because something does not converge with a randomly chosen initial guess, converges to an unphysical answer, etc. In these cases, it makes sense to simply try again with a new initial guess.
&lt;/p&gt;

&lt;p&gt;
For this example, say we have this objective function with two minima. We will say that any solution above 0.5 is unphysical.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt;(x):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -(np.exp(-50 * (x - 0.25)**2) + 0.5 * np.exp(-100 * (x - 0.75)**2))


&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.linspace(0, 1)
plt.plot(x, f(x))
plt.xlabel(&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'y'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/1749ee4492947f204b2e25cc2f9059edd2929869.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
Here we define a function that takes a guess, and gets a solution. If the solution is unphysical, we raise an exception. We define a custom exception so we can handle it specifically.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;UnphysicalSolution&lt;/span&gt;(&lt;span style="color: #6434A3;"&gt;Exception&lt;/span&gt;):
    &lt;span style="color: #0000FF;"&gt;pass&lt;/span&gt;

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_minima&lt;/span&gt;(guess):
    &lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = minimize(f, guess)

    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; sol.x &amp;gt; 0.5:
        &lt;span style="color: #0000FF;"&gt;raise&lt;/span&gt; UnphysicalSolution
    &lt;span style="color: #0000FF;"&gt;else&lt;/span&gt;:
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Some initial guesses work fine.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;get_minima(0.2)    
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="orgc9b6264"&gt;
  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -1.0000000000069416
        x: [ 2.500e-01]
      nit: 4
      jac: [ 4.470e-08]
 hess_inv: [[ 1.000e-02]]
     nfev: 14
     njev: 7
&lt;/pre&gt;

&lt;p&gt;
But, others don't.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;get_minima(0.8)    
&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;
UnphysicalSolution                        Traceback (most recent call last)
Cell In[16], line 1
-&amp;#x2014;&amp;gt; 1 get_minima(0.8)
&lt;/p&gt;

&lt;p&gt;
Cell In[14], line 8, in get_minima(guess)
      5 sol = minimize(f, guess)
      7 if sol.x &amp;gt; 0.5:
-&amp;#x2014;&amp;gt; 8     raise UnphysicalSolution
      9 else:
     10     return sol
&lt;/p&gt;

&lt;p&gt;
UnphysicalSolution: 
&lt;/p&gt;

&lt;p&gt;
Here is an example where we can simply rerun with a new guess. That is done here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;try_again&lt;/span&gt;(args, kwargs, exc):
    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;isinstance&lt;/span&gt;(exc, UnphysicalSolution):
        &lt;span style="color: #BA36A5;"&gt;args&lt;/span&gt; = (np.random.random(),)
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; args, kwargs
  
&lt;span style="color: #6434A3;"&gt;@supervisor&lt;/span&gt;(exception_funcs=(try_again,), verbose=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)    
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;get_minima&lt;/span&gt;(guess):
    sol = minimize(f, guess)

    &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; sol.x &amp;gt; 0.5:
        &lt;span style="color: #0000FF;"&gt;raise&lt;/span&gt; UnphysicalSolution
    &lt;span style="color: #0000FF;"&gt;else&lt;/span&gt;:
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

get_minima(np.random.random())
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="orgad7b6a5"&gt;
Proposed fix in try_again: ((0.7574152313004273,), {})
Proposed fix in try_again: ((0.39650554857922415,), {})
  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -1.0000000000069411
        x: [ 2.500e-01]
      nit: 3
      jac: [ 0.000e+00]
 hess_inv: [[ 1.000e-02]]
     nfev: 14
     njev: 7
&lt;/pre&gt;


&lt;p&gt;
You can see it took two iterations to find a solution. Other times it might take zero or one, or maybe more, it depends on where the guesses fall.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5b8b358" class="outline-2"&gt;
&lt;h2 id="org5b8b358"&gt;&lt;span class="section-number-2"&gt;3.&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
This solution works pretty well, similar to custodian. It is a little simpler than custodian I think, as you can do simple things with functions, and don't really need to make classes for everything. Probably it does less than custodian, and also probably there are some corner issues I haven't uncovered yet. It was a nice exercise in building a decorator though, and thinking through all the ways this can be done.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/09/20/Supervising-Python-functions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.7-pre&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication - Sequential Sampling Methods for Finding Classification Boundaries in Engineering Applications]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/New-publication-Sequential-Sampling-Methods-for-Finding-Classification-Boundaries-in-Engineering-Applications" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/New-publication-Sequential-Sampling-Methods-for-Finding-Classification-Boundaries-in-Engineering-Applications</id>
    <updated>2023-09-19T15:57:56Z</updated>
    <published>2023-09-19T15:57:56Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="news" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="publication" />
    <summary type="html"><![CDATA[New publication - Sequential Sampling Methods for Finding Classification Boundaries in Engineering Applications]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/New-publication-Sequential-Sampling-Methods-for-Finding-Classification-Boundaries-in-Engineering-Applications"><![CDATA[


&lt;p&gt;
We have a new publication out! In this work we show how to use classification algorithms to find boundaries in science and engineering applications. These applications come up all over the place, for example you may want to know what compositions phase separate, and which ones are single phase, or what conditions lead to degradation and which ones don't. You might want to know which operating parameters have desirable properties, and which don't. In this work we show how to efficiently find the boundaries between these regions using active learning and a classifier. We show that this approach is generally better (more accurate and fewer experiments) than doing a dense grid search.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;bhat-2023-sequen-sampl&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Maya Bhat and John R. Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Sequential Sampling Methods for Finding Classification
                  Boundaries in Engineering Applications},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Industrial \&amp;amp; Engineering Chemistry Research},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       {n/a},
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       {n/a},
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        {n/a},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2023,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1021/acs.iecr.3c02362&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;http://dx.doi.org/10.1021/acs.iecr.3c02362&lt;/span&gt;}
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Check out the Youtube video summary here:
&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/upvDBvLMGgo?si=ZTUpVP2-dKOd4Yuh" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/acs.iecr.3c02362'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/09/19/New-publication---Sequential-Sampling-Methods-for-Finding-Classification-Boundaries-in-Engineering-Applications.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.7-pre&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[Using Custodian to help converge an optimization problem]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/Using-Custodian-to-help-converge-an-optimization-problem" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/Using-Custodian-to-help-converge-an-optimization-problem</id>
    <updated>2023-09-19T15:35:08Z</updated>
    <published>2023-09-19T15:34:21Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="programming" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="optimization" />
    <summary type="html"><![CDATA[Using Custodian to help converge an optimization problem]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/09/19/Using-Custodian-to-help-converge-an-optimization-problem"><![CDATA[


&lt;p&gt;
In high-throughput calculations, some fraction of them usually fail for some reason. Sometimes it is easy to fix these calculations and re-run them successfully, for example, you might just need a different initialization, or to increase memory or the number of allowed steps, etc.  &lt;a href="http://materialsproject.github.io/custodian/"&gt;custodian&lt;/a&gt; is a tool that is designed for this purpose. 
&lt;/p&gt;

&lt;p&gt;
The idea is we make a function to do what we want that has arguments that control that. We need a function that can examine the output of the function and determine if it succeeded, and if it didn't succeed to say what new arguments to try next. Then we run the function in custodian and let it take care of rerunning with new arguments until it either succeeds, or tries too many times.
&lt;/p&gt;

&lt;p&gt;
The goal here is to use &lt;a href="http://materialsproject.github.io/custodian/"&gt;custodian&lt;/a&gt; to fix a problem optimization. The example is a little contrived, we set a number of iterations artificially low so that the minimization fails by reaching the maximum number of iterations. Custodian will catch this, and increase the number of iterations until it succeeds. Here is the objective function:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(x):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(x**2) - 10*np.exp(x)

&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.linspace(0, 2)
plt.plot(x, objective(x))
plt.xlabel(&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'y'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/354616de80c1f529dd249d03f96e5bc023bbd321.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
Clearly there is a minimum near 1.75, but with a bad initial guess, and not enough iterations, an optimizer fails here. We can tell it fails from the message here, and the solution is run it again with more iterations.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; minimize

minimize(objective, 0.0, options={&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: 2})
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="org27fcdb3"&gt;
:RESULTS:
  message: Maximum number of iterations has been exceeded.
  success: False
   status: 1
      fun: -36.86289091418059
        x: [ 1.661e+00]
      nit: 2
      jac: [-2.374e-01]
 hess_inv: [[ 6.889e-03]]
     nfev: 20
     njev: 10
:END:
&lt;/pre&gt;

&lt;p&gt;
With Custodian you define a "Job". This is a class with  &lt;code&gt;params&lt;/code&gt; that contain the adjustable arguments in a dictionary, and a &lt;code&gt;run&lt;/code&gt; method that stores the results in the params attribute. This is an important step, because the error handlers only get the params, so you need the results in there to inspect them.
&lt;/p&gt;

&lt;p&gt;
The error handlers are another class with a &lt;code&gt;check&lt;/code&gt; method that returns True if you should rerun, and a &lt;code&gt;correct&lt;/code&gt; method that sets the params to new values to try next. It seems to return some information about what happened. In the &lt;code&gt;correct&lt;/code&gt; method, we double the maximum number of iterations allowed, and use the last solution point that failed as the initial guess for the next run.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; custodian.custodian &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; Custodian, Job, ErrorHandler

&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Minimizer&lt;/span&gt;(Job):
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, params=&lt;span style="color: #D0372D;"&gt;None&lt;/span&gt;):
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params = params &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; params &lt;span style="color: #0000FF;"&gt;else&lt;/span&gt; {&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: 2, &lt;span style="color: #008000;"&gt;'x0'&lt;/span&gt;: 0}
        
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;run&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
        sol = minimize(objective,
                       &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'x0'&lt;/span&gt;],
                       options={&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;]})
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'sol'&lt;/span&gt;] = sol

&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;MaximumIterationsExceeded&lt;/span&gt;(ErrorHandler):
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, params):
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params = params

    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;check&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'sol'&lt;/span&gt;].message == &lt;span style="color: #008000;"&gt;'Maximum number of iterations has been exceeded.'&lt;/span&gt;

    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;correct&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;] *= 2
        &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'x0'&lt;/span&gt;] = &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.params[&lt;span style="color: #008000;"&gt;'sol'&lt;/span&gt;].x        
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; {&lt;span style="color: #008000;"&gt;'errors'&lt;/span&gt;: &lt;span style="color: #008000;"&gt;'MaximumIterations Exceeded'&lt;/span&gt;,
                &lt;span style="color: #008000;"&gt;'actions'&lt;/span&gt;: &lt;span style="color: #008000;"&gt;'maxiter = {self.params["maxiter"]}, x0 = {self.params["x0"]}'&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we setup the initial params to try, create a Custodian object with the handler and job, and then run it. The results and final params are stored in the params object.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = {&lt;span style="color: #008000;"&gt;'maxiter'&lt;/span&gt;: 1, &lt;span style="color: #008000;"&gt;'x0'&lt;/span&gt;: 0}

&lt;span style="color: #BA36A5;"&gt;c&lt;/span&gt; = Custodian([MaximumIterationsExceeded(params)],
              [Minimizer(params)],
               max_errors=5)

c.run()
&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; key &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; params:
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(key, params[key])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example" id="orgca61279"&gt;
MaximumIterationsExceeded
MaximumIterationsExceeded
maxiter 4
x0 [1.66250127]
sol   message: Optimization terminated successfully.
  success: True
   status: 0
      fun: -36.86307468296398
        x: [ 1.662e+00]
      nit: 1
      jac: [-9.060e-06]
 hess_inv: [[1]]
     nfev: 6
     njev: 3
&lt;/pre&gt;



&lt;p&gt;
Note that params is modified, and finally has the maxiter value that worked, and the solution in it. You can see we had to rerun this problem  twice before it succeeded, but this happened automatically after the setup. This example is easy because we can simply increase the maxiter value, and no serious logic is needed. Other use cases might include try it again with another solver, try again with a different initial guess, etc. 
&lt;/p&gt;

&lt;p&gt;
It feels a little heavyweight to define the classes, and to store the results in params here, but this was overall under an hour of work to put it all together, starting from scratch with the &lt;a href="http://materialsproject.github.io/custodian/"&gt;Custodian documentation&lt;/a&gt; from the example on the front page. You can do more sophisticated things, including having multiple error handlers. Overall, for a package designed for molecular simulations, this worked well for a different kind of problem.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/09/19/Using-Custodian-to-help-converge-an-optimization-problem.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.7-pre&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[New Publication - An Inverse Mapping Approach for Process Systems Engineering Using Automatic Differentiation and the Implicit Function Theorem]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/04/25/New-Publication-An-Inverse-Mapping-Approach-for-Process-Systems-Engineering-Using-Automatic-Differentiation-and-the-Implicit-Function-Theorem" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/04/25/New-Publication-An-Inverse-Mapping-Approach-for-Process-Systems-Engineering-Using-Automatic-Differentiation-and-the-Implicit-Function-Theorem</id>
    <updated>2023-04-25T13:43:14Z</updated>
    <published>2023-04-25T13:43:14Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="publication" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="news" />
    <summary type="html"><![CDATA[New Publication - An Inverse Mapping Approach for Process Systems Engineering Using Automatic Differentiation and the Implicit Function Theorem]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/04/25/New-Publication-An-Inverse-Mapping-Approach-for-Process-Systems-Engineering-Using-Automatic-Differentiation-and-the-Implicit-Function-Theorem"><![CDATA[


&lt;p&gt;
Solving inverse problems, where we know what outputs we want from a model and seek the inputs that provide them, is a difficult task. A conventional approach to this problem is to use a nonlinear program (NLP) solver to iteratively find the inputs for a specific output. If you seek a desired output space, then you must solve the NLP many times to map out the corresponding input space. This is often expensive, and tedious to perform. In this work, we demonstrate a new approach to solving this problem that avoids the NLP formulation, and is faster. The idea is simple; we compute a system of differential equations that maps how the input space changes with the output space. Then from a single known point we can integrate a path in the output space to automatically trace the corresponding path in the input space! We compute the system of differential equations using automatic differentiation, and the implicit derivative theorem. We show two examples of this using a steady state continuously stirred tank reactor, which is a set of nonlinear algebraic equations that define the output space from input variables, and another plug flow reactor where the output space is defined by a set of differential equations that must be numerically integrated. In both cases we use automatic differentiation to define the system of ODEs that relate outputs and inputs, and show that the path integration method developed here is as accurate and faster than even the best NLP approach. The idea in this paper is general and applicable to many other systems, not just chemical reactors.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;alves-2023&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Alves, Victor and Kitchin, John R. and Lima, Fernando V.},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {An inverse mapping approach for process systems engineering
                  using automatic differentiation and the implicit function
                  theorem},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {AIChE Journal},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2023,
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       {n/a},
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       {n/a},
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        {e18119},
  &lt;span style="color: #BA36A5;"&gt;keywords&lt;/span&gt; =     {automatic differentiation, implicit function theorem, inverse
                  mapping, inverse problems, process systems engineering},
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1002/aic.18119&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =
                  {https://aiche.onlinelibrary.wiley.com/doi/abs/10.1002/aic.18119}
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1002/aic.18119'&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/UAIUSr4TzBk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/04/25/New-Publication---An-Inverse-Mapping-Approach-for-Process-Systems-Engineering-Using-Automatic-Differentiation-and-the-Implicit-Function-Theorem.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.5.5&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication - WhereWulff A Semiautonomous Workflow for Systematic Catalyst Surface Reactivity under Reaction Conditions]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/04/16/New-publication-WhereWulff-A-Semiautonomous-Workflow-for-Systematic-Catalyst-Surface-Reactivity-under-Reaction-Conditions" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/04/16/New-publication-WhereWulff-A-Semiautonomous-Workflow-for-Systematic-Catalyst-Surface-Reactivity-under-Reaction-Conditions</id>
    <updated>2023-04-16T09:49:02Z</updated>
    <published>2023-04-16T09:46:53Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="publication" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="news" />
    <summary type="html"><![CDATA[New publication - WhereWulff A Semiautonomous Workflow for Systematic Catalyst Surface Reactivity under Reaction Conditions]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/04/16/New-publication-WhereWulff-A-Semiautonomous-Workflow-for-Systematic-Catalyst-Surface-Reactivity-under-Reaction-Conditions"><![CDATA[


&lt;p&gt;
Suppose you want to explore metal oxides as potential water oxidation electrocatalysts. There are many steps to do this. You can use databases of materials to get compositions and structures, but for each one you have to determine the ground state structure, including magnetic states, for each bulk structure, and filter out bulk materials that are not stable under water oxidation conditions. Then, using the remaining structures you have to construct slabs and determine which surfaces are likely to be stable, and most relevant. After that you have to compute adsorption energies on those surfaces to see which surfaces have the most relevant reactivity (while also being stable). This results in hundreds to thousands of calculations that depend on each other in important ways. It is very useful to use software workflow tools to facilitate and manage this process. In this paper we develop a workflow like this for exploring metal oxides for water oxidation. The software is open source and available at &lt;a href="https://github.com/ulissigroup/wherewulff"&gt;https://github.com/ulissigroup/wherewulff&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
The paper is free to read for 6 months at &lt;a href="https://pubs.acs.org/doi/10.1021/acs.jcim.3c00142"&gt;https://pubs.acs.org/doi/10.1021/acs.jcim.3c00142&lt;/a&gt;.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;sanspeur-2023&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; = {Rohan Yuri Sanspeur and Javier Heras-Domingo and John R. Kitchin and Zachary Ulissi},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; = {wherewulff: a Semiautonomous Workflow for Systematic Catalyst Surface Reactivity Under Reaction Conditions},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; = {Journal of Chemical Information and Modeling},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; = {nil},
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; = {nil},
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; = {nil},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; = {2023},
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; = {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1021/acs.jcim.3c00142&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; = {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;http://dx.doi.org/10.1021/acs.jcim.3c00142&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;DATE_ADDED&lt;/span&gt; = {Sun Apr 16 09:17:23 2023},
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/acs.jcim.3c00142'&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/UyjTvIeZOEk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/04/16/New-publication---WhereWulff-A-Semiautonomous-Workflow-for-Systematic-Catalyst-Surface-Reactivity-under-Reaction-Conditions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.5.5&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication - High throughput discovery of ternary Cu-Fe-Ru alloy catalysts for photo-driven hydrogen production]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/04/15/New-publication-High-throughput-discovery-of-ternary-Cu-Fe-Ru-alloy-catalysts-for-photo-driven-hydrogen-production" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/04/15/New-publication-High-throughput-discovery-of-ternary-Cu-Fe-Ru-alloy-catalysts-for-photo-driven-hydrogen-production</id>
    <updated>2023-04-15T08:14:28Z</updated>
    <published>2023-04-15T08:14:28Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="publication" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="news" />
    <summary type="html"><![CDATA[New publication - High throughput discovery of ternary Cu-Fe-Ru alloy catalysts for photo-driven hydrogen production]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/04/15/New-publication-High-throughput-discovery-of-ternary-Cu-Fe-Ru-alloy-catalysts-for-photo-driven-hydrogen-production"><![CDATA[


&lt;p&gt;
Finding new ways to make hydrogen with renewable energy and renewable feedstocks using earth abundant materials remains a challenge in catalysis today. Metal nanoparticles are common heterogeneous catalysts for hydrogen production, and their properties can often be improved by using multiple metals at a time. In this work we show a high-throughput experimental approach to discovering a ternary alloy catalyst containing earth abundant metals that is more active at producing hydrogen than any of the pure metals it is made of. It a surprising discovery because these metals are not typically miscible, and they do not form a well characterized material, but rather a distribution of particle sizes and compositions. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;bhat-2023-high-throug&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; = {Maya Bhat and Zoe C Simon and Savannah Talledo and Riti Sen and Jacob H. Smith and Stefan Bernhard and Jill E Millstone and John R Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; = {High Throughput Discovery of Ternary Cu-Fe-Ru Alloy Catalysts for Photo-Driven Hydrogen Production},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; = {Reaction Chemistry \&amp;amp; Engineering},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; = {nil},
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; = {nil},
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; = {nil},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; = {2023},
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; = {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1039/d3re00059a&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; = {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;http://dx.doi.org/10.1039/D3RE00059A&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;DATE_ADDED&lt;/span&gt; = {Sat Apr 15 07:55:55 2023},
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/d3re00059a'&gt;&lt;/div&gt;
&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/2OXbkIvWkjs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/04/15/New-publication---High-throughput-discovery-of-ternary-Cu-Fe-Ru-alloy-catalysts-for-photo-driven-hydrogen-production.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.5.5&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[MS Word comments from org-mode]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/02/25/MS-Word-comments-from-org-mode" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/02/25/MS-Word-comments-from-org-mode</id>
    <updated>2023-02-25T15:48:27Z</updated>
    <published>2023-02-25T11:49:07Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="orgmode" />
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="docx" />
    <summary type="html"><![CDATA[MS Word comments from org-mode]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/02/25/MS-Word-comments-from-org-mode"><![CDATA[


&lt;div id="table-of-contents" role="doc-toc"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents" role="doc-toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org0b8ac89"&gt;1. export features for test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb2df34d"&gt;2. References&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga834870"&gt;3. Alternate build with HTML.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
TL;DR: 
&lt;/p&gt;

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/sKo1qb3xxWI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;
Today I &lt;a href="https://www.reddit.com/r/orgmode/comments/11bkt2h/is_it_possible_to_pass_html_in_org_to_pandoc_word/"&gt;learned&lt;/a&gt; you can make a Word document from org-mode with Word comments in them. This could be useful when working with collaborators maybe. The gist is you use html for the comment, then export to markdown or html, then let pandoc convert those to docx. A comment in HTML looks like this:
&lt;/p&gt;

&lt;pre class="example" id="orga243141"&gt;
&amp;lt;span class="comment-start" author="jkitchin"&amp;gt;Comment text&amp;lt;/span&amp;gt;The text being commented on &amp;lt;span class="comment-end"&amp;gt;&amp;lt;/span&amp;gt; 
&lt;/pre&gt;

&lt;p&gt;
Let's wrap that in a link for convenience. I use a full display so it is easy to see the comment. I only export the comment for markdown and html export, for everything else we just use the path. We somewhat abuse the link syntax here by using the path for the text to comment on, and the description for the comment.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-link-set-parameters
 &lt;span style="color: #008000;"&gt;"comment"&lt;/span&gt;
 &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (path desc backend)
           (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (member backend '(md html))
               (format &lt;span style="color: #008000;"&gt;"&amp;lt;span class=\"comment-start\" author=\"%s\"&amp;gt;%s&amp;lt;/span&amp;gt;%s&amp;lt;span class=\"comment-end\"&amp;gt;&amp;lt;/span&amp;gt;"&lt;/span&gt;
                       (user-full-name)
                       desc
                       path)
             &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;ignore for other backends and just use path&lt;/span&gt;
             path))
 &lt;span style="color: #006FE0;"&gt;:display&lt;/span&gt; 'full
 &lt;span style="color: #006FE0;"&gt;:face&lt;/span&gt; '(&lt;span style="color: #006FE0;"&gt;:foreground&lt;/span&gt; &lt;span style="color: #008000;"&gt;"orange"&lt;/span&gt;))                  
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we use it like this &lt;span class="comment-start" author="John Kitchin"&gt;This is the comment&lt;/span&gt;This is the text commented on&lt;span class="comment-end"&gt;&lt;/span&gt;.
&lt;/p&gt;

&lt;p&gt;
In org-mode it looks like:
&lt;/p&gt;

&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/date-25-02-2023-time-11-44-11.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
To get the Word doc, we need some code that first exports to Markdown, and then calls pandoc to convert that to docx. Here is my solution to that. Usually you would put this in a subsection tagged with :noexport: but I show it here to see it. Running this block generates the docx file and opens it. Here I also leverage org-ref to get some citations and cross-references.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;org-ref-refproc&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((org-export-before-parsing-hook '(org-ref-cite-natmove &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;do this first&lt;/span&gt;
                                        org-ref-csl-preprocess-buffer
                                        org-ref-refproc))
       (md (org-md-export-to-markdown))
       (docx (concat (file-name-sans-extension md) &lt;span style="color: #008000;"&gt;".docx"&lt;/span&gt;)))
  (shell-command (format &lt;span style="color: #008000;"&gt;"pandoc -s %s -o %s"&lt;/span&gt; md docx))
  (org-open-file docx '(16)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The result looks like this in MS Word:
&lt;/p&gt;


&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/date-25-02-2023-time-11-41-37.png"&gt;&lt;figcaption&gt;How a comment looks in Word.&lt;/figcaption&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
That is pretty remarkable. There are some limitations in Markdown, e.g. I find the tables don't look good, not all equations are converted, some cross-references are off. Next we add some more org-features and try the export with HTML.
&lt;/p&gt;

&lt;div id="outline-container-org0b8ac89" class="outline-2"&gt;
&lt;h2 id="org0b8ac89"&gt;&lt;span class="section-number-2"&gt;1.&lt;/span&gt; export features for test&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Test cross-references, references, equations, etc&amp;#x2026;
&lt;/p&gt;

&lt;p&gt;
Aliquam erat volutpat (Fig. &lt;a href="fig-2"&gt;fig-2&lt;/a&gt;).  Nunc eleifend leo vitae magna.  In id erat non orci commodo lobortis.  Proin neque massa, cursus ut, gravida ut, lobortis eget, lacus.  Sed diam.  Praesent fermentum tempor tellus.  Nullam tempus &lt;a href="&amp;amp;yang-2022-evaluat-degree"&gt;&amp;amp;yang-2022-evaluat-degree&lt;/a&gt;.  Mauris ac felis vel velit tristique imperdiet.  Donec at pede.  Etiam vel neque nec dui dignissim bibendum.  Vivamus id enim.  Phasellus neque orci, porta a, aliquet quis in Table &lt;a href="tab-1"&gt;tab-1&lt;/a&gt;, semper a, massa.  Phasellus purus (&lt;a href="eq-1"&gt;eq-1&lt;/a&gt;).  Pellentesque tristique imperdiet tortor.  Nam euismod tellus id erat &lt;a href="&amp;amp;kolluru-2022-open-chall"&gt;&amp;amp;kolluru-2022-open-chall&lt;/a&gt;.
&lt;/p&gt;

&lt;table id="org90422fb" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;
&lt;caption class="t-above"&gt;&lt;span class="table-number"&gt;Table 1:&lt;/span&gt; A table.&lt;/caption&gt;

&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;x&lt;/td&gt;
&lt;td class="org-right"&gt;y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;1&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
We have equations:
&lt;/p&gt;

\begin{equation}
\label{org9973acf}
y = mx + b
\end{equation}


&lt;ul class="org-ul"&gt;
&lt;li&gt;bullet1
&lt;ul class="org-ul"&gt;
&lt;li&gt;nested bullet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;bullet2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
some defintions:
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;emacs&lt;/dt&gt;&lt;dd&gt;greatest editor&lt;/dd&gt;
&lt;/dl&gt;


&lt;ol class="org-ol"&gt;
&lt;li&gt;item 1&lt;/li&gt;
&lt;li&gt;item 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
One equation: \(e^{i\pi} - 1 = 0\)
&lt;/p&gt;

&lt;p&gt;
A second equation:
&lt;/p&gt;

\begin{equation}
e^{i\pi} - 1 = 0
\end{equation}
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgb2df34d" class="outline-2"&gt;
&lt;h2 id="orgb2df34d"&gt;&lt;span class="section-number-2"&gt;2.&lt;/span&gt; References&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
&lt;a href="~/Dropbox/emacs/bibliography/references.bib"&gt;~/Dropbox/emacs/bibliography/references.bib&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga834870" class="outline-2"&gt;
&lt;h2 id="orga834870"&gt;&lt;span class="section-number-2"&gt;3.&lt;/span&gt; Alternate build with HTML.&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Here we consider &lt;span class="comment-start" author="John Kitchin"&gt;For example, html&lt;/span&gt;alternate build approaches&lt;span class="comment-end"&gt;&lt;/span&gt;.
&lt;/p&gt;

&lt;p&gt;
Run this to get the docx file. I find this superior; it has references, cross-references, equations, tables, figures, etc. Even a title.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((org-export-before-parsing-hook '(org-ref-csl-preprocess-buffer
                                         org-ref-refproc))
       (org-html-with-latex 'dvipng)
       (f (org-html-export-to-html))
       (docx (concat (file-name-sans-extension f) &lt;span style="color: #008000;"&gt;".docx"&lt;/span&gt;)))
  (shell-command (format &lt;span style="color: #008000;"&gt;"pandoc -s %s -o %s"&lt;/span&gt; f docx))
  (org-open-file docx '(16)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/02/25/MS-Word-comments-from-org-mode.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.5.5&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[Update on finding the minimum distance from a point to a curve]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/02/17/Update-on-finding-the-minimum-distance-from-a-point-to-a-curve" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/02/17/Update-on-finding-the-minimum-distance-from-a-point-to-a-curve</id>
    <updated>2023-02-17T18:41:43Z</updated>
    <published>2023-02-17T18:41:43Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="optimization" />
    <summary type="html"><![CDATA[Update on finding the minimum distance from a point to a curve]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/02/17/Update-on-finding-the-minimum-distance-from-a-point-to-a-curve"><![CDATA[


&lt;p&gt;
Almost 10 years ago I &lt;a href="https://kitchingroup.cheme.cmu.edu/blog/2013/02/14/Find-the-minimum-distance-from-a-point-to-a-curve/"&gt;wrote&lt;/a&gt; about finding the minimum distance from a point to a curve using a constrained optimization. At that time, the way to do this used &lt;code&gt;scipy.optimize.fmin_coblya&lt;/code&gt;. I learned today from a student, that sometimes this method fails! I reproduce the code here, updated for Python 3, some style updates, and to show it does indeed fail sometimes, notably when the point is "outside" the parabola.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fmin_cobyla

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt;(x):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x**2

&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; P &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; np.array([[0.5, 2],
                   [2, 2],
                   [-1, 2],
                   [-2, 2],
                   [0, 0.5],
                   [0, -0.5]]):
    
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(X):
        &lt;span style="color: #BA36A5;"&gt;X&lt;/span&gt; = np.array(X)
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.linalg.norm(X - P)

    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;c1&lt;/span&gt;(X):
        &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;,&lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = X
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; f(x) - y

    &lt;span style="color: #BA36A5;"&gt;X&lt;/span&gt; = fmin_cobyla(objective, x0=[P[0], f(P[0])], cons=[c1])

    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The minimum distance is &lt;/span&gt;{objective(X):1.2f}&lt;span style="color: #008000;"&gt;. Constraint satisfied = &lt;/span&gt;{c1(X) &amp;lt; 1e-6}&lt;span style="color: #008000;"&gt;'&lt;/span&gt;)

    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Verify the vector to this point is normal to the tangent of the curve&lt;/span&gt;
    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;position vector from curve to point&lt;/span&gt;
    v1 = np.array(P) - np.array(X)
    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;position vector&lt;/span&gt;
    v2 = np.array([1, 2.0 * X[0]])
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'dot(v1, v2) = '&lt;/span&gt;, np.dot(v1, v2))

    x = np.linspace(-2, 2, 100)

    plt.plot(x, f(x), &lt;span style="color: #008000;"&gt;'r-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'f(x)'&lt;/span&gt;)
    plt.plot(P[0], P[1], &lt;span style="color: #008000;"&gt;'bo'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'point'&lt;/span&gt;)
    plt.plot([P[0], X[0]], [P[1], X[1]], &lt;span style="color: #008000;"&gt;'b-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'shortest distance'&lt;/span&gt;)
    plt.plot([X[0], X[0] + 1], [X[1], X[1] + 2.0 * X[0]], &lt;span style="color: #008000;"&gt;'g-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'tangent'&lt;/span&gt;)
    plt.axis(&lt;span style="color: #008000;"&gt;'equal'&lt;/span&gt;)
    plt.xlabel(&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;)
    plt.ylabel(&lt;span style="color: #008000;"&gt;'y'&lt;/span&gt;)    
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The minimum distance is 0.86. Constraint satisfied = True
dot(v1, v2) =  0.0002913487659186309
The minimum distance is 0.00. Constraint satisfied = False
dot(v1, v2) =  0.00021460906432962284
The minimum distance is 0.39. Constraint satisfied = True
dot(v1, v2) =  0.00014271520451364372
The minimum distance is 0.00. Constraint satisfied = False
dot(v1, v2) =  -0.0004089466778209598
The minimum distance is 0.50. Constraint satisfied = True
dot(v1, v2) =  1.9999998429305957e-12
The minimum distance is 0.00. Constraint satisfied = False
dot(v1, v2) =  8.588744170160093e-06
&lt;figure&gt;&lt;img src="/media/f66cff16ba65526d5877bd894142fa021c51f434.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
So, sure enough, the optimizer is failing to find a solution that meets the constraint. It is strange it does not work on the outside. That is almost certainly an algorithm problem. Here we solve it nearly identically with the more modern &lt;code&gt;scipy.optimize.minimize&lt;/code&gt; function, and it converges every time. 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; minimize

&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; P &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; np.array([[0.5, 2],
                   [2, 2],
                   [-1, 2],
                   [-2, 2],
                   [0, 0.5],
                   [0, -0.5]]):
    
    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(X):
        &lt;span style="color: #BA36A5;"&gt;X&lt;/span&gt; = np.array(X)
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.linalg.norm(X - P)

    &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;c1&lt;/span&gt;(X):
        &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;,&lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = X
        &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; f(x) - y

    &lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = minimize(objective, x0=[P[0], f(P[0])], constraints={&lt;span style="color: #008000;"&gt;'type'&lt;/span&gt;: &lt;span style="color: #008000;"&gt;'eq'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'fun'&lt;/span&gt;: c1})
    X = sol.x

    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The minimum distance is &lt;/span&gt;{objective(X):1.2f}&lt;span style="color: #008000;"&gt;. Constraint satisfied = &lt;/span&gt;{sol.status &amp;lt; 1e-6}&lt;span style="color: #008000;"&gt;'&lt;/span&gt;)

    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Verify the vector to this point is normal to the tangent of the curve&lt;/span&gt;
    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;position vector from curve to point&lt;/span&gt;
    v1 = np.array(P) - np.array(X)
    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;position vector&lt;/span&gt;
    v2 = np.array([1, 2.0 * X[0]])
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'dot(v1, v2) = '&lt;/span&gt;, np.dot(v1, v2))

    x = np.linspace(-2, 2, 100)

    plt.plot(x, f(x), &lt;span style="color: #008000;"&gt;'r-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'f(x)'&lt;/span&gt;)
    plt.plot(P[0], P[1], &lt;span style="color: #008000;"&gt;'bo'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'point'&lt;/span&gt;)
    plt.plot([P[0], X[0]], [P[1], X[1]], &lt;span style="color: #008000;"&gt;'b-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'shortest distance'&lt;/span&gt;)
    plt.plot([X[0], X[0] + 1], [X[1], X[1] + 2.0 * X[0]], &lt;span style="color: #008000;"&gt;'g-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'tangent'&lt;/span&gt;)
    plt.axis(&lt;span style="color: #008000;"&gt;'equal'&lt;/span&gt;)
    plt.xlabel(&lt;span style="color: #008000;"&gt;'x'&lt;/span&gt;)
    plt.ylabel(&lt;span style="color: #008000;"&gt;'y'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The minimum distance is 0.86. Constraint satisfied = True
dot(v1, v2) =  1.0701251773603815e-08
The minimum distance is 0.55. Constraint satisfied = True
dot(v1, v2) =  -0.0005793028003104883
The minimum distance is 0.39. Constraint satisfied = True
dot(v1, v2) =  -1.869272921939391e-05
The minimum distance is 0.55. Constraint satisfied = True
dot(v1, v2) =  0.0005792953298950909
The minimum distance is 0.50. Constraint satisfied = True
dot(v1, v2) =  0.0
The minimum distance is 0.50. Constraint satisfied = True
dot(v1, v2) =  0.0
&lt;figure&gt;&lt;img src="/media/4776aa1f11411aa8cf0c3ea47f96e2a8973e314e.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
There is no wisdom in fixing the first problem, here I just tried a newer optimization method. Out of the box with default settings it just worked. I did learn the answer is sensitive to the initial guess, so it could make sense to sample the function and find the point that is closest as the initial guess, but here the simple heuristic guess I used worked fine.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/02/17/Update-on-finding-the-minimum-distance-from-a-point-to-a-curve.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.5.5&lt;/p&gt;]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>https://kitchingroup.cheme.cmu.edu/blog</uri>
    </author>
    <title type="html"><![CDATA[Caching expensive function calls so you don't have to rerun them]]></title>
    <link rel="alternate" type="text/html" href="https://kitchingroup.cheme.cmu.edu/blog/2023/02/01/Caching-expensive-function-calls-so-you-don-t-have-to-rerun-them" />
    <id>https://kitchingroup.cheme.cmu.edu/blog/2023/02/01/Caching-expensive-function-calls-so-you-don-t-have-to-rerun-them</id>
    <updated>2023-02-01T20:11:02Z</updated>
    <published>2023-02-01T20:09:44Z</published>
    <category scheme="https://kitchingroup.cheme.cmu.edu/blog" term="python" />
    <summary type="html"><![CDATA[Caching expensive function calls so you don't have to rerun them]]></summary>
    <content type="html" xml:base="https://kitchingroup.cheme.cmu.edu/blog/2023/02/01/Caching-expensive-function-calls-so-you-don-t-have-to-rerun-them"><![CDATA[


&lt;div id="table-of-contents" role="doc-toc"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents" role="doc-toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org07769a2"&gt;1. where things start to go wrong&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org45a5a5a"&gt;1.1. Global variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org81a44de"&gt;1.2. running functions with mutable arguments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgeecc951"&gt;1.3. If you run the same function different ways, the cache is not reused&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgb8d7f30"&gt;1.4. Fragile cache invalidation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd5fbbc2"&gt;2. Some partial solutions with pycse.hashcache&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orge7c0587"&gt;2.1. No known problem with global variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org857113f"&gt;2.2. hashcache and mutable arguments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4925e4a"&gt;2.3. Reuse the cache when you run different ways&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8461f88"&gt;2.4. Insensitivity to unimportant changes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgfb0f2ed"&gt;3. Is it the answer?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Check out the video at:
&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/Sp0qebuYsZU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;
Nobody likes to run expensive jobs more than necessary, so cache solutions are often used where you save the results, and look them up later. There is functools.cache in Python, but it is memory only, and not persistent, so you start over in a new session.
&lt;/p&gt;

&lt;p&gt;
For persistent cache, joblib (&lt;a href="https://joblib.readthedocs.io/en/latest/"&gt;https://joblib.readthedocs.io/en/latest/&lt;/a&gt;) is a standard tool for this. Here is a simple example: 
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; joblib &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; Memory
&lt;span style="color: #BA36A5;"&gt;location&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'/Users/jkitchin/Dropbox/emacs/journal/2023/02/01/joblib_cache/joblib_cache'&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;memory&lt;/span&gt; = Memory(location, verbose=0)

&lt;span style="color: #6434A3;"&gt;@memory.cache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;fun&lt;/span&gt;(x=1.0):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs &amp;#128012;.'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x**2

&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(fun(2)) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Runs the function&lt;/span&gt;
&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(fun(2)) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Looks up the cached value&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
If you see this, go get a coffee while it runs 🐌.
4
4
&lt;/p&gt;

&lt;p&gt;
That works because joblib saves the results in a file in the location you specify.
&lt;/p&gt;

&lt;p&gt;
Here is another example with another arg.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #6434A3;"&gt;@memory.cache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f2&lt;/span&gt;(x=1.0, a=3):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs. a=&lt;/span&gt;{"&amp;#128012;"*a}&lt;span style="color: #008000;"&gt;'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2

(f2(2),       &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Runs function&lt;/span&gt;
 f2(2, a=3),  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;calls cache&lt;/span&gt;
 f2(2, 4))    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Runs another function because a changed&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
If you see this, go get a coffee while it runs. a=🐌🐌🐌
If you see this, go get a coffee while it runs. a=🐌🐌🐌🐌
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here, we look up from the cache each time.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;(f2(2), f2(2, a=3), f2(2, 4))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;div id="outline-container-org07769a2" class="outline-2"&gt;
&lt;h2 id="org07769a2"&gt;&lt;span class="section-number-2"&gt;1.&lt;/span&gt; where things start to go wrong&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org45a5a5a" class="outline-3"&gt;
&lt;h3 id="org45a5a5a"&gt;&lt;span class="section-number-3"&gt;1.1.&lt;/span&gt; Global variables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;p&gt;
First, we look at an uncached version of a function that uses a global variable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 3

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f3&lt;/span&gt;(x=1.0):
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2

f3(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
12
&lt;/p&gt;

&lt;p&gt;
We can change &lt;code&gt;a&lt;/code&gt; and see the change.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt;=0
f3(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
0
&lt;/p&gt;

&lt;p&gt;
Now we look at a cached version.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 3
&lt;span style="color: #6434A3;"&gt;@memory.cache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f4&lt;/span&gt;(x=1.0):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs &amp;#128012;.'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2

(f4(2), f4(2), f4(2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
If you see this, go get a coffee while it runs 🐌.
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Changing the global variable does not change the cache though. uh oh. This is just wrong. The answers should clearly be 0. Incorrect cache invalidation strikes.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 0
(f4(2), f4(2), f4(2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org81a44de" class="outline-3"&gt;
&lt;h3 id="org81a44de"&gt;&lt;span class="section-number-3"&gt;1.2.&lt;/span&gt; running functions with mutable arguments&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-2"&gt;
&lt;p&gt;
Using mutable arguments is a recipe for trouble and unanticipated problems, but it is easy to unintentionally do, and not always obvious, as I show here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase.build &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; bulk
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase.calculators.emt &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; EMT

&lt;span style="color: #BA36A5;"&gt;atoms&lt;/span&gt; = bulk(&lt;span style="color: #008000;"&gt;'Pd'&lt;/span&gt;)
atoms.set_calculator(EMT())

&lt;span style="color: #6434A3;"&gt;@memory.cache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f&lt;/span&gt;(atoms):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee.'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; atoms.get_potential_energy()

(f(atoms), f(atoms))

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
If you see this, go get a coffee.
If you see this, go get a coffee.
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;0.0003422625372841992&lt;/td&gt;
&lt;td class="org-right"&gt;0.0003422625372841992&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
You can see this ran twice. The reason is that the atoms object was mutated by adding data onto it. Here is how I know:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; joblib
&lt;span style="color: #BA36A5;"&gt;atoms&lt;/span&gt; = bulk(&lt;span style="color: #008000;"&gt;'Pd'&lt;/span&gt;)
atoms.set_calculator(EMT())
joblib.&lt;span style="color: #006FE0;"&gt;hash&lt;/span&gt;(atoms), atoms._calc.results
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;ee2ed2eb9fdb4b3d6416803a33f43a22&lt;/td&gt;
&lt;td class="org-left"&gt;nil&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here you can see that simply running the get energy function the hash changes because the results dictionary on the calculator changes. That means subsequent uses of the atoms object will have a different hash, and you cannot rely on that to look up the results. In this case the results should not change the output of the function, but since they are included in the hash, it incorrectly invalidates the hash.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;atoms.get_potential_energy()
joblib.&lt;span style="color: #006FE0;"&gt;hash&lt;/span&gt;(atoms), atoms._calc.results
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;d37ef0a5761f499060b4f55bdf644814&lt;/td&gt;
&lt;td class="org-left"&gt;(energy : 0.0003422625372841992 energies : array ((0.00034226)) free_energy : 0.0003422625372841992 forces : array (((0 0 0))))&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Suffice to say, this is non-obvious, but having seen it, not a surprise; mutable arguments are frequently a source of problems.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgeecc951" class="outline-3"&gt;
&lt;h3 id="orgeecc951"&gt;&lt;span class="section-number-3"&gt;1.3.&lt;/span&gt; If you run the same function different ways, the cache is not reused&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-3"&gt;
&lt;p&gt;
Some aspects of this are specific to org-mode and how scripts are run in it. Here we have to use an absolute path to make sure we use the right cache. That still doesn't solve the problem though as we will see.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; joblib &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; Memory
&lt;span style="color: #BA36A5;"&gt;location&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'/Users/jkitchin/Dropbox/emacs/journal/2023/02/01/joblib_cache/joblib_cache'&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;memory&lt;/span&gt; = Memory(location, verbose=0)

a = 3
&lt;span style="color: #6434A3;"&gt;@memory.cache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f4&lt;/span&gt;(x=1.0):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2

&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;((f4(2), f4(2), f4(2)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The issue is that joblib uses the file name it thinks the function is from in the path it saves the results. The filename is different
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgb8d7f30" class="outline-3"&gt;
&lt;h3 id="orgb8d7f30"&gt;&lt;span class="section-number-3"&gt;1.4.&lt;/span&gt; Fragile cache invalidation&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-4"&gt;
&lt;p&gt;
joblib uses the function source in its hash. That means &lt;i&gt;any&lt;/i&gt; change to the source, including the function name, renaming variables, whitespace, comments or docstring changes invalidates the hash even though they may have no change in the output. That is an overabundance of caution, but simple to implement.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #6434A3;"&gt;@memory.cache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;f4&lt;/span&gt;(x=1.0):
    &lt;span style="color: #036A07;"&gt;'add a ds.'&lt;/span&gt;
    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;comment&lt;/span&gt;
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2

&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;((f4(2), f4(2), f4(2)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
If you see this, go get a coffee while it runs
(0, 0, 0)
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgd5fbbc2" class="outline-2"&gt;
&lt;h2 id="orgd5fbbc2"&gt;&lt;span class="section-number-2"&gt;2.&lt;/span&gt; Some partial solutions with pycse.hashcache&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
I wrote &lt;code&gt;hashcache&lt;/code&gt; to solve some of these problems. It is actually built on top of joblib.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; pycse
pycse.__version__, pycse.__file__
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;2.2.1&lt;/td&gt;
&lt;td class="org-left"&gt;/Users/jkitchin/Dropbox/python/pycse/pycse/__init__.py&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; pycse.hashcache &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; hashcache
  
hashcache.&lt;span style="color: #BA36A5;"&gt;location&lt;/span&gt; = &lt;span style="color: #008000;"&gt;"/Users/jkitchin/Dropbox/emacs/journal/2023/02/01/cache"&lt;/span&gt;
hashcache.&lt;span style="color: #BA36A5;"&gt;verbose&lt;/span&gt; = &lt;span style="color: #D0372D;"&gt;False&lt;/span&gt;

&lt;span style="color: #6434A3;"&gt;@hashcache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;h1&lt;/span&gt;(x):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'This runs soo slow... Go get a coffee'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x**2

h1(2), h1(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;td class="org-right"&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge7c0587" class="outline-3"&gt;
&lt;h3 id="orge7c0587"&gt;&lt;span class="section-number-3"&gt;2.1.&lt;/span&gt; No known problem with global variables&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 3
&lt;span style="color: #6434A3;"&gt;@hashcache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;h4&lt;/span&gt;(x=1.0):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2

(h4(2), h4(2), h4(2))

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
If you see this, go get a coffee while it runs
&lt;/p&gt;
&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt;=0
(h4(2), h4(2), h4(2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;td class="org-right"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Whew!!! we got the right answers. hashcache does a better job detecting the external change.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org857113f" class="outline-3"&gt;
&lt;h3 id="org857113f"&gt;&lt;span class="section-number-3"&gt;2.2.&lt;/span&gt; hashcache and mutable arguments&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-2"&gt;
&lt;p&gt;
hashcache does not solve the mutable argument problem, but, it does warn you it detected it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase.build &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; bulk
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; ase.calculators.emt &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; EMT

&lt;span style="color: #BA36A5;"&gt;atoms&lt;/span&gt; = bulk(&lt;span style="color: #008000;"&gt;'Pd'&lt;/span&gt;)
atoms.set_calculator(EMT())

&lt;span style="color: #6434A3;"&gt;@hashcache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;h&lt;/span&gt;(atoms):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee.'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; atoms.get_potential_energy()

(h(atoms), h(atoms), h(atoms))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;0.0003422625372841992&lt;/td&gt;
&lt;td class="org-right"&gt;0.0003422625372841992&lt;/td&gt;
&lt;td class="org-right"&gt;0.0003422625372841992&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4925e4a" class="outline-3"&gt;
&lt;h3 id="org4925e4a"&gt;&lt;span class="section-number-3"&gt;2.3.&lt;/span&gt; Reuse the cache when you run different ways&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-3"&gt;
&lt;p&gt;
hashcache uses the same cache at the function and function environment level, so it avoids reruns even from different places. It is a judgement call by you to say if this is the right thing to do.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(h1(2), h1(2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
4 4
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; pycse.hashcache &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; hashcache
hashcache.&lt;span style="color: #BA36A5;"&gt;location&lt;/span&gt; = &lt;span style="color: #008000;"&gt;"/Users/jkitchin/Dropbox/emacs/journal/2023/02/01/cache"&lt;/span&gt;

&lt;span style="color: #6434A3;"&gt;@hashcache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;h1&lt;/span&gt;(x):
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'This runs soo slow... Go get a coffee'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x**2

&lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(h1(2), h1(2))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8461f88" class="outline-3"&gt;
&lt;h3 id="org8461f88"&gt;&lt;span class="section-number-3"&gt;2.4.&lt;/span&gt; Insensitivity to unimportant changes&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-4"&gt;
&lt;p&gt;
Instead of hashing the source of the function, in hashcache I hash the bytecode instead. This is certainly less sensitive to unimportant changes like docstrings, comments or whitespace. I do use the function name in the hash, so even though that does not affect the output, I thought it might be confusing in the future.
&lt;/p&gt;

&lt;p&gt;
Here, small changes like comments, docstrings, etc, don't affect the hash.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-jupyter-python"&gt;&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 3
&lt;span style="color: #6434A3;"&gt;@hashcache&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;h4&lt;/span&gt;(x=1.0):
    &lt;span style="color: #036A07;"&gt;'doc string'&lt;/span&gt;
    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;comments&lt;/span&gt;
    &lt;span style="color: #006FE0;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'If you see this, go get a coffee while it runs'&lt;/span&gt;)
    &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; a*x**2    

(h4(2), h4(2), h4(2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;td class="org-right"&gt;12&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfb0f2ed" class="outline-2"&gt;
&lt;h2 id="orgfb0f2ed"&gt;&lt;span class="section-number-2"&gt;3.&lt;/span&gt; Is it the answer?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Probably not completely. It is almost certain I have not captured all the ways the cache should be invalidated, or when a new cache should be used. hashcache is for now, a proof of concept in understanding why this is a hard problem to solve. I prefer its behavior over the defaults in joblib so far though.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2023 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2023/02/01/Caching-expensive-function-calls-so-you-don't-have-to-rerun-them.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.5.5&lt;/p&gt;]]></content>
  </entry>
</feed>
