<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Sun, 11 Jun 2017 20:10:19 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Adding keymaps to src blocks via org-font-lock-hook</title>
      <link>http://jkitchin.github.io/blog/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook</link>
      <pubDate>Sat, 10 Jun 2017 15:27:07 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">vAsDcb07joQ_xulHaGfKP0V6CIY=</guid>
      <description>Adding keymaps to src blocks via org-font-lock-hook</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgff08e05"&gt;1. Update&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I had an idea to use custom keymaps in src-blocks. For example, you could then use lispy directly in your org-files without entering org-special-edit, or the elpy key-bindings in python blocks. There are other solutions I have seen, e.g. polymode, that claim to do this. You might guess that if they worked, I would not be writing this! There was some nice discussion about this idea on the org-mode mailing list, and Nicolas Goaziou pointed out this might be accomplished with the org-font-lock-hook.
&lt;/p&gt;

&lt;p&gt;
You can check out the video here:
&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/a2jHqB1qWiY" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;
It was relatively easy to figure out how to do this. Keymaps can be added to regions during font-lock, so I just had to hook into the org-mode font lock system with a function to find the src blocks and add the keymap as a text-property. That took three steps:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Define the keymaps to use. I use an a-list of (language . map) for this.&lt;/li&gt;
&lt;li&gt;Define the font-lock function. This will add the keymap properties to src-blocks.&lt;/li&gt;
&lt;li&gt;Define a minor mode to toggle this feature on and off.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Here is the definition of the keymaps. Generally I just copy the mode-map I want and then add some things to them. For example sometimes it is still a good idea to jump into the org-special-edit mode. For example, if you try to use a command in a Python block to send the buffer to the repl while in org-mode you are sure to get an error! You might also want to add the C-c C-e export command if you use that a lot. An alternative approach, of course, is to copy the org-map and add additional bindings to it. The choice is up to you.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;lispy&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;elpy&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defcustom&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;scimax-src-block-keymaps&lt;/span&gt;
  `((&lt;span style="color: #008000;"&gt;"ipython"&lt;/span&gt; . ,(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((map (copy-keymap elpy-mode-map)))
                    (define-key map (kbd &lt;span style="color: #008000;"&gt;"C-c C-c"&lt;/span&gt;) 'org-ctrl-c-ctrl-c)
                    (define-key map (kbd &lt;span style="color: #008000;"&gt;"C-c '"&lt;/span&gt;) 'org-edit-special)
                    map))
    (&lt;span style="color: #008000;"&gt;"python"&lt;/span&gt; . ,(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((map (copy-keymap python-mode-map)))
                   (define-key map (kbd &lt;span style="color: #008000;"&gt;"C-c C-c"&lt;/span&gt;) 'org-ctrl-c-ctrl-c)
                   (define-key map (kbd &lt;span style="color: #008000;"&gt;"C-c '"&lt;/span&gt;) 'org-edit-special)
                   map))
    (&lt;span style="color: #008000;"&gt;"emacs-lisp"&lt;/span&gt; . ,(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((map (make-composed-keymap '(org-mode-map lisp-mode-map lispy-mode-map))))
                       (define-key map (kbd &lt;span style="color: #008000;"&gt;"C-c C-c"&lt;/span&gt;) 'org-ctrl-c-ctrl-c)
                       (define-key map (kbd &lt;span style="color: #008000;"&gt;"C-c '"&lt;/span&gt;) 'org-edit-special)
                       map)))
  &lt;span style="color: #036A07;"&gt;"alist of custom keymaps for src blocks."&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next we define the function that will apply the keymap to each src block. The keymaps are only applied when they are defined in the variable above. This function is derived from org-fontify-meta-lines-and-blocks-1.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-add-keymap-to-src-blocks&lt;/span&gt; (limit)
  &lt;span style="color: #036A07;"&gt;"Add keymaps to src-blocks defined in `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;scimax-src-block-keymaps&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;save-match-data&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((case-fold-search t))
      (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (re-search-forward
             &lt;span style="color: #008000;"&gt;"^&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;[ \t]*#&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;\\+[a-zA-Z]+:?&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt; &lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;$&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;_&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;[a-zA-Z]+&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;?&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;[ \t]*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt; \t\n]*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;[ \t]*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;.*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;"&lt;/span&gt;
             limit t)
        (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((beg (match-beginning 0))
              (lang (match-string 7))
              (dc3 (downcase (match-string 3)))
              end)
          (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
           ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (match-end 4) (equal dc3 &lt;span style="color: #008000;"&gt;"+begin"&lt;/span&gt;))
            (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (re-search-forward
                   (concat &lt;span style="color: #008000;"&gt;"^[ \t]*#\\+end"&lt;/span&gt; (match-string 4) &lt;span style="color: #008000;"&gt;"\\&amp;gt;.*"&lt;/span&gt;)
                   nil t) &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;on purpose, we look further than LIMIT&lt;/span&gt;
              (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; end (min (point-max) (match-end 0)))
              (add-text-properties
               beg end '(font-lock-fontified t font-lock-multiline t))

              &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Add keymap&lt;/span&gt;
              (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (assoc (org-no-properties lang) scimax-src-block-keymaps)
                (add-text-properties
                 beg end `(local-map ,(cdr (assoc
                                            (org-no-properties lang)
                                            scimax-src-block-keymaps)))))
              t))))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here we create an advice to trick any functions that need to know the major mode. We only apply the spoof if we are in org-mode and in a src block though. Otherwise we call the original function. So far lispy&amp;#x2013;eval is the only function I have needed it for. This might be a general strategy though to do other things like narrow to the src-block, or even go into special edit mode temporarily if there are commands that require it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-spoof-mode&lt;/span&gt; (orig-func &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"Advice function to spoof commands in org-mode src blocks.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;It is for commands that depend on the major mode. One example is&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;`&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;lispy--eval&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (org-in-src-block-p)
      (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((major-mode (intern (format &lt;span style="color: #008000;"&gt;"%s-mode"&lt;/span&gt; (first (org-babel-get-src-block-info))))))
        (apply orig-func args))
    (apply orig-func args)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We define a minor mode so we can toggle this on and off. Here we add the function to the org-font-lock-hook and advise the lispy&amp;#x2013;eval function. I had to add the font-lock-function to the end of the org-font-lock hook for some reason, and also add local-map as an extra-managed property so it would be removed when we toggle it off.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;define-minor-mode&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-src-keymap-mode&lt;/span&gt;
  &lt;span style="color: #036A07;"&gt;"Minor mode to add mode keymaps to src-blocks."&lt;/span&gt;
  &lt;span style="color: #006FE0;"&gt;:init-value&lt;/span&gt; nil
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; scimax-src-keymap-mode
      (&lt;span style="color: #0000FF;"&gt;progn&lt;/span&gt;
        (add-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks t)
        (add-to-list 'font-lock-extra-managed-props 'local-map)
        (advice-add 'lispy--eval &lt;span style="color: #006FE0;"&gt;:around&lt;/span&gt; 'scimax-spoof-mode)
        (message &lt;span style="color: #008000;"&gt;"enabled"&lt;/span&gt;))
    (remove-hook 'org-font-lock-hook #'scimax-add-keymap-to-src-blocks)
    (advice-remove 'lispy--eval 'scimax-spoof-mode))
  (font-lock-fontify-buffer))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That is it! I am pretty sure this is a good idea. It helps a lot when you are writing a lot of short code blocks and near equal amounts of text (like in this blog post). It also helps write the code since many things like indentation, parentheses, etc. are automatically handled. That is what I used to go into special-edit mode all the time for!
&lt;/p&gt;

&lt;p&gt;
I have not used this long enough to know if it causes any other surprises. If you try it and find any, leave a comment!
&lt;/p&gt;

&lt;div id="outline-container-orgff08e05" class="outline-2"&gt;
&lt;h2 id="orgff08e05"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Update&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
It turns out you can have the best of all the worlds by combining keymaps. The make-composed-keymap creates a new keymap that combines a keymaps and falls through to a parent keymap. So here we use that to combine several keymaps, falling through to org-mode. The only subtlety I have come across is that I remapped &amp;lt;return&amp;gt; in orgmode to scimax/org-return, and not all modes define it, so I redefine it in some places to just be newline.
&lt;/p&gt;

&lt;p&gt;
I use a few maps here, and some of them seem to just add menus that are only active when your cursor is in the block. Pretty handy!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; scimax-src-block-keymaps
      `((&lt;span style="color: #008000;"&gt;"ipython"&lt;/span&gt; . ,(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((map (make-composed-keymap
                                  `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                  org-mode-map)))
                        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;In org-mode I define RET so we f&lt;/span&gt;
                        (define-key map (kbd &lt;span style="color: #008000;"&gt;"&amp;lt;return&amp;gt;"&lt;/span&gt;) 'newline)
                        map))
        (&lt;span style="color: #008000;"&gt;"python"&lt;/span&gt; . ,(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((map (make-composed-keymap
                                  `(,elpy-mode-map ,python-mode-map ,pyvenv-mode-map)
                                  org-mode-map)))
                        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;In org-mode I define RET so we f&lt;/span&gt;
                        (define-key map (kbd &lt;span style="color: #008000;"&gt;"&amp;lt;return&amp;gt;"&lt;/span&gt;) 'newline)
                        map))
        (&lt;span style="color: #008000;"&gt;"emacs-lisp"&lt;/span&gt; . ,(make-composed-keymap `(,lispy-mode-map
                                                  ,emacs-lisp-mode-map
                                                  ,outline-minor-mode-map)
                                               org-mode-map))))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/06/10/Adding-keymaps-to-src-blocks-via-org-font-lock-hook.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.7&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Org-mode and ipython enhancements in scimax</title>
      <link>http://jkitchin.github.io/blog/2017/05/26/Org-mode-and-ipython-enhancements-in-scimax</link>
      <pubDate>Fri, 26 May 2017 16:54:16 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[ipython]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">2U7yqcTW38o7Ws3S_FWYgzkOIag=</guid>
      <description>Org-mode and ipython enhancements in scimax</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org696d7c2"&gt;1. Some convenience functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgef414e8"&gt;2. ob-ipython-inspect works&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgd62ef75"&gt;3. Getting selective output from Ipython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5cac271"&gt;4. Where was that error?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org3ebd0a8"&gt;5. Asynchronous Ipython&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
We have made some improvements to using Ipython in org-mode in the past including:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/01/29/ob-ipython-and-inline-figures-in-org-mode/"&gt;Inline figures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/01/21/Exporting-org-mode-to-Jupyter-notebooks/"&gt;Export to Jupyter notebooks&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
Today I will talk about a few new features and improvements I have introduced to scimax for using org-mode and Ipython together.
&lt;/p&gt;

&lt;p&gt;
The video for this post might be more obvious than the post:
&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/dMira3QsUdg" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

&lt;div id="outline-container-org696d7c2" class="outline-2"&gt;
&lt;h2 id="org696d7c2"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Some convenience functions&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
There are a few nice shortcuts in the Jupyter notebook. Now we have some convenient commands in scimax to mimic those. My favorites are adding cells above or below the current cell. You can insert a new src block above the current one with (M-x &lt;code&gt;org-babel-insert-block&lt;/code&gt;). You can use a prefix arg to insert it below the current block.
&lt;/p&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;code&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;below&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;some code&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
I am particularly fond of splitting a large block into two smaller blocks. Use (M-x &lt;code&gt;org-babel-split-src-block&lt;/code&gt;) to do that and leave the point in the upper block. Use a prefix arg to leave the point in the lower block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;lots of code in large block&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Even more code&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;The end of the long block&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You can execute all the blocks up to the current point with (M-x &lt;code&gt;org-babel-execute-to-point&lt;/code&gt;).
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgef414e8" class="outline-2"&gt;
&lt;h2 id="orgef414e8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; ob-ipython-inspect works&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
In the original ob-ipython I found that ob-ipython-inspect did not work unless you were in special edit mode. That is too inconvenient. I modified a few functions to work directly from the org-buffer. I bind this to M-. in org-mode.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Compute areas and colors&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;N&lt;/span&gt; = 150
&lt;span style="color: #BA36A5;"&gt;r&lt;/span&gt; = 2 * np.random.rand(N)
&lt;span style="color: #BA36A5;"&gt;theta&lt;/span&gt; = 2 * np.pi * np.random.rand(N)
&lt;span style="color: #BA36A5;"&gt;area&lt;/span&gt; = 200 * r**2
&lt;span style="color: #BA36A5;"&gt;colors&lt;/span&gt; = theta

&lt;span style="color: #BA36A5;"&gt;ax&lt;/span&gt; = plt.subplot(111, projection=&lt;span style="color: #008000;"&gt;'polar'&lt;/span&gt;)
&lt;span style="color: #BA36A5;"&gt;c&lt;/span&gt; = ax.scatter(theta, r, c=colors, s=area, cmap=&lt;span style="color: #008000;"&gt;'hsv'&lt;/span&gt;, alpha=0.75)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
&amp;lt;matplotlib.figure.Figure at 0x114ded710&amp;gt;
&lt;img src="/media/ob-ipython-1758dfdd7a96829c50791c7cc9a39f3a.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-orgd62ef75" class="outline-2"&gt;
&lt;h2 id="orgd62ef75"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Getting selective output from Ipython&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Out of the box Ipython returns a lot of results. This block, for example returns a plain text, image and latex result as output.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; sympy &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; *
&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;commenting out init_printing() results in no output&lt;/span&gt;
init_printing()

var(&lt;span style="color: #008000;"&gt;'x y'&lt;/span&gt;)
x**2 + y
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
 2
x  + y
&lt;img src="/media/ob-ipython-da6fb3a34919a4f694cfaae45b6f0868.png"&gt; 
&lt;/p&gt;


&lt;p&gt;
We can select which one we want with a new header argument :ob-ipython-results. For this block you can give it the value of text/plain, text/latex or image/png.
&lt;/p&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;var(&lt;span style="color: #008000;"&gt;'x y'&lt;/span&gt;)
x**2 + y
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
 2
x  + y
&lt;/p&gt;

&lt;p&gt;
Or to get the image:
&lt;/p&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;var(&lt;span style="color: #008000;"&gt;'x y'&lt;/span&gt;)
x**2 + y
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/ob-ipython-da6fb3a34919a4f694cfaae45b6f0868.png"&gt; 
&lt;/p&gt;


&lt;p&gt;
This shows up with &lt;a href="https://emacs.stackexchange.com/questions/33005/python-org-mode-babel-output-column-headers-misaligned/33016#33016"&gt;pandas too&lt;/a&gt;. This block creates a table of data and then shows the first 5 rows. Ipython returns both plain text and html here.
&lt;/p&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; pandas &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; pd
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; datetime &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; dt

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;makeSim&lt;/span&gt;(nHosps, nPatients):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt; = pd.DataFrame()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'patientid'&lt;/span&gt;] = &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'hospid'&lt;/span&gt;] = np.random.randint(0, nHosps, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'sex'&lt;/span&gt;] = np.random.randint(0, 2, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'age'&lt;/span&gt;] = np.random.normal(65,18, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'race'&lt;/span&gt;] = np.random.randint(0, 4, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'cptCode'&lt;/span&gt;] = np.random.randint(1, 100, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'rdm30d'&lt;/span&gt;] = np.random.uniform(0, 1, nPatients) &amp;lt; 0.1
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'mort30d'&lt;/span&gt;] = np.random.uniform(0, 1, nPatients) &amp;lt; 0.2
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'los'&lt;/span&gt;] = np.random.normal(8, 2, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; df

&lt;span style="color: #BA36A5;"&gt;discharges&lt;/span&gt; = makeSim(50, 10000)
discharges.head()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;

&lt;/p&gt;

&lt;p&gt;
   patientid  hospid  sex        age  race  cptCode rdm30d mort30d        los
0          0      10    1  64.311947     0        8  False   False   8.036793
1          1       6    0  82.951484     1       73   True   False   7.996024
2          2      27    1  53.064501     3       95  False   False   9.015144
3          3      37    0  64.799128     0       93  False   False  10.099032
4          4      46    0  99.111394     2       25  False   False  11.711427
&lt;/p&gt;
&lt;div&gt;
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;patientid&lt;/th&gt;
      &lt;th&gt;hospid&lt;/th&gt;
      &lt;th&gt;sex&lt;/th&gt;
      &lt;th&gt;age&lt;/th&gt;
      &lt;th&gt;race&lt;/th&gt;
      &lt;th&gt;cptCode&lt;/th&gt;
      &lt;th&gt;rdm30d&lt;/th&gt;
      &lt;th&gt;mort30d&lt;/th&gt;
      &lt;th&gt;los&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;64.311947&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;8.036793&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;82.951484&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;73&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;7.996024&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;53.064501&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;95&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;9.015144&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;64.799128&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;93&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;10.099032&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;46&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;99.111394&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;11.711427&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;
We can use the header to select only the plain text output!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; pandas &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; pd
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; datetime &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; dt

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;makeSim&lt;/span&gt;(nHosps, nPatients):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt; = pd.DataFrame()
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'patientid'&lt;/span&gt;] = &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'hospid'&lt;/span&gt;] = np.random.randint(0, nHosps, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'sex'&lt;/span&gt;] = np.random.randint(0, 2, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'age'&lt;/span&gt;] = np.random.normal(65,18, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'race'&lt;/span&gt;] = np.random.randint(0, 4, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'cptCode'&lt;/span&gt;] = np.random.randint(1, 100, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'rdm30d'&lt;/span&gt;] = np.random.uniform(0, 1, nPatients) &amp;lt; 0.1
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'mort30d'&lt;/span&gt;] = np.random.uniform(0, 1, nPatients) &amp;lt; 0.2
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;df&lt;/span&gt;[&lt;span style="color: #008000;"&gt;'los'&lt;/span&gt;] = np.random.normal(8, 2, nPatients)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; df

&lt;span style="color: #BA36A5;"&gt;discharges&lt;/span&gt; = makeSim(50, 10000)
discharges.head()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
   patientid  hospid  sex        age  race  cptCode rdm30d mort30d        los
0          0      21    0  73.633836     1       38  False   False   7.144019
1          1      16    1  67.518804     3       23  False   False   3.340534
2          2      15    0  44.139033     0        8  False   False   9.258706
3          3      29    1  45.510276     2        5  False   False  10.590245
4          4       7    0  52.974924     2        4  False    True   5.811064
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5cac271" class="outline-2"&gt;
&lt;h2 id="org5cac271"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Where was that error?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
A somewhat annoying feature of running cells in org-mode is when there is an exception there has not been a good way to jump to the line that caused the error to edit it. The lines in the src block are not numbered, so in a large block it can be tedious to find the line. In scimax, when you get an exception it will number the lines in the src block, and when you press q in the exception traceback buffer it will jump to the line in the block where the error occurred.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(1)
&lt;span style="color: #8D8D84;"&gt;#&lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;raise Exception('Here')&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
1
2
&lt;/p&gt;



&lt;p&gt;
If you don't like the numbers add this to your init file:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ob-ipython-number-on-exception nil)
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3ebd0a8" class="outline-2"&gt;
&lt;h2 id="org3ebd0a8"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; Asynchronous Ipython&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
I have made a few improvements to the asynchronous workflow in Ipython. We now have a calculation queue, so you can use C-c C-c to execute several blocks in a row, and they will run asynchronously in the order you ran them. While they are running you can continue using Emacs, e.g. writing that paper, reading email, checking RSS feeds, tetris, &amp;#x2026; This also lets you run all the blocks up to the current point (M-x &lt;code&gt;org-babel-execute-ipython-buffer-to-point-async&lt;/code&gt;) or the whole buffer (of Ipython) blocks asynchronously (M-x &lt;code&gt;org-babel-execute-ipython-buffer-async&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
To turn this on by default put this in your init file:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; org-babel-async-ipython t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This requires all src blocks to have a name, and running the block will give it a name if you have not named the block. By default we use human-readable names. While the block is running, there will be a link indicating it is running. You can click on the link to cancel it. Running subsequent blocks will queue them to be run when the first block is done.
&lt;/p&gt;

&lt;p&gt;
Here is an example:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="orgb3ddac3"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; time
time.sleep(5)
&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 5
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'done'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org5b7e30b"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(3 * a)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
15
&lt;/p&gt;




&lt;p&gt;
Occasionally you will run into an issue. You can clear the queue with &lt;code&gt;org-babel-async-ipython-clear-queue&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/05/26/Org-mode-and-ipython-enhancements-in-scimax.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A partial symbolic numeric solver in emacs-lisp</title>
      <link>http://jkitchin.github.io/blog/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp</link>
      <pubDate>Sun, 21 May 2017 11:33:15 EDT</pubDate>
      <category><![CDATA[math]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[emacs-lisp]]></category>
      <guid isPermaLink="false">yXBmBn5c2JK1DkEAlZuJewhh724=</guid>
      <description>A partial symbolic numeric solver in emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org18a4554"&gt;1. The Newton solver in emacs-lisp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
I have been exploring  ways to use emacs-lisp to express scientific ideas. In this post, we explore a partial symbolic numeric solver in Emacs-lisp. This involves some syntactic developments to more clearly identify something we want to solve for and to then generate the code required to solve it.
&lt;/p&gt;

&lt;p&gt;
In section &lt;a href="#org18a4554"&gt;The Newton solver&lt;/a&gt; you can find a simple implementation of a Newton solver in emacs-lisp. This function allows you to numerically solve equations that can be written in the form \(f(x) = 0\) for \(x\) given an initial guess. You write a function for \(f(x)\) and pass the function to the solver. This is a standard approach used in Python with fsolve, for example. Here is an example of solving a trivial problem: \(x - 4 = 0\) just to check that it works. We use a lambda function for \(f(x) = x - 4 = 0\). The answer is \(x=4\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(newton-f (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (- x 4)) 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That syntax is not too bad, but we have the whole lambda expression in there, and some repetition of what we want to solve for as an argument and in the function. It would be interesting if we could just have an expression that gets solved, e.g. &lt;code&gt;(newton-f (- x? 4) 2)&lt;/code&gt; where &lt;code&gt;x?&lt;/code&gt; indicates the thing to solve for.
&lt;/p&gt;

&lt;p&gt;
We can do that! We can take an expression, flatten it and find the variable names that end with ?. We should check that there is only one, but for now we don't. Here is an example that does that. I use a nested expression here just to illustrate that the code finds the &lt;code&gt;x?&lt;/code&gt; variable correctly.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;dash&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((body '((* (- x? 4) 1))))
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for item in (-flatten body)
        if (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (symbolp item) (s-ends-with? &lt;span style="color: #008000;"&gt;"?"&lt;/span&gt; (symbol-name item)))
        collect item))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
So, given an expression we can identify the unknown that should be the argument to a lambda function. So, we create a macro that takes that expression and constructs a function to solve it, then calls newton-f on it. The macro is syntactically useful here because we do not have to quote the expression. Here is that macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;solve&lt;/span&gt; (expression guess)
  `(newton-f
    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for item in (-flatten expression)
                   if (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (symbolp item) (s-ends-with? &lt;span style="color: #008000;"&gt;"?"&lt;/span&gt; (symbol-name item)))
                   collect item)
      ,expression)
    ,guess))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
I call this a partial symbolic solver because we do some introspection symbolically to identify what to solve for, and then construct the code required to solve it. Here is that trivial example (x? - 4 = 0). It just shows we can have some nesting and it still works. I am not so thrilled with the initial guess, but this is an iterative solver, so you either need an initial guess, or a solution range.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;solve&lt;/span&gt; (* (- x? 4) 1) 3)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is what that expands into:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(macroexpand '(solve (* (- x? 4) 1) 3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It expands into what we would have written in the first place. The benefit to us is less typing, and a simpler syntax. Both of those reduce the opportunity to make errors!
&lt;/p&gt;

&lt;p&gt;
A more realistic problem might be: Reactant A flows into a continuously stirred tank reactor at a rate of  \(F_{A0} = 1\) mol/min with a volumetric flow of \(v_0 = 1\) L/min.. The reactor achieves 50% conversion (\(X\)) of A to products. The reaction rate law is known to be \(-r_A = k C_A\) with \(k = 0.1\) 1/min. Estimate the volume of the reactor. If you have taken my class in reaction engineering, you know the following facts:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;The exit molar flow is defined by \(F_A = F_{A0} (1 - X)\)&lt;/li&gt;
&lt;li&gt;The exit concentration is \(C_A = F_A / v_0\)&lt;/li&gt;
&lt;li&gt;The mole balance is defined by \(0 = F_{A0} - F_A + r_A V\)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
That is all we need; we can solve for \(V\) from the last equation. This is simple enough you might do the algebra to get: \(V = \frac{F_{A0} - F_A}{-r_A}\) which can be simply evaluated. We use our solver here and compare it to the evaluation.
&lt;/p&gt;

&lt;p&gt;
Here is the solver:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((Fa0 1)
       (X 0.5)
       (Fa (* Fa0 (- 1 X)))
       (k 0.1)
       (v0 1)
       (Ca (/ Fa v0))
       (r (* k Ca))
       (ra (* r -1)))
  (&lt;span style="color: #0000FF;"&gt;solve&lt;/span&gt; (+ Fa0 (* Fa -1) (* ra V?)) 2))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
It is pretty hard to imagine doing something like this in Python! It would probably involve parsing a string.
&lt;/p&gt;

&lt;p&gt;
Here is the evaluation from our algebra:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((Fa0 1)
       (X 0.5)
       (Fa (* Fa0 (- 1 X)))
       (k 0.1)
       (v0 1)
       (Ca (/ Fa v0))
       (r (* k Ca))
       (ra (* r -1)))
  (/ (- Fa0 Fa) (* -1 ra)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Within the tolerance specified in &lt;code&gt;newton-f&lt;/code&gt;, these are the same.
&lt;/p&gt;

&lt;p&gt;
This is just the tip of the iceberg though. You may have noticed that none of the variables in the let* had any descriptions. Sure, you could put some comments after them, but those are not really part of the code.
&lt;/p&gt;

&lt;p&gt;
Also, we had to define the variables in advance of the expression. That is a limitation of how computers work, they cannot evaluate undefined variables. It &lt;i&gt;constrains&lt;/i&gt; how we can express the idea. What if we could instead specify the equation first, then the data? That way we are clear what we are trying to do at a higher level, and fill in the details later. Suppose we wanted a syntax like the block below instead. Here we emphasize the equation we are solving first, and then define the variables and quantities used in the equation, and finally the guess that we use to find the solution.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;solve1&lt;/span&gt;
 (eqn (+ Fa0 (* -1 Fa) (* ra V?)))
 (data ((k 0.1 &lt;span style="color: #008000;"&gt;"rate constant 1/min"&lt;/span&gt;)
        (Ca0 1.0 &lt;span style="color: #008000;"&gt;"feed concentration"&lt;/span&gt;)
        (v0 1 &lt;span style="color: #008000;"&gt;"volumetric flow L/min"&lt;/span&gt;)
        (Fa0 (* v0 Ca0) &lt;span style="color: #008000;"&gt;"Inlet molar flow"&lt;/span&gt;)
        (X 0.5 &lt;span style="color: #008000;"&gt;"Desired conversion"&lt;/span&gt;)
        (Fa (* Fa0 (- 1 X)) &lt;span style="color: #008000;"&gt;"Exit molar flow"&lt;/span&gt;)
        (Ca (/ Fa v0) &lt;span style="color: #008000;"&gt;"exit concentration"&lt;/span&gt;)
        (ra (* -1 k Ca) &lt;span style="color: #008000;"&gt;"rate in the reactor"&lt;/span&gt;)))
 (guess 8))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That is achievable with the solve1 macro below! It too has some limitations, mostly the order of the data block still has to be correct, e.g. you cannot use a variable before it is defined. It would take some serious macro-fu to sort these so that everything is defined in the right order! Still, it allows you to express an &lt;i&gt;executable&lt;/i&gt; idea in the order we defined. The strings in this syntax for documenting the variables are ignored, but they could be used in the macro to print useful information or something else you could imagine. You could also make them mandatory to encourage documentation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;solve1&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((expression (second (assoc 'eqn body)))
        (data (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for d in (second (assoc 'data body))
                    collect (list (first d) (second d))))
        (guess (second (assoc 'guess body))))
    `(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ,data
       (newton-f
        (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for item in (-flatten expression)
                       if (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (symbolp item) (s-ends-with? &lt;span style="color: #008000;"&gt;"?"&lt;/span&gt; (symbol-name item)))
                       collect item)
          ,expression)
        ,guess))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
To summarize, lisp macros allow us to rewrite the syntax of code before it is evaluated. This gives us the opportunity to inspect it, and generate new code, e.g. functions with arguments based on the contents of expressions, to save us typing. It also allows us to define ideas in a near arbitrary order that make sense to us, and then rearrange them so they make sense to the computer. See, for example,  &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/03/22/A-better-defun-for-emacs-lisp/"&gt;this post&lt;/a&gt; for an example of changing how functions are defined.
&lt;/p&gt;

&lt;p&gt;
This seems to be heading in the domain specific language direction. I think it would be very helpful in engineering problem solving to build up tools like this. They could start out simple for new students to use. They never need to see the macro parts of this, just to learn how to use them for problem solving. These beginner tools would be limited in what they could do to minimize how much lisp is required to be learned so students can focus on the problem solving. Eventually they might outgrow them, and in the process transition to having the full lisp language at their disposal for problem solving.
&lt;/p&gt;


&lt;div id="outline-container-org18a4554" class="outline-2"&gt;
&lt;h2 id="org18a4554"&gt;&lt;a id="ID-53A5F60F-F929-43BB-AD9D-167D6EBEB8EB"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; The Newton solver in emacs-lisp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This is an emacs-lisp implementation of Newton's method. It is a simple implementation for a single variable. The tolerance and step-size are hard-coded for this post because we focus on the partial symbolic solver, not the best solver methods.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;See https://en.wikipedia.org/wiki/Newton%27s_method for the method&lt;/span&gt;

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;newton-f&lt;/span&gt; (func x0)
  &lt;span style="color: #036A07;"&gt;"Solve the equation FUNC(x)=0 using Newton's method.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;X0 is an initial guess."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((tolerance 1e-6)
         (x x0)
         (dx 1e-6)
         fx fpx)
    (&lt;span style="color: #0000FF;"&gt;while&lt;/span&gt; (&amp;gt; (abs (funcall func x)) tolerance)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; fx (funcall func x)
            fpx (/ (- (funcall func (+ x dx)) (funcall func (- x dx))) (* 2 dx))
            x (- x (/ fx fpx))))
    x))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/05/21/A-partial-symbolic-numeric-solver-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A new and improved Emacs gnuplot DSL</title>
      <link>http://jkitchin.github.io/blog/2017/05/05/A-new-and-improved-Emacs-gnuplot-DSL</link>
      <pubDate>Fri, 05 May 2017 10:26:00 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[lisp]]></category>
      <category><![CDATA[plotting]]></category>
      <guid isPermaLink="false">SKkqBSazd8jxa4md_x_2Xt31v8A=</guid>
      <description>A new and improved Emacs gnuplot DSL</description>
      <content:encoded><![CDATA[


&lt;p&gt;
A significant limitation of the	&lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/05/04/An-emacs-lisp-dsl-for-gnuplot/"&gt;previous&lt;/a&gt; DSL I wrote is that all the plotting commands have to go in one macro. It would be nice to accumulate them in different forms, and when you want to run them all. A classic way to do that in Emacs lisp is to make a global variable, e.g. &lt;code&gt;*gnuplot-cmds*&lt;/code&gt; and append commands to it. Then when you want to, run the commands.
&lt;/p&gt;

&lt;p&gt;
A more modern approach is to use a closure to encapsulate the commands. Here is a &lt;a href="http://letoverlambda.com"&gt;"let over lambda"&lt;/a&gt; that defines a few functions that encapsulate an enclosed variable gnuplot-commands. We define one function to add commands to the list of commands, one to clear the commands, one to generate the gnuplot script as a string, and one to run the program. The enclosed variable &lt;code&gt;gnuplot-commands&lt;/code&gt; is basically only accessible by these functions. It is encapsulated, similar to if we defined a class in Python then made an instance of it with an attribute that was accessible only be instance methods. On one hand, this "protects" the variable, and keeps it out of the global namespace. On the other hand, we lose the documentation that would have come with a defvar, and we have to define a function to access the contents of that variable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((gnuplot-commands '(&lt;span style="color: #008000;"&gt;"set terminal qt"&lt;/span&gt;)))

  (&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot-add-cmd&lt;/span&gt; (s)
    &lt;span style="color: #036A07;"&gt;"Append the command S to gnuplot-cmds."&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; gnuplot-commands (append gnuplot-commands (list s))))

  (&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot-clear&lt;/span&gt; ()
    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; gnuplot-commands '(&lt;span style="color: #008000;"&gt;"set terminal qt"&lt;/span&gt;)))

  (&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot-script&lt;/span&gt; ()
    (s-join &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; gnuplot-commands)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
To run the commands, we define this function. It does not need to be in the closure because it only accesses the commands through functions we defined in the closure.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot-show&lt;/span&gt; ()
    (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((temporary-file-directory &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;)
           (cmdfile (make-temp-file &lt;span style="color: #008000;"&gt;"gnuplot-cmds-"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;".gpl"&lt;/span&gt;))
           (shellcmd (format &lt;span style="color: #008000;"&gt;"gnuplot --persist -c \"%s\""&lt;/span&gt; cmdfile))
           (cmds (gnuplot-script)))
      (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; cmdfile
        (insert cmds))
      (shell-command shellcmd)
      (delete-file cmdfile)
      cmds))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Last time I noted I had a new idea for the DSL syntax that would give us more flexibility to inject variables and code into the DSL. The idea is to use keywords, symbols that start with :, to indicate they should be replaced by the value of the non-keyword symbol in the environment, and for any form that starts with : to evaluate that form. So, (: - 5 4) would get replaced by 1. Here is the new macro for that.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;kargs&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"Convert symbols to strings, quote strings, and (expr) to what they evaluate to."&lt;/span&gt;
  `(s-join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (list ,@(cl-mapcan
                        (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                          (list
                           (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
                            ((keywordp s)
                             (format &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt;
                                     (symbol-value (intern (substring (symbol-name s) 1)))))
                            ((symbolp s)
                             (symbol-name s))
                            ((stringp s)
                             (format &lt;span style="color: #008000;"&gt;"\"%s\""&lt;/span&gt; s))
                            ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp s) (eq : (car s)))
                             `(&lt;span style="color: #0000FF;"&gt;with-output-to-string&lt;/span&gt;
                                (princ ,(cdr s))))
                            (t
                             (format &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt; s)))))
                        args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, our gnuplot macro is simpler, since all it does is add commands to the list. If the form is a string, we add it as is, if the form starts with (: stuff) we evaluate the cdr of the form, and otherwise, we pass the form contents to the kargs macro for processing.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; forms)
  `(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for s in (list ,@(mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                                    (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
                                     ((stringp x)
                                      x)
                                     ((&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (listp x) (eq : (car x)))
                                      `,(cdr x))
                                     (t
                                      `(&lt;span style="color: #0000FF;"&gt;kargs&lt;/span&gt; ,@x))))
                                  forms))
         do (gnuplot-add-cmd s)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
What did that gain us? First, we can break up a script so we can talk about it, maybe do some calculations, etc&amp;#x2026; Let's look at the exmaple at &lt;a href="http://gnuplot.sourceforge.net/demo/linkedaxes.html"&gt;http://gnuplot.sourceforge.net/demo/linkedaxes.html&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
We can start with the basic settings.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(gnuplot-clear)

(&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
 (set terminal png)
 (set output &lt;span style="color: #008000;"&gt;"linkedaxes.png"&lt;/span&gt;)
 (set encoding utf8)
 (set key outside Left)
 (set bmargin 5)
 (set tmargin 6)
 (set style data lines)
 (set tics in)
 (set ticslevel 0.5)
 (set xlabel  &lt;span style="color: #008000;"&gt;"X-ray energy in eV"&lt;/span&gt;)

 (set format y  \'%5.1fe\')
 (set title &lt;span style="color: #008000;"&gt;" Anomalous scattering factors "&lt;/span&gt;)
 (set xrange  [9000:14400])
 (set offset 0\,0\,1.0\,0)
 (set xtics nomirror)
 (set link x via 12398./x inverse 12398./x)

 (set x2label  &lt;span style="color: #008000;"&gt;"X-ray wavelength in &amp;#197;"&lt;/span&gt;)
 (set x2tics 0.1  format &lt;span style="color: #008000;"&gt;"%.1f &amp;#197;"&lt;/span&gt; nomirror))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We need to download some data files. We can do that, and add another line to the gnuplot script. The escaping on the quotes and commas is especially tedious in this one ;) but, we don't need those pesky line-continuations here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(shell-command &lt;span style="color: #008000;"&gt;"wget http://www.bmsc.washington.edu/scatter/data/Br.dat"&lt;/span&gt;)
(shell-command &lt;span style="color: #008000;"&gt;"wget http://www.bmsc.washington.edu/scatter/data/Ta.dat"&lt;/span&gt;)


(&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
 (&lt;span style="color: #0000FF;"&gt;plot&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Br.dat"&lt;/span&gt; volatile using 1:3 title \'Br f\"\'  lt 1 lw 3\, \'\' volatile using 1:2 title &lt;span style="color: #008000;"&gt;"Br f'"&lt;/span&gt;  lt 1 lw 1\,
       &lt;span style="color: #008000;"&gt;"Ta.dat"&lt;/span&gt; volatile using 1:3 title \'Ta f\"\' lt 2 lw 3\, \'\' volatile using 1:2 title \"Ta f\'\"  lt 2 lw 1))

(gnuplot-script)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Finally, we can set the output to png, and run our program.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(gnuplot-show)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Looks good.
&lt;/p&gt;



&lt;p&gt;
&lt;img src="/media/linkedaxes.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
What about the fancy keyword formatting? Here is an example of that in action. :term gets replaced by the term variable, :png gets replaced by the filename, and :x is replaced by 4.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(gnuplot-clear)
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((x 4)
      (term &lt;span style="color: #008000;"&gt;"png"&lt;/span&gt;)
      (png &lt;span style="color: #008000;"&gt;"\"polar.png\""&lt;/span&gt;))
  (&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
   (set terminal &lt;span style="color: #006FE0;"&gt;:term&lt;/span&gt;)
   (set output &lt;span style="color: #006FE0;"&gt;:png&lt;/span&gt;)
   (set polar)
   (set dummy t)
   (&lt;span style="color: #0000FF;"&gt;plot&lt;/span&gt; sin\( &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; *t\) \,cos\( &lt;span style="color: #006FE0;"&gt;:x&lt;/span&gt; *t\))
   (set offset 0\,0\,0\,0)))

(gnuplot-show)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/polar.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
There are a few nuances I didn't expect. First, you have to escape the parentheses in this case because otherwise it looks like a form that will be ignored. Second, you have to quote the string to get quotes into the gnuplot script. Third, there has to be a space before and after the keywords for emacs to parse it correctly and do the substitution.
&lt;/p&gt;

&lt;p&gt;
Let's look at one last example that uses the (: form). We reproduce a figure from &lt;a href="http://gnuplot.sourceforge.net/demo/transparent_solids.html"&gt;http://gnuplot.sourceforge.net/demo/transparent_solids.html&lt;/a&gt; here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(gnuplot-clear)
(&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
 (set terminal pngcairo  background &lt;span style="color: #008000;"&gt;"#ffffff"&lt;/span&gt; enhanced font &lt;span style="color: #008000;"&gt;"arial,9"&lt;/span&gt; fontscale 1.0 size 512\, 384 )
 (set output &lt;span style="color: #008000;"&gt;"transparent-solids.png"&lt;/span&gt;)
 &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;construct the title&lt;/span&gt;
 (set title (&lt;span style="color: #0000FF;"&gt;:&lt;/span&gt; format &lt;span style="color: #008000;"&gt;"\"%s\""&lt;/span&gt; (concat &lt;span style="color: #008000;"&gt;"Interlocking Tori - PM3D surface"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"with depth sorting and transparency"&lt;/span&gt;)))

 &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;use lisp code to create a gnuplot command&lt;/span&gt;
 (&lt;span style="color: #0000FF;"&gt;:&lt;/span&gt; concat &lt;span style="color: #008000;"&gt;"unset"&lt;/span&gt; &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; &lt;span style="color: #008000;"&gt;"border"&lt;/span&gt;)

 (unset key)
 (set object 1 rect from screen 0\, 0\, 0 to screen 1\, 1\, 0 behind)
 (set object 1 rect fc  rgb \"gray\"  fillstyle solid 1.0  border -1)
 (set view 64\, 345\, 1.24375\, 0.995902)
 (set isosamples 50\, 20)
 (unset xtics)
 (unset ytics)
 (unset ztics)
 (set dummy u\,v)
 (set parametric)
 (set urange [ -pi : pi ])
 (set vrange [ -pi : pi ])

 (set style fill  transparent solid 0.30 border)
 (set pm3d depthorder)
 (set palette rgbformulae 8\, 9\, 7)
 (set pm3d interpolate 1\,1 flush begin noftriangles border lt black linewidth 0.500 dashtype solid corners2color mean)
 (set colorbox vertical origin screen 0.9\, 0.2\, 0 size screen 0.05\, 0.6\, 0 front  noinvert bdefault)

 (splot (&lt;span style="color: #0000FF;"&gt;:&lt;/span&gt; concat &lt;span style="color: #008000;"&gt;"cos(u)+.5*cos(u)*cos(v),sin(u)+.5*sin(u)*cos(v),.5*sin(v) with pm3d,"&lt;/span&gt;
           &lt;span style="color: #008000;"&gt;"1+cos(u)+.5*cos(u)*cos(v),.5*sin(v),sin(u)+.5*sin(u)*cos(v) with pm3d"&lt;/span&gt;)))
(gnuplot-show)
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;img src="/media/transparent-solids.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
Overall this seems like an improvement to the DSL. I didn't invent the idea of reusing keywords this way out of the blue. In On Lisp, Paul graham uses "special" variable names in Chapter 18, where he shows how to use gensyms for special purposes, and also variables with special names like ?x. Even Emacs is using a variation of this idea. Check out this &lt;a href="http://endlessparentheses.com/new-on-elpa-and-in-emacs-25-1-let-alist.html"&gt;new let-alist&lt;/a&gt; macro:
&lt;/p&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let-alist&lt;/span&gt; '((x . 5))
  (+ 1 .x))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
There is a special variable inside the body that is a dot-name. The macro expands to provide a value for that symbol. I wonder if I should have tried to use an approach like this instead. Maybe another day. After I read and study the four defuns and single defmacro that make this possible!
&lt;/p&gt;

&lt;p&gt;
You can see here what happens:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(macroexpand '(let-alist '((x . 5))
  (+ 1 .x)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The macro builds up an internal alist for the dot-names.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/05/05/A-new-and-improved-Emacs-gnuplot-DSL.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>An emacs-lisp dsl for gnuplot</title>
      <link>http://jkitchin.github.io/blog/2017/05/04/An-emacs-lisp-dsl-for-gnuplot</link>
      <pubDate>Thu, 04 May 2017 19:33:55 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[lisp]]></category>
      <category><![CDATA[plotting]]></category>
      <guid isPermaLink="false">0UZjXdfBOloIK7bnw4odvEI2ep0=</guid>
      <description>An emacs-lisp dsl for gnuplot</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orge24f7e9"&gt;1. Embedding Python or gnuplot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgfe7800b"&gt;2. An alternative approach using a DSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga773a9d"&gt;3. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Plotting is a pretty general feature we need in scientific work. In this post we examine a way we could get at least minimal plotting into Emacs-lisp with as lispy a syntax as reasonable.
&lt;/p&gt;

&lt;div id="outline-container-orge24f7e9" class="outline-2"&gt;
&lt;h2 id="orge24f7e9"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Embedding Python or gnuplot&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
With org-mode we can fluidly integrate many languages in one document. That is not the goal here, where I want to integrate plotting into a program. You certainly could go this route to embed python programs in your lisp programs for plotting.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;python&lt;/span&gt; (code)
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((temporary-file-directory &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;)
        (tmpfile (make-temp-file &lt;span style="color: #008000;"&gt;"py-"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;".py"&lt;/span&gt;)))
    (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; tmpfile
      (insert code))
    (shell-command-to-string (format &lt;span style="color: #008000;"&gt;"python %s"&lt;/span&gt; tmpfile))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is that function in action.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(python &lt;span style="color: #008000;"&gt;"import matplotlib.pyplot as plt&lt;/span&gt;
&lt;span style="color: #008000;"&gt;import numpy as np&lt;/span&gt;
&lt;span style="color: #008000;"&gt;x = np.linspace(0, 1)&lt;/span&gt;
&lt;span style="color: #008000;"&gt;y = np.exp(x)&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.plot(x, y, label='data')&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.title('A Title')&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.xlim([0, 1])&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.ylim([1, 2.75])&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.xlabel('x')&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.ylabel('y')&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.legend()&lt;/span&gt;
&lt;span style="color: #008000;"&gt;plt.savefig('figpy.png')"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And the corresponding figure:
&lt;img src="/media/figpy.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
This is irritating for a few reasons. One is it is annoying to write python programs in string form; you don't get much editor support for indentation or syntax highlighting, and you have to be careful with quotes. It is not that easy to switch that snippet to Python mode either. You are pretty limited in writing programs that expand and modify the code too. Basically you have to do that all by string manipulation.
&lt;/p&gt;

&lt;p&gt;
Along these lines, you could imagine a gnuplot function. It ends up not being much better.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot&lt;/span&gt; (cmds)
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((temporary-file-directory &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;)
         (cmdfile (make-temp-file &lt;span style="color: #008000;"&gt;"gnuplot-cmds-"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;".gpl"&lt;/span&gt;))
         (shellcmd (format &lt;span style="color: #008000;"&gt;"gnuplot --persist -c \"%s\""&lt;/span&gt; cmdfile)))
    (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; cmdfile
      (insert cmds))
    (shell-command shellcmd)
    (delete-file cmdfile)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You use this the same way.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt; &lt;span style="color: #008000;"&gt;"set title \"Simple Plots\" font \",20\"&lt;/span&gt;
&lt;span style="color: #008000;"&gt;set key left box&lt;/span&gt;
&lt;span style="color: #008000;"&gt;set samples 50&lt;/span&gt;
&lt;span style="color: #008000;"&gt;set style data points&lt;/span&gt;
&lt;span style="color: #008000;"&gt;set terminal png&lt;/span&gt;
&lt;span style="color: #008000;"&gt;set output \"gnuplot.png\"&lt;/span&gt;

&lt;span style="color: #008000;"&gt;plot [-10:10] sin(x),atan(x),cos(atan(x))"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/gnuplot.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
It has the same limitations as our string-based Python solution. The benefit of them is the native command structure for Python or gnuplot is used, so anything they can do you can too.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgfe7800b" class="outline-2"&gt;
&lt;h2 id="orgfe7800b"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; An alternative approach using a DSL&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
As an alternative, we consider here a domain specific language (DSL) that maps onto gnuplot. Suppose we could do this instead.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
 (set terminal png)
 (set output &lt;span style="color: #008000;"&gt;"test.png"&lt;/span&gt;)
 (set title &lt;span style="color: #008000;"&gt;"Simple Plots"&lt;/span&gt; font &lt;span style="color: #008000;"&gt;",20"&lt;/span&gt;)
 (set key left box)
 (set samples 50)
 (set style data points)

 (&lt;span style="color: #0000FF;"&gt;plot&lt;/span&gt; [-10:10] sin\(x\) \,atan\(x\) \,cos\(atan\(x\)\)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is the figure from that code. The most annoying part of this is in the plot function we have to escape all the parentheses and commas, but otherwise it looks pretty lispy. The output of that program is the gnuplot commands that were generated for making the plot.
&lt;img src="/media/test.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
This retains a lot of benefits of programming in lisp. &lt;code&gt;gnuplot&lt;/code&gt; has to be a macro though because we do not want to evaluate the s-expressions inside as lisp. For starters they just look lispy, I don't actually use them as lisp at all. Instead we transform them to the gnuplot code.
&lt;/p&gt;

&lt;p&gt;
In the following code, I will develop the gnuplot macro. It has some sticky and tricky points, and it is not obvious it will support all the features of gnuplot, but I learned a lot doing it that I will share here.
&lt;/p&gt;

&lt;p&gt;
Starting with a simple form inside the macro, I wanted to convert (set output "test.png") to "set output \"test.png\"". For this DSL, I want to treat every symbol in the form as if it should be turned into a string, anything that is a string should be quoted, and anything that is in parentheses (i.e. it passes listp) should be evaluated and converted to a string. Then all those strings should be joined by spaces. Here is a macro that does that (adapted from a solution at &lt;a href="https://emacs.stackexchange.com/questions/32558/eval-some-arguments-in-a-macro/32570?noredirect=1#comment50186_32570"&gt;https://emacs.stackexchange.com/questions/32558/eval-some-arguments-in-a-macro/32570?noredirect=1#comment50186_32570&lt;/a&gt;).
&lt;/p&gt;

&lt;p&gt;
There are a couple of corner cases that are handled here. If the arg is a string, we quote it.  If the arg is not a symbol or string, then it is evaluated and converted to a string. Importantly, this is done in the run environment though, so we can inject variables into the gnuplot code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;gargs&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  &lt;span style="color: #036A07;"&gt;"Convert symbols to strings, quote strings, and (expr) to what they evaluate to."&lt;/span&gt;
  `(s-join &lt;span style="color: #008000;"&gt;" "&lt;/span&gt; (list ,@(cl-mapcan
                        (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                          (list
                           (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
                            ((symbolp s)
                             (symbol-name s))
                            ((stringp s)
                             (format &lt;span style="color: #008000;"&gt;"\"%s\""&lt;/span&gt; s))
                            (t
                             `(&lt;span style="color: #0000FF;"&gt;with-output-to-string&lt;/span&gt;
                                (princ ,s))))))
                        args))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are a few examples of how it works. The loop is just to get a vertical table in org-mode for the blog post.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for s in
      (list (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; set key title &lt;span style="color: #008000;"&gt;"before fit"&lt;/span&gt; size \, (+ 5 5))
            (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; set title &lt;span style="color: #008000;"&gt;"red"&lt;/span&gt;)
            (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; set yrange [0:*])
            (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; &lt;span style="color: #008000;"&gt;"5"&lt;/span&gt;)
            (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((x 6)) (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; (identity x)))
            (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; 'x)
            (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; '(x))
            (&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; set label 1 &lt;span style="color: #008000;"&gt;"plot for [n=2:10] sin(x*n)/n"&lt;/span&gt; at graph .95\, graph .92 right))
      collect
      (list s))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
A limitation of this is that we either have quote things like parentheses, commas, semi-colons and sometimes square brackets:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; plot for [n=2:10] sin\(x*n\)/n notitle lw \(13-n\)/2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Or we have to use the string form instead; we can always fall back to that.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; &lt;span style="color: #008000;"&gt;"plot for [n=2:10] sin(x*n)/n notitle lw (13-n)/2"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
The macro above will do the grunt work on each form in the gnuplot macro. Finally, for the gnuplot macro, I want to take all the forms, convert them to gnuplot commands, write them to a temporary file, and then run gnuplot on the file, and finally delete the temp file. I assume we start with a gui terminal so graphs pop up unless you change it in your macro body. Here is that macro. It returns the generated code so it easy to see if you got the right program.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;gnuplot&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; forms)
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((temporary-file-directory &lt;span style="color: #008000;"&gt;"."&lt;/span&gt;)
         (cmdfile (make-temp-file &lt;span style="color: #008000;"&gt;"gnuplot-cmds-"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;".gpl"&lt;/span&gt;))
         (shellcmd (format &lt;span style="color: #008000;"&gt;"gnuplot --persist -c \"%s\""&lt;/span&gt; cmdfile))
         (cmd-string))
    `(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((cmd-string (s-join &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; (list ,@(mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x)
                                                      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (stringp x)
                                                          x
                                                        `(&lt;span style="color: #0000FF;"&gt;gargs&lt;/span&gt; ,@x)))
                                                    forms)))))
       (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; ,cmdfile
         (insert &lt;span style="color: #008000;"&gt;"set terminal qt\n"&lt;/span&gt;)
         (insert cmd-string)
         (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; cmd-string (buffer-string)))
       (shell-command ,shellcmd)
       (delete-file ,cmdfile)
       cmd-string)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is a figure adapted from &lt;a href="http://gnuplot.sourceforge.net/demo/iterate.html"&gt;http://gnuplot.sourceforge.net/demo/iterate.html&lt;/a&gt;. I use the string form for the last line to avoid escaping all the special characters.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
 (set terminal png)
 (set output &lt;span style="color: #008000;"&gt;"iteration.png"&lt;/span&gt;)
 (set title &lt;span style="color: #008000;"&gt;"Iteration within plot command"&lt;/span&gt;)
 (set xrange [0:3])
 (set label 1 &lt;span style="color: #008000;"&gt;"plot for [n=2:10] sin(x*n)/n"&lt;/span&gt; at graph .95\, graph .92 right)
 &lt;span style="color: #008000;"&gt;"plot for [n=2:10] sin(x*n)/n notitle lw (13-n)/2"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is the resulting figure.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/iteration.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
That is overall pretty sweet. There is a little dissonance between the strings, escaped comma, etc.., and it is not terribly ideal for integrating with regular lisp code inside the macro yet. That seems to be a feature of my choice to use (expr) as the syntax to evaluate a form. It means you have to do some gymnastics to get some s-expressions into the graphs. For example below I use a couple of variables to inject values. To get a string I have to use format to add the extra quotes, and to get the number I have to use the identity function. I also used escaped characters in the last line to see the difference.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((ts &lt;span style="color: #008000;"&gt;"Iteration and substitution"&lt;/span&gt;)
      (x0 0)
      (xf 3)
      (g1 0.95)
      (g2 0.92))
  (&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
   (set terminal png)
   (set output &lt;span style="color: #008000;"&gt;"iteration-2.png"&lt;/span&gt;)
   (set title (format &lt;span style="color: #008000;"&gt;"\"%s\""&lt;/span&gt; ts))
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Note the escaped square brackets&lt;/span&gt;
   (set xrange \[ (identity x0) : (identity xf) \])
   (set label 1 &lt;span style="color: #008000;"&gt;"plot for [n=2:10] sin(x*n)/n"&lt;/span&gt; at graph (identity g1) \, graph (identity g2) right)
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;note here I escaped the parentheses!&lt;/span&gt;
   (&lt;span style="color: #0000FF;"&gt;plot&lt;/span&gt; for [n=2:10] sin\(x*n\)/n notitle lw \(13-n\)/2)))
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;img src="/media/iteration-2.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-orga773a9d" class="outline-2"&gt;
&lt;h2 id="orga773a9d"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
For the simple plots here, my DSL worked ok. There is a tradeoff in the syntax I chose that has some consequences. We cannot use the values of symbols in this DSL without resorting to hackery like (identity sym). We also cannot use the infix notation for sin(x) without quoting it as "sin(x)" or escaping the parentheses, e.g. &lt;code&gt;sin\(x\)&lt;/code&gt;, likewise square brackets which lisp will read  as a vector. Commas have to be escaped, which is probably an emacs-lisp issue. To address that would require a reader macro which emacs-lisp does not have great support for. I am calling this experiment done for now. I have another syntax idea to try out another day.
&lt;/p&gt;

&lt;p&gt;
Here is a preview of what it might look like. It is basically the same but I reuse keywords to indicate that :x0 should be replaced by whatever x0 evaluates to, and (: - 1 0.05) should be evaluated. The special character escaping is still there of course, since that is a limitation of the emacs lisp reader I think. I might try using x0? and (? - 1 0.05) instead. That might be less confusing. I like that the keywords are syntax highlighted for free though, and you can't use them for anything else.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((ts &lt;span style="color: #008000;"&gt;"Iteration and substitution"&lt;/span&gt;)
      (x0 0)
      (xf 3)
      (g2 0.92))
  (&lt;span style="color: #0000FF;"&gt;gnuplot&lt;/span&gt;
   (set terminal png)
   (set output &lt;span style="color: #008000;"&gt;"iteration-2.png"&lt;/span&gt;)
   (set title &lt;span style="color: #006FE0;"&gt;:ts&lt;/span&gt;)
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Note the escaped square brackets&lt;/span&gt;
   (set xrange \[ &lt;span style="color: #006FE0;"&gt;:x0&lt;/span&gt; : &lt;span style="color: #006FE0;"&gt;:xf&lt;/span&gt; \])
   (set label 1 &lt;span style="color: #008000;"&gt;"plot for [n=2:10] sin(x*n)/n"&lt;/span&gt; at graph (&lt;span style="color: #0000FF;"&gt;:&lt;/span&gt; - 1 0.05) \, graph &lt;span style="color: #006FE0;"&gt;:g2&lt;/span&gt; right)
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;note here I escaped the parentheses!&lt;/span&gt;
   (&lt;span style="color: #0000FF;"&gt;plot&lt;/span&gt; for [n=2:10] sin(x*n)/n notitle lw (13-n)/2)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This has the benefit of a little cleaner injection of variables and selective execution of parenthetical expressions, we will just ignore any that don't pass (= (car expr) :). That May not work for sin((: + 1 1) x) though, unless I escape the outer parentheses too.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/05/04/An-emacs-lisp-dsl-for-gnuplot.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Emulating Sparql queries in emacs-lisp with pattern matching</title>
      <link>http://jkitchin.github.io/blog/2017/04/30/Emulating-Sparql-queries-in-emacs-lisp-with-pattern-matching</link>
      <pubDate>Sun, 30 Apr 2017 13:46:47 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[lisp]]></category>
      <guid isPermaLink="false">R3y1c_-hnfEQdQtr5ieB1MNVUk8=</guid>
      <description>Emulating Sparql queries in emacs-lisp with pattern matching</description>
      <content:encoded><![CDATA[


&lt;p&gt;
Sqarql is a query language for RDF triples. A triple is a data structure that consists of a (subject predicate object). Sparql lets you query the triples to extract data from them. I have been interested in using these to augment the &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/01/03/Find-stuff-in-org-mode-anywhere/"&gt;SQL databases I generate&lt;/a&gt; from my org-files to be able to infer relationships between subjects and objects. For example, I could encode relationships into the contact database I use, and then infer new information that is not encoded explicitly. So far though I haven't found a good Sparql database that I can easily integrate into Emacs (or even play around with). I am reading On Lisp these days and chapters 18 and 19 talk about destructuring and pattern matching, and I realized these can be used to implement something like Sparql queries on simple lisp data structures. In this post I explore what it looks like and how to do it.
&lt;/p&gt;

&lt;p&gt;
Let's consider a small database of triples that codify relationships between two people. For example, we can codify that Ann is Bob's mother with (Bob mother Ann). Here is our little database.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; triples '((Bob mother Ann)
                (Bill father Bob)
                (Lucy mother Jane)
                (Bob wife Jane)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can filter out facts from the database with a -filter. Here we filter out triples about Bob. Emacs has nice pattern matching in the pcase macro (see &lt;a href="http://www.wilfred.me.uk/blog/2017/03/19/pattern-matching-in-emacs-lisp/"&gt;http://www.wilfred.me.uk/blog/2017/03/19/pattern-matching-in-emacs-lisp/&lt;/a&gt; and &lt;a href="http://newartisans.com/2016/01/pattern-matching-with-pcase/"&gt;http://newartisans.com/2016/01/pattern-matching-with-pcase/&lt;/a&gt; for example). It turns out this is an amazing way to solve this problem. Here we look at triples with the pattern that they start with Bob.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(-filter (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (triple) (&lt;span style="color: #0000FF;"&gt;pcase&lt;/span&gt; triple (`(Bob ,_ ,_) t))) triples)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And here we get all the mothers.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(-filter (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (triple) (&lt;span style="color: #0000FF;"&gt;pcase&lt;/span&gt; triple (`(,_ mother ,_) t))) triples)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can infer some facts about these people from the database by using some "rules". For example, there is not an entry that tells us directly who Bill's grandmother is. If we assume that the mother of a person's father is their grandmother, then we can infer Bill's grandmother is Ann. In this post, we examine how to write code that can find that answer. We will use pattern matching on pairs of triples to do it.
&lt;/p&gt;

&lt;p&gt;
We can enumerate pairs of triples, and use pattern matching to find the pair of triples that meet the criteria we specify. The criteria we want to match is (in pseudo-sparql):
&lt;/p&gt;

&lt;pre class="example"&gt;
(Bill father ?dad) (?dad mother ?grandmother)
&lt;/pre&gt;

&lt;p&gt;
In other words, we want to find a triple that contains Bill as the subject, father as the predication, and then his father will be the object, and then find another triple that matches a predicate of mother with the subject equal to the father object we found in the first triple, and the object of the second triple will be Bill's grandmother. We enumerate pairs of triples for the comparison. Here is a way to do that. It is not a very efficient way to do it; it would be better to first filter out the triples that match (Bill father &lt;i&gt;something&lt;/i&gt;) and then filter out the triples that match (&lt;i&gt;anything&lt;/i&gt; mother &lt;i&gt;any other thing&lt;/i&gt;) &lt;i&gt;and&lt;/i&gt; then consider the pairs of those triples. I will save that for another day; efficiency is not the point today ;)
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i below (length triples)
      append
      (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt;
       for j below (length triples)
       if (not (= i j))
       collect
       (list (nth i triples) (nth j triples))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You can see the pair that matches is the fourth one down (actually the first one matches too, but not exactly in the order of the pattern we specified). Next, we use pcase for the pattern matching. This amazing macro allows you to specify a pattern in terms of reusable variables so we can specify that the same value exists in multiple places. We will use this pattern (in pcase syntax):
&lt;/p&gt;

&lt;pre class="example"&gt;
`((Bill father ,dad) (,dad mother ,grandmother))
&lt;/pre&gt;

&lt;p&gt;
That means match a list that has the first element of (Bill father &lt;i&gt;something&lt;/i&gt;) and store the value of &lt;i&gt;something&lt;/i&gt; in the variable dad. The second element of the list must match (&lt;i&gt;something&lt;/i&gt; mother &lt;i&gt;another thing&lt;/i&gt;) and store the value of &lt;i&gt;another thing&lt;/i&gt; in the variable grandmother. The two variables dad and grandmother are then available in the body of the pcase statement. Here is the code to loop over the triples and return the result when we find a match.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;catch&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;result&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i below (length triples)
        do
        (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt;
         for j below (length triples)
         if (not (= i j))
         collect
         (&lt;span style="color: #0000FF;"&gt;pcase&lt;/span&gt; (list (nth i triples) (nth j triples))
           (`((Bill father ,dad) (,dad mother ,grandmother))
            (&lt;span style="color: #0000FF;"&gt;throw&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;result&lt;/span&gt; (format &lt;span style="color: #008000;"&gt;"Bill's dad is %s and his grandmother is %s"&lt;/span&gt; dad grandmother)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Not bad. It would be worthwhile to encapsulate that into a macro perhaps, so you could just write something like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;select&lt;/span&gt; (dad grandmother) from triples where `((Bill father ,dad) (,dad mother ,grandmother)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
For fun I implemented a limited version of this below. It is fairly limited, and lightly tested. The biggest limitation is we hard-coded the search over pairs of triples. This version searches by brute force too, because I don't know how to build in filtering yet. It is another exercise for another day to remove these limitations. Here I just want to try out the macro with the syntactic sugar of "from" and "where" (which are totally ignored) as well at the backquoted query.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;select&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((values (first args))
        (db (third args))
        (query (fifth args)))
    `&lt;span style="color: #D0372D;"&gt;(catch &lt;/span&gt;'&lt;span style="color: #D0372D;"&gt;result&lt;/span&gt;
       (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for i below (length ,db)
             do
             (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt;
              for j below (length ,db)
              if (not (= i j))
              do
              (&lt;span style="color: #0000FF;"&gt;pcase&lt;/span&gt; (list (nth i triples) (nth j triples))
                (,query
                 (&lt;span style="color: #0000FF;"&gt;throw&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;result&lt;/span&gt; (list ,@values)))))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is a fun way to write the query that finds the grandmother of the person named Bill with variable capture.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;select&lt;/span&gt; (person dad grandmother) from triples
        where `((,(&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; person (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; Bill person)) father ,dad) (,dad mother ,grandmother)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can see the grandmother is Ann, as we found before.
&lt;/p&gt;

&lt;p&gt;
Let's have a look at the macro expansion. Clearly our macro hides a lot of work from us!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(macroexpand '(select (person dad grandmother) from triples
        where `((,(&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; person (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; Bill person)) father ,dad) (,dad mother ,grandmother))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Bill&lt;/td&gt;
&lt;td class="org-left"&gt;Bob&lt;/td&gt;
&lt;td class="org-left"&gt;Ann&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
How about another example query. Who is Lucy's dad? The most direct query would be `(Lucy father ,dad), but a) that fact is not in the database, and b) our select macro won't search a single query anyway. So, let's examine how to find the answer by inference.
&lt;/p&gt;

&lt;p&gt;
Let's assume that Lucy's dad is also the husband of her mother. Let's also assume that we can infer that if we know Jane is the wife of Bob, then Bob is the husband of Jane, and so we can infer from our database that Bob is Lucy's dad. This results in a query on a pair of triples that matches a pattern like:
&lt;/p&gt;

&lt;pre class="example"&gt;
(Lucy mother ?mom) (?dad wife ?mom)
&lt;/pre&gt;

&lt;p&gt;
Here is that query in our select macro.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;select&lt;/span&gt; (person mom dad) from triples
        where `((,(&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; person (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; Lucy person)) mother ,mom) (,dad wife ,mom)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Pretty cool! Clearly there is still a lot to do to make this practical. The implementation I used here wouldn't scale well with large numbers of triples, and its limited to a single kind of query. Chapters 18 and 19 in On Lisp address the query limitation (and they are not even limited to triples) and a different syntax style that is more Sparql like. When I get through them, I will probably add a new post on it. There are a lot of interesting problems to solve here including what to do if there are multiple matches, or inconsistent data? The Sparql select command allows you to group, order and limit the results which would be increasingly useful with larger triple stores. That would definitely add a lot of code to the macro!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/04/30/Emulating-Sparql-queries-in-emacs-lisp-with-pattern-matching.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A callable plist data structure for Emacs</title>
      <link>http://jkitchin.github.io/blog/2017/04/16/A-callable-plist-data-structure-for-Emacs</link>
      <pubDate>Sun, 16 Apr 2017 16:44:53 EDT</pubDate>
      <category><![CDATA[macro]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[elisp]]></category>
      <guid isPermaLink="false">g-L-SDSuJKkcZwHQyGqqiWpzU7k=</guid>
      <description>A callable plist data structure for Emacs</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbe53949"&gt;1. An update &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2017-04-21 Fri&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Emacs lisp has a few data structures that store key-value pairs. Here are some canonical examples of these data structures and the way to get data out of them.
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;a-lists&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data '((key1 . 4)
              (key2 . &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;))))
  (cdr (assoc 'key2 data)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;p-lists&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data '(&lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;)))
  (plist-get data &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;A hash table&lt;/li&gt;
&lt;/ul&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data #s(hash-table data (key1 4 key2 &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;))))
  (gethash 'key2 data))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Each of these uses some function to get data out of them. I have been learning about closures today, and realized a way you can make a "callable" data structure using them. In a closure, the data is stored as part of a function. We will use a &lt;a href="http://letoverlambda.com"&gt;"let over lambda"&lt;/a&gt; with a defalias in a lexical environment to achieve this. I will wrap a p-list with this approach, but it could work with any of the examples above. We will make the function have a few behaviors that allow us to see the whole data structure with no args, to get a value with one arg that is a key, and to set a value if there are more than two args add them as key-val pairs to the data structure. This block binds the function to the symbol "d" which is then a callable function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((data '(&lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;)))
  (&lt;span style="color: #0000FF;"&gt;defalias&lt;/span&gt; '&lt;span style="color: #006699;"&gt;d&lt;/span&gt;
    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; key-vals)
      (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;no args, return data&lt;/span&gt;
       ((= 0 (length key-vals))
        data)
       &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;just a key, get val&lt;/span&gt;
       ((= 1 (length key-vals))
        (plist-get data (car key-vals)))
       (t
        (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in (-slice key-vals 0 nil 2)
              for val in (-slice key-vals 1 nil 2)
              do
              (plist-put data key val))
        data)))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now we can use it like to get some data out:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And add new values like:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key3&lt;/span&gt; &lt;span style="color: #008000;"&gt;"oak"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
You can update a value with this too:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key3&lt;/span&gt; &lt;span style="color: #008000;"&gt;"pine"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
or add multiple values like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d &lt;span style="color: #006FE0;"&gt;:key4&lt;/span&gt; 0 &lt;span style="color: #006FE0;"&gt;:key5&lt;/span&gt; 9)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And see the whole plist with no args:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Pretty nice! It seems like there ought to be a macro to facilitate creating those. Here is one.
This macro basically expands to the same code as above, but for fun I add a default value option.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;default-dict&lt;/span&gt; (var &lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; default &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; key-vals)
  &lt;span style="color: #036A07;"&gt;"Bind a callable plist to VAR that contains KEY-VALS."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ()
    `&lt;span style="color: #D0372D;"&gt;(let ((data &lt;/span&gt;',key-vals))
       (&lt;span style="color: #0000FF;"&gt;defalias&lt;/span&gt; ',var
         (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; key-vals)
           (message &lt;span style="color: #008000;"&gt;"%s"&lt;/span&gt; key-vals)
           (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;no args, return data&lt;/span&gt;
            ((= 0 (length key-vals))
             data)
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;just a key, get val&lt;/span&gt;
            ((= 1 (length key-vals))
             (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt;  (plist-get data (car key-vals)) ,default))
            (t
             (&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in (-slice key-vals 0 nil 2)
                   for val in (-slice key-vals 1 nil 2)
                   do
                   (plist-put data key val))
             data)))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is an instance of it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;default-dict&lt;/span&gt; d2 &lt;span style="color: #008000;"&gt;"None"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; &lt;span style="color: #008000;"&gt;"tree"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And here it is in use.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d2 &lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(d2 &lt;span style="color: #006FE0;"&gt;:new-key&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Not bad. If you come from Python, you might find this style of data structure to be more similar to what you are used to seeing. It sure seems less verbose than the usual plist boilerplate I have used before.
&lt;/p&gt;

&lt;div id="outline-container-orgbe53949" class="outline-2"&gt;
&lt;h2 id="orgbe53949"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; An update &lt;span class="timestamp-wrapper"&gt;&lt;span class="timestamp"&gt;&amp;lt;2017-04-21 Fri&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
One (perhaps undesirable even) feature of the approach above is that it creates a function in the global namespace. This might have unintended consequences with name clashes or shadowing, and if you later use the same variable name for a plist, you would change the function behavior. Here we consider a way to limit the scope of where these functions exist and work. The labels macro provides one way to do this, we just create temporary functions that only exist within a scope. There is a lot of backticking and comma operators in this, and it took quite a few iterations to get it working!
&lt;/p&gt;

&lt;p&gt;
This macro creates temporary functions for each keyword that return the value in the plist.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;with-dict&lt;/span&gt; (key-vals &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  &lt;span style="color: #036A07;"&gt;"A context-manager for a plist where each key is a callable&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;function that returns the value."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;declare&lt;/span&gt; (indent 1))
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((g (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (symbolp key-vals)
                (symbol-value key-vals)
              key-vals))
         (keys (-slice g 0 nil 2)))
    `(&lt;span style="color: #0000FF;"&gt;labels&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in keys
                    collect
                    (list key '() `&lt;span style="color: #D0372D;"&gt;(plist-get &lt;/span&gt;',g  ,key)))
       ,@body)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is how we use it:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-dict&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:a&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:b&lt;/span&gt; 'some-symbol &lt;span style="color: #006FE0;"&gt;:c&lt;/span&gt; 3)
  (&lt;span style="color: #006FE0;"&gt;:b&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We can also use it with variables that hold mappings like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((d '(&lt;span style="color: #006FE0;"&gt;:key1&lt;/span&gt; 1 &lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt; some-other-symbol &lt;span style="color: #006FE0;"&gt;:key3&lt;/span&gt; 3)))
  (&lt;span style="color: #0000FF;"&gt;with-dict&lt;/span&gt; d
    (format &lt;span style="color: #008000;"&gt;"We got %s"&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:key2&lt;/span&gt;))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
That is pretty interesting! In case that looks similar to a context manager in Python, now you know where Python got that idea ;)
&lt;/p&gt;

&lt;p&gt;
Another related idea is to let-bind the values to variables withing a scope. We can't use the keywords directly here, so I use some hackery to strip off the colon so it is a regular symbol. That is not quite as nice I guess since you have to remember to remove the : from the symbols in the body of your code.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;with-plist-vals&lt;/span&gt; (plist &lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; body)
  &lt;span style="color: #036A07;"&gt;"Bind the values of a plist to variables with the name of the keys."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;declare&lt;/span&gt; (indent 1))
  `(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ,(&lt;span style="color: #0000FF;"&gt;loop&lt;/span&gt; for key in (-slice plist 0 nil 2)
               for val in (-slice plist 1 nil 2)
               collect (list (intern
                              (substring (symbol-name key) 1))
                             val))
     ,@body))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here is an example usage.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-plist-vals&lt;/span&gt; (&lt;span style="color: #006FE0;"&gt;:a&lt;/span&gt; 4 &lt;span style="color: #006FE0;"&gt;:b&lt;/span&gt; 6)
 (* 2 a))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Obviously that is just an alternate syntax for the let statement, but it lets you leverage the plist syntax for multiple purposes.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/04/16/A-callable-plist-data-structure-for-Emacs.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A new org-mode exporter to Word for scimax</title>
      <link>http://jkitchin.github.io/blog/2017/04/15/A-new-org-mode-exporter-to-Word-for-scimax</link>
      <pubDate>Sat, 15 Apr 2017 16:19:05 EDT</pubDate>
      <category><![CDATA[export]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">G2OqnAq_1YfN4yGs1NWp5LH4yQc=</guid>
      <description>A new org-mode exporter to Word for scimax</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am continuing to chip away to getting a reasonable export behavior for org-mode to MS Word. I have previously made some progress with Pandoc &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/01/29/Export-org-mode-to-docx-with-citations-via-pandoc/"&gt;here&lt;/a&gt; and &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies/"&gt;here&lt;/a&gt;, but those solutions never stuck with me. So here is another go. Here I leverage Pandoc again, but use a path through LaTeX to get citations without modifying the org-ref cite link syntax. The code for this can be found here: &lt;a href="https://github.com/jkitchin/scimax/blob/master/ox-word.el"&gt;https://github.com/jkitchin/scimax/blob/master/ox-word.el&lt;/a&gt;. The gist is you use org-ref like you always do, and you specify the bibliography style for Pandoc like this:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-15-04-2017-time-16-06-53.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
You can download other csl files at &lt;a href="https://www.zotero.org/styles"&gt;https://www.zotero.org/styles&lt;/a&gt;. Then you can simply export the org-doc to a Word document with the key-binding C-c C-e w p.
&lt;/p&gt;

&lt;p&gt;
Here is an example document to illustrate the exporter. I have written about data sharing in catalysis &lt;a class='org-ref-reference' href="#kitchin-2015-examp"&gt;kitchin-2015-examp&lt;/a&gt; and surface science &lt;a class='org-ref-reference' href="#kitchin-2015-data-surfac-scien"&gt;kitchin-2015-data-surfac-scien&lt;/a&gt;.
&lt;/p&gt;

&lt;p&gt;
Here is an example source block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

plt.plot([1, 2, 3, 4, 5, 6])
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/ob-ipython-b8591826ba9e316738705d03264316a5.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
See Ref. &lt;a href="#fig:line"&gt;fig:line&lt;/a&gt; for example. These do not work. That might require additional pre-processing to replace them with numbers.
&lt;/p&gt;

&lt;p&gt;
Here is the Word document that is generated: &lt;a href="/media/2017-04-15.docx"&gt;2017-04-15.docx&lt;/a&gt; 
&lt;/p&gt;

&lt;p&gt;
As a penultimate result it might be ok. The references are reasonably formatted, but not compatible with Endnote, or other bibliography manager software. There are still some issues with Figure numbering and cross-references, but it is not too bad. The main benefit of this seems to be that one source generates HTML and the Word document.
&lt;/p&gt;

&lt;p&gt;

&lt;h1 class='org-ref-bib-h1'&gt;Bibliography&lt;/h1&gt;
&lt;ul class='org-ref-bib'&gt;&lt;li&gt;&lt;a id="kitchin-2015-examp"&gt;[kitchin-2015-examp] Kitchin, Examples of Effective Data Sharing in Scientific Publishing, &lt;i&gt;ACS Catalysis&lt;/i&gt;, &lt;b&gt;5(6)&lt;/b&gt;, 3894-3899 (2015). &lt;a href=" http://dx.doi.org/10.1021/acscatal.5b00538 "&gt;link&lt;/a&gt;. &lt;a href="http://dx.doi.org/10.1021/acscatal.5b00538"&gt;doi&lt;/a&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a id="kitchin-2015-data-surfac-scien"&gt;[kitchin-2015-data-surfac-scien] "John Kitchin", Data Sharing in Surface Science, &lt;i&gt;"Surface Science "&lt;/i&gt;, &lt;b&gt;647&lt;/b&gt;, 103-107 (2016). &lt;a href="http://www.sciencedirect.com/science/article/pii/S0039602815001326"&gt;link&lt;/a&gt;. &lt;a href="http://dx.doi.org/10.1016/j.susc.2015.05.007"&gt;doi&lt;/a&gt;.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/04/15/A-new-org-mode-exporter-to-Word-for-scimax.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Autoformatting ordinal numbers and fractions in orgmode</title>
      <link>http://jkitchin.github.io/blog/2017/04/11/Autoformatting-ordinal-numbers-and-fractions-in-orgmode</link>
      <pubDate>Tue, 11 Apr 2017 15:05:56 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">aBxgPZr2cpO_yP5zCdWuoaXpm7Y=</guid>
      <description>Autoformatting ordinal numbers and fractions in orgmode</description>
      <content:encoded><![CDATA[


&lt;p&gt;
MS Word has a &lt;i&gt;few&lt;/i&gt; things I like. One of them is the ability to autoformat things to make an ordinal number string like 1st to the superscripted version 1&lt;sup&gt;st&lt;/sup&gt; while you type or a 1/2 to .  I thought it would be pretty easy to implement that for org-mode. It turns out it was not so easy!
&lt;/p&gt;

&lt;p&gt;
There does not appear to be a way to specify a regexp pattern as an abbreviation, or an abbrev that starts with a number. What we need for ordinal numbers is to recognize a sequence of numbers followed by "st", "nd", "rd" or "th" followed by a space or punctuation, and then superscript the letters. In case you didn't want the replacement to occur, you should be able to undo it and get back the original string. This addition was a little hard won, so I am sharing the lessons here.
&lt;/p&gt;

&lt;p&gt;
The logic I used is to put a function in the post-self-insert-hook. The function only works in org-mode, when not in a codeblock and when looking back at a regexp that matches a pattern to be replaced. Getting it to undo was trickier than expected. Eventually I worked out that you put an undo boundary in place before the change, and then it seems like you can undo the changes. I created a minor mode so it is easy to toggle this on and off.
&lt;/p&gt;

&lt;p&gt;
Here is the implementation:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defcustom&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;scimax-autoformat-ordinals&lt;/span&gt; t
  &lt;span style="color: #036A07;"&gt;"Determines if scimax autoformats ordinal numbers."&lt;/span&gt;
  &lt;span style="color: #006FE0;"&gt;:group&lt;/span&gt; 'scimax)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-org-autoformat-ordinals&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Expand ordinal words to superscripted versions in org-mode.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;1st to 1^{st}.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;2nd to 2^{nd}&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;3rd to 3^{rd}&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;4th to 4^{th}"&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; scimax-autoformat-ordinals
             (eq major-mode 'org-mode)
             (not (org-in-src-block-p))
             (looking-back &lt;span style="color: #008000;"&gt;"&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?3:&lt;/span&gt;&lt;span style="color: #008000;"&gt;\\&amp;lt;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?1:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[0-9]+&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?2:&lt;/span&gt;&lt;span style="color: #008000;"&gt;st&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;nd&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;rd&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;th&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;\\&amp;gt;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[[:punct:]]&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;[[:space:]]&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;"&lt;/span&gt;
                           (line-beginning-position)))
    (undo-boundary)
    (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
      (replace-match &lt;span style="color: #008000;"&gt;"\\1^{\\2}"&lt;/span&gt; nil nil nil 3))))


(&lt;span style="color: #0000FF;"&gt;defcustom&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;scimax-autoformat-fractions&lt;/span&gt; t
  &lt;span style="color: #036A07;"&gt;"Determines if scimax autoformats fractions."&lt;/span&gt;
  &lt;span style="color: #006FE0;"&gt;:group&lt;/span&gt; 'scimax)


(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-org-autoformat-fractions&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Expand fractions to take up space."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; scimax-autoformat-fractions
             (eq major-mode 'org-mode)
             (not (org-in-src-block-p))
             (looking-back &lt;span style="color: #008000;"&gt;"&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?3:&lt;/span&gt;&lt;span style="color: #008000;"&gt;\\&amp;lt;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(&lt;/span&gt;&lt;span style="color: #008000;"&gt;1/4&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;1/2&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;3/4&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;\\&amp;gt;&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[[:punct:]]&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;|&lt;/span&gt;&lt;span style="color: #008000;"&gt;[[:space:]]&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;"&lt;/span&gt;
                           (line-beginning-position)))
    (undo-boundary)
    (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt;
      (replace-match (cdr (assoc (match-string 3) '((&lt;span style="color: #008000;"&gt;"1/4"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"&amp;#188;"&lt;/span&gt;)
                                                    (&lt;span style="color: #008000;"&gt;"1/2"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"&amp;#189;"&lt;/span&gt;)
                                                    (&lt;span style="color: #008000;"&gt;"3/4"&lt;/span&gt; . &lt;span style="color: #008000;"&gt;"&amp;#190;"&lt;/span&gt;))))
                     nil nil nil 3))))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-org-autoformat&lt;/span&gt; ()
  &lt;span style="color: #036A07;"&gt;"Autoformat functions."&lt;/span&gt;
  (scimax-org-autoformat-ordinals)
  (scimax-org-autoformat-fractions))

(&lt;span style="color: #0000FF;"&gt;define-minor-mode&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-autoformat-mode&lt;/span&gt;
  &lt;span style="color: #036A07;"&gt;"Toggle `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;scimax-autoformat-mode&lt;/span&gt;&lt;span style="color: #036A07;"&gt;'.  Converts 1st to 1^{st} as you type."&lt;/span&gt;
  &lt;span style="color: #006FE0;"&gt;:init-value&lt;/span&gt; nil
  &lt;span style="color: #006FE0;"&gt;:lighter&lt;/span&gt; (&lt;span style="color: #008000;"&gt;" om"&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; scimax-ordinal-mode
      (add-hook 'post-self-insert-hook #'scimax-org-autoformat nil 'local)
    (remove-hook 'post-self-insert-hook #'scimax-org-autoformat 'local)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This is now a feature in scimax. This marks the 500&lt;sup&gt;th&lt;/sup&gt; blog post! That is  way to 1000. At the current rate of posting, it will be at least 5 years until I hit that!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/04/11/Autoformatting-ordinal-numbers-and-fractions-in-orgmode.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A better return in org-mode</title>
      <link>http://jkitchin.github.io/blog/2017/04/09/A-better-return-in-org-mode</link>
      <pubDate>Sun, 09 Apr 2017 10:56:42 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">0iu8sLfQQWT9g84NGKEsM4n2ffg=</guid>
      <description>A better return in org-mode</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org774898d"&gt;1. a subheading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4f302f8"&gt;2. another Subheading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
Over on &lt;a href="http://emacs.stackexchange.com/questions/24574/org-mode-default-to-alt-enter-for-bullets"&gt;Stackoverflow&lt;/a&gt; someone wanted a better return in org-mode. They wanted return to add items in a list (instead of M-Ret). Someone posted a partial solution, and here I improve on it to add new items to lists, new headings after a heading, and new rows to tables. In each case, a double return on an empty item, headline or table row will delete that line, and terminate the list, headlines or table. You can still use M-Ret, and this function falls through to org-return like it did before. You can use a prefix arg to get a regular return if you want one (e.g. you want to press enter on a headline to push it down).
&lt;/p&gt;

&lt;p&gt;
Here is the function. Give it a try. It is a small but helpful addition I think. I have not used it for long, so if you come across issues leave a comment!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;org-inlinetask&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax/org-return&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;optional&lt;/span&gt; ignore)
  &lt;span style="color: #036A07;"&gt;"Add new list item, heading or table row with RET.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;A double return on an empty element deletes it.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;Use a prefix arg to get regular RET. "&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt; &lt;span style="color: #008000;"&gt;"P"&lt;/span&gt;)
  (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; ignore
      (org-return)
    (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;

     ((eq 'line-break (car (org-element-context)))
      (org-return-indent))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Open links like usual, unless point is at the end of a line.&lt;/span&gt;
     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and if at beginning of line, just press enter.&lt;/span&gt;
     ((&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt; (eq 'link (car (org-element-context))) (not (eolp)))
          (bolp))
      (org-return))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;It doesn't make sense to add headings in inline tasks. Thanks Anders&lt;/span&gt;
     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Johansson!&lt;/span&gt;
     ((org-inlinetask-in-task-p)
      (org-return))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;checkboxes too&lt;/span&gt;
     ((org-at-item-checkbox-p)
      (org-insert-todo-heading nil))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;lists end with two blank lines, so we need to make sure we are also not&lt;/span&gt;
     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;at the beginning of a line to avoid a loop where a new entry gets&lt;/span&gt;
     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;created with only one blank line.&lt;/span&gt;
     ((org-in-item-p)
      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;save-excursion&lt;/span&gt; (beginning-of-line) (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-begin&lt;/span&gt; (org-element-context)))
          (org-insert-heading)
        (beginning-of-line)
        (delete-region (line-beginning-position) (line-end-position))
        (org-return)))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;org-heading&lt;/span&gt;
     ((org-at-heading-p)
      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (not (string= &lt;span style="color: #008000;"&gt;""&lt;/span&gt; (org-element-property &lt;span style="color: #006FE0;"&gt;:title&lt;/span&gt; (org-element-context))))
          (&lt;span style="color: #0000FF;"&gt;progn&lt;/span&gt; (org-end-of-meta-data)
                 (org-insert-heading-respect-content)
                 (outline-show-entry))
        (beginning-of-line)
        (&lt;span style="color: #0000FF;"&gt;setf&lt;/span&gt; (buffer-substring
               (line-beginning-position) (line-end-position)) &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;tables&lt;/span&gt;
     ((org-at-table-p)
      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (-any?
           (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (x) (not (string= &lt;span style="color: #008000;"&gt;""&lt;/span&gt; x)))
           (nth
            (- (org-table-current-dline) 1)
            (org-table-to-lisp)))
          (org-return)
        &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;empty row&lt;/span&gt;
        (beginning-of-line)
        (&lt;span style="color: #0000FF;"&gt;setf&lt;/span&gt; (buffer-substring
               (line-beginning-position) (line-end-position)) &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
        (org-return)))

     &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;fall-through case&lt;/span&gt;
     (t
      (org-return)))))


(define-key org-mode-map (kbd &lt;span style="color: #008000;"&gt;"RET"&lt;/span&gt;)
  'scimax/org-return)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are a few tests:
&lt;/p&gt;


&lt;ol class="org-ol"&gt;
&lt;li&gt;numbered item&lt;/li&gt;
&lt;li&gt;second item
&lt;ol class="org-ol"&gt;
&lt;li&gt;nested number&lt;/li&gt;
&lt;li&gt;second number&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;ul class="org-ul"&gt;
&lt;li&gt;unordered 1&lt;/li&gt;
&lt;li&gt;unordered 2
&lt;ul class="org-ul"&gt;
&lt;li&gt;nested&lt;/li&gt;
&lt;li&gt;nested 2
&lt;ul class="org-ul"&gt;
&lt;li&gt;nested with link: &lt;a href="http://emacs.stackexchange.com"&gt;http://emacs.stackexchange.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class="org-ul"&gt;
&lt;li class="off"&gt;&lt;code&gt;[&amp;#xa0;]&lt;/code&gt; check 1&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[&amp;#xa0;]&lt;/code&gt; check 2&lt;/li&gt;
&lt;li class="off"&gt;&lt;code&gt;[&amp;#xa0;]&lt;/code&gt; check 3&lt;/li&gt;
&lt;/ul&gt;


&lt;div class="inlinetask"&gt;
&lt;b&gt;an inline task&lt;/b&gt;&lt;br /&gt;
&lt;p&gt;
With some content
&lt;/p&gt;
&lt;/div&gt;


&lt;div id="outline-container-org774898d" class="outline-2"&gt;
&lt;h2 id="org774898d"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; a subheading&lt;/h2&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4f302f8" class="outline-2"&gt;
&lt;h2 id="org4f302f8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; another Subheading&lt;/h2&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2017 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2017/04/09/A-better-return-in-org-mode.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.0.5&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
