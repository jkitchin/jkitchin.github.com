<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Sun, 07 Oct 2018 17:08:18 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Compressibility factor variation from the van der Waals equation by three different approaches</title>
      <link>http://jkitchin.github.io/blog/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches</link>
      <pubDate>Sun, 07 Oct 2018 13:08:11 EDT</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[ode]]></category>
      <category><![CDATA[python]]></category>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">nzuQ2552fiegwa_OqTuF-vQ3pMs=</guid>
      <description>Compressibility factor variation from the van der Waals equation by three different approaches</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org4da961c"&gt;1. Method 1 - fsolve&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgcde095a"&gt;2. Method 2 - solve_ivp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org29acef6"&gt;3. Method 3 - autograd + solve_ivp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In the book &lt;span class="underline"&gt;Problem solving in chemical and biochemical engineering with POLYMATH, Excel and Matlab&lt;/span&gt; by Cutlip and Shacham there is a problem (7.1) where you want to plot the compressibility factor for CO&lt;sub&gt;2&lt;/sub&gt; over a range of $0.1 &amp;le; P_r &amp;lt;= 10 for a constant \(T_r=1.1\) using the van der Waal equation of state. There are a two standard ways to do this:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Solve a nonlinear equation for different values of \(P_r\).&lt;/li&gt;
&lt;li&gt;Solve a nonlinear equation for one value of \(P_r\), then derive an ODE for how the compressibility varies with \(P_r\) and integrate it over the relevant range.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
In this post, we compare and contrast the two methods, and consider a variation of the second method that uses automatic differentiation.
&lt;/p&gt;

&lt;div id="outline-container-org4da961c" class="outline-2"&gt;
&lt;h2 id="org4da961c"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Method 1 - fsolve&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
The van der Waal equation of state is:
&lt;/p&gt;

&lt;p&gt;
\(P = \frac{R T}{V - b} - \frac{a}{V^2}\).
&lt;/p&gt;

&lt;p&gt;
We define the reduced pressure as \(P_r = P / P_c\), and the reduced temperature as \(T_r = T / T_c\).
&lt;/p&gt;

&lt;p&gt;
So, we simply solve for V at a given \(P_r\), and then compute \(Z\). There is a subtle trick needed to make this easy to solve, and that is to multiply each side of the equation by \((V - b)\) to avoid a singularity when \(V = b\), which happens in this case near \(P_r \approx 7.5\).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #BA36A5;"&gt;R&lt;/span&gt; = 0.08206
&lt;span style="color: #BA36A5;"&gt;Pc&lt;/span&gt; = 72.9
&lt;span style="color: #BA36A5;"&gt;Tc&lt;/span&gt; = 304.2

&lt;span style="color: #BA36A5;"&gt;a&lt;/span&gt; = 27 * R**2 * Tc**2 / (Pc * 64)
&lt;span style="color: #BA36A5;"&gt;b&lt;/span&gt; = R * Tc / (8 * Pc)

&lt;span style="color: #BA36A5;"&gt;Tr&lt;/span&gt; = 1.1

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(V, Pr):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = Pr * Pc
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;T&lt;/span&gt; = Tr * Tc
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; P * (V - b) - (R * T)  +  a / V**2 * (V - b)


&lt;span style="color: #BA36A5;"&gt;Pr_range&lt;/span&gt; = np.linspace(0.1, 10)
&lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = [fsolve(objective, 3, args=(Pr,))[0] &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; Pr &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; Pr_range]

&lt;span style="color: #BA36A5;"&gt;T&lt;/span&gt; = Tr * Tc
&lt;span style="color: #BA36A5;"&gt;P_range&lt;/span&gt; = Pr_range * Pc
&lt;span style="color: #BA36A5;"&gt;Z&lt;/span&gt; = P_range * V / (R * T)

plt.plot(Pr_range, Z)
plt.xlabel(&lt;span style="color: #008000;"&gt;'$P_r$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'Z'&lt;/span&gt;)
plt.xlim([0, 10])
plt.ylim([0, 2])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(0, 2)

&lt;/pre&gt;



&lt;p&gt;
&lt;img src="/media/13bc1d996aa4bd032faad00425793120-90490byl.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
That looks like Figure 7-1 in the book. This approach is fine, but the equation did require a little algebraic finesse to solve, and you have to use some iteration to get the solution.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgcde095a" class="outline-2"&gt;
&lt;h2 id="orgcde095a"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Method 2 - solve_ivp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
In this method, you have to derive an expression for \(\frac{dV}{dP_r}\). That derivation goes like this:
&lt;/p&gt;

&lt;p&gt;
\(\frac{dV}{dP_r} = \frac{dV}{dP} \frac{dP}{dP_r}\)
&lt;/p&gt;

&lt;p&gt;
The first term \(\frac{dV}{dP}\) is \((\frac{dP}{dV})^{-1}\), which we can derive directly from the van der Waal equation, and the second term is just a constant: \(P_c\) from the definition of \(P_r\).
&lt;/p&gt;

&lt;p&gt;
They derived:
&lt;/p&gt;

&lt;p&gt;
\(\frac{dP}{dV} = -\frac{R T}{(V - b)^2} + \frac{2 a}{V^3}\)
&lt;/p&gt;

&lt;p&gt;
We need to solve for one V, at the beginning of the range of \(P_r\) we are interested in.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;V0, = fsolve(objective, 3, args=(0.1,))
V0
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3.6764763125625461

&lt;/pre&gt;

&lt;p&gt;
Now, we can define the functions, and integrate them to get the same solution. I defined these pretty verbosely, just for readability.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; solve_ivp

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dPdV&lt;/span&gt;(V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -R * T / (V - b)**2 + 2 * a / V**3

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dVdP&lt;/span&gt;(V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 / dPdV(V)

&lt;span style="color: #BA36A5;"&gt;dPdPr&lt;/span&gt; = Pc

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dVdPr&lt;/span&gt;(Pr, V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; dVdP(V) * dPdPr

&lt;span style="color: #BA36A5;"&gt;Pr_span&lt;/span&gt; = (0.1, 10)
&lt;span style="color: #BA36A5;"&gt;Pr_eval&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;h&lt;/span&gt; = np.linspace(*Pr_span, retstep=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)

&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(dVdPr, Pr_span, (V0,), dense_output=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;, max_step=h)

&lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = sol.y[0]
&lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = sol.t * Pc
&lt;span style="color: #BA36A5;"&gt;Z&lt;/span&gt; = P * V / (R * T)
plt.plot(sol.t, Z)
plt.xlabel(&lt;span style="color: #008000;"&gt;'$P_r$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'Z'&lt;/span&gt;)
plt.xlim([0, 10])
plt.ylim([0, 2])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(0, 2)

&lt;/pre&gt;



&lt;p&gt;
&lt;img src="/media/13bc1d996aa4bd032faad00425793120-90490o8r.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
This also looks like Figure 7-1. It is arguably a better approach since we only need an initial condition, and after that have a reliable integration (rather than many iterative solutions from an initial guess of the solution in fsolve).
&lt;/p&gt;

&lt;p&gt;
The only downside to this approach (in my opinion) is the need to derive and implement derivatives. As equations of state get more complex, this gets more tedious and complicated.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org29acef6" class="outline-2"&gt;
&lt;h2 id="org29acef6"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Method 3 - autograd + solve_ivp&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
The whole point of automatic differentiation is to get derivatives of functions that are written as programs. We explore here the possibility of using this to solve this problem. The idea is to use autograd to define the derivative \(dP/dV\), and then solve the ODE like we did before.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; grad

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;P&lt;/span&gt;(V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; R * T / (V - b) - a / V**2

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;autograd.grad returns a callable that acts like a function&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;dPdV&lt;/span&gt; = grad(P, 0)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dVdPr&lt;/span&gt;(Pr, V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 / dPdV(V) * Pc

&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(dVdPr,  Pr_span, (V0,), dense_output=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;, max_step=h)

V, = sol.y
&lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = sol.t * Pc
&lt;span style="color: #BA36A5;"&gt;Z&lt;/span&gt; = P * V / (R * T)
plt.plot(sol.t, Z)
plt.xlabel(&lt;span style="color: #008000;"&gt;'$P_r$'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'Z'&lt;/span&gt;)
plt.xlim([0, 10])
plt.ylim([0, 2])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(0, 2)

&lt;/pre&gt;



&lt;p&gt;
&lt;img src="/media/13bc1d996aa4bd032faad00425793120-90490O2H.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
Not surprisingly, this answer looks the same as the previous ones. I think this solution is pretty awesome. We only had to implement the van der Waal equation, and then let autograd do its job to get the relevant derivative. We don't get a free pass on calculus here; we still have to know which derivatives are important. We also need some knowledge about how to use autograd, but with that, this problem becomes pretty easy to solve.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/10/07/Compressibility-factor-variation-from-the-van-der-Waals-equation-by-three-different-approaches.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Solving nonlinear algebra problems with internal state information</title>
      <link>http://jkitchin.github.io/blog/2018/09/24/Solving-nonlinear-algebra-problems-with-internal-state-information</link>
      <pubDate>Mon, 24 Sep 2018 15:25:06 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">BlqHNVHd84spZMeCrwRb4yewh38=</guid>
      <description>Solving nonlinear algebra problems with internal state information</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org532d5ce"&gt;1. First approach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga01a4af"&gt;2. Second approach - use a state dictionary as an arg in the objective function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc590864"&gt;3. third approach - a callable object&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgaef298d"&gt;4. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In engineering, we often need to solve an equation in one variable, and then use the solution to compute other variables. For example, we might want the bubble point temperature of a mixture, and then to determine the composition of the vapor phase that has formed. In other words, we compute the temperature, and then have to use it in a subsequent step to get the composition. Here is a bubble point computation adapted from example 10.2 in Smith and van Ness, Introduction to Chemical Engineering Thermodynamics.
&lt;/p&gt;

&lt;p&gt;
Given a solution of acetone (x&lt;sub&gt;1&lt;/sub&gt;=0.3), acetonitrile (x&lt;sub&gt;2&lt;/sub&gt;=0.45) and nitromethane (x&lt;sub&gt;3&lt;/sub&gt;=0.25) at a total pressure of 80 kPa, compute the bubble point temperature and gas phase composition.
&lt;/p&gt;

&lt;p&gt;
The key here is to find a temperature where the gas-phase mole fractions sum to one. The gas phase mole fractions are defined by:
&lt;/p&gt;

&lt;p&gt;
\(y_i = x_i Pvap_i(T) / P\)
&lt;/p&gt;

&lt;p&gt;
The typical way I would teach students how solve this looks like this. It uses the Antoine equation coded below to estimate the vapor pressure of each component as a function of temperature, and then uses fsolve to find a temperature where the gas-phase mole fractions sum to one.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve

&lt;span style="color: #BA36A5;"&gt;acetone&lt;/span&gt; = (14.5463, 2940.46, 237.22)
&lt;span style="color: #BA36A5;"&gt;acetonitrile&lt;/span&gt; = (14.2724, 2945.47,224)
&lt;span style="color: #BA36A5;"&gt;nitromethane&lt;/span&gt; = (14.2043, 2972.64, 209)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;antoine&lt;/span&gt;(T, A, B, C):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;T&lt;/span&gt; = &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(T) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;there is some subtle issue that comes up when T is an array,&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;as passed in from fsolve. It needs to be a float, or you get&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the wrong answer.&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(A - B / (T + C))

&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.array([0.3, 0.45, 0.25])
&lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = 80

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;Pvap&lt;/span&gt; = np.array([antoine(T, *pars) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; pars &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [acetone, acetonitrile, nitromethane]])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = x * Pvap / P
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 - y.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;()

Tans, = fsolve(objective, 70)

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;This is where we end up repeating code&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;Pvap&lt;/span&gt; = np.array([antoine(Tans, *pars) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; pars &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [acetone, acetonitrile, nitromethane]])
&lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = x * Pvap / P

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The bubble point temperature is {Tans:1.2f} degC, and the gas phase compositions are {np.round(y, 4)}.'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].


&lt;/pre&gt;

&lt;p&gt;
This solution works fine, but there is in my opinion, an issue with the small amount of repeated code at the end that is required to get the composition of the gas-phase. This is a small problem here, but as the problems get bigger it is more and more tedious to correctly repeat all the code to see what the state of a system is at the solution, and it seems wasteful to have to repeat the computations; they were known in the objective function. In the following subsections, I explore some alternative approaches to reduce the repetition.
&lt;/p&gt;

&lt;div id="outline-container-org532d5ce" class="outline-2"&gt;
&lt;h2 id="org532d5ce"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; First approach&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
There are two small chunks of repeated code in the example above. One way to minimize the amount of repeated code is to pull these out into reusable functions. Here, we do that, and only have to repeat one function call at the end to get the system composition out.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve

&lt;span style="color: #BA36A5;"&gt;acetone&lt;/span&gt; = (14.5463, 2940.46, 237.22)
&lt;span style="color: #BA36A5;"&gt;acetonitrile&lt;/span&gt; = (14.2724, 2945.47,224)
&lt;span style="color: #BA36A5;"&gt;nitromethane&lt;/span&gt; = (14.2043, 2972.64, 209)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;antoine&lt;/span&gt;(T, A, B, C):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;T&lt;/span&gt; = &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(T) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;there is some subtle issue that comes up when T is an array,&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;as passed in from fsolve. It needs to be a float, or you get&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;the wrong answer.&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(A - B / (T + C))

&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.array([0.3, 0.45, 0.25])
&lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = 80

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;Pvap&lt;/span&gt;(T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.array([antoine(T, *pars) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; pars &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [acetone, acetonitrile, nitromethane]])

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;y&lt;/span&gt;(T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x * Pvap(T) / P

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 - y(T).&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;()

Tans, = fsolve(objective, 70)

&lt;span style="color: #BA36A5;"&gt;yans&lt;/span&gt; = y(Tans) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;minimal repetition of a calculation to get the composition state.&lt;/span&gt;

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The bubble point temperature is {Tans:1.2f} degC, and the gas phase compositions are {np.round(yans, 4)}.'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].


&lt;/pre&gt;

&lt;p&gt;
That is a small improvement. The code is not much shorter, just reorganized for easier reuse. It would be easy in this case to also get the vapor pressures of each species at this temperature, just by calling the &lt;code&gt;Pvap&lt;/code&gt; function. Still, it feels annoying we have to recalculate the answer to something you know must have already been known when the objective function was evaluated.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga01a4af" class="outline-2"&gt;
&lt;h2 id="orga01a4af"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Second approach - use a state dictionary as an arg in the objective function&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
In this approach, we will use a dictionary to store the state of the objective function. The dictionary will be in the global namespace, and we will just update it each time the objective function is called.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve

&lt;span style="color: #BA36A5;"&gt;acetone&lt;/span&gt; = (14.5463, 2940.46, 237.22)
&lt;span style="color: #BA36A5;"&gt;acetonitrile&lt;/span&gt; = (14.2724, 2945.47,224)
&lt;span style="color: #BA36A5;"&gt;nitromethane&lt;/span&gt; = (14.2043, 2972.64, 209)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;antoine&lt;/span&gt;(T, A, B, C):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(A - B / (T + C))

&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.array([0.3, 0.45, 0.25])

&lt;span style="color: #BA36A5;"&gt;state&lt;/span&gt; = {}

&lt;span style="color: #BA36A5;"&gt;P&lt;/span&gt; = 80


&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(T, state):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;T&lt;/span&gt; = &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(T)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;Pvap&lt;/span&gt; = np.array([antoine(T, *pars) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; pars &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [acetone, acetonitrile, nitromethane]])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = x * Pvap / P
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   state.update({&lt;span style="color: #008000;"&gt;'y'&lt;/span&gt;: y,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; &lt;span style="color: #008000;"&gt;'T'&lt;/span&gt;:  T,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; &lt;span style="color: #008000;"&gt;'Pvap'&lt;/span&gt;: Pvap,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; &lt;span style="color: #008000;"&gt;'z'&lt;/span&gt;: 1 - y.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;()})
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; state[&lt;span style="color: #008000;"&gt;'z'&lt;/span&gt;]

Tans, = fsolve(objective, 70, args=(state,))

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The bubble point temperature is {Tans:1.2f} degC, and the gas phase compositions are {np.round(state["y"], 4)}.'&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(Tans- state[&lt;span style="color: #008000;"&gt;'T'&lt;/span&gt;]) &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;check to make sure last value from objective is the same as the solution&lt;/span&gt;
state
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].
0.0


&lt;/pre&gt;

&lt;pre class="example"&gt;
{'Pvap': array([ 138.5620209 ,   67.07966082,   32.98218545]),
 'T': 68.60064626680659,
 'y': array([ 0.51960758,  0.37732309,  0.10306933]),
 'z': -3.4194869158454821e-14}

&lt;/pre&gt;

&lt;p&gt;
What we see in the &lt;code&gt;state&lt;/code&gt; dictionary is the result from the last time that the objective function was called. It appears that the list time it was called is also where the solution comes from, so the other variables stored here should be consistent. Now you can see we have access to both the Pvap and y composition data from the solution without needing any further computations. This approach could be easily extended to store any derived quantities that represent internal states you want. We don't store any history in this, but you could by appending to lists in the dictionary.
&lt;/p&gt;

&lt;p&gt;
One &lt;i&gt;feature&lt;/i&gt; of this is the state dictionary is updated by side effect, and you have to use the state dictionary as an argument parameter to the function.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgc590864" class="outline-2"&gt;
&lt;h2 id="orgc590864"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; third approach - a callable object&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
A standard approach to tracking state data is to encapsulate it in a class. fsolve requires a callable function that returns zero at the solution. It is possible to make an object &lt;i&gt;act like a callable function&lt;/i&gt; if we define a &lt;code&gt;__call__&lt;/code&gt; method on it. Then, in this method, we can set attributes on the object to keep track of the state, similar to what we did with the dictionary. Since we have a class, we can define some other special dunder methods, e.g. to print the solution. Here is one implementation.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve

&lt;span style="color: #0000FF;"&gt;class&lt;/span&gt; &lt;span style="color: #6434A3;"&gt;Objective&lt;/span&gt;(&lt;span style="color: #006FE0;"&gt;object&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;acetone&lt;/span&gt; = (14.5463, 2940.46, 237.22)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;acetonitrile&lt;/span&gt; = (14.2724, 2945.47,224)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;nitromethane&lt;/span&gt; = (14.2043, 2972.64, 209)

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__init__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, x, P):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x = np.array(x)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.P = P

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;antoine&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, T, A, B, C):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.exp(A - B / (T + C))

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__str__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;s&lt;/span&gt; = f&lt;span style="color: #008000;"&gt;'The bubble point temperature is {self.T:1.2f} degC, and the gas phase compositions are {np.round(self.y, 4)}.'&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; s

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;__call__&lt;/span&gt;(&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;, T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;T&lt;/span&gt; = &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(T)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.T = T
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.Pvap = np.array([&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.antoine(T, *pars) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; pars &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [&lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.acetone, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.acetonitrile, &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.nitromethane]])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y = &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.x * &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.Pvap / &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.P
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 - &lt;span style="color: #0000FF;"&gt;self&lt;/span&gt;.y.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;()

&lt;span style="color: #BA36A5;"&gt;obj&lt;/span&gt; = Objective(x=np.array([0.3, 0.45, 0.25]), P=80)
ans, = fsolve(obj, 60)

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(obj)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The bubble point temperature is 68.60 degC, and the gas phase compositions are [ 0.5196  0.3773  0.1031].


&lt;/pre&gt;


&lt;p&gt;
Similar to the state dictionary approach, there is no repeated code here, and no repeated evaluations to get to the state after the solution. This is a bit more advanced Python than the state dictionary. Note, this implementation doesn't have any checking in it, so if you try to print the object before calling fsolve, you will get an error because the attributes don't exist until &lt;i&gt;after&lt;/i&gt; the object has been called. That is also an issue with the state dictionary above.
&lt;/p&gt;

&lt;p&gt;
There are many choices you could make in constructing this example. Maybe this one has gone too far in encapsulating the antoine function as a method. That limits its reusability for another problem. On the other hand, you can reuse it for any other pressure or liquid composition of acetone, acetonitrile and nitromethane very readily.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgaef298d" class="outline-2"&gt;
&lt;h2 id="orgaef298d"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
We looked at three ways to reduce having redundant code in the solution to problems involving nonlinear algebra. The first approach is conceptually simple; you break out as much as you can into reusable functions, and then at most have repeated function calls. These computations are usually not expensive, so repeating them is mostly tedious and provides opportunities for mistakes. This is probably what I will stick to for teaching students that are just seeing this for the first time.
&lt;/p&gt;

&lt;p&gt;
The second approach used a dictionary (other data structures could work too) as an argument to the objective function, and internal states were kept in the dictionary so that after the problem was solved, you have immediate access to them. This is more advanced than the first approach because it requires understanding that the dictionary is modified as a side effect of solving the problem.
&lt;/p&gt;

&lt;p&gt;
Finally,  we considered an object-oriented class encapsulation of the information we wanted. I consider this the most advanced Python solution, since it requires some understanding of classes, dunder methods and attributes, and how to make an instance of a class.
&lt;/p&gt;

&lt;p&gt;
The last two methods seem like candidates for an advanced class in problem solving. Thoughts?
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/09/24/Solving-nonlinear-algebra-problems-with-internal-state-information.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Integration of the heat capacity</title>
      <link>http://jkitchin.github.io/blog/2018/09/05/Integration-of-the-heat-capacity</link>
      <pubDate>Wed, 05 Sep 2018 13:48:14 EDT</pubDate>
      <category><![CDATA[uncategorized]]></category>
      <guid isPermaLink="false">dZGy-Kx0naEkhAQmLx5Q7VtMAJg=</guid>
      <description>Integration of the heat capacity</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf41bb27"&gt;1. Integrate the heat capacity&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgf021687"&gt;1.1. solution&amp;#xa0;&amp;#xa0;&amp;#xa0;&lt;span class="tag"&gt;&lt;span class="solution"&gt;solution&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgebff74a"&gt;2. Verify via &amp;Delta; H&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgb0cce22"&gt;2.1. solution&amp;#xa0;&amp;#xa0;&amp;#xa0;&lt;span class="tag"&gt;&lt;span class="solution"&gt;solution&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
From thermodynamics, the heat capacity is defined as \(C_p = \left(\frac{dH}{dT}\right)_P\). That means we can calculate the heat required to change the temperature of some material from the following integral:
&lt;/p&gt;

&lt;p&gt;
\(H_2 - H_1 = Q = \int_{T_1}^{T_2} C_p(T) dT\)
&lt;/p&gt;

&lt;p&gt;
In the range of 298-1200K, the heat capacity of CO&lt;sub&gt;2&lt;/sub&gt; is given by a &lt;a href="https://webbook.nist.gov/cgi/cbook.cgi?ID=C124389&amp;amp;Units=SI&amp;amp;Mask=1#Thermo-Gas"&gt;Shomate polynomial&lt;/a&gt;:
&lt;/p&gt;

&lt;p&gt;
\(C_p(t) = A + B t + C t^2 + D t^3 + E/t^2\) with units of J/mol/K.
&lt;/p&gt;

&lt;p&gt;
where \(t = T / 1000\), and \(T\) is the temperature in K. The constants in the equation are
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;&amp;#xa0;&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;A&lt;/td&gt;
&lt;td class="org-right"&gt;24.99735&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;B&lt;/td&gt;
&lt;td class="org-right"&gt;55.18696&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;C&lt;/td&gt;
&lt;td class="org-right"&gt;-33.69137&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;D&lt;/td&gt;
&lt;td class="org-right"&gt;7.948387&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;E&lt;/td&gt;
&lt;td class="org-right"&gt;-0.136638&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;F&lt;/td&gt;
&lt;td class="org-right"&gt;-403.6075&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;G&lt;/td&gt;
&lt;td class="org-right"&gt;228.2431&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;H&lt;/td&gt;
&lt;td class="org-right"&gt;-393.5224&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div id="outline-container-orgf41bb27" class="outline-2"&gt;
&lt;h2 id="orgf41bb27"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Integrate the heat capacity&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Use this information to compute the energy (Q in kJ/mol) required to raise the temperature of CO&lt;sub&gt;2&lt;/sub&gt; from 300K to 600K. You should use &lt;code&gt;scipy.integrate.quad&lt;/code&gt; to perform the integration.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf021687" class="outline-3"&gt;
&lt;h3 id="orgf021687"&gt;&lt;span class="section-number-3"&gt;1.1&lt;/span&gt; solution&amp;#xa0;&amp;#xa0;&amp;#xa0;&lt;span class="tag"&gt;&lt;span class="solution"&gt;solution&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-1-1"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;A&lt;/span&gt; =  24.99735
&lt;span style="color: #BA36A5;"&gt;B&lt;/span&gt; =  55.18696
&lt;span style="color: #BA36A5;"&gt;C&lt;/span&gt; = -33.69137
&lt;span style="color: #BA36A5;"&gt;D&lt;/span&gt; =  7.948387
&lt;span style="color: #BA36A5;"&gt;E&lt;/span&gt; = -0.136638
&lt;span style="color: #BA36A5;"&gt;F&lt;/span&gt; = -403.6075
&lt;span style="color: #BA36A5;"&gt;G&lt;/span&gt; =  228.2431
&lt;span style="color: #BA36A5;"&gt;H&lt;/span&gt; = -393.5224

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;Cp&lt;/span&gt;(T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt; = T / 1000
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; A + B*t + C*t**2 + D*t**3 + E / t**2

&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; quad

&lt;span style="color: #BA36A5;"&gt;dH&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;_&lt;/span&gt; = quad(Cp, 300, 600)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The change in enthalpy is {dH / 1000:1.3f} kJ/mol'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The change in enthalpy is 12.841 kJ/mol


&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgebff74a" class="outline-2"&gt;
&lt;h2 id="orgebff74a"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Verify via &amp;Delta; H&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The change in enthalpy (in kJ / mol) from standard state is
&lt;/p&gt;

&lt;p&gt;
\(dH − dH_{298.15}= A t + B t^2/2 + C t^3/3 + D t^4/4 − E/t + F − H\)
&lt;/p&gt;

&lt;p&gt;
again, \(t = T / 1000\).
&lt;/p&gt;

&lt;p&gt;
Use this equation to compute the change in enthalpy when you increase the temperature from 300 K to 600 K.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgb0cce22" class="outline-3"&gt;
&lt;h3 id="orgb0cce22"&gt;&lt;span class="section-number-3"&gt;2.1&lt;/span&gt; solution&amp;#xa0;&amp;#xa0;&amp;#xa0;&lt;span class="tag"&gt;&lt;span class="solution"&gt;solution&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-2-1"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dH&lt;/span&gt;(T):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt; = T / 1000
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; A * t + B*t**2 / 2 + C * t**3 / 3 + D * t**4 / 4 - E/t + F - H

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The change in enthalpy is {dH(600) - dH(300):1.3f} kJ/mol'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The change in enthalpy is 12.841 kJ/mol


&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/09/05/Integration-of-the-heat-capacity.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A new ode integrator function in scipy</title>
      <link>http://jkitchin.github.io/blog/2018/09/04/A-new-ode-integrator-function-in-scipy</link>
      <pubDate>Tue, 04 Sep 2018 21:20:58 EDT</pubDate>
      <category><![CDATA[scipy]]></category>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">e7L6DytRVe1VWizNIhScM2uYiQs=</guid>
      <description>A new ode integrator function in scipy</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I learned recently about a new way to solve ODEs in scipy: &lt;a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.solve_ivp.html"&gt;scipy.integrate.solve_ivp&lt;/a&gt;. This new function is recommended instead of &lt;code&gt;scipy.integrate.odeint&lt;/code&gt; for new code. This function caught my eye because it added functionality that was previously missing, and that I had written into my pycse package. That functionality is events.
&lt;/p&gt;

&lt;p&gt;
To explore how to use this new function, I will recreate an old &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2013/01/28/Mimicking-ode-events-in-python/"&gt;blog post&lt;/a&gt; where I used events to count the number of roots in a function. Spoiler alert: it may not be ready for production.
&lt;/p&gt;

&lt;p&gt;
The question at hand is how many roots are there in \(f(x) = x^3 + 6x^2 - 4x - 24\), and what are they. Now, I know there are three roots and that you can use &lt;code&gt;np.roots&lt;/code&gt; for this, but that
only works for polynomials. Here they are, so we know what we are looking for.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
np.roots([1, 6, -4, -24])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
array([-6.,  2., -2.])

&lt;/pre&gt;

&lt;p&gt;
The point of this is to find a more general way to count roots in an interval. We do it by integrating the derivative of the function, and using an event function to  count when the function is equal to zero. First, we define the derivative:
&lt;/p&gt;

&lt;p&gt;
\(f'(x) = 3x^2 + 12x - 4\), and the value of our original function at some value that is the beginning of the range we want to consider, say \(f(-8) = -120\). Now, we have an ordinary differential equation that can be integrated. Our event function is simply, it is just the function value \(y\). In the next block, I include an optional t_eval arg so we can see the solution at more points.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;fprime&lt;/span&gt;(x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 3 * x**2 + 12 * x - 4

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;event&lt;/span&gt;(x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; y

&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; solve_ivp
&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(fprime, (-8, 4), np.array([-120]), t_eval=np.linspace(-8, 4, 10), events=[event])
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
 message: 'The solver successfully reached the interval end.'
    nfev: 26
    njev: 0
     nlu: 0
     sol: None
  status: 0
 success: True
       t: array([-8.        , -6.66666667, -5.33333333, -4.        , -2.66666667,
      -1.33333333,  0.        ,  1.33333333,  2.66666667,  4.        ])
t_events: [array([-6.])]
       y: array([[-120.        ,  -26.96296296,   16.2962963 ,   24.        ,
         10.37037037,  -10.37037037,  -24.        ,  -16.2962963 ,
         26.96296296,  120.        ]])

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;sol.t_events
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[array([-6.])]

&lt;/pre&gt;

&lt;p&gt;
Huh. That is not what I expected. There should be three values in sol.t_events, but there is only one. Looking at sol.y, you can see there are three sign changes, which means three zeros. The graph here confirms that.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
plt.plot(sol.t, sol.y[0])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[&amp;lt;matplotlib.lines.Line2D at 0x151281d860&amp;gt;]

&lt;/pre&gt;



&lt;p&gt;
&lt;img src="/media/e56c3df20f7d52f874861f0041da6fd5-18185E.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
What appears to be happening is that the events are only called during the solver steps, which are &lt;i&gt;different&lt;/i&gt; than the t_eval steps. It appears a workaround is to specify a max_step that can be taken by the solver to force the event functions to be evaluated more often. Adding this seems to create a new cryptic warning.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(fprime, (-8, 4), np.array([-120]), events=[event], max_step=1.0)
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
/Users/jkitchin/anaconda/lib/python3.6/site-packages/scipy/integrate/_ivp/rk.py:145: RuntimeWarning: divide by zero encountered in double_scalars
  max(1, SAFETY * error_norm ** (-1 / (order + 1))))


&lt;/pre&gt;

&lt;pre class="example"&gt;
 message: 'The solver successfully reached the interval end.'
    nfev: 80
    njev: 0
     nlu: 0
     sol: None
  status: 0
 success: True
       t: array([-8.        , -7.89454203, -6.89454203, -5.89454203, -4.89454203,
      -3.89454203, -2.89454203, -1.89454203, -0.89454203,  0.10545797,
       1.10545797,  2.10545797,  3.10545797,  4.        ])
t_events: [array([-6., -2.,  2.])]
       y: array([[-120.        , -110.49687882,  -38.94362768,    3.24237128,
         22.06111806,   23.51261266,   13.59685508,   -1.68615468,
        -16.33641662,  -24.35393074,  -19.73869704,    3.50928448,
         51.39001383,  120.        ]])

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;sol.t_events
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[array([-6., -2.,  2.])]

&lt;/pre&gt;

&lt;p&gt;
That is more like it. Here, I happen to know the answers, so we are safe setting a max_step of 1.0, but that feels awkward and unreliable. You don't want this max_step to be too small, because it probably makes for more computations. On the other hand, it can't be too large either because you might miss roots. It seems there is room for improvement on this.
&lt;/p&gt;

&lt;p&gt;
It also seems odd that the solve_ivp only returns the t_events, and not also the corresponding solution values. I guess in this case, we know the solution values are zero at t_events, but, supposing you instead were looking for a maximum value by getting a derivative that was equal to zero, you might end up getting stuck solving for it some how.
&lt;/p&gt;

&lt;p&gt;
Let's consider this parabola with a maximum at \(x=2\), where \(y=2\):
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.linspace(0, 4)
plt.plot(x, 2 - (x - 2)**2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[&amp;lt;matplotlib.lines.Line2D at 0x1512dad9e8&amp;gt;]

&lt;/pre&gt;



&lt;p&gt;
&lt;img src="/media/e56c3df20f7d52f874861f0041da6fd5-181K3p.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
We can find the maximum like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;yprime&lt;/span&gt;(x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -2  * (x - 2)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;maxevent&lt;/span&gt;(x, y):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; yprime(x, y)

&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(yprime, (0, 4), np.array([-2]), events=[maxevent])
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
/Users/jkitchin/anaconda/lib/python3.6/site-packages/scipy/integrate/_ivp/rk.py:145: RuntimeWarning: divide by zero encountered in double_scalars
  max(1, SAFETY * error_norm ** (-1 / (order + 1))))


&lt;/pre&gt;

&lt;pre class="example"&gt;
 message: 'The solver successfully reached the interval end.'
    nfev: 20
    njev: 0
     nlu: 0
     sol: None
  status: 0
 success: True
       t: array([ 0.        ,  0.08706376,  0.95770136,  4.        ])
t_events: [array([ 2.])]
       y: array([[-2.        , -1.65932506,  0.91361355, -2.        ]])

&lt;/pre&gt;

&lt;p&gt;
Clearly, we found the maximum at x=2, but now what?  Re-solve the ODE and use t_eval with the t_events values? Use a fine t_eval array, and interpolate the solution? That doesn't seem smart. You could make the event terminal, so that it stops at the max, and then read off the last value, but this will not work if you want to count more than one maximum, for example.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;maxevent.terminal&lt;/span&gt; = &lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;
solve_ivp(yprime, (0, 4), (-2,), events=[maxevent])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
/Users/jkitchin/anaconda/lib/python3.6/site-packages/scipy/integrate/_ivp/rk.py:145: RuntimeWarning: divide by zero encountered in double_scalars
  max(1, SAFETY * error_norm ** (-1 / (order + 1))))


&lt;/pre&gt;

&lt;pre class="example"&gt;
 message: 'A termination event occurred.'
    nfev: 20
    njev: 0
     nlu: 0
     sol: None
  status: 1
 success: True
       t: array([ 0.        ,  0.08706376,  0.95770136,  2.        ])
t_events: [array([ 2.])]
       y: array([[-2.        , -1.65932506,  0.91361355,  2.        ]])

&lt;/pre&gt;

&lt;p&gt;
Internet: am I missing something obvious here?
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/09/04/A-new-ode-integrator-function-in-scipy.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Getting geo-tagged information from photos for blogging</title>
      <link>http://jkitchin.github.io/blog/2018/07/01/Getting-geo-tagged-information-from-photos-for-blogging</link>
      <pubDate>Sun, 01 Jul 2018 19:17:18 EDT</pubDate>
      <category><![CDATA[geotag]]></category>
      <category><![CDATA[orgmode]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">To7Oj9cQgVbpXvdso0vW9uTFc2o=</guid>
      <description>Getting geo-tagged information from photos for blogging</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am kind of late to this game, but recently I turned on location services for the camera on my phone. That means the location of the photo is stored in the photo, and we can use that to create urls to the photo location in a map for example. While traveling, I thought this would be a good application for org-mode to add functionality to documents with photos in them, e.g. to be able to click on them to see where they are from, or to automate creation of html pages with links to maps, etc. In this post I explore some ways to achieve those ideas. What I would like is a custom org link that shows me a thumbnail of the image, and which exports to show the image in an html file with a link to a pin on Google maps.
&lt;/p&gt;

&lt;p&gt;
So, let's dig in. Imagemagick provides an identify command that can extract the information stored in the images. Here we consider just the GPS information. I some pictures on a recent vacation, and one is unimaginatively named IMG_1759.JPG. Let's see where it was taken.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;identify -verbose IMG_1759.JPG | grep GPS
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSAltitude:&lt;/td&gt;
&lt;td class="org-left"&gt;14426/387&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSAltitudeRef:&lt;/td&gt;
&lt;td class="org-left"&gt;0&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSDateStamp:&lt;/td&gt;
&lt;td class="org-left"&gt;2018:06:30&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSDestBearing:&lt;/td&gt;
&lt;td class="org-left"&gt;11767/80&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSDestBearingRef:&lt;/td&gt;
&lt;td class="org-left"&gt;T&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSImgDirection:&lt;/td&gt;
&lt;td class="org-left"&gt;11767/80&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSImgDirectionRef:&lt;/td&gt;
&lt;td class="org-left"&gt;T&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSInfo:&lt;/td&gt;
&lt;td class="org-left"&gt;1632&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLatitude:&lt;/td&gt;
&lt;td class="org-left"&gt;22/1,&lt;/td&gt;
&lt;td class="org-left"&gt;11/1,&lt;/td&gt;
&lt;td class="org-left"&gt;614/100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLatitudeRef:&lt;/td&gt;
&lt;td class="org-left"&gt;N&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLongitude:&lt;/td&gt;
&lt;td class="org-left"&gt;159/1,&lt;/td&gt;
&lt;td class="org-left"&gt;40/1,&lt;/td&gt;
&lt;td class="org-left"&gt;4512/100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSLongitudeRef:&lt;/td&gt;
&lt;td class="org-left"&gt;W&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSSpeed:&lt;/td&gt;
&lt;td class="org-left"&gt;401/100&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSSpeedRef:&lt;/td&gt;
&lt;td class="org-left"&gt;K&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;td class="org-left"&gt;&amp;#xa0;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;exif:GPSTimeStamp:&lt;/td&gt;
&lt;td class="org-left"&gt;3/1,&lt;/td&gt;
&lt;td class="org-left"&gt;44/1,&lt;/td&gt;
&lt;td class="org-left"&gt;3900/100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
The interpretation here is that I took that photo at latitude 22° 11' 6.14" N, and longitude 159° 40' 45.12" W. Evidently I was moving at 4.01 in some unit; I can confirm that I was at least moving, I was on a ship when I took that picture, and it was moving.
&lt;/p&gt;

&lt;p&gt;
According to &lt;a href="http://alvarestech.com/temp/routeconverter/RouteConverter/navigation-formats/src/main/doc/googlemaps/Google_Map_Parameters.htm"&gt;this&lt;/a&gt; you can make a url to a Google maps pin in satellite picture mode that looks like this: &lt;a href="http://maps.google.com/maps?q=22%2011%206.14N,159%2040%2045.12W&amp;amp;t=k"&gt;http://maps.google.com/maps?q=22 11 6.14N,159 40 45.12W&amp;amp;t=k&lt;/a&gt;. It doesn't seem possible to set the zoom in this url (at least setting the zoom doesn't do anything, and I didn't feel like trying all the other variations that are reported to sometimes work). I guess that is ok for now, it adds some suspense that you have to zoom out to see where the image is in some cases.
&lt;/p&gt;

&lt;p&gt;
We need a little function to take an image file and generate that link. We have to do some algebra on the latitude and longitude which are stored as integers with a division operator. I am going to pipe this through an old unix utility called bc mostly because it is simple, and I won't have to parse it much. bc is a little archaic, you have to set the scale first, which tells it how many decimal places to output. The degrees and minutes are integers, so we will have to deal with that later.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;&lt;span style="color: #006FE0;"&gt;echo&lt;/span&gt; &lt;span style="color: #008000;"&gt;"scale=2; 614/100"&lt;/span&gt; | bc
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
6.14

&lt;/pre&gt;

&lt;p&gt;
Here is our function. I filter out the lines with GPS in them into an a-list. Then, I grab out the specific quantities I want and construct the url. There is a little hackery since it appears the degrees and minutes should be integers in the url formulation used here, so I convert them to numbers and then take the floor. The function is a little longer than I thought, but it isn't too bad I guess. It is a little repetitious, but not enough to justify refactoring.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-map-url&lt;/span&gt; (fname)
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((gps-lines (-keep (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (line)
                             (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (s-contains? &lt;span style="color: #008000;"&gt;"GPS"&lt;/span&gt; line) (s-trim line)))
                           (process-lines &lt;span style="color: #008000;"&gt;"identify"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"-verbose"&lt;/span&gt; fname)))
         (gps-alist (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s) (s-split &lt;span style="color: #008000;"&gt;": "&lt;/span&gt; s t))  gps-lines))
         (latitude (mapcar
                    (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                      (s-trim (shell-command-to-string
                               (format &lt;span style="color: #008000;"&gt;"echo \"scale=2;%s\" | bc"&lt;/span&gt; s))))
                    (s-split &lt;span style="color: #008000;"&gt;","&lt;/span&gt; (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLatitude"&lt;/span&gt; gps-alist)))))
         (latitude-ref (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLatitudeRef"&lt;/span&gt; gps-alist)))
         (longitude (mapcar
                     (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                       (s-trim
                        (shell-command-to-string
                         (format &lt;span style="color: #008000;"&gt;"echo \"scale=2;%s\" | bc"&lt;/span&gt; s))))
                     (s-split &lt;span style="color: #008000;"&gt;","&lt;/span&gt; (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLongitude"&lt;/span&gt; gps-alist)))))
         (longitude-ref (cadr (assoc &lt;span style="color: #008000;"&gt;"exif:GPSLongitudeRef"&lt;/span&gt; gps-alist))))
    (s-format &lt;span style="color: #008000;"&gt;"http://maps.google.com/maps?q=$0 $1 $2$3,$4 $5 $6$7&amp;amp;t=k"&lt;/span&gt;
              'elt
              (list
               (floor (string-to-number (nth 0 latitude)))
               (floor (string-to-number (nth 1 latitude)))
               (nth 2 latitude)
               latitude-ref
               (floor (string-to-number (nth 0 longitude)))
               (floor (string-to-number (nth 1 longitude)))
               (nth 2 longitude)
               longitude-ref))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
iphoto-map-url

&lt;/pre&gt;

&lt;p&gt;
Here is the function in action, making the url.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(iphoto-map-url &lt;span style="color: #008000;"&gt;"IMG_1759.JPG"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
http://maps.google.com/maps?q=22 11 6.14N,159 40 45.12W&amp;amp;t=k

&lt;/pre&gt;

&lt;p&gt;
It is kind of slow, but that is because the identify shell command is kind of slow when you run it with the -verbose tag. Now, I would like the following things to happen when I publish it to html:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;I want the image wrapped in an img tag inside a figure environment.&lt;/li&gt;
&lt;li&gt;I want the image to by hyperlinked to its location in Google maps.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
In the org file, I want a thumbnail overlay on it, so I can see the image while writing, and I want it to toggle like other images. I use an iPhone to take the photos, so we will call it an iphoto link.
&lt;/p&gt;

&lt;p&gt;
Here is the html export function I will use. It is a little hacky that I hard code the width in at 300 pixels, but I didn't feel like figuring out how to get it from an #+attr_html line right now. It probably requires a filter function where you have access to the actual org-elements. I put the url to the image location in a figure caption here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-export&lt;/span&gt; (path desc backend)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq 'html backend)
    (format &lt;span style="color: #008000;"&gt;"&amp;lt;figure&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000;"&gt;&amp;lt;img src=\"%s\" width=\"300\"&amp;gt;&lt;/span&gt;
&lt;span style="color: #008000;"&gt;%s&lt;/span&gt;
&lt;span style="color: #008000;"&gt;&amp;lt;/figure&amp;gt;"&lt;/span&gt;
            path
            (format &lt;span style="color: #008000;"&gt;"&amp;lt;figcaption&amp;gt;%s &amp;lt;a href=\"%s\"&amp;gt;map&amp;lt;/a&amp;gt;&amp;lt;/figcaption&amp;gt;"&lt;/span&gt;
                    (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; desc &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                    (iphoto-map-url path))))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
iphoto-export

&lt;/pre&gt;

&lt;p&gt;
Ok, the last detail I want is to put an image overlay on my new link so I can see it. I want this to work with org-toggle-inline-images so I can turn the images on and off like regular image links with C-c C-x C-v. This function creates overlays as needed, and ties into the org-inline-image-overlays so they get deleted on toggling. We have to advise the display function to redraw these, which we clumsily do by restarting the org font-lock machinery which will redraw the thumbnails from the activate-func property of the links. I also hard code the thumbnail width in this function, when it could be moved out to a variable or attribute.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-thumbnails&lt;/span&gt; (start end imgfile bracketp)
  (&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; bracketp
    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;and&lt;/span&gt;
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;it is an image&lt;/span&gt;
           (org-string-match-p (image-file-name-regexp) imgfile)
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and it exists&lt;/span&gt;
           (f-exists? imgfile)
           &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;and there is no overlay here.&lt;/span&gt;
           (not (ov-at start)))
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; img (create-image (expand-file-name imgfile)
                              'imagemagick nil &lt;span style="color: #006FE0;"&gt;:width&lt;/span&gt; 300
                              &lt;span style="color: #006FE0;"&gt;:background&lt;/span&gt; &lt;span style="color: #008000;"&gt;"lightgray"&lt;/span&gt;))
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ov (make-overlay start end))
      (overlay-put ov 'display img)
      (overlay-put ov 'face 'default)
      (overlay-put ov 'org-image-overlay t)
      (overlay-put ov 'modification-hooks
                   (list
                    `(&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
                       (org-display-inline-remove-overlay ,ov t ,start ,end))))
      (&lt;span style="color: #0000FF;"&gt;push&lt;/span&gt; ov org-inline-image-overlays))))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;iphoto-redraw-thumbnails&lt;/span&gt; (&lt;span style="color: #6434A3;"&gt;&amp;amp;rest&lt;/span&gt; args)
  (org-restart-font-lock))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this redisplays these thumbnails on image toggling&lt;/span&gt;
(advice-add 'org-display-inline-images &lt;span style="color: #006FE0;"&gt;:after&lt;/span&gt; 'iphoto-redraw-thumbnails)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next, we define the link with a follow, export, tooltip and activate-func (which puts the overlay on).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-link-set-parameters
 &lt;span style="color: #008000;"&gt;"iphoto"&lt;/span&gt;
 &lt;span style="color: #006FE0;"&gt;:follow&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (path) (browse-url (iphoto-map-url path)))
 &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'iphoto-export
 &lt;span style="color: #006FE0;"&gt;:help-echo&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Click me to see where this photo is on a map."&lt;/span&gt;
 &lt;span style="color: #006FE0;"&gt;:activate-func&lt;/span&gt; 'iphoto-thumbnails)
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
So finally, here is the mysterious image.
&lt;/p&gt;


&lt;p&gt;
&lt;figure&gt;
&lt;img src="/media/IMG_1759.JPG" width="300"&gt;
&lt;figcaption&gt; &lt;a href="http://maps.google.com/maps?q=22 11 6.14N,159 40 45.12W&amp;t=k"&gt;map&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;


&lt;p&gt;
Now, in org-mode, I see the image in an overlay, and I can toggle it on and off. If I click on the image, it opens a browser to Google maps with a pin at the spot I took it. When I export it, it wraps the image in a &amp;lt;figure&amp;gt; tag, and puts a url in the caption to the map. If you click on it, and zoom out, you will see this is a picture of the Nāpali Coast on Kauai in Hawaii, and I was in fact out at sea when I took the picture. It was spectacular. Here is another one. This one is a little more obvious with the zoom. Here, I was on land. Since this link is bracketed, it does not show the overlay however in the org-file.
&lt;/p&gt;

&lt;p&gt;
&lt;figure&gt;
&lt;img src="/media/IMG_1749.JPG" width="300"&gt;
&lt;figcaption&gt;Another vacation picture, this time with a caption. &lt;a href="http://maps.google.com/maps?q=21 57 37.01N,159 21 6.72W&amp;t=k"&gt;map&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
Overall, this was easier than I expected. It might be faster to outsource reading the exif data to some dedicate library, perhaps in python that would return everything you want in an easy to parse json data structure. The speed of computing the url is only annoying when you export or click on the links though.
&lt;/p&gt;

&lt;p&gt;
I didn't build in any error handling, e.g. if you do this on a photo with no GPS data it will probably not handle it gracefully. I also haven't tested this on any other images, e.g. south of the equator, from other cameras, etc. I assume this exif data is pretty standard, but it is a wild world out there&amp;#x2026; It would still be nice to find a way to get a string representing the nearest known location somehow, that would help the caption be more useful.
&lt;/p&gt;

&lt;p&gt;
There is one little footnote to speak of, and that is I had to do a little hackery to get this to work with my blog machinery. You can see what it is in the org-source, I buried it in a noexport subheading, because it isn't that interesting in the grand scheme of things. It was just necessary because I export these org-files to blogofile, which then builds the html pages, instead of just exporting them. The images have to be copied to a source directory, and paths changed in the html to point to them. See, boring stuff. Otherwise, the code above should be fine for regular org and html files! Now, my vacation is over so it is time to get back to work.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/07/01/Getting-geo-tagged-information-from-photos-for-blogging.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Literate programming with python doctests</title>
      <link>http://jkitchin.github.io/blog/2018/05/17/Literate-programming-with-python-doctests</link>
      <pubDate>Thu, 17 May 2018 16:41:19 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[orgmode]]></category>
      <category><![CDATA[noweb]]></category>
      <guid isPermaLink="false">LOCS3-CpseSjnbubGeO3Zmhf9Rc=</guid>
      <description>Literate programming with python doctests</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org91f890f"&gt;1. Add a way to run the tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org4759a84"&gt;2. Tangle the file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org8727607"&gt;3. Run the tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org5a82a2f"&gt;4. The noweb doctest block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
On the org-mode mailing list we had a nice discussion about using noweb and org-mode in literate programming. The results of that discussion were blogged about &lt;a href="http://kdr2.com/tech/emacs/1805-approach-org-ref-code-to-text.html"&gt;here&lt;/a&gt;. I thought of a different application of this for making &lt;a href="https://pymotw.com/3/doctest/"&gt;doctests&lt;/a&gt; in Python functions. I have to confess I have never liked these because I have always thought they were a pain to write since you basically have to put code and results into a docstring. The ideas developed in the discussion above led me to think of a new way to write these that seems totally reasonable.
&lt;/p&gt;

&lt;p&gt;
The idea is just to put noweb placeholders in the function docstring for the doctests. The placeholders will be expanded when you tangle the file, and they will get their contents from other src-blocks where you have written and run examples to test them.
&lt;/p&gt;

&lt;p&gt;
This video might make the rest of this post easier to follow:
&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/u8CWbedVV9Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen&gt;&lt;/iframe&gt;

&lt;p&gt;
I will illustrate the idea using org-mode and the ob-ipython I have in scimax. The defaults of my ob-ipython setup are not useful for this example because it puts the execution count and mime types of output in the output. These are not observed in a REPL, and so we turn this off by setting these variables.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; ob-ipython-suppress-execution-count t
      ob-ipython-show-mime-types nil)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we make an example function that takes a single argument and returns one divided by that argument. This block is runnable, and the function is then defined in the jupyter kernel. The docstring contains several noweb references to doctest blocks we define later. For now, they don't do anything. See &lt;a href="#org5a82a2f"&gt;The noweb doctest block&lt;/a&gt; section for the block that is used to expand these. This block also has a tangle header which indicates the file to tangle the results to. When I run this block, it is sent to a Jupyter kernel and saved in memory for use in subsequent blocks.
&lt;/p&gt;

&lt;p&gt;
Here is the block with no noweb expansion. Note that this is easier to read in the original org source than it is to read in the published blog format.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;func&lt;/span&gt;(a):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"""A function to divide one by a.&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   &amp;lt;&amp;lt;doctest("doctest-1")&amp;gt;&amp;gt;&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   &amp;lt;&amp;lt;doctest("doctest-2")&amp;gt;&amp;gt;&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   &amp;lt;&amp;lt;doctest("doctest-3")&amp;gt;&amp;gt;&lt;/span&gt;

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   Returns: 1 / a.&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;&lt;span style="color: #036A07;"&gt;   """&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 1 / a

&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we can write a series of named blocks that define various tests we might want to use as doctests. You can run these blocks here, and verify they are correct. Later, when we tangle the document, these will be incorporated into the tangled file in the docstring we defined above.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org4eaeeaf"&gt;func(5) == 0.2
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
True

&lt;/pre&gt;



&lt;p&gt;
This next test will raise an Exception, and we just run it to make sure it does.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org560fcaf"&gt;func(0)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

ZeroDivisionErrorTraceback (most recent call last)
&amp;lt;ipython-input-6-ba0cd5a88f0a&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 func(0)

&amp;lt;ipython-input-1-eafd354a3163&amp;gt; in func(a)
     18     Returns: 1 / a.
     19     """
---&amp;gt; 20     return 1 / a

ZeroDivisionError: division by zero

&lt;/pre&gt;



&lt;p&gt;
This is just a doctest with indentation to show how it is used.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython" id="org968debf"&gt;&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; i &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(1, 4):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(func(i))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
1.0
0.5
0.3333333333333333


&lt;/pre&gt;



&lt;p&gt;
That concludes the examples I want incorporated into the doctests. Each one of these blocks has a name, which is used as an argument to the noweb references in the function docstring.
&lt;/p&gt;

&lt;div id="outline-container-org91f890f" class="outline-2"&gt;
&lt;h2 id="org91f890f"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Add a way to run the tests&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
This is a common idiom to enable easy running of the doctests. This will get tangled out to the file.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;__name__&lt;/span&gt; == &lt;span style="color: #008000;"&gt;"__main__"&lt;/span&gt;:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; doctest
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   doctest.testmod()
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org4759a84" class="outline-2"&gt;
&lt;h2 id="org4759a84"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Tangle the file&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
So far, the Python code we have written only exists in the org-file, and in memory. Tangling is the extraction of the code into a code file.
&lt;/p&gt;

&lt;p&gt;
We run this command, which extracts the code blocks marked for tangling, and expands the noweb references in them.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-babel-tangle)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;test.py&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here is what we get:
&lt;/p&gt;

&lt;pre class="example"&gt;
def func(a):
    """A function to divide one by a.

    &amp;gt;&amp;gt;&amp;gt; func(5) == 0.2
    True

    &amp;gt;&amp;gt;&amp;gt; func(0)
    Traceback (most recent call last):
    ZeroDivisionError: division by zero

    &amp;gt;&amp;gt;&amp;gt; for i in range(1, 4):
    ...     print(func(i))
    1.0
    0.5
    0.3333333333333333


    Returns: 1 / a.
    """
    return 1 / a

if __name__ == "__main__":
    import doctest
    doctest.testmod()

&lt;/pre&gt;

&lt;p&gt;
That looks like a reasonable python file. You can see the doctest blocks have been inserted into the docstring, as desired. The proof of course is that we can run these doctests, and use the python module. We show that next.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org8727607" class="outline-2"&gt;
&lt;h2 id="org8727607"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Run the tests&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Now, we can check if the tests pass in a fresh run (i.e. not using the version stored in the jupyter kernel.) The standard way to run the doctests is like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;python test.py -v
&lt;/pre&gt;
&lt;/div&gt;




&lt;p&gt;
Well, that's it! It worked fine. Now we have a python file we can import and reuse, with some doctests that show how it works. For example, here it is in a small Python script.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; test &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; func
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(func(3))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0.3333333333333333

&lt;/pre&gt;



&lt;p&gt;
There are surely some caveats to keep in mind here. This was just a simple proof of concept idea that isn't tested beyond this example. I don't know how many complexities would arise from more complex doctests. But, it seems like a good idea to continue pursuing if you like using doctests, and like using org-mode and interactive/literate programming techniques.
&lt;/p&gt;

&lt;p&gt;
It is definitely an interesting way to use noweb to build up better code files in my opinion.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5a82a2f" class="outline-2"&gt;
&lt;h2 id="org5a82a2f"&gt;&lt;a id="ID-D4437A03-A9D0-4B6D-B254-5F03CFB25F95"&gt;&lt;/a&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; The noweb doctest block&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
These blocks are used in the noweb expansions. Each block takes a variable which is the name of a block. This block grabs the body of the named src block and formats it as if it was in a REPL.
&lt;/p&gt;

&lt;p&gt;
We also grab the results of the named block and format it for the doctest. We use a heuristic to detect Tracebacks and modify the output to be consistent with it. In that case we assume the relevant Traceback is on the last line.
&lt;/p&gt;

&lt;p&gt;
Admittedly, this does some fragile feeling things, like trimming whitespace here and there to remove blank lines, and quoting quotes (which was not actually used in this example), and removing the ": " pieces of ob-ipython results. Probably other ways of running the src-blocks would not be that suitable for this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org52486c2"&gt;(org-babel-goto-named-src-block name)
(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((src (s-trim-right (org-element-property &lt;span style="color: #006FE0;"&gt;:value&lt;/span&gt; (org-element-context))))
       (src-lines (split-string src &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;))
       body result)
  (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; body
        (s-trim-right
         (s-concat &lt;span style="color: #008000;"&gt;"&amp;gt;&amp;gt;&amp;gt; "&lt;/span&gt; (car src-lines) &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;
                   (s-join &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; (mapcar (&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; (s)
                                          (concat &lt;span style="color: #008000;"&gt;"... "&lt;/span&gt; s))
                                        (cdr src-lines))))))
  &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;now the results&lt;/span&gt;
  (org-babel-goto-named-result name)
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((result (org-element-context)))
    (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; result
          (&lt;span style="color: #0000FF;"&gt;thread-last&lt;/span&gt;
              (buffer-substring (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-begin&lt;/span&gt; result)
                                (org-element-property &lt;span style="color: #006FE0;"&gt;:contents-end&lt;/span&gt; result))
            (s-trim)
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;remove ": " from beginning of lines&lt;/span&gt;
            (replace-regexp-in-string &lt;span style="color: #008000;"&gt;"^: *"&lt;/span&gt; &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
            &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;quote quotes&lt;/span&gt;
            (replace-regexp-in-string &lt;span style="color: #008000;"&gt;"\\\""&lt;/span&gt; &lt;span style="color: #008000;"&gt;"\\\\\""&lt;/span&gt;)))
    (&lt;span style="color: #0000FF;"&gt;when&lt;/span&gt; (string-match &lt;span style="color: #008000;"&gt;"Traceback"&lt;/span&gt; result)
      (&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; result (format
                    &lt;span style="color: #008000;"&gt;"Traceback (most recent call last):\n%s"&lt;/span&gt;
                    (car (last (split-string result &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt;))))))
    (concat body &lt;span style="color: #008000;"&gt;"\n"&lt;/span&gt; result)))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/17/Literate-programming-with-python-doctests.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>f-strings in emacs-lisp</title>
      <link>http://jkitchin.github.io/blog/2018/05/14/f-strings-in-emacs-lisp</link>
      <pubDate>Mon, 14 May 2018 17:27:42 EDT</pubDate>
      <category><![CDATA[elisp]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">fy7uCq1luP3IH-u2u_WegS14a4Q=</guid>
      <description>f-strings in emacs-lisp</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am a big fan of f-strings in Python 3. They let you put variable names and expressions in a string template that get expanded to create new strings. Here is a simple example of using those:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;username&lt;/span&gt; = &lt;span style="color: #008000;"&gt;'John Kitchin'&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;somevar&lt;/span&gt; = 5**0.5
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{username:30s}{somevar:1.2f}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24


&lt;/pre&gt;

&lt;p&gt;
String formatting in emacs-lisp is by comparison not as fun and easy. Out of the box we have:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (format &lt;span style="color: #008000;"&gt;"%-30s%1.2f"&lt;/span&gt; username somevar))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24

&lt;/pre&gt;

&lt;p&gt;
That is still three lines of code, but it is ugly and hard to read like the old python code:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'%-30s%1.2f'&lt;/span&gt; % (username, somevar))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24


&lt;/pre&gt;


&lt;p&gt;
My experience has shown that this gets harder to figure out as the strings get larger, and f-strings are easier to read.
&lt;/p&gt;

&lt;p&gt;
The wonderful &lt;a href="https://github.com/magnars/s.el"&gt;'s&lt;/a&gt; library provides some salvation for emacs-lisp, if you don't want the format fields. You can refer to variables in a lexical environment like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (&lt;span style="color: #0000FF;"&gt;s-lex-format&lt;/span&gt; &lt;span style="color: #008000;"&gt;"${username}${somevar}"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin2.23606797749979

&lt;/pre&gt;

&lt;p&gt;
Today, I decided to do something about this, and wrote this little macro. It is a variation on s-lex-format that introduces a slightly new syntax. You can now add an optional format field separated from the variable name by a space.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defmacro&lt;/span&gt; &lt;span style="color: #006699;"&gt;f-string&lt;/span&gt; (fmt)
  &lt;span style="color: #036A07;"&gt;"Like `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;s-format&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' but with format fields in it.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;FMT is a string to be expanded against the current lexical&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;environment. It is like what is used in `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;s-lex-format&lt;/span&gt;&lt;span style="color: #036A07;"&gt;', but has&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;an expanded syntax to allow format-strings. For example:&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;${user-full-name 20s} will be expanded to the current value of&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;the variable `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;user-full-name&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' in a field 20 characters wide.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  (let ((f (sqrt 5)))  (f-string \"${f 1.2f}\"))&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;  will render as: 2.24&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;This function is inspired by the f-strings in Python 3.6, which I&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;enjoy using a lot.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;"&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((matches (s-match-strings-all&lt;span style="color: #008000;"&gt;"${&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?3:&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?1:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt;} ]+&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt; *&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;(?2:&lt;/span&gt;&lt;span style="color: #008000;"&gt;[&lt;/span&gt;&lt;span style="color: #008000;"&gt;^&lt;/span&gt;&lt;span style="color: #008000;"&gt;}]*&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;\\&lt;/span&gt;&lt;span style="color: #008000; font-weight: bold;"&gt;)&lt;/span&gt;&lt;span style="color: #008000;"&gt;}"&lt;/span&gt; fmt))
         (agetter (&lt;span style="color: #0000FF;"&gt;cl-loop&lt;/span&gt; for (m0 m1 m2 m3) in matches
                        collect `(cons ,m3  (format (format &lt;span style="color: #008000;"&gt;"%%%s"&lt;/span&gt; (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (string= ,m2 &lt;span style="color: #008000;"&gt;""&lt;/span&gt;)
                                                                      (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; s-lex-value-as-lisp &lt;span style="color: #008000;"&gt;"S"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"s"&lt;/span&gt;)
                                                                   ,m2))
                                                  (symbol-value (intern ,m1)))))))

    `&lt;span style="color: #D0372D;"&gt;(s-format ,fmt &lt;/span&gt;'aget (list ,@agetter))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
f-string

&lt;/pre&gt;

&lt;p&gt;
Here it is in action.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((username &lt;span style="color: #008000;"&gt;"John Kitchin"&lt;/span&gt;)
      (somevar (sqrt 5)))
  (&lt;span style="color: #0000FF;"&gt;f-string&lt;/span&gt; &lt;span style="color: #008000;"&gt;"${username -30s}${somevar 1.2f}"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
John Kitchin                  2.24

&lt;/pre&gt;

&lt;p&gt;
It still lacks some of the capability of f-strings in python, e.g. in Python, arguments inside the template to be expanded get evaluated. The solution used above is too simple for that, since it just used a regexp and is limited to the value of variables in the lexical environment.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{5**0.5:1.3f}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
2.236


&lt;/pre&gt;

&lt;p&gt;
Nevertheless, this simple solution matches what I do most of the time anyway, so I still consider it an improvement!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/14/f-strings-in-emacs-lisp.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Making it easier to extend the export of org-mode links with generic functions</title>
      <link>http://jkitchin.github.io/blog/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions</link>
      <pubDate>Wed, 09 May 2018 19:49:14 EDT</pubDate>
      <category><![CDATA[orgmode]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">6zitH1v5O3fSqcDJ8SfMByrxF7Q=</guid>
      <description>Making it easier to extend the export of org-mode links with generic functions</description>
      <content:encoded><![CDATA[


&lt;p&gt;
I am a big fan of org-mode links. Lately, I have had a need to modify how some links are exported, e.g. defining new exports for different backends, or fine-tuning a particular backend. This can be difficult, depending on how the link was set up. Here is a typical setup I am used to using, where the different options for the backends are handled in a conditional statement in a single function. I will just use a link that just serves to illustrate the issues here. These links are just sytactic sugar for markup, they don't do anything else. We start with an example that just converts text to italic text for different backends like html or latex.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-export&lt;/span&gt; (path desc backend)
  (&lt;span style="color: #0000FF;"&gt;cond&lt;/span&gt;
   ((eq 'html backend)
    (format &lt;span style="color: #008000;"&gt;"&amp;lt;em&amp;gt;%s&amp;lt;/em&amp;gt;"&lt;/span&gt; path))
   ((eq 'latex backend)
    (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))
   &lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;fall-through case for everything else&lt;/span&gt;
   (t
    path)))

(org-link-set-parameters &lt;span style="color: #008000;"&gt;"italic"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'italic-link-export)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;:export&lt;/td&gt;
&lt;td class="org-left"&gt;italic-link-export&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'html t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;p&amp;gt;
&amp;lt;em&amp;gt;text&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'latex t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
\textit{text}

&lt;/pre&gt;

&lt;p&gt;
This falls through though to the default case.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ox-md&lt;/span&gt;)
(org-export-string-as &lt;span style="color: #008000;"&gt;"italic:text"&lt;/span&gt; 'md t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

# Table of Contents



text


&lt;/pre&gt;

&lt;p&gt;
The point I want to make here is that this is not easy to extend as a user. You have to either modify the italic-link-export function, advise it, or monkey-patch it. None of these are especially nice.
&lt;/p&gt;

&lt;p&gt;
I could define italic-link-export in a way that it retrieves the function to use from an alist or hash-table using the backend, but then you have to do two things to modify the behavior: define a backend specific function &lt;i&gt;and&lt;/i&gt; register it in the lookup variable. It is also possible to just look up a function by a derived symbol, e.g. using fboundp, and then using funcall to execute it. This looks something like this:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;a user definable function for exporting to latex&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-export-latex&lt;/span&gt; (path desc backend)
  (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;generic export function that looks up functions or defaults to&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;italic-link-exporter&lt;/span&gt; (path desc backend)
  &lt;span style="color: #036A07;"&gt;"Run `&lt;/span&gt;&lt;span style="color: #D0372D;"&gt;italic-link-export-BACKEND&lt;/span&gt;&lt;span style="color: #036A07;"&gt;' if it exists, or return path."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((func (intern-soft (format &lt;span style="color: #008000;"&gt;"italic-link-export-%s"&lt;/span&gt; backend))))
    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (fboundp func)
        (funcall func path desc backend)
      path)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This has some indirection, but allows you to just define new functions to add new export backends, or replace single backend exports. It isn't bad, but there is room for improvement.
&lt;/p&gt;

&lt;p&gt;
In this &lt;a href="https://github.com/jkitchin/org-ref/issues/492#issuecomment-387806180"&gt;comment&lt;/a&gt; in org-ref, I saw a new opportunity to address this issue using generic functions in elisp! The idea is to define a generic function that handles the general export case, and then define additional functions for each specific backend based on the signature of the export function. I will switch to bold markup for this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;cl-defgeneric&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; (path desc backend)
 &lt;span style="color: #036A07;"&gt;"Generic function to export a bold link."&lt;/span&gt;
 path)

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this one runs when the backend is equal to html&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; ((path t) (desc t) (backend (eql html)))
 (format &lt;span style="color: #008000;"&gt;"&amp;lt;b&amp;gt;%s&amp;lt;/b&amp;gt;"&lt;/span&gt; path))

&lt;span style="color: #8D8D84;"&gt;;; &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;this one runs when the backend is equal to latex&lt;/span&gt;
(&lt;span style="color: #0000FF;"&gt;cl-defmethod&lt;/span&gt; &lt;span style="color: #006699;"&gt;bold-link-export&lt;/span&gt; ((path t) (desc t) (backend (eql latex)))
 (format &lt;span style="color: #008000;"&gt;"\\textit{%s}"&lt;/span&gt; path))

(org-link-set-parameters &lt;span style="color: #008000;"&gt;"bold"&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;:export&lt;/span&gt; 'bold-link-export)
&lt;/pre&gt;
&lt;/div&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-left" /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;:export&lt;/td&gt;
&lt;td class="org-left"&gt;bold-link-export&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
Here it is in action:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'html t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;p&amp;gt;
some &amp;lt;b&amp;gt;text&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'latex t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
This uses the generic function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;ox-md&lt;/span&gt;)
(org-export-string-as &lt;span style="color: #008000;"&gt;"some bold:text"&lt;/span&gt; 'md t)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;

# Table of Contents



some text


&lt;/pre&gt;

&lt;p&gt;
The syntax for defining the generic function is pretty similar to a regular function. The specific methods are a little different since they have to provide the specific "signature" that triggers each method. Here we only differentiate on the type of the backend. It is nice these are all separate functions though. It makes it trivial to add new ones, and less intrusive to replace in my opinion.
&lt;/p&gt;

&lt;p&gt;
Generic functions have many other potential applications to replace functions that use lots of conditions to control flow, with a fall-through option at the end. You can learn more about them here: &lt;a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html"&gt;https://www.gnu.org/software/emacs/manual/html_node/elisp/Generic-Functions.html&lt;/a&gt;. There is a lot more to them than I have illustrated here.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/05/09/Making-it-easier-to-extend-the-export-of-org-mode-links-with-generic-functions.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>New publication in Nature Catalysis</title>
      <link>http://jkitchin.github.io/blog/2018/04/16/New-publication-in-Nature-Catalysis</link>
      <pubDate>Mon, 16 Apr 2018 12:53:52 EDT</pubDate>
      <category><![CDATA[news]]></category>
      <category><![CDATA[publication]]></category>
      <guid isPermaLink="false">viY5_PFkfHLMmQvwdFnK2BAPlWs=</guid>
      <description>New publication in Nature Catalysis</description>
      <content:encoded><![CDATA[


&lt;p&gt;
Machine learning (ML) is impacting many fields, including catalysis. In this comment, I briefly discuss the major directions that ML is influencing the field of catalysis, along with some outlook on future directions. There were strict word and reference limits, so apologies in advance if I left out your work!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;kitchin-2018-machin-learn-catal&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {John R. Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Machine Learning in Catalysis},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {Nature Catalysis},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       1,
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       4,
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        {230-232},
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2018,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1038/s41929-018-0056-y&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1038/s41929-018-0056-y&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;DATE_ADDED&lt;/span&gt; =   {Mon Apr 16 12:50:43 2018},
}
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
You can see a read-only version of the paper here: &lt;a href="https://rdcu.be/LGrM"&gt;https://rdcu.be/LGrM&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1038/s41929-018-0056-y'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/04/16/New-publication-in-Nature-Catalysis.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Caching searches using biblio and only seeing new results</title>
      <link>http://jkitchin.github.io/blog/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results</link>
      <pubDate>Wed, 11 Apr 2018 20:46:56 EDT</pubDate>
      <category><![CDATA[biblio]]></category>
      <category><![CDATA[arxiv]]></category>
      <category><![CDATA[elisp]]></category>
      <guid isPermaLink="false">KOPSYg1aBm18lX8lJYHeRtMOL74=</guid>
      <description>Caching searches using biblio and only seeing new results</description>
      <content:encoded><![CDATA[


&lt;p&gt;
In this &lt;a href="https://github.com/jkitchin/scimax/issues/196"&gt;issue&lt;/a&gt; in scimax, Robert asked if it was possible to save searches, and then to repeat them every so often and only see the new results. This needs some persistent caching of the records, and a comparison of the current search results with the previous search results.
&lt;/p&gt;

&lt;p&gt;
&lt;a href="https://github.com/cpitclaudel/biblio.el"&gt;biblio&lt;/a&gt; provides a nice interface to searching a range of resources for bibliographic references. In this post, I will focus on arxiv. Out of the box, biblio does not seem to support this use case, but as you will see, it has many of the pieces required to achieve it. Let's start picking those pieces apart.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;biblio&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
biblio

&lt;/pre&gt;

&lt;p&gt;
Here is the first piece we need: a way to run a query, and get results back as a data structure. Here we just look at the first result.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((query &lt;span style="color: #008000;"&gt;"alloy segregration"&lt;/span&gt;)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; cb
                  (funcall backend 'parse-buffer))))
  (car results))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;((doi . &lt;span style="color: #008000;"&gt;"10.1103/PhysRevB.76.014112"&lt;/span&gt;)
 (identifier . &lt;span style="color: #008000;"&gt;"0704.2752v2"&lt;/span&gt;)
 (year . &lt;span style="color: #008000;"&gt;"2007"&lt;/span&gt;)
 (title . &lt;span style="color: #008000;"&gt;"Modelling Thickness-Dependence of Ferroelectric Thin Film Properties"&lt;/span&gt;)
 (authors nil nil nil nil nil nil nil nil nil nil nil nil nil &lt;span style="color: #008000;"&gt;"L. Palova"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;"P. Chandra"&lt;/span&gt; nil &lt;span style="color: #008000;"&gt;"K. M. Rabe"&lt;/span&gt; nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)
 (container . &lt;span style="color: #008000;"&gt;"PRB 76, 014112 (2007)"&lt;/span&gt;)
 (category . &lt;span style="color: #008000;"&gt;"cond-mat.mtrl-sci"&lt;/span&gt;)
 (references &lt;span style="color: #008000;"&gt;"10.1103/PhysRevB.76.014112"&lt;/span&gt; &lt;span style="color: #008000;"&gt;"0704.2752v2"&lt;/span&gt;)
 (type . &lt;span style="color: #008000;"&gt;"eprint"&lt;/span&gt;)
 (url . &lt;span style="color: #008000;"&gt;"https://doi.org/10.1103/PhysRevB.76.014112"&lt;/span&gt;)
 (direct-url . &lt;span style="color: #008000;"&gt;"http://arxiv.org/pdf/0704.2752v2"&lt;/span&gt;))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Next, we need a database to store the results in. I will just use a flat file database with a file for each record. The filename will be the md5 hash of the doi or the record itself. Why is that a good idea? Well, the doi is a constant, so if it exists the md5 will also be a constant. The doi itself is not a good filename in general, but the md5 is. The md5 of the record itself will be fragile to any changes, so if it has a doi, we should use it. If it doesn't and later gets one, we should see it again since that could mean it has been published. Also, if it changes because of some new version we might want to see it again. In any case, the existence of that file will be evidence we have seen that record before, and will indicate we need to remove it from the current view.
&lt;/p&gt;

&lt;p&gt;
The flat file database is not super inspired. It is modeled a little after elfeed, but other solutions might work better for large sets of records, but this approach will work fine for this post.
&lt;/p&gt;

&lt;p&gt;
Here is a function that returns nil if the record has been seen, and if not, saves the record and returns it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defvar&lt;/span&gt; &lt;span style="color: #BA36A5;"&gt;db-dir&lt;/span&gt; &lt;span style="color: #008000;"&gt;"~/.arxiv-db/"&lt;/span&gt;)

(&lt;span style="color: #0000FF;"&gt;unless&lt;/span&gt; (f-dir? db-dir) (make-directory db-dir t))

(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;unseen-record-p&lt;/span&gt; (record)
  &lt;span style="color: #036A07;"&gt;"Given a RECORD return it if it is unseen.&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;Also, save the record so next time it will be marked seen. A&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;record is seen if we have seen the DOI or the record as a string&lt;/span&gt;
&lt;span style="color: #036A07;"&gt;before."&lt;/span&gt;
  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((doi (cdr (assoc 'doi record)))
         (contents (&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
                     (prin1 record (current-buffer))
                     (buffer-string)))
         (hash (md5 (&lt;span style="color: #0000FF;"&gt;or&lt;/span&gt; doi contents)))
         (fname (expand-file-name hash db-dir)))

    (&lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; (f-exists? fname)
        nil
      (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; fname
        (insert contents))
      record)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
unseen-record-p

&lt;/pre&gt;

&lt;p&gt;
Now we can use that as a filter that saves records by side effect.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;defun&lt;/span&gt; &lt;span style="color: #006699;"&gt;scimax-arxiv&lt;/span&gt; (query)
  (&lt;span style="color: #0000FF;"&gt;interactive&lt;/span&gt; &lt;span style="color: #008000;"&gt;"Query: "&lt;/span&gt;)

  (&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((backend 'biblio-arxiv-backend)
         (cb (url-retrieve-synchronously (funcall backend 'url query)))
         (results (-filter 'unseen-record-p (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; cb
                                              (funcall backend 'parse-buffer))))
         (results-buffer (biblio--make-results-buffer (current-buffer) query backend)))
    (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; results-buffer
      (biblio-insert-results results &lt;span style="color: #008000;"&gt;""&lt;/span&gt;))
    (pop-to-buffer results-buffer)))

(scimax-arxiv &lt;span style="color: #008000;"&gt;"alloy segregation"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
#&amp;lt;buffer *arXiv search*&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
Now, when I run that once I see something like this:
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-11-04-2018-time-20-19-52.png"&gt;
&lt;/p&gt;


&lt;p&gt;
and if I run it again:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(scimax-arxiv &lt;span style="color: #008000;"&gt;"alloy segregation"&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
#&amp;lt;buffer *arXiv search*&amp;gt;

&lt;/pre&gt;

&lt;p&gt;
Then the buffer is empty, since we have seen all the entries before.
&lt;/p&gt;


&lt;p&gt;
&lt;img src="/media/date-11-04-2018-time-20-20-37.png"&gt;
&lt;/p&gt;

&lt;p&gt;
Here are the files in our database:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;ls ~/.arxiv-db/
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Here are the contents of one of those files:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
 (insert-file-contents &lt;span style="color: #008000;"&gt;"~/.arxiv-db/18085fe2512e15d66addc7dfb71f7cd2"&lt;/span&gt;)
 (read (buffer-string)))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
((doi) (identifier . 1101.3464v3) (year . 2011) (title . Characterizing Solute Segregation and Grain Boundary Energy in a Binary
  Alloy Phase Field Crystal Model) (authors nil nil nil nil nil nil nil nil nil nil nil nil nil Jonathan Stolle nil Nikolas Provatas nil nil nil nil nil nil nil nil nil nil nil) (container) (category . cond-mat.mtrl-sci) (references nil 1101.3464v3) (type . eprint) (url . http://arxiv.org/abs/1101.3464v3) (direct-url . http://arxiv.org/pdf/1101.3464v3))

&lt;/pre&gt;

&lt;p&gt;
So, if you need to read this in again later, no problem.
&lt;/p&gt;

&lt;p&gt;
Now, what could go wrong? I don't know much about how the search results from arxiv are returned. For example, this query returns 10 hits.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;let*&lt;/span&gt; ((query &lt;span style="color: #008000;"&gt;"alloy segregration"&lt;/span&gt;)
       (backend 'biblio-arxiv-backend)
       (cb (url-retrieve-synchronously (funcall backend 'url query)))
       (results (&lt;span style="color: #0000FF;"&gt;with-current-buffer&lt;/span&gt; cb
                  (funcall backend 'parse-buffer))))
  (length results))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
10

&lt;/pre&gt;

&lt;p&gt;
There is just no way there are only 10 hits for this query. So, there must be a bunch more that you get by either changing the requested number in some argument, or by using subsequent queries to get the rest of them. I don't know if there are more advanced query options with biblio, e.g. to find entries newer than the last time it was run. On the advanced search &lt;a href="https://arxiv.org/find"&gt;page&lt;/a&gt; for arxiv, it looks like there is only a by year option.
&lt;/p&gt;

&lt;p&gt;
This is still a good idea, and a lot of the pieces are here,
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/04/11/Caching-searches-using-biblio-and-only-seeing-new-results.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.6&lt;/p&gt;
]]></content:encoded>
    </item>
  </channel>
</rss>
