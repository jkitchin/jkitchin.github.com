<?xml version="1.0" encoding="UTF-8"?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <atom:link href="http://kitchingroup.cheme.cmu.edu/blog/feed/index.xml" rel="self" type="application/rss+xml" />
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Fri, 13 Sep 2019 13:56:21 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    
    <item>
      <title>Sensitivity analysis with odeint and autograd</title>
      <link>http://jkitchin.github.io/blog/2019/09/13/Sensitivity-analysis-with-odeint-and-autograd</link>
      <pubDate>Fri, 13 Sep 2019 09:56:09 EDT</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">a-lpqe22WfbPZV59JCJkZAVvMR0=</guid>
      <description>Sensitivity analysis with odeint and autograd</description>
      <content:encoded><![CDATA[


&lt;p&gt;
In this &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis/"&gt;previous post&lt;/a&gt; I showed a way to do sensitivity analysis of the solution of a differential equation to parameters in the equation using autograd. The basic approach was to write a differentiable integrator, and then use it in a function so that autograd could take the derivative.
&lt;/p&gt;

&lt;p&gt;
Since that time, autograd has added &lt;a href="https://github.com/HIPS/autograd/blob/master/autograd/scipy/integrate.py"&gt;derivative support&lt;/a&gt; for &lt;code&gt;scipy.integrate.odeint&lt;/code&gt;. In this post we examine that. As usual with autograd, we have to import the autograd version of numpy, and the autograd version of odeint. We will find the derivative of the solution to an ODE (which is an array) so we need to also import the jacobian function. Finally, there is a subtle, and non-obvious requirement that we need to import the autograd tuple. That ensures that the variables are differentiable through the tuple we will use for the arguments.
&lt;/p&gt;

&lt;p&gt;
The differential equation we solve returns the concentration of a species as a function of time, and the solution depends on two parameters, i.e. \(C = f(t; k_1, k_{-1})\), and we are interested in the time-dependent sensitivity of \(C\) with respect to those parameters. The approach we use is to define a function that has those parameters as arguments. The function will solve the ODE and return the time-dependent solution. First we make that solution, mostly to see that the autograd version of odeint works.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd.scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; odeint
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; jacobian
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd.builtins &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;tuple&lt;/span&gt;

&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #BA36A5;"&gt;Ca0&lt;/span&gt; = 1.0
&lt;span style="color: #BA36A5;"&gt;k1&lt;/span&gt; = &lt;span style="color: #BA36A5;"&gt;k_1&lt;/span&gt; = 3.0

&lt;span style="color: #BA36A5;"&gt;tspan&lt;/span&gt; = np.linspace(0, 0.5)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;C&lt;/span&gt;(K):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;k1&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;k_1&lt;/span&gt; = K
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dCdt&lt;/span&gt;(Ca, t, k1, k_1):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -k1 * Ca + k_1 * (Ca0 - Ca)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = odeint(dCdt, Ca0, tspan, &lt;span style="color: #006FE0;"&gt;tuple&lt;/span&gt;((k1, k_1)))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; sol

plt.plot(tspan, C([k1, k_1]))
plt.xlim([tspan.&lt;span style="color: #006FE0;"&gt;min&lt;/span&gt;(), tspan.&lt;span style="color: #006FE0;"&gt;max&lt;/span&gt;()])
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
&amp;lt;Figure size 432x288 with 1 Axes&amp;gt;
&lt;/pre&gt;


&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/bca9e95a16f361ce6d92dd6efe90a2e653e014ef.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;


&lt;p&gt;
Now, the solution is an array, and we want the derivative of C with respect to the parameters at each time point. That means we want the jacobian derivative of the output with respect to the input. Here is the autograd approach to doing that. The jacobian function returns a function that we can evaluate to get the derivatives.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; time
&lt;span style="color: #BA36A5;"&gt;t0&lt;/span&gt; = time.time()
&lt;span style="color: #BA36A5;"&gt;dCdk&lt;/span&gt; = jacobian(C, 0)


&lt;span style="color: #BA36A5;"&gt;k_sensitivity&lt;/span&gt; = dCdk(np.array([k1, k_1]))

&lt;span style="color: #BA36A5;"&gt;k1_sensitivity&lt;/span&gt; = k_sensitivity[:, 0, 0]
&lt;span style="color: #BA36A5;"&gt;k_1_sensitivity&lt;/span&gt; = k_sensitivity[:, 0, 1]

plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(k1_sensitivity), label=&lt;span style="color: #008000;"&gt;'dC/dk1'&lt;/span&gt;)
plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(k_1_sensitivity), label=&lt;span style="color: #008000;"&gt;'dC/dk_1'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #008000;"&gt;'best'&lt;/span&gt;)
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'sensitivity'&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'Elapsed time = {time.time() - t0:1.1f} seconds'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Elapsed time = 38.2 seconds
&lt;/p&gt;

&lt;pre class="example"&gt;
&amp;lt;Figure size 432x288 with 1 Axes&amp;gt;
&lt;/pre&gt;


&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/3a0a58bb6d4b3e1b215c2918d511f3a8a3a2ca3d.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
That looks similar to the results from before. It is pretty slow I think, that took more than half a minute to work out. That is still faster and probably more correct than if I had to do it by hand. In contrast, however, the finite difference code below is comparatively very fast! I don't know what is slow in the autograd implementation. I guess it is an implementation detail.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numdifftools &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; nd
&lt;span style="color: #BA36A5;"&gt;t0&lt;/span&gt; = time.time()

&lt;span style="color: #BA36A5;"&gt;fdk1&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;fdk_1&lt;/span&gt; = nd.Jacobian(C)([k1, k_1]).T
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'Elapsed time = {time.time() - t0:1.1f} seconds'&lt;/span&gt;)

plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(fdk1), label=&lt;span style="color: #008000;"&gt;'fd dC/dk1'&lt;/span&gt;)
plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(fdk_1), label=&lt;span style="color: #008000;"&gt;'fd dC/dk_1'&lt;/span&gt;)
plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(k1_sensitivity), &lt;span style="color: #008000;"&gt;'y--'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'dC/dk1'&lt;/span&gt;)
plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(k_1_sensitivity),&lt;span style="color: #008000;"&gt;'m--'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'dC/dk_1'&lt;/span&gt;)
plt.legend(loc=&lt;span style="color: #008000;"&gt;'best'&lt;/span&gt;);
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;);
plt.ylabel(&lt;span style="color: #008000;"&gt;'sensitivity'&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Elapsed time = 0.1 seconds
&lt;/p&gt;

&lt;pre class="example"&gt;
&amp;lt;Figure size 432x288 with 1 Axes&amp;gt;
&lt;/pre&gt;


&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/be7bf4798396d6a27938715f6bb0e22b8f3e0b1c.png"&gt;&lt;/figure&gt; 
&lt;/p&gt;

&lt;p&gt;
You can see the two results are visually indistinguishable. Even the code is pretty similar. I would tend to prefer the autograd way since it should be less sensitive to finite difference artifacts, but it is nice to have an independent way to test if it is working.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2019 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2019/09/13/Sensitivity-analysis-with-odeint-and-autograd.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.2.3&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>New publication in SoftwareX</title>
      <link>http://jkitchin.github.io/blog/2019/07/08/New-publication-in-SoftwareX</link>
      <pubDate>Mon, 08 Jul 2019 07:15:33 EDT</pubDate>
      <category><![CDATA[news]]></category>
      <category><![CDATA[publication]]></category>
      <guid isPermaLink="false">fmIo7oU0ElRNK5iJCK9Iv9po1wY=</guid>
      <description>New publication in SoftwareX</description>
      <content:encoded><![CDATA[


&lt;p&gt;
Bibliometrics are increasingly used to quantify scholarly productivity. In this paper, we introduce a Python package called &lt;a href="https://pypi.org/project/pybliometrics/"&gt;pybliometrics&lt;/a&gt; that provides a scriptable interface to Scopus to aggregate publication data for analysis. The package provides pretty comprehensive coverage of the APIs for author, abstract, affiliation and citation queries. The manuscript shows examples for downloading abstracts in bulk, building collaboration network graphs, and analyzing citation trends. You have to get a key from Scopus to access their databases, and the package provides some guidance on how to get it and configure the package. If you are interested in bibliometrics, this package may be useful to you!
&lt;/p&gt;


&lt;div class="org-src-container"&gt;
&lt;pre class="src src-bibtex"&gt;&lt;span style="color: #006699;"&gt;@article&lt;/span&gt;{&lt;span style="color: #D0372D;"&gt;rose-2019-pybliom&lt;/span&gt;,
  &lt;span style="color: #BA36A5;"&gt;author&lt;/span&gt; =       {Michael E. Rose and John R. Kitchin},
  &lt;span style="color: #BA36A5;"&gt;title&lt;/span&gt; =        {Pybliometrics: Scriptable Bibliometrics Using a Python
                  Interface To Scopus},
  &lt;span style="color: #BA36A5;"&gt;journal&lt;/span&gt; =      {SoftwareX},
  &lt;span style="color: #BA36A5;"&gt;volume&lt;/span&gt; =       10,
  &lt;span style="color: #BA36A5;"&gt;number&lt;/span&gt; =       {nil},
  &lt;span style="color: #BA36A5;"&gt;pages&lt;/span&gt; =        100263,
  &lt;span style="color: #BA36A5;"&gt;year&lt;/span&gt; =         2019,
  &lt;span style="color: #BA36A5;"&gt;doi&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;10.1016/j.softx.2019.100263&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;url&lt;/span&gt; =          {&lt;span style="color: #006DAF; text-decoration: underline;"&gt;https://doi.org/10.1016/j.softx.2019.100263&lt;/span&gt;},
  &lt;span style="color: #BA36A5;"&gt;DATE_ADDED&lt;/span&gt; =   {Mon Jul 8 07:06:58 2019},
}
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'&gt;&lt;/script&gt;
&lt;div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.softx.2019.100263'&gt;&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2019 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2019/07/08/New-publication-in-SoftwareX.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.2.3&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>An improvement for figures in ipython + scimax</title>
      <link>http://jkitchin.github.io/blog/2019/03/12/An-improvement-for-figures-in-ipython-+-scimax</link>
      <pubDate>Tue, 12 Mar 2019 14:18:26 EDT</pubDate>
      <category><![CDATA[ipython]]></category>
      <guid isPermaLink="false">7JS92IXaWxu9Qw0ujiw9pNqIeuk=</guid>
      <description>An improvement for figures in ipython + scimax</description>
      <content:encoded><![CDATA[


&lt;p&gt;
One of the best features of ipython in scimax is automatic inline images that you do not have to name. This has had a downside though, and that is it is not easy to use this &lt;i&gt;and&lt;/i&gt; put attributes like names (so you can reference them later) or captions, or if you want a specific filename to get that. No more. Now you can use the &lt;code&gt;:ipyfile&lt;/code&gt; header argument to control these. For example, if you use this in the header of the next block, it will save the images into the filenames you specified (in the order they are defined), and add attributes to the output. The syntax is just a list of plists (in elispese).
&lt;/p&gt;

&lt;pre class="example"&gt;
:ipyfile '((:name "clockwise" :filename "obipy-resources/clockwise.png" :caption "A clockwise spiral.") (:name "counterclockwise" :filename "obipy-resources/counterclockwise.png" :caption "A counterclockwise spiral."))
&lt;/pre&gt;

&lt;p&gt;
That allows you to refer to the clockwise one in Figure &lt;a href="#clockwise"&gt;clockwise&lt;/a&gt; and the counterclockwise in Fig.  &lt;a href="#counterclockwise"&gt;counterclockwise&lt;/a&gt;. That may be helpful when using Ipython to write papers or for presentations where you might prefer named figures that are easy to find. Enjoy!
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt; = np.linspace(0, 20 * np.pi, 350)
&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.exp(-0.1 * t) * np.sin(t)
&lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = np.exp(-0.1 * t) * np.cos(t)

plt.plot(x, y)
plt.axis(&lt;span style="color: #008000;"&gt;'equal'&lt;/span&gt;)

plt.figure()
plt.plot(y, x)

plt.axis(&lt;span style="color: #008000;"&gt;'equal'&lt;/span&gt;)

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'Length of t = {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(&lt;span style="color: #006FE0;"&gt;len&lt;/span&gt;(t)))
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;'x .dot. y = {}'&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(x @ y))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Length of t = 350
x .dot. y = 1.3598389888491538
&lt;/p&gt;



&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/clockwise.png"&gt;&lt;figcaption&gt;A clockwise spiral.&lt;/figcaption&gt;&lt;/figure&gt; 
&lt;/p&gt;



&lt;p&gt;
&lt;figure&gt;&lt;img src="/media/counterclockwise.png"&gt;&lt;figcaption&gt;A counterclockwise spiral.&lt;/figcaption&gt;&lt;/figure&gt; 
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2019 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2019/03/12/An-improvement-for-figures-in-ipython-+-scimax.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.2.1&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Using results from one code block in another org-mode</title>
      <link>http://jkitchin.github.io/blog/2019/02/12/Using-results-from-one-code-block-in-another-org-mode</link>
      <pubDate>Tue, 12 Feb 2019 09:20:58 EST</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[elisp]]></category>
      <category><![CDATA[orgmode]]></category>
      <guid isPermaLink="false">gzZgY5oqeB9thgLDRCfcJu-iwyw=</guid>
      <description>Using results from one code block in another org-mode</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org679863a"&gt;1. :var&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org1cd48f8"&gt;2. :cache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org744145d"&gt;3. :wrap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org603dd14"&gt;4. :file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org61d9dad"&gt;5. "remote" data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf9c3e0a"&gt;6. Manually saving data in files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org578795b"&gt;7. An appendix for data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org828ee8b"&gt;8. Caveats&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
One really great feature in org-mode is you have many options to pass data between code-blocks. In this post we look at some of these options using emacs-lisp as the language. This runs in a &lt;i&gt;session&lt;/i&gt; where you can keep variables in memory between blocks, and use them in subsequent blocks.
&lt;/p&gt;

&lt;p&gt;
Here we set a variable to a value.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;setq&lt;/span&gt; some-variable 42)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
42
&lt;/pre&gt;


&lt;p&gt;
Then later in another block we can use that variable:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(+ some-variable 1)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
43
&lt;/pre&gt;


&lt;p&gt;
While you are in the session, &lt;code&gt;some-variable&lt;/code&gt; can be used. If you want some mind-bending trouble, the emacs-lisp session is global, and you can access &lt;code&gt;some-variable&lt;/code&gt; even in another buffer! Don't do that. When you close emacs this variable will disappear, and all that is left are the results from above.
&lt;/p&gt;

&lt;p&gt;
There is another way to pass information from one block to another using named src blocks and variables in the block header. This allows you to pass data between blocks by name, and you will see later you can even access the results by name from other files.
&lt;/p&gt;

&lt;div id="outline-container-org679863a" class="outline-2"&gt;
&lt;h2 id="org679863a"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; :var&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
First, we give our src block a name like this:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+name: block-1
#+BEGIN_SRC emacs-lisp
(current-time-string)
#+END_SRC
&lt;/pre&gt;

&lt;p&gt;
When we run this, the results will have a name too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org0eee06d"&gt;(current-time-string)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Tue Feb 12 08:19:23 2019
&lt;/pre&gt;


&lt;p&gt;
Now, we can use the named result as &lt;i&gt;input&lt;/i&gt; to a new block using the :var header.
&lt;/p&gt;

&lt;pre class="example"&gt;
#+BEGIN_SRC emacs-lisp :var input=block-1
(format "We got %S in block-1" input)
#+END_SRC
&lt;/pre&gt;

&lt;p&gt;
When we run this block, emacs will run block-1 and put the output in to the variable &lt;code&gt;input&lt;/code&gt; which we use inside the code block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(format &lt;span style="color: #008000;"&gt;"We got %S in block-1"&lt;/span&gt; input)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "Tue Feb 12 08:20:44 2019" in block-1
&lt;/pre&gt;


&lt;p&gt;
Some things to note:
&lt;/p&gt;
&lt;ol class="org-ol"&gt;
&lt;li&gt;Every time you run this, block-1 gets rerun.&lt;/li&gt;
&lt;li&gt;The results in this block are not the same as in block-1&lt;/li&gt;
&lt;li&gt;The results in block-1 are not changed when you run the second block.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
You may not want to rerun block-1 each time; maybe it is an expensive calculation, or maybe it should not be changed. You can prevent this behavior by using the :cache header.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1cd48f8" class="outline-2"&gt;
&lt;h2 id="org1cd48f8"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; :cache&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
If you specify &lt;code&gt;:cache yes&lt;/code&gt; then org-mode &lt;i&gt;should&lt;/i&gt; store a hash of the code block with the results, and if the code block hasn't changed then it should not run again.
&lt;/p&gt;

&lt;pre class="example"&gt;
#+name: block-2
#+BEGIN_SRC emacs-lisp :cache yes
(current-time-string)
#+END_SRC
&lt;/pre&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="orgb1aedb8"&gt;(current-time-string)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Tue Feb 12 08:06:22 2019
&lt;/pre&gt;


&lt;p&gt;
Now, we use block-2 as input to a block, we see the output is the same as the output from block-2.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(format &lt;span style="color: #008000;"&gt;"We got %S in block-2"&lt;/span&gt; input)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "Tue Feb 12 08:06:22 2019" in block-2
&lt;/pre&gt;


&lt;p&gt;
Ok, but what if my results are too large to put in the buffer, or too complex for text? You still have some options.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org744145d" class="outline-2"&gt;
&lt;h2 id="org744145d"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; :wrap&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
Suppose we generate some json in one block, and we want to use it in another block. We still want to see the json in the buffer as an intermediate result. We can wrap the output in a json block like this.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="orgd0725ee"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;div class="json"&gt;
&lt;p&gt;
{"date":"Tue Feb 12 08:30:20 2019"}
&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;
Then, we can simply input that output into a new block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(format &lt;span style="color: #008000;"&gt;"We got %S in json"&lt;/span&gt; input)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "{\"date\":\"Tue Feb 12 08:30:20 2019\"}
" in json
&lt;/pre&gt;


&lt;p&gt;
This admittedly still pretty simple, text-based data. It is probably not a good idea to do this with binary data.
&lt;/p&gt;

&lt;p&gt;
Note you can refer to this result even in another org-file:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+BEGIN_SRC emacs-lisp :var input=./2019-02-12.org:json
input
#+END_SRC

#+RESULTS:
: {"date":"Tue Feb 12 08:30:20 2019"}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org603dd14" class="outline-2"&gt;
&lt;h2 id="org603dd14"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; :file&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
It may be that your data is too large to conveniently put into your org-file, or maybe it is binary data. No problem, just put it into an external file using the :file header. It looks like this:
&lt;/p&gt;

&lt;pre class="example"&gt;
#+name: block-3
#+BEGIN_SRC emacs-lisp :cache yes :file block-3
(require 'json)
(json-encode `(("date" . ,(current-time-string))))
#+END_SRC

#+RESULTS[a14d376653bd8c40a0961ca95f21d8837dddec66]: block-3
[[file:block-3]]
&lt;/pre&gt;


&lt;p&gt;
Note that you have to provide a file name for this. Sometimes that is nice if you want a human recognizable file to send to someone, but it would also be nice if there was an automatic naming scheme, e.g. based on an sha-1 hash of the src block.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org5f97d46"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;a href="/media/block-3"&gt;block-3&lt;/a&gt; 
&lt;/p&gt;

&lt;p&gt;
Now you can use other tools to check out the file. Here we can still use simple shell tools.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;cat block-3
&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;
The output of block-3 is a file name:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;input
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
/Users/jkitchin/Box Sync/kitchingroup/jkitchin/journal/2019/02/12/block-3
&lt;/pre&gt;


&lt;p&gt;
So you can use it in a new block to read the data in, and then do something new with it.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
  (insert-file-contents input)
  (format &lt;span style="color: #008000;"&gt;"We got %S in block-3"&lt;/span&gt; (json-read-from-string (buffer-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got ((date . "Tue Feb 12 08:46:55 2019")) in block-3
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org61d9dad" class="outline-2"&gt;
&lt;h2 id="org61d9dad"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; "remote" data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
The blocks do not have to be in order. If you want, you can put your blocks in an &lt;a href="#org578795b"&gt;appendix&lt;/a&gt;, and then just have analysis blocks here that use them. That way, you can have short blocks here that are more readable, but longer, more complex blocks elsewhere that do not clutter your document.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
  (insert-file-contents input)
  (format &lt;span style="color: #008000;"&gt;"We got %S in the appendix data"&lt;/span&gt; (json-read-from-string (buffer-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "{\"date\":\"Tue Feb 12 09:11:12 2019\"}" in the appendix data
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgf9c3e0a" class="outline-2"&gt;
&lt;h2 id="orgf9c3e0a"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; Manually saving data in files&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
Note you can also manually save data in a file, for example:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="org99c8008"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((f &lt;span style="color: #008000;"&gt;"block-4.json"&lt;/span&gt;))
  (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; f
    (prin1
     (json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
     (current-buffer)))
  f)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
block-4.json
&lt;/pre&gt;


&lt;p&gt;
We put the filename as the last variable which is returned by the block, so that we don't have to manually type it later in the next block. You know, try not to repeat yourself&amp;#x2026;
&lt;/p&gt;

&lt;p&gt;
This just shows we did write out to our file:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-sh"&gt;cat block-4.json
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
And we read the file in here, using the filename from block-4 as an input variable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp"&gt;(&lt;span style="color: #0000FF;"&gt;with-temp-buffer&lt;/span&gt;
  (insert-file-contents input)
  (format &lt;span style="color: #008000;"&gt;"We got %S in block-4"&lt;/span&gt; (json-read-from-string (buffer-string))))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
We got "{\"date\":\"Tue Feb 12 08:51:25 2019\"}" in block-4
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org578795b" class="outline-2"&gt;
&lt;h2 id="org578795b"&gt;&lt;span class="section-number-2"&gt;7&lt;/span&gt; An appendix for data&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-7"&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-emacs-lisp" id="orgfc06cf8"&gt;(&lt;span style="color: #0000FF;"&gt;require&lt;/span&gt; '&lt;span style="color: #D0372D;"&gt;json&lt;/span&gt;)
(&lt;span style="color: #0000FF;"&gt;let&lt;/span&gt; ((f &lt;span style="color: #008000;"&gt;"appendix.json"&lt;/span&gt;))
  (&lt;span style="color: #0000FF;"&gt;with-temp-file&lt;/span&gt; f
    (prin1
     (json-encode `((&lt;span style="color: #008000;"&gt;"date"&lt;/span&gt; . ,(current-time-string))))
     (current-buffer)))
  f)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
appendix.json
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-org828ee8b" class="outline-2"&gt;
&lt;h2 id="org828ee8b"&gt;&lt;span class="section-number-2"&gt;8&lt;/span&gt; Caveats&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-8"&gt;
&lt;p&gt;
Using org-mode like this is almost always finding the right tradeoffs in what is persistent, and where is it stored. Not all of the intermediate data/calculations are stored; if they are really cheap you can just run the code blocks again. If they are really small, i.e. easy for your to read in a few lines, you can store them in the document. If they are really large, you can store them in a file.
&lt;/p&gt;

&lt;p&gt;
The beauty of having everything in an org-file is you have a single file that is easy to transport. When the files get too large though, it can become impractical, e.g. emacs may slow down if you try to put thousands of lines of xml data into the buffer. Then, you have to make some decisions about what to keep, where to keep it, and in what form to keep it.
&lt;/p&gt;

&lt;p&gt;
For short projects where you only need a single compute session, having everything in memory may be fine. For longer projects, say one that is long enough you will close all the buffers, and possibly restart emacs in between working on it, then you have to make some decisions about what to save from each block so you can continue the work in the next session. Again, you have to decide what to save, where to save, and in what form.
&lt;/p&gt;

&lt;p&gt;
Once you start saving data outside the org-file, it becomes less portable, or more tricky to move the file because you need to also move all the data files to keep it intact. I have explored a concept of making an org-archive in the past, where you get a list of all files linked in the org-file, but this so far has just been worked out for some small proof of concept ideas.
&lt;/p&gt;

&lt;p&gt;
Not all languages are the same in org-mode. They do not all support sessions for example, and they may not all work like the examples here. The scimax iPython modifications do not behave like the examples above. That is probably due to bugs I have inadvertently introduced, and in the future I will try to make it work like emacs-lisp does above.
&lt;/p&gt;

&lt;p&gt;
Overall, org-mode has one of the most flexible and powerful systems for passing and reusing data in documents I have ever seen. It is not perfect, and in such a powerful system there are many unexplored or lightly traveled corners that may have hazards in them. It still seems pretty promising though.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2019 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2019/02/12/Using-results-from-one-code-block-in-another-org-mode.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.2.1&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>2018 in a nutshell for the Kitchin Research Group</title>
      <link>http://jkitchin.github.io/blog/2018/12/31/2018-in-a-nutshell-for-the-Kitchin-Research-Group</link>
      <pubDate>Mon, 31 Dec 2018 15:17:32 EST</pubDate>
      <category><![CDATA[news]]></category>
      <guid isPermaLink="false">rRVwqNhv2iK5JJ3Xr1qdIwWrDqI=</guid>
      <description>2018 in a nutshell for the Kitchin Research Group</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgbd65150"&gt;1. An all new research group&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf1eb546"&gt;2. Publications&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org6dc4f47"&gt;3. New courses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf521ee8"&gt;4. Emacs, org-mode and scimax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge03ea8f"&gt;5. Online activity&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org189de38"&gt;5.1. kitchingroup.cheme.cmu.edu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgc1d2765"&gt;5.2. Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org08ef442"&gt;5.3. YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#org552c652"&gt;5.4. Twitter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#org9d4a3c6"&gt;6. Summary and outlook&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
The majority of this year was spent finishing my sabbatical in the Google Accelerated Science Research group. I finished that up in August, and have returned to Pittsburgh now. I spent that time learning about differentiable programming and machine learning applications in science and engineering. It was a great learning year for me, and the beginning of some new research directions.
&lt;/p&gt;

&lt;p&gt;
It wasn't all work, I was able to bike over 3000 miles while we lived in California, spent lots of weekends at beaches, state parks, San Francisco, and many other beautiful places. There is a lot I miss from my sabbatical, but I am mostly glad to be back home.
&lt;/p&gt;

&lt;div id="outline-container-orgbd65150" class="outline-2"&gt;
&lt;h2 id="orgbd65150"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; An all new research group&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
In 2017, the last of my students finished, and my group shrunk temporarily to zero for a semester. That luckily coincided with the beginning of my sabbatical, which allowed me to focus exclusively on starting new research directions. Towards the end of last year, three new PhD students joined my group. I did not take any new PhD students this year, but several new MS students joined the group at the end of 2018:
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;Siddhant Lambor (co-advised with Prof. Lynn Walker)&lt;/li&gt;
&lt;li&gt;Gautham Swaminathan (co-advised with Prof. Lynn Walker)&lt;/li&gt;
&lt;li&gt;Siddarth Achar&lt;/li&gt;
&lt;li&gt;Senhong Liu&lt;/li&gt;
&lt;li&gt;Dingqi Nai&lt;/li&gt;
&lt;li&gt;Qiong Wang&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
These students will all work on some aspect of machine learning in formulation research, design of experiments, and molecular simulation. It should be an exciting year!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf1eb546" class="outline-2"&gt;
&lt;h2 id="orgf1eb546"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Publications&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
2018 was a light year on publications, largely due to my group shrinking to zero, and being on sabbatical.  I wrote a nice perspective article on machine learning in catalysis:
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#kitchin-2018-machin-learn-catal"&gt;kitchin-2018-machin-learn-catal&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;This perspective article describes how machine learning is being used in catalysis research and opportunities for further research.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;
And several publications from past M.S. students got finished and published:
&lt;/p&gt;

&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#thirumalai-2018-inves-react"&gt;thirumalai-2018-inves-react&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;This paper shows that many single atom alloys have unique electronic structure features that are responsible for their special catalytic properties.&lt;/dd&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#gao-2018-model-pallad"&gt;gao-2018-model-pallad&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We used DFT calculations to build a neural network potential to model adatom diffusion on a metal surface.&lt;/dd&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#wang-2018-densit-funct"&gt;wang-2018-densit-funct&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;We used DFT calculations to build a neural network potential to model zirconia polymorphs, oxygen vacancy formation and diffusion.&lt;/dd&gt;
&lt;/dl&gt;


&lt;p&gt;
This was technically published in 2017, but it was &lt;a href="https://twitter.com/JPhysCM/status/1078217723790921728"&gt;the most cited article in J. Phys.: Cond. Matt. in 2018&lt;/a&gt;!
&lt;/p&gt;


&lt;dl class="org-dl"&gt;
&lt;dt&gt;&lt;a class='org-ref-reference' href="#larsen-2017-atomic-simul"&gt;larsen-2017-atomic-simul&lt;/a&gt;&lt;/dt&gt;&lt;dd&gt;This is a modern update on the Atomic Simulation Environment Python software. We have been using and contributing to this software for about 15 years now!&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;
Citations on our past work continue to grow.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-30-12-2018-time-09-13-15.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
&lt;h1 class='org-ref-bib-h1'&gt;Bibliography&lt;/h1&gt;
&lt;ul class='org-ref-bib'&gt;&lt;li&gt;&lt;a id="kitchin-2018-machin-learn-catal"&gt;[kitchin-2018-machin-learn-catal]&lt;/a&gt; &lt;a name="kitchin-2018-machin-learn-catal"&gt;&lt;/a&gt;John Kitchin, Machine Learning in Catalysis, &lt;i&gt;Nature Catalysis&lt;/i&gt;, &lt;b&gt;1(4)&lt;/b&gt;, 230-232 (2018). &lt;a href="https://doi.org/10.1038/s41929-018-0056-y"&gt;link&lt;/a&gt;. &lt;a href="http://dx.doi.org/10.1038/s41929-018-0056-y"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a id="thirumalai-2018-inves-react"&gt;[thirumalai-2018-inves-react]&lt;/a&gt; &lt;a name="thirumalai-2018-inves-react"&gt;&lt;/a&gt;Hari Thirumalai &amp; John Kitchin, Investigating the Reactivity of Single Atom Alloys Using  Density Functional Theory, &lt;i&gt;Topics in Catalysis&lt;/i&gt;, &lt;b&gt;61(5-6)&lt;/b&gt;, 462-474 (2018). &lt;a href="https://doi.org/10.1007/s11244-018-0899-0"&gt;link&lt;/a&gt;. &lt;a href="http://dx.doi.org/10.1007/s11244-018-0899-0"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a id="gao-2018-model-pallad"&gt;[gao-2018-model-pallad]&lt;/a&gt; &lt;a name="gao-2018-model-pallad"&gt;&lt;/a&gt;Tianyu Gao &amp; John Kitchin, Modeling Palladium Surfaces With Density Functional Theory,  Neural Networks and Molecular Dynamics, &lt;i&gt;Catalysis Today&lt;/i&gt;, &lt;b&gt;312&lt;/b&gt;, 132-140 (2018). &lt;a href="https://doi.org/10.1016/j.cattod.2018.03.045"&gt;link&lt;/a&gt;. &lt;a href="http://dx.doi.org/10.1016/j.cattod.2018.03.045"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a id="wang-2018-densit-funct"&gt;[wang-2018-densit-funct]&lt;/a&gt; &lt;a name="wang-2018-densit-funct"&gt;&lt;/a&gt;Chen Wang, Akshay Tharval &amp; John Kitchin, A Density Functional Theory Parameterised Neural Network Model  of Zirconia, &lt;i&gt;Molecular Simulation&lt;/i&gt;, &lt;b&gt;44(8)&lt;/b&gt;, 623-630 (2018). &lt;a href="https://doi.org/10.1080/08927022.2017.1420185"&gt;link&lt;/a&gt;. &lt;a href="http://dx.doi.org/10.1080/08927022.2017.1420185"&gt;doi&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a id="larsen-2017-atomic-simul"&gt;[larsen-2017-atomic-simul]&lt;/a&gt; &lt;a name="larsen-2017-atomic-simul"&gt;&lt;/a&gt;Ask Hjorth Larsen, Jens J\orgen Mortensen, Jakob, Blomqvist, Ivano E Castelli, Rune Christensen, , Marcin DuÅ‚ak, Jesper Friis, Michael N Groves, , Bj\ork Hammer, Cory Hargus, Eric D Hermes, Paul C, Jennings, Peter Bjerre Jensen, James Kermode, John, R Kitchin, Esben Leonhard Kolsbjerg, Joseph Kubal, , Kristen Kaasbjerg, Steen Lysgaard, J\'on Bergmann, Maronsson, Tristan Maxson, Thomas Olsen, Lars, Pastewka, Andrew Peterson, Carsten Rostgaard, Jakob, Schi\otz, Ole Sch\"utt, Mikkel Strange, Kristian, S Thygesen, Tejs Vegge, Lasse Vilhelmsen, Michael, Walter, Zhenhua Zeng &amp; Karsten W Jacobsen, The Atomic Simulation Environment-A Python Library for Working  With Atoms, &lt;i&gt;Journal of Physics: Condensed Matter&lt;/i&gt;, &lt;b&gt;29(27)&lt;/b&gt;, 273002 (2017). &lt;a href="http://stacks.iop.org/0953-8984/29/i=27/a=273002"&gt;link&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org6dc4f47" class="outline-2"&gt;
&lt;h2 id="org6dc4f47"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; New courses&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
On my return from my sabbatical, I taught a new course for me, 06-623 Mathematical modeling of chemical engineering processes. I taught this course in Python, and it was a tour of mathematical and scientific programming that started with &lt;code class="src src-ipython"&gt;&lt;span style="color: #036A07;"&gt;"Hello world"&lt;/span&gt;&lt;/code&gt; 'Hello world' and ended with machine learning. We traveled through differential equations, nonlinear algebra, optimization, and regression along the way using numpy and scipy. It was a fun class, and I look forward to teaching it again next Fall. You can see the course notes at &lt;a href="https://github.com/jkitchin/f18-06623"&gt;https://github.com/jkitchin/f18-06623&lt;/a&gt;. I ran this course using Jupyter notebooks (of course I wrote the notes in org-mode and used the jupyter notebook exporter I wrote to make these!) and Box.com. It worked, but wasn't my favorite. I will try to go back to Emacs+org-mode for this next year.
&lt;/p&gt;

&lt;p&gt;
This coming spring will be another new course: our junior Transport Lab course.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf521ee8" class="outline-2"&gt;
&lt;h2 id="orgf521ee8"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Emacs, org-mode and scimax&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
org-ref has been downloaded close to 40K times! I thought it &lt;a href="https://twitter.com/johnkitchin/status/1072555130850041856"&gt;passed 40K&lt;/a&gt; early in December, but MELPA shows it with just under 40K today. They switched servers recently, so maybe some statistics were lost. If you count the Melpa-stable downloads, it is still over 40K. There are now over 50 contributors to org-ref besides me! That is pretty awesome, and hopefully speaks to the number of people interested in using Emacs for scientific publishing.
&lt;/p&gt;

&lt;p&gt;
This fall I picked up scimax development again after my sabbatical break, and have a few notable improvements I will launch in 2019. These include:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;Many improvements to ipython in scimax:
&lt;ul class="org-ul"&gt;
&lt;li&gt;Code completion&lt;/li&gt;
&lt;li&gt;Inspection&lt;/li&gt;
&lt;li&gt;More jupyter-like features (?, ??) and key-bindings&lt;/li&gt;
&lt;li&gt;export to Jupyter notebooks&lt;/li&gt;
&lt;li&gt;src-block keymaps&lt;/li&gt;
&lt;li&gt;and more.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A new editmarks package that will allow persistent comments, highlights, and track-change mode.&lt;/li&gt;
&lt;li&gt;Improved support for literate programming in org-mode including jump to the definition in org-mode.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Scimax is an increasingly important project to me, and in 2019 I am going to work on some ways that will make it easier for me to spend more time on it in the future.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge03ea8f" class="outline-2"&gt;
&lt;h2 id="orge03ea8f"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; Online activity&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org189de38" class="outline-3"&gt;
&lt;h3 id="org189de38"&gt;&lt;span class="section-number-3"&gt;5.1&lt;/span&gt; kitchingroup.cheme.cmu.edu&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-1"&gt;
&lt;p&gt;
Since I was on sabbatical, it was a low volume blogging year with only 22 posts. Traffic to the blog was up nonetheless from the last year. I suspect I will blog more this year.
&lt;/p&gt;


&lt;p&gt;
&lt;img src="/media/date-30-12-2018-time-09-25-34.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-orgc1d2765" class="outline-3"&gt;
&lt;h3 id="orgc1d2765"&gt;&lt;span class="section-number-3"&gt;5.2&lt;/span&gt; Github&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-2"&gt;
&lt;p&gt;
I was even less active in 2018 than in 2017 on GitHub activity. You can see it picked back up this past fall as I returned to my day job as a professor. I expect 2019 will pick back up as usual.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-30-12-2018-time-09-26-11.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org08ef442" class="outline-3"&gt;
&lt;h3 id="org08ef442"&gt;&lt;span class="section-number-3"&gt;5.3&lt;/span&gt; YouTube&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-3"&gt;
&lt;p&gt;
Our &lt;a href="https://studio.youtube.com/channel/UCQp2VLAOlvq142YN3JO3y8w/analytics/tab-overview/period-year?utm_campaign=upgrade&amp;amp;utm_medium=redirect&amp;amp;utm_source=/analytics"&gt;YouTube traffic&lt;/a&gt; is down this year compared to last year. It is still always interesting to see the spikes in traffic on the org-mode is awesome video. Maybe it got mentioned on Hacker News or something. I only made one video last year; I took a break while on sabbatical, and was busy this fall with a new course. Maybe 2019 will be a better year for that. I have some plans for new videos in the new year on ipython, and some updates in scimax.
&lt;/p&gt;

&lt;p&gt;
&lt;img src="/media/date-30-12-2018-time-09-28-26.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
We did cross 1000 subscribers this year. That doesn't qualify my channel for monetization yet, you also need 4000 watch hours in the past year. Last year we only had 1466 hours, so not that close yet. Why am I interested in this? I am actively looking for ways to support scimax development, and this could be one way to do that.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org552c652" class="outline-3"&gt;
&lt;h3 id="org552c652"&gt;&lt;span class="section-number-3"&gt;5.4&lt;/span&gt; Twitter&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-5-4"&gt;
&lt;p&gt;
It wasn't super easy to get all the Twitter data, I had to manually download the information from each month. Now that I have it, I did some analysis, so here it is. First we look at how many tweets, likes, retweets, etc. there were last year:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; csv
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; glob

&lt;span style="color: #BA36A5;"&gt;tweets&lt;/span&gt; = 0
&lt;span style="color: #BA36A5;"&gt;impressions&lt;/span&gt; = 0
&lt;span style="color: #BA36A5;"&gt;texts&lt;/span&gt; = []
&lt;span style="color: #BA36A5;"&gt;times&lt;/span&gt; = [] &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;times of the tweets&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;likes&lt;/span&gt; = 0
&lt;span style="color: #BA36A5;"&gt;retweets&lt;/span&gt; = 0
&lt;span style="color: #BA36A5;"&gt;replies&lt;/span&gt; = 0

&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; csvfile &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; glob.glob(&lt;span style="color: #008000;"&gt;'*.csv'&lt;/span&gt;):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;with&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;open&lt;/span&gt;(csvfile) &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; f:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;reader&lt;/span&gt; = csv.DictReader(f)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; row &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; reader:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;tweets&lt;/span&gt; += 1
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;impressions&lt;/span&gt; += &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(row[&lt;span style="color: #008000;"&gt;'impressions'&lt;/span&gt;])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;texts&lt;/span&gt; += [row[&lt;span style="color: #008000;"&gt;'Tweet text'&lt;/span&gt;]]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;times&lt;/span&gt; += [row[&lt;span style="color: #008000;"&gt;'time'&lt;/span&gt;]]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;likes&lt;/span&gt; += &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(row[&lt;span style="color: #008000;"&gt;'likes'&lt;/span&gt;])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;replies&lt;/span&gt; += &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(row[&lt;span style="color: #008000;"&gt;'replies'&lt;/span&gt;])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;retweets&lt;/span&gt; += &lt;span style="color: #006FE0;"&gt;float&lt;/span&gt;(row[&lt;span style="color: #008000;"&gt;'retweets'&lt;/span&gt;])

&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'''{tweets} Tweets with {int(impressions)} impressions.&lt;/span&gt;
&lt;span style="color: #008000;"&gt;There were {int(likes)} likes, {int(retweets)} retweets, and {int(replies)} replies.'''&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
471 Tweets with 282655 impressions.
There were 1089 likes, 220 retweets, and 341 replies.
&lt;/p&gt;

&lt;p&gt;
Next, we look at the time distribution of these tweets. It seems like this should be easier to do (it probably is in Pandas).
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; datetime
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np

&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt; = np.array([datetime.datetime.strptime(time[0:-6], &lt;span style="color: #008000;"&gt;"%Y-%m-%d %H:%M"&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; time &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; times])

&lt;span style="color: #BA36A5;"&gt;months&lt;/span&gt; = np.zeros(12)
&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; time &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; x:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;months&lt;/span&gt;[time.month - 1] += 1

plt.bar(np.arange(12), months)
plt.xticks(np.arange(12), [&lt;span style="color: #008000;"&gt;'January'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'February'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'March'&lt;/span&gt;,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;  &lt;span style="color: #008000;"&gt;'April'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'May'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'June'&lt;/span&gt;,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;  &lt;span style="color: #008000;"&gt;'July'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'August'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'September'&lt;/span&gt;,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;  &lt;span style="color: #008000;"&gt;'October'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'November'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'December'&lt;/span&gt;],
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;  rotation=45);
plt.ylabel(&lt;span style="color: #008000;"&gt;'Tweet count'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/cdc7d711087c709e77a3f6d76ca7f635-2070zAJ.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org9d4a3c6" class="outline-2"&gt;
&lt;h2 id="org9d4a3c6"&gt;&lt;span class="section-number-2"&gt;6&lt;/span&gt; Summary and outlook&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-6"&gt;
&lt;p&gt;
2018 was a pretty good year. I took a break from several things I have spent a lot of time in the past and learned some new things I spend my time on now. I am looking forward to getting back to some of the old things, especially scimax development. I still think it is a key component of modern scientific research and publishing, and that it has an important role in education. Stay tuned!
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/12/31/2018-in-a-nutshell-for-the-Kitchin-Research-Group.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.14&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Line integrals in Python with autograd</title>
      <link>http://jkitchin.github.io/blog/2018/11/16/Line-integrals-in-Python-with-autograd</link>
      <pubDate>Fri, 16 Nov 2018 08:39:44 EST</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[integration]]></category>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">8pnl2uSxymXf56S8frpp6psrwys=</guid>
      <description>Line integrals in Python with autograd</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#org107f13d"&gt;1. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
A line integral is an integral of a function along a curve in space. We usually represent the curve by a parametric equation, e.g. \(\mathbf{r}(t) = [x(t), y(t), z(t)] = x(t)\mathbf{i} + y(t)\mathbf{j} + z(t)\mathbf{k}\).  So, in general the curve will be a vector function, and the function we want to integrate will also be a vector function.
&lt;/p&gt;

&lt;p&gt;
Then, we can write the line integral definition as:
&lt;/p&gt;

&lt;p&gt;
\(\int_C \mathbf{F(r)}\cdot d\mathbf{r} = \int_a^b \mathbf{F}({\mathbf{r}(t)) \cdot \mathbf{r'}(t) dt\) where \(\mathbf{r'}(t) = \frac{d\mathbf{r}}{dt}\). This integrand is a scalar function, because of the dot product.
&lt;/p&gt;

&lt;p&gt;
The following examples are adapted from Chapter 10 in Advanced Engineering Mathematics by Kreysig.
&lt;/p&gt;

&lt;p&gt;
The first example is the evaluation of  a line integral in the plane. We want to evaluate the integral of \(\mathbf{F(r)}=[-y, -xy]\) on the curve \(\mathbf{r(t)}=[-sin(t), cos(t)]\) from t=0 to t = &amp;pi;/2. The answer in the book is given as 0.4521. Here we evaluate this numerically, using autograd for the relevant derivative. Since the curve has multiple outputs, we have to use the jacobian function to get the derivatives. After that, it is a simple bit of matrix multiplication, and a call to the quad function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; jacobian
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; quad

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;F&lt;/span&gt;(X):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = X
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -y, -x * y

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;r&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.array([-np.sin(t), np.cos(t)])

&lt;span style="color: #BA36A5;"&gt;drdt&lt;/span&gt; = jacobian(r)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;integrand&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; F(r(t)) @ drdt(t)

&lt;span style="color: #BA36A5;"&gt;I&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;e&lt;/span&gt; = quad(integrand, 0.0, np.pi / 2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The integral is {I:1.4f}.'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The integral is 0.4521.


&lt;/pre&gt;

&lt;p&gt;
We get the same result as the analytical solution.
&lt;/p&gt;


&lt;p&gt;
The next example is in three dimensions. Find the line integral along \(\mathbf{r}(t)=[cos(t), sin(t), 3t]\) of the function \(\mathbf{F(r)}=[z, x, y]\) from t=0 to t=2 &amp;pi;. The solution is given as 21.99.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; elementwise_grad, grad, jacobian

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;F&lt;/span&gt;(X):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt; = X
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; [z, x, y]

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;C&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.array([np.cos(t), np.sin(t), 3 * t])

&lt;span style="color: #BA36A5;"&gt;dCdt&lt;/span&gt; = jacobian(C, 0)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;integrand&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; F(C(t)) @ dCdt(t)

&lt;span style="color: #BA36A5;"&gt;I&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;e&lt;/span&gt; = quad(integrand, 0, 2 * np.pi)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The integral is {I:1.2f}.'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The integral is 21.99.


&lt;/pre&gt;

&lt;p&gt;
That is also the same as the analytical solution. Note the real analytical solution was 7 &amp;pi;, which is nearly equivalent to our answer.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;7 * np.pi - I
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
3.552713678800501e-15

&lt;/pre&gt;


&lt;p&gt;
As a final example, we consider an alternate form of the line integral. In this form we do not use a dot product, so the integral results in a vector. This doesn't require anything from autograd, but does require us to be somewhat clever in how to do the integrals since quad can only integrate scalar functions. We need to integrate each component of the integrand independently. Here is one approach where we use lambda functions for each component. You could also manually separate the components.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;F&lt;/span&gt;(r):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt; = r
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x * y, y * z, z

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;r&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.array([np.cos(t), np.sin(t), 3 * t])

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;integrand&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; F(r(t))

[quad(&lt;span style="color: #0000FF;"&gt;lambda&lt;/span&gt; t: integrand(t)[i], 0, 2 * np.pi)[0] &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; i &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; [0, 1, 2]]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[-6.9054847581172525e-18, -18.849555921538755, 59.21762640653615]

&lt;/pre&gt;

&lt;p&gt;
The analytical solution in this case was given as:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;[0, -6 * np.pi, 6 * np.pi**2]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[0, -18.84955592153876, 59.21762640653615]

&lt;/pre&gt;

&lt;p&gt;
which is evidently the same as our numerical solution.
&lt;/p&gt;

&lt;p&gt;
Maybe an alternative, but more verbose is this vectorized integrate function. We still make temporary functions for integrating, and the vectorization is essentially like the list comprehension above, but we avoid the lambda functions.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #6434A3;"&gt;@np.vectorize&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;integrate&lt;/span&gt;(i):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;integrand&lt;/span&gt;(t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; F(r(t))[i]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;I&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;e&lt;/span&gt; = quad(integrand, 0, 2 * np.pi)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; I

integrate([0, 1, 2])
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
array([ -6.90548476e-18,  -1.88495559e+01,   5.92176264e+01])

&lt;/pre&gt;

&lt;div id="outline-container-org107f13d" class="outline-2"&gt;
&lt;h2 id="org107f13d"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Once again, autograd provides a convenient way to compute function jacobians which make it easy to evaluate line integrals in Python.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/11/16/Line-integrals-in-Python-with-autograd.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.14&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Using autograd for error propagation</title>
      <link>http://jkitchin.github.io/blog/2018/11/05/Using-autograd-for-error-propagation</link>
      <pubDate>Mon, 05 Nov 2018 21:04:21 EST</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[uncertainty]]></category>
      <guid isPermaLink="false">VOnvqoFwCueTJTkZl1jY2hDGjqY=</guid>
      <description>Using autograd for error propagation</description>
      <content:encoded><![CDATA[


&lt;p&gt;
Back in &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2013/03/07/Another-approach-to-error-propagation/"&gt;2013&lt;/a&gt; I wrote about using the uncertainties package to propagate uncertainties. The problem setup was for finding the uncertainty in the exit concentration from a CSTR when there are uncertainties in the other parameters. In this problem we were given this information about the parameters and their uncertainties.
&lt;/p&gt;

&lt;table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides"&gt;


&lt;colgroup&gt;
&lt;col  class="org-left" /&gt;

&lt;col  class="org-right" /&gt;

&lt;col  class="org-right" /&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th scope="col" class="org-left"&gt;Parameter&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;value&lt;/th&gt;
&lt;th scope="col" class="org-right"&gt;&amp;sigma;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="org-left"&gt;Fa0&lt;/td&gt;
&lt;td class="org-right"&gt;5&lt;/td&gt;
&lt;td class="org-right"&gt;0.05&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;v0&lt;/td&gt;
&lt;td class="org-right"&gt;10&lt;/td&gt;
&lt;td class="org-right"&gt;0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;V&lt;/td&gt;
&lt;td class="org-right"&gt;66000&lt;/td&gt;
&lt;td class="org-right"&gt;100&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td class="org-left"&gt;k&lt;/td&gt;
&lt;td class="org-right"&gt;3&lt;/td&gt;
&lt;td class="org-right"&gt;0.2&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;
The exit concentration is found by solving this equation:
&lt;/p&gt;

&lt;p&gt;
\(0 = Fa0 - v0 * Ca - k * Ca**2 * V\)
&lt;/p&gt;

&lt;p&gt;
So the question was what is Ca, and what is the uncertainty on it? Finding Ca is easy with fsolve.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve

&lt;span style="color: #BA36A5;"&gt;Fa0&lt;/span&gt; = 5.0
&lt;span style="color: #BA36A5;"&gt;v0&lt;/span&gt; = 10.0

&lt;span style="color: #BA36A5;"&gt;V&lt;/span&gt; = 66000.0
&lt;span style="color: #BA36A5;"&gt;k&lt;/span&gt; = 3.0

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;func&lt;/span&gt;(Ca, v0, k, Fa0, V):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"Mole balance for a CSTR. Solve this equation for func(Ca)=0"&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;Fa&lt;/span&gt; = v0 * Ca     &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;exit molar flow of A&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;ra&lt;/span&gt; = -k * Ca**2  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;rate of reaction of A L/mol/h&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Fa0 - Fa + V * ra

Ca, = fsolve(func, 0.1 * Fa0 / v0, args=(v0, k, Fa0, V))
Ca
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
0.0050000000000000001

&lt;/pre&gt;

&lt;p&gt;
The uncertainty on Ca is a little trickier. A &lt;a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty#Simplification"&gt;simplified&lt;/a&gt; way to estimate it is:
&lt;/p&gt;

&lt;p&gt;
\(\sigma_{Ca} = \sqrt{(dCa/dv0)^2 \sigma_{v0}^2 + (dCa/dv0)^2 \sigma_{v0}^2 + (dCa/dFa0)^2 \sigma_{Fa0}^2 + (dCa/dV)^2 \sigma_{V}^2}\)
&lt;/p&gt;

&lt;p&gt;
We know the &amp;sigma;_i for each input, we just need those partial derivatives. However, we only have the implicit function we used to solve for Ca, and I do not want to do the algebra to solve for Ca. Luckily, we &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/08/Getting-derivatives-from-implicit-functions-with-autograd/"&gt;previously worked out&lt;/a&gt; how to get these derivatives from an implicit function using autograd. We just need to loop through the arguments, get the relevant derivatives, and accumulate the product of the squared derivatives and errors. Finally, take the square root of that sum.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; grad

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;these are the uncertainties on the inputs&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;s&lt;/span&gt; = [&lt;span style="color: #D0372D;"&gt;None&lt;/span&gt;, 0.1, 0.2, 0.05, 100]

&lt;span style="color: #BA36A5;"&gt;S2&lt;/span&gt; = 0.0

&lt;span style="color: #BA36A5;"&gt;dfdCa&lt;/span&gt; = grad(func, 0)
&lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; i &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(1, 5):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dfdarg2&lt;/span&gt; = grad(func, i)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dCadarg2&lt;/span&gt; = -dfdarg2(Ca, v0, k, Fa0, V) / dfdCa(Ca, v0, k, Fa0, V)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;S2&lt;/span&gt; += dCadarg2**2 * s[i]**2

&lt;span style="color: #BA36A5;"&gt;Ca_s&lt;/span&gt; = np.sqrt(S2)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'Ca = {Ca:1.5f} +\- {Ca_s}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Ca = 0.00500 +\- 0.00016776432898276802


&lt;/pre&gt;

&lt;p&gt;
That is the same uncertainty estimate the quantities package provided. One benefit here is I did not have to do the somewhat complicated wrapping procedure around fsolve that was required with uncertainties to get this. On the other hand, I did have to derive the formula and implement them. It worked fine here, since we have an implicit function and a way to get the required derivatives. It could take some work to do this with the exit concentration of a PFR, which requires an integrator. Maybe that &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis/"&gt;differentiable integrator&lt;/a&gt; will come in handy again!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/11/05/Using-autograd-for-error-propagation.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.14&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Constrained optimization with Lagrange multipliers and autograd</title>
      <link>http://jkitchin.github.io/blog/2018/11/03/Constrained-optimization-with-Lagrange-multipliers-and-autograd</link>
      <pubDate>Sat, 03 Nov 2018 09:39:20 EDT</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[optimization]]></category>
      <guid isPermaLink="false">Iy0PvHLUa3-zADMW_uQnOCfZ6Z4=</guid>
      <description>Constrained optimization with Lagrange multipliers and autograd</description>
      <content:encoded><![CDATA[


&lt;p&gt;
Constrained optimization is common in engineering problems solving. A prototypical example (from Greenberg, Advanced Engineering Mathematics, Ch 13.7) is to find the point on a plane that is closest to the origin. The plane is defined by the equation \(2x - y + z = 3\), and we seek to minimize \(x^2 + y^2 + z^2\) subject to the equality constraint defined by the plane. &lt;code&gt;scipy.optimize.minimize&lt;/code&gt; provides a pretty convenient interface to solve a problem like this, ans shown here.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; minimize

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(X):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt; = X
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x**2 + y**2 + z**2

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;eq&lt;/span&gt;(X):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt; = X
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; 2 * x - y + z - 3

&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = minimize(objective, [1, -0.5, 0.5], constraints={&lt;span style="color: #008000;"&gt;'type'&lt;/span&gt;: &lt;span style="color: #008000;"&gt;'eq'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'fun'&lt;/span&gt;: eq})
sol
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
    fun: 1.5
    jac: array([ 2.00000001, -0.99999999,  1.00000001])
message: 'Optimization terminated successfully.'
   nfev: 5
    nit: 1
   njev: 1
 status: 0
success: True
      x: array([ 1. , -0.5,  0.5])

&lt;/pre&gt;

&lt;p&gt;
I like the minimize function a lot, although I am not crazy for how the constraints are provided. The alternative used to be that there was an argument for equality constraints and another for inequality constraints. Analogous to &lt;code&gt;scipy.integrate.solve_ivp&lt;/code&gt; event functions, they could have also used function attributes.
&lt;/p&gt;

&lt;p&gt;
Sometimes, it might be desirable to go back to basics though, especially if you are unaware of the &lt;code&gt;minimize&lt;/code&gt; function or perhaps suspect it is not working right and want an independent answer. Next we look at how to construct this constrained optimization problem using Lagrange multipliers. This converts the problem into an augmented unconstrained optimization problem we can use &lt;code&gt;fsolve&lt;/code&gt; on. The gist of this method is we formulate a new problem:
&lt;/p&gt;

&lt;p&gt;
\(F(X) = f(X) - \lambda g(X)\)
&lt;/p&gt;

&lt;p&gt;
and then solve the simultaneous resulting equations:
&lt;/p&gt;

&lt;p&gt;
\(F_x(X) = F_y(X) = F_z(X) = g(X) = 0\) where \(F_x\) is the derivative of \(f*\) with respect to \(x\), and \(g(X)\) is the equality constraint written so it is equal to zero. Since we end up with four equations that equal zero, we can simply use fsolve to get the solution. Many &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2013/02/03/Using-Lagrange-multipliers-in-optimization/"&gt;years ago&lt;/a&gt; I used a finite difference approximation to the derivatives. Today we use autograd to get the desired derivatives. Here it is.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; grad

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;F&lt;/span&gt;(L):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;'Augmented Lagrange function'&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;_lambda&lt;/span&gt; = L
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; objective([x, y, z]) - _lambda * eq([x, y, z])

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Gradients of the Lagrange function&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;dfdL&lt;/span&gt; = grad(F, 0)

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Find L that returns all zeros in this function.&lt;/span&gt;
&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;obj&lt;/span&gt;(L):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;_lambda&lt;/span&gt; = L
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dFdx&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;dFdy&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;dFdz&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;dFdlam&lt;/span&gt; = dfdL(L)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; [dFdx, dFdy, dFdz, eq([x, y, z])]

&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.optimize &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; fsolve
&lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;z&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;_lam&lt;/span&gt; = fsolve(obj, [0.0, 0.0, 0.0, 1.0])
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'The answer is at {x, y, z}'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
The answer is at (1.0, -0.5, 0.5)


&lt;/pre&gt;

&lt;p&gt;
That is the same answer as before. Note we have still relied on some black box solver inside of fsolve (instead of inside minimize), but it might be more clear what problem we are solving (e.g. finding zeros). It takes a bit more work to set this up, since we have to construct the augmented function, but autograd makes it pretty convenient to set up the final objective function we want to solve.
&lt;/p&gt;

&lt;p&gt;
How do we know we are at a minimum? We can check that the Hessian is positive definite in the original function we wanted to minimize. You can see here the array is positive definite, e.g. all the eigenvalues are positive. autograd makes this easy too.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; hessian
&lt;span style="color: #BA36A5;"&gt;h&lt;/span&gt; = hessian(objective, 0)
h(np.array([x, y, z]))
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
array([[ 2.,  0.,  0.],
       [ 0.,  2.,  0.],
       [ 0.,  0.,  2.]])

&lt;/pre&gt;

&lt;p&gt;
In case it isn't evident from that structure that the eigenvalues are all positive, here we compute them:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;np.linalg.eig(h(np.array([x, y, z])))[0]
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
array([ 2.,  2.,  2.])

&lt;/pre&gt;

&lt;p&gt;
In summary, autograd continues to enable advanced engineering problems to be solved.
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/11/03/Constrained-optimization-with-Lagrange-multipliers-and-autograd.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.14&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>Solving coupled ODEs with a neural network and autograd</title>
      <link>http://jkitchin.github.io/blog/2018/11/02/Solving-coupled-ODEs-with-a-neural-network-and-autograd</link>
      <pubDate>Fri, 02 Nov 2018 19:53:00 EDT</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">Ry5Ux3UbG7_HZnK_dVp9iHlLtpE=</guid>
      <description>Solving coupled ODEs with a neural network and autograd</description>
      <content:encoded><![CDATA[


&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#orgfefaa95"&gt;1. The standard numerical solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orge5dacb7"&gt;2. Can a neural network learn the solution?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orga332637"&gt;3. Given a neural network function how do we get the right derivatives?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgf85faff"&gt;4. Solving the system of ODEs with a neural network&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#orgbbded67"&gt;5. Summary&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
In a previous &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/11/28/Solving-ODEs-with-a-neural-network-and-autograd/index.html"&gt;post&lt;/a&gt; I wrote about using ideas from machine learning to solve an ordinary differential equation using a neural network for the solution. A friend recently tried to apply that idea to coupled ordinary differential equations, without success. It seems like that should work, so here we diagnose the issue and figure it out. This is a long post, but it works in the end.
&lt;/p&gt;

&lt;p&gt;
In the classic series reaction \(A \rightarrow B \rightarrow C\) in a batch reactor, we get the set of coupled mole balances:
&lt;/p&gt;

&lt;p&gt;
\(dC_A/dt = -k_1 C_A\)
&lt;/p&gt;

&lt;p&gt;
\(dC_B/dt = k_1 C_A - k_2 C_B\)
&lt;/p&gt;

&lt;p&gt;
\(dC_C/dt = k2 C_B\)
&lt;/p&gt;

&lt;div id="outline-container-orgfefaa95" class="outline-2"&gt;
&lt;h2 id="orgfefaa95"&gt;&lt;span class="section-number-2"&gt;1&lt;/span&gt; The standard numerical solution&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-1"&gt;
&lt;p&gt;
Here is the standard numerical solution to this problem. This will give us a reference for what the solution should look like.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; scipy.integrate &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; solve_ivp

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;ode&lt;/span&gt;(t, C):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;Ca&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Cb&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Cc&lt;/span&gt; = C
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dCadt&lt;/span&gt; = -k1 * Ca
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dCbdt&lt;/span&gt; = k1 * Ca - k2 * Cb
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dCcdt&lt;/span&gt; = k2 * Cb
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; [dCadt, dCbdt, dCcdt]

&lt;span style="color: #BA36A5;"&gt;C0&lt;/span&gt; = [1.0, 0.0, 0.0]
&lt;span style="color: #BA36A5;"&gt;k1&lt;/span&gt; = 1
&lt;span style="color: #BA36A5;"&gt;k2&lt;/span&gt; = 1

&lt;span style="color: #BA36A5;"&gt;sol&lt;/span&gt; = solve_ivp(ode, (0, 10), C0)

%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

plt.plot(sol.t, sol.y.T)
plt.legend([&lt;span style="color: #008000;"&gt;'A'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;])
plt.xlabel(&lt;span style="color: #008000;"&gt;'Time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/d0abffb7b8615837cad7f2cceb378aac-65837xDK.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge5dacb7" class="outline-2"&gt;
&lt;h2 id="orge5dacb7"&gt;&lt;span class="section-number-2"&gt;2&lt;/span&gt; Can a neural network learn the solution?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-2"&gt;
&lt;p&gt;
The first thing I want to show is that you can train a neural network to reproduce this solution. That is certainly a prerequisite to the idea working. We use the  same code I used before, but this time our neural network will output three values, one for each concentration.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; grad, elementwise_grad, jacobian
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy.random &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; npr
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd.misc.optimizers &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; adam

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;init_random_params&lt;/span&gt;(scale, layer_sizes, rs=npr.RandomState(0)):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"""Build a list of (weights, biases) tuples, one for each layer."""&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; [(rs.randn(insize, outsize) * scale,   &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;weight matrix&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;rs.randn(outsize) * scale)           &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;bias vector&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; insize, outsize &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;zip&lt;/span&gt;(layer_sizes[:-1], layer_sizes[1:])]

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;swish&lt;/span&gt;(x):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"see https://arxiv.org/pdf/1710.05941.pdf"&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x / (1.0 + np.exp(-x))

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;C&lt;/span&gt;(params, inputs):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #036A07;"&gt;"Neural network functions"&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; W, b &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; params:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;outputs&lt;/span&gt; = np.dot(inputs, W) + b
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;inputs&lt;/span&gt; = swish(outputs)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; outputs

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;initial guess for the weights and biases&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = init_random_params(0.1, layer_sizes=[1, 8, 3])
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we train our network to reproduce the solution. I ran this block manually a bunch of times, but eventually you see that we can train a one layer network with 8 nodes to output all three concentrations pretty accurately. So, there is no issue there, a neural network can represent the solution.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective_soln&lt;/span&gt;(params, step):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;((sol.y.T - C(params, sol.t.reshape([-1, 1])))**2)

&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = adam(grad(objective_soln), params,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; step_size=0.001, num_iters=500)

plt.plot(sol.t.reshape([-1, 1]), C(params, sol.t.reshape([-1, 1])),
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;sol.t, sol.y.T, &lt;span style="color: #008000;"&gt;'o'&lt;/span&gt;)
plt.legend([&lt;span style="color: #008000;"&gt;'A'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'Ann'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'Bnn'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'Cnn'&lt;/span&gt;])
plt.xlabel(&lt;span style="color: #008000;"&gt;'Time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/d0abffb7b8615837cad7f2cceb378aac-65837YpQ.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga332637" class="outline-2"&gt;
&lt;h2 id="orga332637"&gt;&lt;span class="section-number-2"&gt;3&lt;/span&gt; Given a neural network function how do we get the right derivatives?&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-3"&gt;
&lt;p&gt;
The next issue is how do we get the relevant derivatives. The solution method I developed here relies on using optimization to find a set of weights that produces a neural network whose derivatives are consistent with the ODE equations. So, we need to be able to get the derivatives that are relevant in the equations.
&lt;/p&gt;

&lt;p&gt;
The neural network outputs three concentrations, and we need the time derivatives of them. Autograd provides three options: &lt;code&gt;grad&lt;/code&gt;, &lt;code&gt;elementwise_grad&lt;/code&gt; and &lt;code&gt;jacobian&lt;/code&gt;. We cannot use &lt;code&gt;grad&lt;/code&gt; because our function is not scalar. We cannot use &lt;code&gt;elementwise_grad&lt;/code&gt; because that will give the wrong shape (I think it may be the sum of the gradients). That leaves us with the &lt;code&gt;jacobian&lt;/code&gt;. This, however, gives an initially unintuitive (i.e. it isn't what we need out of the box) result. The output is 4-dimensional in this case, consistent with the documentation of that function.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;jacC&lt;/span&gt; = jacobian(C, 1)
jacC(params, sol.t.reshape([-1, 1])).shape
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
(17, 3, 17, 1)

&lt;/pre&gt;


&lt;p&gt;
Why does it have this shape? Our time input vector we used has 17 time values, in a column vector. That leads to an output from the NN with a shape of (17, 3), i.e. the concentrations of each species at each time. The jacobian will output an array of shape (17, 3, 17, 1), and we have to extract the pieces we want from that. The first and third dimensions are related to the time steps. The second dimension is the species, and the last dimension is nothing here, but is there because the input is in a column. I use some fancy indexing on the array to get the desired arrays of the derivatives. This is not obvious out of the box. I only figured this out by direct comparison of the data from a numerical solution and the output of the jacobian. Here I show how to do that, and make sure that the derivatives we pull out are comparable to the derivatives defined by the ODEs above. Parity here means they are comparable.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = np.arange(&lt;span style="color: #006FE0;"&gt;len&lt;/span&gt;(sol.t))
plt.plot(jacC(params, sol.t.reshape([-1, 1]))[i, 0, i, 0],   -k1 * sol.y[0], &lt;span style="color: #008000;"&gt;'ro'&lt;/span&gt;)
plt.plot(jacC(params, sol.t.reshape([-1, 1]))[i, 1, i, 0],   -k2 * sol.y[1] + k1 * sol.y[0], &lt;span style="color: #008000;"&gt;'bo'&lt;/span&gt;)
plt.plot(jacC(params, sol.t.reshape([-1, 1]))[i, 2, i, 0],   k2 * sol.y[1], &lt;span style="color: #008000;"&gt;'go'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
[&amp;lt;matplotlib.lines.Line2D at 0x118a2e860&amp;gt;]

&lt;/pre&gt;



&lt;p&gt;
&lt;img src="/media/d0abffb7b8615837cad7f2cceb378aac-65837yLF.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
Note this is pretty inefficient. It requires a lot of calculations (the jacobian here has &lt;code class="src src-python"&gt;&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(17*3*17)&lt;/code&gt; &lt;code&gt;867&lt;/code&gt; elements) to create the jacobian, and we don't need most of them. You could avoid this by creating separate neural networks for each species, and then just use elementwise_grad on each one. Alternatively, one might be able to more efficiently compute some vector-jacobian product. Nevertheless, it looks like we can get the correct derivatives out of the neural network, we just need a convenient function to return them. Here is one such function for this problem, using a fancier slicing and reshaping to get the derivative array.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Derivatives&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;jac&lt;/span&gt; = jacobian(C, 1)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dCdt&lt;/span&gt;(params, t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = np.arange(&lt;span style="color: #006FE0;"&gt;len&lt;/span&gt;(t))
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; jac(params, t)[i, :, i].reshape((&lt;span style="color: #006FE0;"&gt;len&lt;/span&gt;(t), 3))
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div id="outline-container-orgf85faff" class="outline-2"&gt;
&lt;h2 id="orgf85faff"&gt;&lt;span class="section-number-2"&gt;4&lt;/span&gt; Solving the system of ODEs with a neural network&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-4"&gt;
&lt;p&gt;
Finally, we are ready to try solving the ODEs solely by the neural network approach. We reinitialize the neural network first, and define a time grid to solve it on.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt; = np.linspace(0, 10, 25).reshape((-1, 1))
&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = init_random_params(0.1, layer_sizes=[1, 8, 3])
&lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; = 0    &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;number of training steps&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;N&lt;/span&gt; = 501  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;epochs for training&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;et&lt;/span&gt; = 0.0 &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;total elapsed time&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We define our objective function. This function will be zero at the perfect solution, and has contributions for each mole balance and the initial conditions. It could make sense to put additional penalties for things like negative concentrations, or the sum of concentrations is a constant, but we do not do that here, and it does not seem to be necessary.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;objective&lt;/span&gt;(params, step):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;Ca&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Cb&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Cc&lt;/span&gt; = C(params, t).T
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;dCadt&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;dCbdt&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;dCcdt&lt;/span&gt; = dCdt(params, t).T

&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;z1&lt;/span&gt; = np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;((dCadt + k1 * Ca)**2)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;z2&lt;/span&gt; = np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;((dCbdt - k1 * Ca + k2 * Cb)**2)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;z3&lt;/span&gt; = np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;((dCcdt - k2 * Cb)**2)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;ic&lt;/span&gt; = np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;((np.array([Ca[0], Cb[0], Cc[0]]) - C0)**2)  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;initial conditions&lt;/span&gt;
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; z1 + z2 + z3 + ic

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;callback&lt;/span&gt;(params, step, g):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;if&lt;/span&gt; step % 100 == 0:
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(&lt;span style="color: #008000;"&gt;"Iteration {0:3d} objective {1}"&lt;/span&gt;.&lt;span style="color: #006FE0;"&gt;format&lt;/span&gt;(step,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; objective(params, step)))

objective(params, 0)  &lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;make sure the objective is scalar&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
5.2502237371050295

&lt;/pre&gt;

&lt;p&gt;
Finally, we run the optimization. I also manually ran this block several times.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; time
&lt;span style="color: #BA36A5;"&gt;t0&lt;/span&gt; = time.time()

&lt;span style="color: #BA36A5;"&gt;params&lt;/span&gt; = adam(grad(objective), params,
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt; step_size=0.001, num_iters=N, callback=callback)

&lt;span style="color: #BA36A5;"&gt;i&lt;/span&gt; += N
&lt;span style="color: #BA36A5;"&gt;t1&lt;/span&gt; = (time.time() - t0) / 60
&lt;span style="color: #BA36A5;"&gt;et&lt;/span&gt; += t1

plt.plot(t, C(params, t), sol.t, sol.y.T, &lt;span style="color: #008000;"&gt;'o'&lt;/span&gt;)
plt.legend([&lt;span style="color: #008000;"&gt;'Ann'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'Bnn'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'Cnn'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'A'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'B'&lt;/span&gt;, &lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;])
plt.xlabel(&lt;span style="color: #008000;"&gt;'Time'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'C'&lt;/span&gt;)
&lt;span style="color: #0000FF;"&gt;print&lt;/span&gt;(f&lt;span style="color: #008000;"&gt;'{t1:1.1f} minutes elapsed this time. Total time = {et:1.2f} min. Total epochs = {i}.'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;pre class="example"&gt;
Iteration   0 objective 0.00047651643957525214
Iteration 100 objective 0.0004473301532609342
Iteration 200 objective 0.00041218410058863227
Iteration 300 objective 0.00037161526137030344
Iteration 400 objective 0.000327567400443358
Iteration 500 objective 0.0002836975879675981
0.6 minutes elapsed this time. Total time = 4.05 min. Total epochs = 3006.


&lt;/pre&gt;


&lt;p&gt;
&lt;img src="/media/d0abffb7b8615837cad7f2cceb378aac-65837AXS.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
The effort seems to have been worth it though, we get a pretty good solution from our neural network.
&lt;/p&gt;

&lt;p&gt;
We can check the accuracy of the derivatives by noting the sum of the derivatives in this case should be zero. Here you can see that the sum is pretty small. It would take additional optimization to a lower error to get this to be smaller.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;plt.plot(t, np.&lt;span style="color: #006FE0;"&gt;sum&lt;/span&gt;(dCdt(params, t), axis=1))
plt.xlabel(&lt;span style="color: #008000;"&gt;'Time'&lt;/span&gt;)
plt.ylabel(r&lt;span style="color: #008000;"&gt;'$\Sigma dC/dt$'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/d0abffb7b8615837cad7f2cceb378aac-65837NhY.png"&gt; 
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;div id="outline-container-orgbbded67" class="outline-2"&gt;
&lt;h2 id="orgbbded67"&gt;&lt;span class="section-number-2"&gt;5&lt;/span&gt; Summary&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-5"&gt;
&lt;p&gt;
In the end, this method is illustrated to work for systems of ODEs also. There is some subtlety in how to get the relevant derivatives from the jacobian, but after that, it is essentially the same. I think it would be &lt;i&gt;much&lt;/i&gt; faster to do this with separate neural networks for each function in the solution because then you do not need the jacobian, you can use elementwise_grad.
&lt;/p&gt;

&lt;p&gt;
This is not faster than direct numerical integration. One benefit to this solution over a numerical solution is we get an actual continuous function as the solution, rather than an array of data.  This solution is not reliable at longer times, but then again neither is extrapolation of numeric data. It could be interesting to explore if this has any benefits for stiff equations. Maybe another day. For now, I am declaring victory for autograd on this problem.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/11/02/Solving-coupled-ODEs-with-a-neural-network-and-autograd.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.14&lt;/p&gt;]]></content:encoded>
    </item>
    <item>
      <title>A differentiable ODE integrator for sensitivity analysis</title>
      <link>http://jkitchin.github.io/blog/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis</link>
      <pubDate>Thu, 11 Oct 2018 12:13:01 EDT</pubDate>
      <category><![CDATA[autograd]]></category>
      <category><![CDATA[sensitivity]]></category>
      <category><![CDATA[ode]]></category>
      <guid isPermaLink="false">x1b-cquyAyl6Ic4uE4zs0jj8a6U=</guid>
      <description>A differentiable ODE integrator for sensitivity analysis</description>
      <content:encoded><![CDATA[


&lt;p&gt;
&lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2018/10/10/Autograd-and-the-derivative-of-an-integral-function/"&gt;Last time&lt;/a&gt; I wrote about using automatic differentiation to find the derivative of an integral function. A related topic is finding derivatives of functions that are defined by differential equations. We typically use a numerical integrator to find solutions to these functions. Those leave us with numeric solutions which we then have to use to approximate derivatives. What if the integrator itself was differentiable? It is after all, just a program, and automatic differentiation should be able to tell us the derivatives of functions that use them. This is not a new idea, there is already a differentiable ODE solver in &lt;a href="https://www.tensorflow.org/versions/r1.1/api_docs/python/tf/contrib/integrate/odeint"&gt;Tensorflow&lt;/a&gt;. Here I will implement a simple Runge Kutta integrator and then show how we can use automatic differentiation to do &lt;i&gt;sensitivity analysis&lt;/i&gt; on the numeric solution.
&lt;/p&gt;

&lt;p&gt;
I previously used autograd for sensitivity analysis on &lt;i&gt;analytical&lt;/i&gt; solutions in this &lt;a href="http://kitchingroup.cheme.cmu.edu/blog/2017/11/15/Sensitivity-analysis-using-automatic-differentiation-in-Python/"&gt;post&lt;/a&gt;. Here I will compare those results to the results from sensitivity analysis on the &lt;i&gt;numerical solutions&lt;/i&gt;.
&lt;/p&gt;

&lt;p&gt;
First, we need an autograd compatible ODE integrator. Here is one implementation of a simple, fourth order Runge-Kutta integrator. Usually, I would use indexing to do this, but that was not compatible with autograd, so I just accumulate the solution. This is a limitation of autograd, and it is probably not an issue with Tensorflow, for example, or probably pytorch. Those are more sophisticated, and more difficult to use packages than autograd. Here I am just prototyping an idea, so we stick with autograd.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; autograd.numpy &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; np
&lt;span style="color: #0000FF;"&gt;from&lt;/span&gt; autograd &lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; grad
%matplotlib inline
&lt;span style="color: #0000FF;"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span style="color: #0000FF;"&gt;as&lt;/span&gt; plt

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;rk4&lt;/span&gt;(f, tspan, y0, N=50):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;x&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;h&lt;/span&gt; = np.linspace(*tspan, N, retstep=&lt;span style="color: #D0372D;"&gt;True&lt;/span&gt;)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = []
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; = y + [y0]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; i &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; &lt;span style="color: #006FE0;"&gt;range&lt;/span&gt;(0, &lt;span style="color: #006FE0;"&gt;len&lt;/span&gt;(x) - 1):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;k1&lt;/span&gt; = h * f(x[i], y[i])
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;k2&lt;/span&gt; = h * f(x[i] + h / 2, y[i] + k1 / 2)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;k3&lt;/span&gt; = h * f(x[i] + h / 2, y[i] + k2 / 2)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;k4&lt;/span&gt; = h * f(x[i + 1], y[i] + k3)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;y&lt;/span&gt; += [y[-1] + (k1 + (2 * k2) + (2 * k3) + k4) / 6]
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; x, y
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we just check that it works as expected:
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;Ca0&lt;/span&gt; = 1.0
&lt;span style="color: #BA36A5;"&gt;k1&lt;/span&gt; = &lt;span style="color: #BA36A5;"&gt;k_1&lt;/span&gt; = 3.0

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dCdt&lt;/span&gt;(t, Ca):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -k1 * Ca + k_1 * (Ca0 - Ca)

&lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Ca&lt;/span&gt; = rk4(dCdt, (0, 0.5), Ca0)

&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;analytical_A&lt;/span&gt;(t, k1, k_1):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Ca0 / (k1 + k_1) * (k1 * np.exp(-(k1 + k_1) * t) + k_1)

plt.plot(t, Ca, label=&lt;span style="color: #008000;"&gt;'RK4'&lt;/span&gt;)
plt.plot(t, analytical_A(t, k1, k_1), &lt;span style="color: #008000;"&gt;'r--'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'analytical'&lt;/span&gt;)
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'[A]'&lt;/span&gt;)
plt.xlim([0, 0.5])
plt.ylim([0.5, 1])
plt.legend()
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/6a1c5e4c896d855655b8da8b54214af3-90490Zdl.png"&gt; 
&lt;/p&gt;

&lt;p&gt;
That looks fine, we cannot visually distinguish the two solutions, and they both look like Figure 1 in this &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.428.6699&amp;amp;rep=rep1&amp;amp;type=pdf"&gt;paper&lt;/a&gt;. Note the analytical solution is not that complex, but it would not take much variation of the rate law to make this solution difficult to derive.
&lt;/p&gt;

&lt;p&gt;
Next, to do sensitivity analysis, we need to define a function for \(A\) that depends on the rate constants, so we can take a derivative of it with respect to the parameters we want the sensitivity from. We seek the derivatives: \(\frac{dC_A}{dk_1}\) and \(\frac{dC_A}{dk_{-1}}\). Here is a function that does that. It will return the value of [A] at \(t\) given an initial concentration and the rate constants.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;A&lt;/span&gt;(Ca0, k1, k_1, t):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;def&lt;/span&gt; &lt;span style="color: #006699;"&gt;dCdt&lt;/span&gt;(t, Ca):
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; -k1 * Ca + k_1 * (Ca0 - Ca)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #BA36A5;"&gt;t&lt;/span&gt;, &lt;span style="color: #BA36A5;"&gt;Ca_&lt;/span&gt; = rk4(dCdt, (0, t), Ca0)
&lt;span style="color: #9B9B9B; background-color: #EDEDED;"&gt; &lt;/span&gt;   &lt;span style="color: #0000FF;"&gt;return&lt;/span&gt; Ca_[-1]

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;Here are the two derivatives we seek.&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;dCadk1&lt;/span&gt; = grad(A, 1)
&lt;span style="color: #BA36A5;"&gt;dCadk_1&lt;/span&gt; = grad(A, 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
We also use autograd to get the derivatives from the analytical solution for comparison.
&lt;/p&gt;
&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;dAdk1&lt;/span&gt; = grad(analytical_A, 1)
&lt;span style="color: #BA36A5;"&gt;dAdk_1&lt;/span&gt; = grad(analytical_A, 2)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Now, we can plot the sensitivities over the time range and compare them. I use the list comprehensions here because the AD functions aren't vectorized.
&lt;/p&gt;

&lt;div class="org-src-container"&gt;
&lt;pre class="src src-ipython"&gt;&lt;span style="color: #BA36A5;"&gt;tspan&lt;/span&gt; = np.linspace(0, 0.5)

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;From the numerical solutions&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;k1_sensitivity&lt;/span&gt; = [dCadk1(1.0, 3.0, 3.0, t) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; t &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; tspan]
&lt;span style="color: #BA36A5;"&gt;k_1_sensitivity&lt;/span&gt; = [dCadk_1(1.0, 3.0, 3.0, t) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; t &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; tspan]

&lt;span style="color: #8D8D84;"&gt;# &lt;/span&gt;&lt;span style="color: #8D8D84; font-style: italic;"&gt;from the analytical solutions&lt;/span&gt;
&lt;span style="color: #BA36A5;"&gt;ak1_sensitivity&lt;/span&gt; = [dAdk1(t, 3.0, 3.0) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; t &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; tspan]
&lt;span style="color: #BA36A5;"&gt;ak_1_sensitivity&lt;/span&gt; = [dAdk_1(t, 3.0, 3.0) &lt;span style="color: #0000FF;"&gt;for&lt;/span&gt; t &lt;span style="color: #0000FF;"&gt;in&lt;/span&gt; tspan]

plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(ak1_sensitivity), &lt;span style="color: #008000;"&gt;'b-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'k1 analytical'&lt;/span&gt;)
plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(k1_sensitivity), &lt;span style="color: #008000;"&gt;'y--'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'k1 numerical'&lt;/span&gt;)

plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(ak_1_sensitivity), &lt;span style="color: #008000;"&gt;'r-'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'k_1 analytical'&lt;/span&gt;)
plt.plot(tspan, np.&lt;span style="color: #006FE0;"&gt;abs&lt;/span&gt;(k_1_sensitivity), &lt;span style="color: #008000;"&gt;'k--'&lt;/span&gt;, label=&lt;span style="color: #008000;"&gt;'k_1 numerical'&lt;/span&gt;)

plt.xlim([0, 0.5])
plt.ylim([0, 0.1])
plt.legend()
plt.xlabel(&lt;span style="color: #008000;"&gt;'t'&lt;/span&gt;)
plt.ylabel(&lt;span style="color: #008000;"&gt;'sensitivity'&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;img src="/media/6a1c5e4c896d855655b8da8b54214af3-90490mnr.png"&gt; 
&lt;/p&gt;



&lt;p&gt;
The two approaches are indistinguishable on paper. I will note that it takes a lot longer to make the graph from the numerical solution than from the analytical solution because at each point you have to reintegrate the solution from the beginning, which is certainly not efficient. That is an implementation detail that could probably be solved, at the expense of making the code look different than the way I would normally think about the problem.
&lt;/p&gt;

&lt;p&gt;
On the other hand, it is remarkable we get derivatives from the numerical solution, &lt;i&gt;and they look really good&lt;/i&gt;! That means we could do sensitivity analysis on more complex reactions, and still have a reasonable way to get sensitivity. The work here is a long way from that. My simple Runge-Kutta integrator isn't directly useful for systems of ODEs, it wouldn't work well on stiff problems, the step size isn't adaptive, etc. The Tensorflow implementation might be more suitable for this though, and maybe this post is motivation to learn how to use it!
&lt;/p&gt;
&lt;p&gt;Copyright (C) 2018 by John Kitchin. See the &lt;a href="/copying.html"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;
&lt;p&gt;&lt;a href="/org/2018/10/11/A-differentiable-ODE-integrator-for-sensitivity-analysis.org"&gt;org-mode source&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Org-mode version = 9.1.13&lt;/p&gt;]]></content:encoded>
    </item>
  </channel>
</rss>
