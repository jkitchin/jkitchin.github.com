

<!doctype html>
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]>    <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]>    <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html lang="en" class="no-js"> <!--<![endif]-->
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Kitchin Research Group</title>
  <meta name="google-site-verification" content="CGcacJdHc2YoZyI0Vey9XRA5qwhhFDzThKJezbRFcJ4" />
  <meta name="description" content="Chemical Engineering at Carnegie Mellon University">
  <meta name="author" content="John Kitchin">
  <link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
  <link rel="alternate" type="application/atom+xml" title="Atom 1.0" href="/blog/feed/atom" />
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">

  <link rel="stylesheet" href="/css/base.css?v=1">
  <link rel="stylesheet" href="/css/grid.css?v=1">
  <link rel="stylesheet" media="handheld" href="/css/handheld.css?v=1">
  <link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />

  <script src="/js/libs/modernizr-1.7.min.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
  <link rel="stylesheet" href="/themes/theme1/style.css?v=1">
<link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>

</head>
  <body>
    <div id="container" class="container container_12">
      <div id="main" role="main">
        <div id="main_block">
          <header>
<div id="header" class="header_gradient theme_font">
<table><tr><td>
    <h1><a href="/">The Kitchin Research Group</a></h1>
    <h2>Chemical Engineering at Carnegie Mellon University</h2>
</td>
<td colspan=100%><div style="float:right;width:100%;text-align:right;"> <span id='badgeCont737515' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont737515&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span></div>
</td></tr>
</table>
</div>
  <div id="navigation" class="grid_12">

    <ul class="theme_font">
      <li><a href="/blog"
             class="">Blog</a></li>

      <li><a href="/blog/archive"
             class="">Archives</a></li>

      <li><a href="/publications.html">Publications</a></li>

      <li><a href="/research.html"
             class="">Research</a></li>

      <li><a href="/categories.html"
             class="">Categories</a></li>

      <li><a href="/about.html"
             class="">About us</a></li>

      <li><a href="/subscribe.html">Subscribe</a></li>

    </ul>
  </div>
</header>

          <div id="prose_block" class="grid_8">
            
  





<article>
  <div class="blog_post">
    <header>
      <div id="Smooth-transitions-between-discontinuous-functions"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions/" rel="bookmark" title="Permanent Link to Smooth transitions between discontinuous functions">Smooth transitions between discontinuous functions</a></h2>
      <p><small><span class="blog_post_date">Posted January 31, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a>, <a href='/blog/category/miscellaneous/'>miscellaneous</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 06:25 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/30/smooth-transitions-between-discontinuous-functions/" >original post</a>
</p>

<p>
In <a href="http://matlab.cheme.cmu.edu/2011/10/27/compute-pipe-diameter/" >Post 1280</a> we used a correlation for the Fanning friction factor for turbulent flow in a pipe. For laminar flow (Re &lt; 3000), there is another correlation that is commonly used: \(f_F = 16/Re\). Unfortunately, the correlations for laminar flow and turbulent flow have different values at the transition that should occur at Re = 3000. This discontinuity can cause a lot of problems for numerical solvers that rely on derivatives.
</p>

<p>
Today we examine a strategy for smoothly joining these two functions. First we define the two functions.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fF_laminar</span>(Re):
    <span style="color: #8b0000;">return</span> 16.0 / Re

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fF_turbulent_unvectorized</span>(Re):
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Nikuradse correlation for turbulent flow</span>
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)</span>
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we have to solve this equation to get f</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(f):
        <span style="color: #8b0000;">return</span> 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    fguess = 0.01
    f, = fsolve(func, fguess)
    <span style="color: #8b0000;">return</span> f

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this enables us to pass vectors to the function and get vectors as</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">solutions</span>
fF_turbulent = np.vectorize(fF_turbulent_unvectorized)
</pre>
</div>

<p>
Now we plot the correlations.
</p>

<div class="org-src-container">

<pre class="src src-python">Re1 = np.linspace(500, 3000)
f1 = fF_laminar(Re1)

Re2 = np.linspace(3000, 10000)
f2 = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label=<span style="color: #228b22;">'laminar'</span>)
plt.plot(Re2, f2, label=<span style="color: #228b22;">'turbulent'</span>)
plt.xlabel(<span style="color: #228b22;">'Re'</span>)
plt.ylabel(<span style="color: #228b22;">'$f_F$'</span>)
plt.legend()
plt.savefig(<span style="color: #228b22;">'images/smooth-transitions-1.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x051FF630&gt;
[&lt;matplotlib.lines.Line2D object at 0x05963C10&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0576DD70&gt;]
&lt;matplotlib.text.Text object at 0x0577CFF0&gt;
&lt;matplotlib.text.Text object at 0x05798790&gt;
&lt;matplotlib.legend.Legend object at 0x05798030&gt;
</pre>

<p><img src="/img/./images/smooth-transitions-1.png"><p>

<p>
You can see the discontinuity at Re = 3000. What we need is a method to join these two functions smoothly. We can do that with a sigmoid function.
Sigmoid functions
</p>

<p>
A sigmoid function smoothly varies from 0 to 1 according to the equation: \(\sigma(x) = \frac{1}{1 + e^{-(x-x0)/\alpha}}\). The transition is centered on \(x0\), and \(\alpha\) determines the width of the transition.
</p>

<div class="org-src-container">

<pre class="src src-python">x = np.linspace(-4,4);
y = 1.0 / (1 + np.exp(-x / 0.1))
plt.figure(2); plt.clf()
plt.plot(x, y)
plt.xlabel(<span style="color: #228b22;">'x'</span>); plt.ylabel(<span style="color: #228b22;">'y'</span>); plt.title(<span style="color: #228b22;">'$\sigma(x)$'</span>)
plt.savefig(<span style="color: #228b22;">'images/smooth-transitions-sigma.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x0596CF10&gt;
[&lt;matplotlib.lines.Line2D object at 0x05A26D90&gt;]
&lt;matplotlib.text.Text object at 0x059A6050&gt;
&lt;matplotlib.text.Text object at 0x059AF0D0&gt;
&lt;matplotlib.text.Text object at 0x059BEA30&gt;
</pre>

<p><img src="/img/./images/smooth-transitions-sigma.png"><p>

<p>
If we have two functions, \(f_1(x)\) and \(f_2(x)\) we want to smoothly join, we do it like this: \(f(x) = (1-\sigma(x))f_1(x) + \sigma(x)f_2(x)\). There is no formal justification for this form of joining, it is simply a mathematical convenience to get a numerically smooth function. Other functions besides the sigmoid function could also be used, as long as they smoothly transition from 0 to 1, or from 1 to zero.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fanning_friction_factor</span>(Re):
    <span style="color: #228b22;">'''combined, continuous correlation for the fanning friction factor.</span>
<span style="color: #228b22;">    the alpha parameter is chosen to provide the desired smoothness.</span>
<span style="color: #228b22;">    The transition region is about +- 4*alpha. The value 450 was</span>
<span style="color: #228b22;">    selected to reasonably match the shape of the correlation</span>
<span style="color: #228b22;">    function provided by Morrison (see last section of this file)'''</span>
    sigma =  1. / (1 + np.exp(-(Re - 3000.0) / 450.0));
    f = (1-sigma) * fF_laminar(Re) + sigma * fF_turbulent(Re)
    <span style="color: #8b0000;">return</span> f

Re = np.linspace(500,10000);
f = fanning_friction_factor(Re);

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">add data to figure 1</span>
plt.figure(1)
plt.plot(Re,f, label=<span style="color: #228b22;">'smooth transition'</span>)
plt.xlabel(<span style="color: #228b22;">'Re'</span>)
plt.ylabel(<span style="color: #228b22;">'$f_F$'</span>)
plt.legend()
plt.savefig(<span style="color: #228b22;">'images/smooth-transitions-3.png'</span>)
</pre>
</div>

<pre class="example">
... ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... &lt;matplotlib.figure.Figure object at 0x051FF630&gt;
[&lt;matplotlib.lines.Line2D object at 0x05786310&gt;]
&lt;matplotlib.text.Text object at 0x0577CFF0&gt;
&lt;matplotlib.text.Text object at 0x05798790&gt;
&lt;matplotlib.legend.Legend object at 0x05A302B0&gt;
</pre>

<p><img src="/img/./images/smooth-transitions-3.png"><p>

<p>
You can see that away from the transition the combined function is practically equivalent to the original two functions. That is because away from the transition the sigmoid function is 0 or 1. Near Re = 3000 is a smooth transition from one curve to the other curve.
</p>

<p>
<a href="http://www.chem.mtu.edu/~fmorriso/DataCorrelationForSmoothPipes2010.pdf" >Morrison</a> derived a single function for the friction factor correlation over all Re: \(f = \frac{0.0076\left(\frac{3170}{Re}\right)^{0.165}}{1 + \left(\frac{3171}{Re}\right)^{7.0}} + \frac{16}{Re}\). Here we show the comparison with the approach used above. The friction factor differs slightly at high Re, because Morrison's is based on the Prandlt correlation, while the work here is based on the Nikuradse correlation. They are similar, but not the same.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">add this correlation to figure 1</span>
h, = plt.plot(Re, 16.0/Re + (0.0076 * (3170 / Re)**0.165) / (1 + (3170.0 / Re)**7))

ax = plt.gca()
handles, labels = ax.get_legend_handles_labels()

handles.append(h)
labels.append(<span style="color: #228b22;">'Morrison'</span>)
ax.legend(handles, labels)
plt.savefig(<span style="color: #228b22;">'images/smooth-transitions-morrison.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &lt;matplotlib.legend.Legend object at 0x05A5AEB0&gt;
</pre>

<p><img src="/img/./images/smooth-transitions-morrison.png"><p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
The approach demonstrated here allows one to smoothly join two discontinuous functions that describe physics in different regimes, and that must transition over some range of data. It should be emphasized that the method has no physical basis, it simply allows one to create a mathematically smooth function, which could be necessary for some optimizers or solvers to work.</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/01/31/Smooth-transitions-between-discontinuous-functions.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Linear-programming-example-with-inequality-constraints"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/01/31/Linear-programming-example-with-inequality-constraints/" rel="bookmark" title="Permanent Link to Linear programming example with inequality constraints">Linear programming example with inequality constraints</a></h2>
      <p><small><span class="blog_post_date">Posted January 31, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/linear-programming/'>linear programming</a>, <a href='/blog/category/optimization/'>optimization</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated February 27, 2013 at 02:44 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>

<a href="http://matlab.cheme.cmu.edu/2011/10/21/linear-programming-example-with-inequality-constraints/" >Matlab post</a>
</p>

<p>
adapted from <a href="http://www.matrixlab-examples.com/linear-programming.html" >http://www.matrixlab-examples.com/linear-programming.html</a> which solves this problem with fminsearch.
</p>

<p>
Let us suppose that a merry farmer has 75 roods (4 roods = 1 acre) on which to plant two crops: wheat and corn. To produce these crops, it costs the farmer (for seed, water, fertilizer, etc. ) $120 per rood for the wheat, and $210 per rood for the corn. The farmer has $15,000 available for expenses, but after the harvest the farmer must store the crops while awaiting favorable or good market conditions. The farmer has storage space for 4,000 bushels. Each rood yields an average of 110 bushels of wheat or 30 bushels of corn. If the net profit per bushel of wheat (after all the expenses) is $1.30 and for corn is $2.00, how should the merry farmer plant the 75 roods to maximize profit?
</p>

<p>
Let \(x\) be the number of roods of wheat planted, and \(y\) be the number of roods of corn planted. The profit function is: \( P = (110)($1.3)x + (30)($2)y = 143x + 60y \)
</p>

<p>
There are some constraint inequalities, specified by the limits on expenses, storage and roodage. They are:
</p>

<p>
\(\$120x + \$210y <= \$15000\) (The total amount spent cannot exceed the amount the farm has)
</p>

<p>
\(110x + 30y <= 4000\) (The amount generated should not exceed storage space.)
</p>

<p>
\(x + y <= 75\) (We cannot plant more space than we have.)
</p>

<p>
\(0 <= x and 0 <= y \) (all amounts of planted land must be positive.)
</p>

<p>
To solve this problem, we cast it as a linear programming problem, which minimizes a function f(X) subject to some constraints. We create a proxy function for the negative of profit, which we seek to minimize.
</p>

<p>
f = -(143*x + 60*y)
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fmin_cobyla

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(X):
    <span style="color: #228b22;">'''objective function to minimize. It is the negative of profit,</span>
<span style="color: #228b22;">    which we seek to maximize.'''</span>
    x, y = X
    <span style="color: #8b0000;">return</span> -(143*x + 60*y)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">c1</span>(X):
    <span style="color: #228b22;">'Ensure 120x + 210y &lt;= 15000'</span>
    x,y = X
    <span style="color: #8b0000;">return</span> 15000 - 120 * x - 210*y

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">c2</span>(X):
    <span style="color: #228b22;">'ensure 110x + 30y &lt;= 4000'</span>
    x,y = X
    <span style="color: #8b0000;">return</span> 4000 - 110*x - 30 * y

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">c3</span>(X):
    <span style="color: #228b22;">'Ensure x + y is less than or equal to 75'</span>
    x,y = X
    <span style="color: #8b0000;">return</span> 75 - x - y

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">c4</span>(X):
    <span style="color: #228b22;">'Ensure x &gt;= 0'</span>
    <span style="color: #8b0000;">return</span> X[0]

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">c5</span>(X):
    <span style="color: #228b22;">'Ensure y &gt;= 0'</span>
    <span style="color: #8b0000;">return</span> X[1]

X = fmin_cobyla(objective, x0=[20, 30], cons=[c1, c2, c3, c4, c5])

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'We should plant {0:1.2f} roods of wheat.'</span>.format(X[0])
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'We should plant {0:1.2f} roods of corn'</span>.format(X[1])
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The maximum profit we can earn is ${0:1.2f}.'</span>.format(-objective(X))
</pre>
</div>

<pre class="example">
   Normal return from subroutine COBYLA

   NFVALS =   40   F =-6.315625E+03    MAXCV = 4.547474E-13
   X = 2.187500E+01   5.312500E+01
We should plant 21.88 roods of wheat.
We should plant 53.12 roods of corn
The maximum profit we can earn is $6315.62.
</pre>

<p>
This code is not exactly the same as the original <a href="http://matlab.cheme.cmu.edu/2011/10/21/linear-programming-example-with-inequality-constraints/" >post</a>, but we get to the same answer. The linear programming capability in scipy is currently somewhat limited in 0.10. It is a little better in 0.11, but probably not as advanced as Matlab. There are some external libraries available:
</p>

<ol>
<li><a href="http://abel.ee.ucla.edu/cvxopt/" >http://abel.ee.ucla.edu/cvxopt/</a>
</li>
<li><a href="http://openopt.org/LP" >http://openopt.org/LP</a>
</li>
</ol>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/01/31/Linear-programming-example-with-inequality-constraints.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/01/31/Linear-programming-example-with-inequality-constraints">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Curve-fitting-to-get-overlapping-peak-areas"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/01/29/Curve-fitting-to-get-overlapping-peak-areas/" rel="bookmark" title="Permanent Link to Curve fitting to get overlapping peak areas">Curve fitting to get overlapping peak areas</a></h2>
      <p><small><span class="blog_post_date">Posted January 29, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/data-analysis/'>data analysis</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated February 27, 2013 at 02:45 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      




<p>
Today we examine an approach to fitting curves to overlapping peaks to deconvolute them so we can estimate the area under each curve. We have a text file that contains data from a gas chromatograph with two peaks that overlap. We want the area under each peak to estimate the gas composition. You will see how to read the text file in, parse it to get the data for plotting and analysis, and then how to fit it.
</p>


<p>
A line like &ldquo;# of Points        9969&rdquo; tells us the number of points we have to read. The data starts after a line containing &ldquo;R.Time        Intensity&rdquo;. Here we read the number of points, and then get the data into arrays.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

datafile = <span style="color: #228b22;">'data/gc-data-21.txt'</span>

i = 0
<span style="color: #8b0000;">with</span> <span style="color: #8b0000;">open</span>(datafile) <span style="color: #8b0000;">as</span> f:
    lines = f.readlines()

<span style="color: #8b0000;">for</span> i,line <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(lines):
    <span style="color: #8b0000;">if</span> <span style="color: #228b22;">'# of Points'</span> <span style="color: #8b0000;">in</span> line:
        npoints = <span style="color: #8b0000;">int</span>(line.split()[-1])
    <span style="color: #8b0000;">elif</span> <span style="color: #228b22;">'R.Time        Intensity'</span> <span style="color: #8b0000;">in</span> line:
        i += 1
        <span style="color: #8b0000;">break</span>

<span style="color: #ff0000; font-weight: bold;"># now get the data</span>
t, intensity = [], []
<span style="color: #8b0000;">for</span> j <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(i, i + npoints):
    fields = lines[j].split()
    t += [<span style="color: #8b0000;">float</span>(fields[0])]
    intensity += [<span style="color: #8b0000;">int</span>(fields[1])]

t = np.array(t)
intensity = np.array(intensity)

<span style="color: #ff0000; font-weight: bold;"># now plot the data in the relevant time frame</span>
plt.plot(t, intensity)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #228b22;">'Time (s)'</span>)
plt.ylabel(<span style="color: #228b22;">'Intensity (arb. units)'</span>)
plt.savefig(<span style="color: #228b22;">'images/deconvolute-1.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... &gt;&gt;&gt; ... ... ... ... ... ... &gt;&gt;&gt; ... &gt;&gt;&gt; ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... [&lt;matplotlib.lines.Line2D object at 0x04CE6CF0&gt;]
(4, 6)
&lt;matplotlib.text.Text object at 0x04BBB950&gt;
&lt;matplotlib.text.Text object at 0x04BD0A10&gt;
</pre>

<p><img src="/img/./images/deconvolute-1.png"><p>

<p>
You can see there is a non-zero baseline. We will normalize that by the average between 4 and 4.4 seconds.
</p>

<div class="org-src-container">

<pre class="src src-python">intensity -= np.mean(intensity[(t&gt; 4) &amp; (t &lt; 4.4)])
plt.figure()
plt.plot(t, intensity)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #228b22;">'Time (s)'</span>)
plt.ylabel(<span style="color: #228b22;">'Intensity (arb. units)'</span>)
plt.savefig(<span style="color: #228b22;">'./images/deconvolute-2.png'</span>)
</pre>
</div>

<pre class="example">
&lt;matplotlib.figure.Figure object at 0x04CF7950&gt;
[&lt;matplotlib.lines.Line2D object at 0x04DF5C30&gt;]
(4, 6)
&lt;matplotlib.text.Text object at 0x04DDB690&gt;
&lt;matplotlib.text.Text object at 0x04DE3630&gt;
</pre>

<p><img src="/img/./images/deconvolute-2.png"><p>

<p>
The peaks are asymmetric, decaying gaussian functions. We define a function for this 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> erf

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">asym_peak</span>(t, pars):
    <span style="color: #228b22;">'from Anal. Chem. 1994, 66, 1294-1301'</span>
    a0 = pars[0]  <span style="color: #ff0000; font-weight: bold;"># peak area</span>
    a1 = pars[1]  <span style="color: #ff0000; font-weight: bold;"># elution time</span>
    a2 = pars[2]  <span style="color: #ff0000; font-weight: bold;"># width of gaussian</span>
    a3 = pars[3]  <span style="color: #ff0000; font-weight: bold;"># exponential damping term</span>
    f = (a0/2/a3*np.exp(a2**2/2.0/a3**2 + (a1 - t)/a3)
         *(erf((t-a1)/(np.sqrt(2.0)*a2) - a2/np.sqrt(2.0)/a3) + 1.0))
    <span style="color: #8b0000;">return</span> f
</pre>
</div>

<p>
To get two peaks, we simply add two peaks together.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">two_peaks</span>(t, *pars):    
    <span style="color: #228b22;">'function of two overlapping peaks'</span>
    a10 = pars[0]  <span style="color: #ff0000; font-weight: bold;"># peak area</span>
    a11 = pars[1]  <span style="color: #ff0000; font-weight: bold;"># elution time</span>
    a12 = pars[2]  <span style="color: #ff0000; font-weight: bold;"># width of gaussian</span>
    a13 = pars[3]  <span style="color: #ff0000; font-weight: bold;"># exponential damping term</span>
    a20 = pars[4]  <span style="color: #ff0000; font-weight: bold;"># peak area</span>
    a21 = pars[5]  <span style="color: #ff0000; font-weight: bold;"># elution time</span>
    a22 = pars[6]  <span style="color: #ff0000; font-weight: bold;"># width of gaussian</span>
    a23 = pars[7]  <span style="color: #ff0000; font-weight: bold;"># exponential damping term   </span>
    p1 = asym_peak(t, [a10, a11, a12, a13])
    p2 = asym_peak(t, [a20, a21, a22, a23])
    <span style="color: #8b0000;">return</span> p1 + p2
</pre>
</div>

<p>
To show the function is close to reasonable, we plot the fitting function with an initial guess for each parameter. The fit is not good, but we have only guessed the parameters for now. 
</p>


<div class="org-src-container">

<pre class="src src-python">parguess = (1500, 4.85, 0.05, 0.05, 5000, 5.1, 0.05, 0.1)
plt.figure()
plt.plot(t, intensity)
plt.plot(t,two_peaks(t, *parguess),<span style="color: #228b22;">'g-'</span>)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #228b22;">'Time (s)'</span>)
plt.ylabel(<span style="color: #228b22;">'Intensity (arb. units)'</span>)
plt.savefig(<span style="color: #228b22;">'images/deconvolution-3.png'</span>)
</pre>
</div>

<pre class="example">
&lt;matplotlib.figure.Figure object at 0x04FEF690&gt;
[&lt;matplotlib.lines.Line2D object at 0x05049870&gt;]
[&lt;matplotlib.lines.Line2D object at 0x04FEFA90&gt;]
(4, 6)
&lt;matplotlib.text.Text object at 0x0502E210&gt;
&lt;matplotlib.text.Text object at 0x050362B0&gt;
</pre>


<p><img src="/img/./images/deconvolution-3.png"><p>

<p>
Next, we use nonlinear curve fitting from scipy.optimize.curve_fit
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> curve_fit

popt, pcov = curve_fit(two_peaks, t, intensity, parguess)
<span style="color: #8b0000;">print</span> popt

plt.plot(t, two_peaks(t, *popt), <span style="color: #228b22;">'r-'</span>)
plt.legend([<span style="color: #228b22;">'data'</span>, <span style="color: #228b22;">'initial guess'</span>,<span style="color: #228b22;">'final fit'</span>])

plt.savefig(<span style="color: #228b22;">'images/deconvolution-4.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; [  1.31039283e+03   4.87474330e+00   5.55414785e-02   2.50610175e-02
   5.32556821e+03   5.14121507e+00   4.68236129e-02   1.04105615e-01]
&gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x0505BA10&gt;]
&lt;matplotlib.legend.Legend object at 0x05286270&gt;
</pre>

<p><img src="/img/./images/deconvolution-4.png"><p>

<p>
The fits are not perfect. The small peak is pretty good, but there is an unphysical tail on the larger peak, and a small mismatch at the peak. There is not much to do about that, it means the model peak we are using is not a good model for the peak. We will still integrate the areas though.
</p>

<div class="org-src-container">

<pre class="src src-python">pars1 = popt[0:4]
pars2 = popt[4:8]

peak1 = asym_peak(t, pars1)
peak2 = asym_peak(t, pars2)

area1 = np.trapz(peak1, t)
area2 = np.trapz(peak2, t)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Area 1 = {0:1.2f}'</span>.format(area1)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Area 2 = {0:1.2f}'</span>.format(area2)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Area 1 is {0:1.2%} of the whole area'</span>.format(area1/(area1 + area2))
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Area 2 is {0:1.2%} of the whole area'</span>.format(area2/(area1 + area2))

plt.figure()
plt.plot(t, intensity)
plt.plot(t, peak1, <span style="color: #228b22;">'r-'</span>)
plt.plot(t, peak2, <span style="color: #228b22;">'g-'</span>)
plt.xlim([4, 6])
plt.xlabel(<span style="color: #228b22;">'Time (s)'</span>)
plt.ylabel(<span style="color: #228b22;">'Intensity (arb. units)'</span>)
plt.legend([<span style="color: #228b22;">'data'</span>, <span style="color: #228b22;">'peak 1'</span>, <span style="color: #228b22;">'peak 2'</span>])
plt.savefig(<span style="color: #228b22;">'images/deconvolution-5.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Area 1 = 1310.39
Area 2 = 5325.57
&gt;&gt;&gt; Area 1 is 19.75% of the whole area
Area 2 is 80.25% of the whole area
&gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x05286ED0&gt;
[&lt;matplotlib.lines.Line2D object at 0x053A5AB0&gt;]
[&lt;matplotlib.lines.Line2D object at 0x05291D30&gt;]
[&lt;matplotlib.lines.Line2D object at 0x053B9810&gt;]
(4, 6)
&lt;matplotlib.text.Text object at 0x0529C4B0&gt;
&lt;matplotlib.text.Text object at 0x052A3450&gt;
&lt;matplotlib.legend.Legend object at 0x053B9ED0&gt;
</pre>

<p><img src="/img/./images/deconvolution-5.png"><p>

<p>
This sample was air, and the first peak is oxygen, and the second peak is nitrogen. we come pretty close to the actual composition of air, although it is low on the oxygen content. To do better, one would have to use a calibration curve.
</p>

<p>
In the end, the overlap of the peaks is pretty small, but it is still difficult to reliably and reproducibly deconvolute them. By using an algorithm like we have demonstrated here, it is possible at least to make the deconvolution reproducible.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Notable differences from Matlab</h2>
<div class="outline-text-2" id="text-1">
<ol>
<li>The order of arguments to np.trapz is reversed. 
</li>
<li>The order of arguments to the fitting function scipy.optimize.curve_fit is different than in Matlab.
</li>
<li>The scipy.optimize.curve_fit function expects a fitting function that has all parameters as arguments, where Matlab expects a vector of parameters.
</li>
</ol>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/01/29/Curve-fitting-to-get-overlapping-peak-areas.org">org-mode source</a><p>


    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/01/29/Curve-fitting-to-get-overlapping-peak-areas">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Mimicking-ode-events-in-python"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/01/28/Mimicking-ode-events-in-python/" rel="bookmark" title="Permanent Link to Mimicking ode events in python">Mimicking ode events in python</a></h2>
      <p><small><span class="blog_post_date">Posted January 28, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/ode/'>ode</a></span> | tags: 
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 06:34 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
The ODE functions in scipy.integrate do not directly support events like the functions in Matlab do. We can achieve something like it though, by digging into the guts of the solver, and writing a little code. In  previous <a href="http://matlab.cheme.cmu.edu/2011/09/10/counting-roots/" >example</a> I used an event to count the number of roots in a function by integrating the derivative of the function. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">myode</span>(f, x):
    <span style="color: #8b0000;">return</span> 3*x**2 + 12*x -4

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">event</span>(f, x):
    <span style="color: #228b22;">'an event is when f = 0'</span>
    <span style="color: #8b0000;">return</span> f 

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial conditions</span>
x0 = -8
f0 = -120

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">final x-range and step to integrate over.</span>
xf = 4   <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">final x value</span>
deltax = 0.45 <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">xstep</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">lists to store the results in</span>
X = [x0]
sol = [f0]
e = [event(f0, x0)]
events = []
x2 = x0
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">manually integrate at each time step, and check for event sign changes at each step</span>
<span style="color: #8b0000;">while</span> x2 &lt;= xf: <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">stop integrating when we get to xf</span>
    x1 = X[-1]
    x2 = x1 + deltax
    f1 = sol[-1]
    
    f2 = odeint(myode, f1, [x1, x2]) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">integrate from x1,f1 to x2,f2</span>
    X += [x2]
    sol += [f2[-1][0]]

    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now evaluate the event at the last position</span>
    e += [event(sol[-1], X[-1])]

    <span style="color: #8b0000;">if</span> e[-1] * e[-2] &lt; 0:
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Event detected where the sign of the event has changed. The</span>
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">event is between xPt = X[-2] and xLt = X[-1]. run a modified bisect</span>
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">function to narrow down to find where event = 0</span>
        xLt = X[-1]
        fLt = sol[-1]
        eLt = e[-1]

        xPt = X[-2]
        fPt = sol[-2]
        ePt = e[-2]

        j = 0
        <span style="color: #8b0000;">while</span> j &lt; 100:
            <span style="color: #8b0000;">if</span> np.abs(xLt - xPt) &lt; 1e-6:
                <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we know the interval to a prescribed precision now.</span>
                <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">print 'Event found between {0} and {1}'.format(x1t, x2t)</span>
                <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'x = {0}, event = {1}, f = {2}'</span>.format(xLt, eLt, fLt)
                events += [(xLt, fLt)]
                <span style="color: #8b0000;">break</span> <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">and return to integrating</span>

            m = (ePt - eLt)/(xPt - xLt) <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">slope of line connecting points</span>
                                        <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">bracketing zero</span>

            <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">estimated x where the zero is      </span>
            new_x = -ePt / m + xPt

            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now get the new value of the integrated solution at that new x</span>
            f  = odeint(myode, fPt, [xPt, new_x])
            new_f = f[-1][-1]
            new_e = event(new_f, new_x)
                        
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now check event sign change</span>
            <span style="color: #8b0000;">if</span> eLt * new_e &gt; 0:
                xPt = new_x
                fPt = new_f
                ePt = new_e
            <span style="color: #8b0000;">else:</span>
                xLt = new_x
                fLt = new_f
                eLt = new_e

            j += 1
        
        
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
plt.plot(X, sol)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">add event points to the graph</span>
<span style="color: #8b0000;">for</span> x,e <span style="color: #8b0000;">in</span> events:
    plt.plot(x,e,<span style="color: #228b22;">'bo '</span>)
plt.savefig(<span style="color: #228b22;">'images/event-ode-1.png'</span>)
</pre>
</div>

<pre class="example">
x = -6.00000006443, event = -4.63518112781e-15, f = -4.63518112781e-15
x = -1.99999996234, event = -1.40512601554e-15, f = -1.40512601554e-15
x = 1.99999988695, event = -1.11022302463e-15, f = -1.11022302463e-15
</pre>

<p><img src="/img/./images/event-ode-1.png"><p>

<p>
That was a lot of programming to do something like find the roots of the function! Below is an example of using a function coded into pycse to solve the same problem. It is a bit more sophisticated because you can define whether an event is terminal, and the direction of the approach to zero for each event.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> *
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">myode</span>(f, x):
    <span style="color: #8b0000;">return</span> 3*x**2 + 12*x -4

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">event1</span>(f, x):
    <span style="color: #228b22;">'an event is when f = 0 and event is decreasing'</span>
    isterminal = <span style="color: #8b0000;">True</span>
    direction = -1
    <span style="color: #8b0000;">return</span> f, isterminal, direction

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">event2</span>(f, x):
    <span style="color: #228b22;">'an event is when f = 0 and increasing'</span>
    isterminal = <span style="color: #8b0000;">False</span>
    direction = 1
    <span style="color: #8b0000;">return</span> f, isterminal, direction

f0 = -120

xspan = np.linspace(-8, 4)
X, F, TE, YE, IE = odelay(myode, f0, xspan, events=[event1, event2])

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
plt.plot(X, F, <span style="color: #228b22;">'.-'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">plot the event locations.use a different color for each event</span>
colors = <span style="color: #228b22;">'rg'</span>

<span style="color: #8b0000;">for</span> x,y,i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(TE, YE, IE):
    plt.plot([x], [y], <span style="color: #228b22;">'o'</span>, color=colors[i])
    
plt.savefig(<span style="color: #228b22;">'images/event-ode-2.png'</span>)
plt.show()
<span style="color: #8b0000;">print</span> TE, YE, IE
</pre>
</div>

<pre class="example">
[-6.0000001083101306, -1.9999999635550625] [-3.0871138978483259e-14, -7.7715611723760958e-16] [1, 0]
</pre>

<p><img src="/img/./images/event-ode-2.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/01/28/Mimicking-ode-events-in-python.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/01/28/Mimicking-ode-events-in-python">Discuss on Twitter</a>

  <hr class="interblog" />
  





<article>
  <div class="blog_post">
    <header>
      <div id="Solving-integral-equations-with-fsolve"></div>
      <h2 class="blog_post_title"><a href="/blog/2013/01/23/Solving-integral-equations-with-fsolve/" rel="bookmark" title="Permanent Link to Solving integral equations with fsolve">Solving integral equations with fsolve</a></h2>
      <p><small><span class="blog_post_date">Posted January 23, 2013 at 09:00 AM</span> | categories:
        <span class="blog_post_categories"><a href='/blog/category/nonlinear-algebra/'>nonlinear algebra</a></span> | tags: <a href='/blog/tag/reaction-engineering/'>reaction engineering</a>
      <p><small><span class="blog_post_date">Updated March 06, 2013 at 04:26 PM</span></small>
      </small></p>
    </header>
    <div class="post_prose">
      



<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/30/solving-integral-equations/" >Original post in Matlab</a>
</p>

<p>
Occasionally we have integral equations we need to solve in engineering problems, for example, the volume of plug flow reactor can be defined by this equation: \(V = \int_{Fa(V=0)}^{Fa} \frac{1}{r_a} dFa\) where \(r_a\) is the rate law. Suppose we know the reactor volume is 100 L, the inlet molar flow of A is 1 mol/L, the volumetric flow is 10 L/min, and \(r_a = -k Ca\), with \(k=0.23\) 1/min. What is the exit molar flow rate? We need to solve the following equation:
</p>

<p>
$$100 = \int_{Fa(V=0)}^{Fa} \frac{1}{-k Fa/\nu} dFa$$
</p>

<p>
We start by creating a function handle that describes the integrand. We can use this function in the quad command to evaluate the integral.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> quad
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

k = 0.23
nu = 10.0
Fao = 1.0

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">integrand</span>(Fa):
    <span style="color: #8b0000;">return</span> -1.0 / (k * Fa / nu)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Fa):
    integral,err = quad(integrand, Fao, Fa)
    <span style="color: #8b0000;">return</span> 100.0 - integral

vfunc = np.vectorize(func)
</pre>
</div>


<p>
We will need an initial guess, so we make a plot of our function to get an idea.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

f = np.linspace(0.01, 1)
plt.plot(f, vfunc(f))
plt.xlabel(<span style="color: #228b22;">'Molar flow rate'</span>)
plt.savefig(<span style="color: #228b22;">'images/integral-eqn-guess.png'</span>)
plt.show()
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x964a910&gt;]
&lt;matplotlib.text.Text object at 0x961fe50&gt;
</pre>

<p><img src="/img/./images/integral-eqn-guess.png"><p>

<p>
Now we can see a zero is near Fa = 0.1, so we proceed to solve the equation.
</p>

<div class="org-src-container">

<pre class="src src-python">Fa_guess = 0.1
Fa_exit, = fsolve(vfunc, Fa_guess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The exit concentration is {0:1.2f} mol/L'</span>.format(Fa_<span style="color: #8b0000;">exit</span> / nu)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; The exit concentration is 0.01 mol/L
</pre>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary notes</h2>
<div class="outline-text-2" id="text-1">
<p>
This example seemed a little easier in Matlab, where the quad function seemed to get automatically vectorized. Here we had to do it by hand.</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/01/23/Solving-integral-equations-with-fsolve.org">org-mode source</a><p>

    </div>
  </div>
</article>



<a href="https://twitter.com/share" class="twitter-share-button" data-via="johnkitchin">Share on Twitter</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


<a href="https://twitter.com/search?q=https://kitchingroup.cheme.cmu.edu/blog/2013/01/23/Solving-integral-equations-with-fsolve">Discuss on Twitter</a>

  <hr class="interblog" />
 <a href="../2">Next Page »</a>

          </div>
          <div id="sidebar" class="grid_4">
            <aside>
<section>
<script>
  (function() {
    var cx = '002533177287215655227:l7uvu35ssbc';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<gcse:search></gcse:search>
</section>

<section>
    <h1 class="post_header_gradient theme_font">Twitter</h1>
    <a class="twitter-timeline" href="https://twitter.com/johnkitchin" data-widget-id="545217643582881792">Tweets by @johnkitchin</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  <section>
    <h1 class="post_header_gradient theme_font">Links</h1>
    <ul>
      <li><a href="https://www.continuum.io">Anaconda Python</a></li>
      <li><a href="/pycse">Pycse</a></li>
      <li><a href="/dft-book">DFT-book</a></li>
    </ul>
  </section>

  <section>
    <h1 class="post_header_gradient theme_font">Latest Posts</h1>
    <ul>
      <li><a href="/blog/2025/02/01/New-publication-Improved-Uncertainty-Estimation-of-Graph-Neural-Network-Potentials-Using-Engineered-Latent-Space-Distance/">New publication - Improved Uncertainty Estimation of Graph Neural Network Potentials Using Engineered Latent Space Distance</a></li>
      <li><a href="/blog/2025/01/30/New-publication-Unifying-theory-of-electronic-descriptors-of-metal-surfaces-upon-perturbation/">New publication - Unifying theory of electronic descriptors of metal surfaces upon perturbation</a></li>
      <li><a href="/blog/2025/01/29/New-publication-The-Potential-of-Zero-Total-Charge-Predicts-Cation-Effects-for-the-Oxygen-Reduction-Reaction/">New publication - The Potential of Zero Total Charge Predicts Cation Effects for the Oxygen Reduction Reaction</a></li>
      <li><a href="/blog/2025/01/28/New-publication-Investigating-the-Error-Imbalance-of-Large-Scale-Machine-Learning-Potentials-in-Catalysis/">New publication - Investigating the Error Imbalance of Large-Scale Machine Learning Potentials in Catalysis</a></li>
      <li><a href="/blog/2025/01/27/New-publication-Structure-Sensitive-Reaction-Kinetics-of-Chiral-Molecules-on-Intrinsically-Chiral-Surfaces/">New publication - Structure Sensitive Reaction Kinetics of Chiral Molecules on Intrinsically Chiral Surfaces</a></li>
    </ul>
  </section>

<section>
<h1 class="post_header_gradient theme_font">Latest GitHub Repos</h1>
  <a href="https://github.com/jkitchin">@jkitchin</a> on GitHub.
  <ul id="my-github-projects">
        <li class="loading">Status updating&#8230;</li>
  </ul>

</section>
</aside>

          </div>
          <div class="clear"></div>
        </div>
      </div>
      
<footer>
  <div id="footer" class="grid_12">
    <div class="grid_8">
      <p>
        <a href="/blog/feed/index.xml">RSS</a>
      </p>
    </div>
    <div class="grid_4" id="credits">
      <p>
        Copyright 2025
        John Kitchin
      </p>
      <p>
        Powered by <a href="http://www.blogofile.com">Blogofile</a>
      </p>
    </div>
  </div>
</footer>

    </div>
      <script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/js/libs/jquery-1.5.1.min.js"%3E%3C/script%3E'))</script>
  <script src="/js/plugins.js"></script>
  <script src="/js/script.js"></script>
  <script src="/js/jquery.tweet.js"></script>  
  <script src="/js/site.js"></script>
  <!--[if lt IE 7 ]>
  <script src="js/libs/dd_belatedpng.js"></script>
  <script> DD_belatedPNG.fix('img, .png_bg');</script>
  <![endif]-->
 
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PH8NF4F0RE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PH8NF4F0RE');
</script>


  </body>
</html>






<script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"></script>
<script src="/js/git.js" type="text/javascript"></script>
<script type="text/javascript">
    $(function() {
     $("#my-github-projects").loadRepositories("jkitchin");
    });
</script>



