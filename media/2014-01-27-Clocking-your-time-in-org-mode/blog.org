* DONE Interesting online python sites
  CLOSED: [2014-01-27 Mon 13:51]
  :PROPERTIES:
  :categories: python
  :date:     2013/02/28 18:58:21
  :updated:  2013/02/28 19:01:33
  :permalink: http://jkitchin.github.com/blog/2013-02-28-interesting-online-python-sites/index.html
  :END:
I have come across some very interesting online, /interactive/ python sites recently.

- http://interactivepython.org has some interactive books with embedded python interpreters in the exercises.

- sympy actually has an [[http://live.sympy.org/][online shell]]! The [[http://docs.sympy.org/0.7.2/index.html][documentation]] has live examples in a shell you can use that is integrated with Sphinx.

Here are a few others I came across:
- https://www.pythonanywhere.com/try-ipython/ Ipython in your browser!
- http://www.trypython.org/#
- http://www.pythontutor.com/
- http://py-ide-online.appspot.com/
* TODO A gradebook app for emacs
  :PROPERTIES:
  :categories: emacs-lisp
  :END:
The goal is to create an emacs library to compute grades from a table in org-mode.

All grades are stored in a table with this structure.

#+tblname: gradebook
| first name | last name | email       | Hwk 1 | Hwk2 | exam1 | project 1 |
|            |           |             | 10    | 10   | 60    | 20        |
|------------+-----------+-------------+-------+------+-------+-----------|
| Jane       | Doe       | jd@cmu.edu  | A     | A    | B     | B         |
| John       | Dillinger | jdi@cmu.edu | B     | B/C  | A     | C         |
| jill       | wutz      | jw@cmu.edu  | D     | D    | R     | R         |

The grading system works like this:

1. Each assignment is worth a certain number of points (in row2).
2. Each assignment for a student is given a letter grade that indicates the quality and correctness of the work.
3. Each letter grade corresponds to a point multiplier:

| A++ |  1.0 |
| A+  | 0.95 |
| A   |  0.9 |
| A-  | 0.85 |
| A/B |  0.8 |
| B+  | 0.75 |
| B   |  0.7 |
| B-  | 0.65 |
| C/B |  0.6 |
| C+  | 0.55 |
| C   |  0.5 |
| C-  | 0.45 |
| C/D |  0.4 |
| D+  | 0.35 |
| D   |  0.3 |
| D-  | 0.25 |
| D/R |  0.2 |
| R+  | 0.15 |
| R   |  0.1 |
| R-  | 0.05 |
| R-- |  0.0 |

4. The number of points earned for an assignment is the point multiplier for the letter grade times the number of points for that assignment.
5. The overall grade is computed as sum(multiplier*points)/sum(points).
6. The overall letter grade is determined by the fraction of overall points received, mapped back on to the letter grade scale.

For example, in the table above, Jane Doe's grade is:

#+BEGIN_SRC emacs-lisp :results value
(let* ((multipliers '(0.9 0.9 0.7 0.7))
       (points '(10 10 60 20))
       (earned-points (mapcar* (lambda (a b) (* a b)) multipliers points))
       (total-earned-points (apply '+ earned-points))
       (total-points (apply '+ points)))
  (/ total-earned-points total-points))
#+END_SRC
#+RESULTS:
: 0.74

Which corresponds to an overall grade of B.

The goal here is to write emacs-lisp code to compute the overall grade of each student and convert it to an overall letter grade and write a little report.

We start by defining a variable to hold the multipliers. We will use an association list. We will prefix every variable and function with =gb/= to indicate it is part of our gradebook code.

#+BEGIN_SRC emacs-lisp
(defvar gb/MULTIPLIERS
  '(("A++" . 1.0)
    ("A+"   . 0.95)
    ("A"    . 0.9)
    ("A-"   . 0.85)
    ("A/B"  . 0.8)
    ("B+"   . 0.75)
    ("B"    . 0.7)
    ("B-"   . 0.65)
    ("B/C"  . 0.6)
    ("C+"   . 0.55)
    ("C"    . 0.5)
    ("C-"   . 0.45)
    ("C/D"  . 0.4)
    ("D+"   . 0.35)
    ("D"    . 0.3)
    ("D-"   . 0.25)
    ("D/R"  . 0.2)
    ("R+"   . 0.15)
    ("R"    . 0.1)
    ("R-"   . 0.05)
    ("R--"  . 0.0))
  "Numeric multipliers for letter grades")
#+END_SRC

#+RESULTS:

Here are two examples of using the gb/MULTIPLIER variable. It is an association list, so the multipler we want is the =cdr= of what the letter is associated with. We take the =cdr= of the return value, which is the numeric multiplier

#+BEGIN_SRC emacs-lisp :results value
(cdr (assoc "A" gb/MULTIPLIERS))
#+END_SRC

#+RESULTS:
: 0.9

We are going to write a series of functions that will compute the overall grade for each student.

A function we will need is to move the cursor into the table. Here is a function that will do that. This function moves the cursor to the beginning of the buffer, searches forward to find a line starting with a #+tblname: "name", and then moves the cursor to the next line which is in the table.

#+BEGIN_SRC emacs-lisp
(defun gb/goto-table (tblname)
  "move cursor into the table labeled tblname"
  (interactive)
  (goto-char (point-min))
  (search-forward-regexp (format "^#\\+tblname:\s+%s" tblname))
  (next-line))
#+END_SRC

#+RESULTS:

We use the function to move the cursor into the table, and then extract all the contents out.  We wrap the function call inside =save-excursion= so that the cursor gets put back where we want it. In this snippet, we use the (org-table-to-lisp) function to convert the table to a lisp structure which we can do further analysis on.

#+BEGIN_SRC emacs-lisp :results value verbatim
;; http://orgmode.org/worg/org-api/org-table-api.html
(require 'org-table) ; needed for access to org-table api

(defun gb/get-gradebook-lisp ()
  (interactive)
  (save-excursion
    (gb/goto-table "gradebook")
    (org-table-to-lisp)))

(gb/get-gradebook-lisp)
#+END_SRC
#+RESULTS:
: (("first name" "last name" "email" "Hwk 1" "Hwk2" "exam1" "project 1") ("" "" "" "10" "10" "60" "20") hline ("Jane" "Doe" "jd@cmu.edu" "A" "A" "B" "B") ("John" "Dillinger" "jdi@cmu.edu" "B" "B/C" "A" "C") ("jill" "wutz" "jw@cmu.edu" "D" "D" "R" "R"))

This is handy. Now we can think about processing the lisp data. Let us get the assignment names, and point values and save them in variables. The assignment names are in the first row, and start in column 3.

#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row1 (car (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENTS (mapcar 'identity (nthcdr 3 row1))))

gb/ASSIGNMENTS
#+END_SRC

#+RESULTS:
: ("Hwk 1" "Hwk2" "exam1" "project 1")

And now the point values, and total points.
#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row2 (cadr (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENT-POINTS (mapcar 'string-to-number (nthcdr 3 row2)))
 (setq gb/TOTAL-POINTS (apply '+ gb/ASSIGNMENT-POINTS)))

(format "ASSIGNMENT-POINTS=%s TOTAL-POINTS=%s" gb/ASSIGNMENT-POINTS gb/TOTAL-POINTS)
#+END_SRC

#+RESULTS:
: "ASSIGNMENT-POINTS=(10 10 60 20) TOTAL-POINTS=100"

So far, so good. Now, we need to get the letter grades for each student, and turn them into point multipliers.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-multiplier (LG)
  "return numeric multiplier for a letter grade"
  (interactive)
  (cdr (assoc (upcase LG) gb/MULTIPLIERS)))

(defun gb/get-multipliers(LGS)
  "apply get-multiplier to a list of letter grades"
  (interactive)
  (mapcar 'gb/get-multiplier LGS))

(defun gb/get-all-student-multipliers ()
  (mapcar 'gb/get-multipliers
          (mapcar (lambda (x)
                    (nthcdr 3 x))
                  (cdddr (gb/get-gradebook-lisp)))))

(gb/get-all-student-multipliers)
#+END_SRC

#+RESULTS:
: ((0.9 0.9 0.7 0.7) (0.7 0.6 0.9 0.5) (0.3 0.3 0.1 0.1))


Finally, we need the product of each multiplier with the gb/ASSIGNMENT-POINTS. This needs some care; some grades may be nil, which we cannot multiply. For now we neglect this detail.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-earned-points (multipliers)
  (mapcar* (lambda (a  b) (* a b)) multipliers gb/ASSIGNMENT-POINTS))

(defun gb/get-all-earned-points ()
  "returns total points earned by each student"
  (mapcar 'gb/get-earned-points  (gb/get-all-student-multipliers)))

(gb/get-all-earned-points)
#+END_SRC

#+RESULTS:
: ((9.0 9.0 42.0 14.0) (7.0 6.0 54.0 10.0) (3.0 3.0 6.0 2.0))

Next, we need to sum all the points and divide by the total points to get the overall numeric grade.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-all-numeric-grades ()
(mapcar (lambda (x)
          (/ (apply '+ x) gb/TOTAL-POINTS))
          (gb/get-all-earned-points)))

(gb/get-all-numeric-grades)
#+END_SRC

#+RESULTS:
: (0.74 0.77 0.14)

And finally, convert the numeric grades to letter grades. This involves finding the highest letter grade multiplier that the overall grade is larger than.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-final-letter-grade (grade)
 (dolist (pair gb/MULTIPLIERS letter-grade)
   (if (< (cdr pair) grade)
       (progn
         (setq letter-grade (car pair))
         (return letter-grade)))))

(mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))
#+END_SRC

#+RESULTS:
: ("B" "B+" "R")

That looks good. Now, let's make a final report of the results.

#+BEGIN_SRC emacs-lisp :results value
(let ((emails (mapcar '(lambda (x) (nth 2 x)) (cdddr (gb/get-gradebook-lisp))))
      (first-names (mapcar '(lambda (x) (nth 0 x)) (cdddr (gb/get-gradebook-lisp))))
      (last-names (mapcar '(lambda (x) (nth 1 x)) (cdddr (gb/get-gradebook-lisp))))
      (final-grades (mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))))
(mapcar* (lambda (fn ln em fg)
           `(,fn ,ln ,em ,fg))
         first-names
         last-names
         emails
         final-grades))
#+END_SRC

#+RESULTS:
| Jane | Doe       | jd@cmu.edu  | B  |
| John | Dillinger | jdi@cmu.edu | B+ |
| jill | wutz      | jw@cmu.edu  | R  |

** Summary
This is a pretty functional bit of code for computing final grades of a fixed format gradebook. It is missing some features. For example, it would not work well if any grades are missing, or if the gradebook is incomplete.

* DONE An index function for strings in emacs-lisp
  CLOSED: [2013-12-22 Sun 12:05]
  :PROPERTIES:
  :categories: emacs-lisp
  :date:     2013/03/05 19:28:30
  :updated:  2013/03/05 19:28:31
  :END:

I could not find an index function for strings in emacs-lisp. The =position= function seems to work for numbers, but not strings. Here is a version that works on strings.
#+BEGIN_SRC emacs-lisp :results value verbatim
(defun index (item list)
  "return index of item in list or nil"
  (let ((counter 0)
        (found nil))
    (dolist (listelement list counter)
      (if (string= item listelement)
        (progn
          (setq found t)
          (return counter)) ; exit the loop
        ;; else increment counter
        (incf counter)))
    ;; if we found it return counter otherwise return nil
    (if found counter nil)))
#+END_SRC

#+RESULTS:
: index

Here are some example uses:

#+BEGIN_SRC emacs-lisp :results value
(index "test" '("a" "test" "y"))
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC emacs-lisp :results value
(index "z" '("a" "b" "z"))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC emacs-lisp :results value verbatim
(index "testy" '("a" "test" "y"))
#+END_SRC

#+RESULTS:
: nil

This raises an error because we use string=.

#+BEGIN_SRC emacs-lisp :results value verbatim
(index 1 '("a" "test" "y" 1))
#+END_SRC
* DONE Integrating the Fermi distribution to compute entropy
  CLOSED: [2013-12-22 Sun 12:04]
  :PROPERTIES:
  :categories: dft, integration, gotcha
  :date:     2013/03/06 09:39:42
  :updated:  2013/03/06 09:47:19
  :END:

The Fermi distribution is defined by $f(\epsilon) = \frac{1}{e^{(\epsilon - \mu)/(k T)} + 1}$. This function describes the occupation of energy levels at temperatures above absolute zero. We use this function to compute electronic entropy in a metal, which contains an integral of $\int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon$, where $n(\epsilon)$ is the electronic density of states. Here we plot the Fermi distribution function. It shows that well below the Fermi level the states are fully occupied, and well above the Fermi level, they are unoccupied. Near the Fermi level, the states go from occupied to unoccupied smoothly.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def f(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.linspace(-10, 10, 200)
plt.plot(espan, f(espan))
plt.ylim([-0.1, 1.1])
plt.savefig('images/fermi-entropy-integrand-1.png')
#+END_SRC

#+RESULTS:

[[./images/fermi-entropy-integrand-1.png]]

Let us consider a simple density of states function, just a parabola. This could represent a s-band for example. We will use this function to explore the integral.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def f(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

def dos(e):
    d = (np.ones(e.shape) - 0.03 * e**2)
    return d * (d > 0)
espan = np.linspace(-10, 10)

plt.plot(espan, dos(espan), label='Total dos')
plt.plot(espan, f(espan) * dos(espan), label='Occupied states')
plt.legend(loc='best')
plt.savefig('images/fermi-entropy-integrand-2.png')
#+END_SRC

#+RESULTS:

[[./images/fermi-entropy-integrand-2.png]]
Now, we consider the integral to compute the electronic entropy. The entropy is proportional to this integral.

\( \int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon \)

It looks straightforward to compute, but it turns out there is a wrinkle. Evaluating the integrand leads to =nan= elements because the ln(0) is -\infty.

#+BEGIN_SRC python
import numpy as np
mu = 0
k = 8.6e-5
T = 100

def fermi(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.array([-20, -10, -5, 0.0, 5, 10])
f = fermi(espan)

print f * np.log(f)
print (1 - f) * np.log(1 - f)
#+END_SRC

#+RESULTS:
: [  0.00000000e+000   0.00000000e+000   0.00000000e+000  -3.46573590e-001
:   -1.85216532e-250               nan]
: [        nan         nan         nan -0.34657359  0.          0.        ]

In this case, these =nan= elements should be equal to zero (x ln(x) goes to zero as x goes to zero). So, we can just ignore those elements in the integral. Here is how to do that.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def fermi(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

def dos(e):
    d = (np.ones(e.shape) - 0.03 * e**2)
    return d * (d > 0)

espan = np.linspace(-20, 10)
f = fermi(espan)
n = dos(espan)

g = n * (f * np.log(f) + (1 - f) * np.log(1 - f))

print np.trapz(espan, g) # nan because of the nan in the g vector
print g

plt.plot(espan, g)
plt.savefig('images/fermi-entropy-integrand-3.png')

# find the elements that are not nan
ind = np.logical_not(np.isnan(g))

# evaluate the integrand for only those points
print np.trapz(espan[ind], g[ind])
#+END_SRC

#+RESULTS:
#+begin_example
nan
[             nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
  -9.75109643e-14  -1.05987106e-10  -1.04640574e-07  -8.76265644e-05
  -4.92684641e-02  -2.91047740e-01  -7.75652579e-04  -1.00962241e-06
  -1.06972936e-09  -1.00527877e-12  -8.36436686e-16  -6.48930917e-19
  -4.37946336e-22  -2.23285389e-25  -1.88578082e-29   0.00000000e+00
   0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00
   0.00000000e+00   0.00000000e+00]
0.208886080897
#+end_example

[[./images/fermi-entropy-integrand-3.png]]

The integrand is pretty well behaved in the figure above. You do not see the full range of the x-axis, because the integrand evaluates to =nan= for very negative numbers. This causes the =trapz= function to return =nan= also. We can solve the problem by only integrating the parts that are not =nan=. We have to use numpy.logical_not to get an element-wise array of which elements are not =nan=. In this example, the integrand is not well sampled, so the area under that curve may not be very accurate.

* DONE Uncertainty in implicit functions
  CLOSED: [2013-12-22 Sun 12:04]
  :PROPERTIES:
  :categories: statistics
  :date:     2013/03/08 17:04:02
  :updated:  2013/03/14 15:34:19
  :END:
Suppose we have an equation $y = e^{a y}$ that we want to solve, where $a$ is a constant with some uncertainty. What is the uncertainty in the solution $y$?

Finding a solution is not difficult. The uncertainty in the solution, however, is not easy, since we do not have an explicit function to propagate errors through. Let us examine the solution first.
#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve

a = 0.20

def f(y):
    return y - np.exp(a * y)

sol, = fsolve(f, 1)
print sol
#+END_SRC

#+RESULTS:
: 1.2958555091

A way to estimate the uncertainty is by Monte Carlo simulation. We solve the equation many times, using values sampled from the uncertainty distribution. Here we assume that the $a$ parameter is normally distributed  with an average of 0.2 and a std deviation of 0.02. We solve the equation 10000 times for different values of $a$ sampled according to the normal distribution. That gives us a distribution of solutions that we can do statistical analysis of to get the average and std deviation.

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
N = 10000

A = np.random.normal(0.2, 0.02, size=N)

sol = np.zeros(A.shape)

for i, a in enumerate(A):
    s, = fsolve(lambda y:y - np.exp(a * y), 1)
    sol[i] = s

ybar = np.mean(sol)
s_y = np.std(sol)

print ybar, s_y, s_y / ybar

import matplotlib.pyplot as plt
count, bins, ignored = plt.hist(sol)
plt.savefig('images/implicit-uncertainty.png')
#+END_SRC

#+RESULTS:
: 1.29887470397 0.0465110111613 0.0358086973433

We get approximately the same answer, and you can see here the distribution of solution values is not quite normal. We compute the standard deviation anyway, and find the standard deviation is about 3.6%. It would be nice to have some analytical method to estimate this uncertainty. So far I have not figured that out.

This method could have relevance in estimating the uncertainty in the friction factor for turbulent flow ($Re > 2100$). In that case we have the implicit equation $\frac{1}{\sqrt{f_F}}=4.0 \log(Re \sqrt{f_F})-0.4$. Uncertainties in the Re number would lead to uncertainties in the friction factor. Whether those uncertainties are larger than the uncertainties from the original correlation would require some investigation.

* TODO Class attributes with validation

#+BEGIN_SRC python
import numpy as np

class SolidVaporPressure(object):
    def __init__(self, A, B, C, D, mp):
        self.A = A
        self.B = B
        self.C = C
        self.D = D
        self.mp = mp


    def __call__(self, t):
        T = np.array(t, dtype=np.float)
        Pvap = 10.0**(5.006
                      + self.A
                      + self.B * T**-1
                      + self.C * np.log10(T)
                      + self.D * T**-3)
        #Pvap[t > self.mp] = np.nan
        return Pvap

Al = SolidVaporPressure(9.459, -17342, -0.7927, 0.0, 933)


print Al([800, 900])
#+END_SRC

#+RESULTS:
: [  3.06351892e-10   7.14962188e-08]

* TODO Testing units
#+BEGIN_SRC python
from pycse.units import units

u = units()

a = 5 * u.kJ
print repr(a)

b = u.kJ**2# * (1.0 / u.kJ)
print repr(b)
c = (1.0 / u.kJ)
print repr(c)

print repr(b*c)
print a.AS((1.0 / u.kJ) * u.kJ**2)
#print a.as_units(u.m)

#print '{0:1.3e}'.format(a)
#print '{0:f kJ}'.format(a)
#+END_SRC

#+RESULTS:
: Unit(5000.0, exponents=[ 2 -2  1  0  0  0  0], label=kJ)
: Unit(1000000.0, exponents=[ 4 -4  2  0  0  0  0], label=kJ^2)
: Unit(0.001, exponents=[-2  2 -1  0  0  0  0], label=kJ^-1)
: Unit(1000.0, exponents=[ 2 -2  1  0  0  0  0], label=(kJ^2)*(kJ^-1))
: 5.0 * (kJ^-1)*(kJ^2)



#+BEGIN_SRC python
from pycse.units import *
from pycse.umath import quad


u = units()
k = 0.23 * 1 / u.min
Cao = 2 * u.mol / u.L
V = 1 * u.L

Nao = Cao * V

def integrand(Na):
    return 1 / (k * Na)

t, terr = quad(integrand, 0.5 * Nao, Nao)
print t
#+END_SRC

#+RESULTS:
: 180.821003624 * s

* TODO Overloading subclass methods

#+BEGIN_SRC python
import numpy as np

class A(np.ndarray):

    def __new__(cls, input_array, label=None):
        # Input array is an already formed ndarray instance
        # We first cast to be our class type
        obj = np.asarray(input_array).view(cls)
        # add the new attribute to the created instance
        obj.label = label
        # Finally, we must return the newly created object:
        return obj

    def __array_finalize__(self, obj):
        if obj is None: return
        self.label = getattr(obj, 'label', None)

    def __array_wrap__(self, out_arr, context=None):
        return np.ndarray.__array_wrap__(self, out_arr, context)

    def __str__(self):
        return 'A({0}, label={1!s})'.format(np.array(self), self.label)


a = A(2)
print a

print a * 2
print np.float(2) * a
print np.float32(2) * a
print np.float64(2) * a
print np.__version__

#+END_SRC

#+RESULTS:
: A(2, label=None)
: A(4, label=None)
: A(4.0, label=None)
: A(4.0, label=None)
: 4.0
: 1.6.1
: 1.6.1

* DONE Capturing stderr and exceptions from python in org-mode
  CLOSED: [2013-12-22 Sun 12:03]
  :PROPERTIES:
  :categories: org-mode,python
  :date:     2013/09/27 19:37:05
  :updated:  2013/09/27 19:47:53
  :END:
I have used org-mode extensively to create examples of using python using the code blocks. For example to illustrate the difference between integer and float division you can do this:

#+BEGIN_SRC python
print 1 / 3
print 1.0 / 3.0
#+END_SRC

#+RESULTS:
: 0
: 0.333333333333

There are some limitations to showing output though. For example, the code blocks do not capture anything from stderr.

#+BEGIN_SRC python
import sys

print >>sys.stderr, 'message to stderr'
#+END_SRC

#+RESULTS:

And exceptions result in no output whatsoever. That is not helpful if you are trying to teach about exceptions!

I discovered a way around this. The key is using a python sandbox that redirects stdout, stderr and that captures anything sent to those channels. You can also capture any exceptions, and redirect them to a variable. Finally, you can construct the output anyway you see fit.

Below is the code that runs python code in a sandbox, with redirected outputs. I defined a function that temporarily redirects the output to stdout and stderr, so they can be captured. I execute the code wrapped in a try/except block to capture any exceptions that occur. Finally, I construct a string formatted in a way that lets you know what was on stdout, stderr, and what was an exception.

#+BEGIN_SRC python :tangle sandbox.py
#!/usr/bin/env python
from cStringIO import StringIO
import os, sys

def Sandbox(code):
    '''Given code as a string, execute it in a sandboxed python environment

    return the output, stderr, and any exception code
    '''
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    redirected_output = sys.stdout = StringIO()
    redirected_error = sys.stderr = StringIO()

    ns_globals = {}
    ns_locals = {}
    out, err, exc = None, None, None

    try:
        exec(code, ns_globals, ns_locals)
    except:
        import traceback
        exc = traceback.format_exc()

    out = redirected_output.getvalue()
    err = redirected_error.getvalue()

    # reset outputs to the original values
    sys.stdout = old_stdout
    sys.stderr = old_stderr

    return out, err, exc


if __name__ == '__main__':
    content = sys.stdin.read()
    out, err, exc =  Sandbox(content)

    s = '''---stdout-----------------------------------------------------------
{0}
'''.format(out)

    if err:
        s += '''---stderr-----------------------------------------------------------
{0}
'''.format(err)

    if exc:
        s += '''---Exception--------------------------------------------------------
{0}
'''.format(exc)

    print s

#+END_SRC

To use this, we have to put this file (sandbox.py) in our PYTHONPATH. Then, we tell org-babel to run python using our new sandbox.py module. org-babel pipes the code in a src block to stdin of the python command, which will be intercepted by our sandbox module. If you put this in your init.el, or other customization location, then subsequent uses of python in org-mode will use your sandbox module. I usually only run this for a session as needed.

#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "python -m sandbox")
#+END_SRC

Now, when we use python, we can capture output to stderr!

#+BEGIN_SRC python
import sys

print >>sys.stderr, 'message to stderr'
#+END_SRC

#+RESULTS:
: ---stdout-----------------------------------------------------------
:
: ---stderr-----------------------------------------------------------
: message to stderr
:
:
And, we can capture exceptions!

#+BEGIN_SRC python
print 1 / 0
#+END_SRC

#+RESULTS:
#+begin_example
---stdout-----------------------------------------------------------

---Exception--------------------------------------------------------
Traceback (most recent call last):
  File "c:\Users\jkitchin\Dropbox\blogofile-jkitchin.github.com\_blog\sandbox.py", line 20, in Sandbox
    exec(code, ns_globals, ns_locals)
  File "<string>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero


#+end_example

There is a little obfuscation in the exception, since it technically occurs in the Sandbox, but this is better than getting no output whatsoever! I have not tested the sandbox.py code extensively, so I don't know if there will be things that do not work as expected. If you find any, please let me know!
* TODO Customizing the export of org-mode elements
In a recent project I have used org-mode to create a document with lots of src blocks describing how to use python. I wanted to find a way to modify the export process so that each code block would be saved to a file, and a link to that file would be put in the exported pdf. I could have used tangling to do that, but I did not want the burden of having to name the code blocks. I wanted them named sequentially, and I often rearrange the blocks or add new ones in.


#+BEGIN_SRC emacs-lisp
(let ((counter 0))

  (defun ox-mrkup-filter-src-block (text back-end info)

    ;; we are processing a src block. Increment counter
    (setq counter (+ counter 1))

    (format "%s

"middle text"

%s" back-end text))

  (let ((org-export-filter-src-block-functions '(ox-mrkup-filter-src-block))
        (async nil)
        (subtreep t)
        (visible-only nil)
        (body-only t)
        (ext-plist '()))
    (org-html-export-as-html async subtreep visible-only body-only ext-plist)))



#+END_SRC
* DONE Notice anything different
  CLOSED: [2013-12-22 Sun 12:03]
  :PROPERTIES:
  :date:     2013/09/29 11:07:00
  :updated:  2013/09/29 11:41:28
  :END:
Based on the last few posts on [[http://jkitchin.github.io/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][making links to external files work in the blog]], and [[http://jkitchin.github.io/blog/2013/09/28/Customizing-export-of-code-blocks-in-HTML/][customizing code block export in HTML]], I have rewritten [[https://github.com/jkitchin/jmax/blob/prelude/blogofile.el][blogofile.el]] to more cleanly support the use of images and data files in my blog posts. Now, I should be able to include a data file (like this [[../../pycse/data/antoine_data.dat][one]]) in a post and you should be able to click on the link to open it after I publish the post in the usual way by pressing F10. That should process the post, construct URLs for all the links, including images, copy the relevant files to the blog directory, and generate the HTML file for blogofile to build. This is a little more robust than it used to be, as all files are stored in a directory named based on the post title, so there is less concern of using duplicate filenames for images and datafiles.

Here is a gratuitous image, just to see if it works ;)

#+CAPTION: test image
[[./images/heat-transfer-roots-1.png]]

Hopefully, there is nothing different on the outside! URLs to images are now in a different place, but that should not be apparent unless you read source code. The real difference is that now there are working links to data files! And it is easier for me to write my posts including them, with simple publishing.
* TODO Testing out a new python units package
  :PROPERTIES:
  :categories: units
  :END:

#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()

distance = 1.0 * u.meter

dd = distance / (1*u.cm)
print 'dd = ',dd
print dd.magnitude, dd.dimensionality
print dd.to('dimensionless')
print
print 5 * dd * u.cm
print 'float = ',float(dd)
import numpy as np
print np.log(dd)


E = 10 * u.kJ/u.mol
R = 2 * u.cal/u.mol/u.K
T = 300 * u.K

print E/R/T
#+END_SRC

#+RESULTS:
: dd =  1.0 meter / centimeter
: 1.0 dimensionless

: 100.0 dimensionless
:
: 5.0 meter
: float =  100.0
: 4.60517018599
: 0.0166666666667 kilojoule / cal



#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()


from scipy.optimize import fsolve
Fa0 = 3.0                 # mol/min
Fa = Fa0 * (1.0 - 0.8)    # mol/min
G = Fa / Fa0

def objective(D):
    return 1 - G - D * G

Dsol, = fsolve(objective, 1.0)


nu = 1 * u.L / u.min
k = 0.34 * 1 / u.hr

# V = D * nu / k
print Dsol * nu / k   # this prints oddly because the units are not simplified
print (Dsol * nu / k).to(u.L)

#+END_SRC

#+RESULTS:
: 11.7647058824 hour * liter / minute
: 705.882352941 liter


* DONE Enabling right-clicks in org-mode links
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/10/21 19:58:52
  :updated:  2013/10/21 20:45:37
  :END:
Out of the box you can click on org-mode links to make the do things. On my machine, all clicks are equal, left mouse, middle mouse, and right mouse all act as a "click". I was curious about whether I could get different behavior on a link with a left or right mouse click. It is easy enough to [[http://orgmode.org/manual/Adding-hyperlink-types.html][define a new link type]]. You define a function that is run when you click on the link.

To figure out what to do here, I looked into the events handling in emacs. According to this [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Click-Events.html][page]], there are click events. So, after we click on a link, there should be a click event which was the last input event. We can get that, figure out which button was pressed, and run code accordingly. We will make the code add some lines to the buffer after the link about what happened.

Here is my link definition.

#+BEGIN_SRC emacs-lisp
(setq counter 1)
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (link-string)
   (let ((button (car last-input-event)))
     (cond ((eq button 'mouse-1)
            (end-of-line)
            (insert (format "\nclick %s. mouse-1 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1)))
           ((eq button 'mouse-2)
            (end-of-line)
            (insert (format "\nclick %s. mouse-2 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1)))
           ((eq button 'mouse-3)
            (end-of-line)
            (insert (format "\nclick %s. mouse-3 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "<pre>%s:%s</pre>" keyword desc)))))
#+END_SRC


Here we make a link. When you click on it, it adds lines right after the link telling you what was clicked on. I left-clicked, middle-clicked and right-clicked. The right-clicked result is the first line.

test:which-button
click 3. mouse-3 pressed (mouse-3 (#<window 46 on blog.org> 56959 (57 . 456) -320964819 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))

click 2. mouse-2 pressed (mouse-2 (#<window 46 on blog.org> 56959 (57 . 456) -320965724 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))

click 1. mouse-2 pressed (mouse-2 (#<window 46 on blog.org> 56959 (57 . 456) -320966660 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))


Curiously, this only shows that mouse-2 (for left or middle mouse) or mouse-3 (for right click) was pressed, never mouse-1. I am not sure what causes that. If I try to capture an event it does show mouse-1 is active.

#+BEGIN_SRC emacs-lisp
(princ (read-event))
#+END_SRC

#+RESULTS:
: (down-mouse-1 (#<window 34 on blog.org> 56437 (253 . 308) -322917920 nil 56437 (31 . 19) nil (93 . 4) (8 . 16)))

Anyway, it looks conceivable that you could have different link actions occur for different mouse clicks. I could see using this in a citation link, where a left click might open the citation in my bibtex file, and right clicking would open a pdf of the citation if it existed.

I have not figured out how flexible this might be, for example could you use modifier keys with mouse clicks? This code suggests that it is possible in emacs, but so far none of these make it into the last-input-event in the org-link clicks.

#+BEGIN_SRC emacs-lisp
(princ (read-event))
#+END_SRC

#+RESULTS:
: (S-down-mouse-1 (#<window 34 on blog.org> 56725 (1 . 299) -322897656 nil 56725 (0 . 18) nil (1 . 11) (8 . 16)))

It might be difficult remembering all the modifiers and clicks, but it would be cool if it was possible!
* DONE Hatched symbols in matplotlib
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: plotting
  :date:     2013/10/26 14:35:19
  :updated:  2013/10/26 14:35:19
  :END:
I learned something new about matplotlib today: How to make hatched (patterned) symbols in a plot. Well, sort of. The scatter plot in matplotlib has a hatch keyword argument that specifies a pattern on the marker. Below, is an example that runs through a handful of hatch patterns, on randomly selected symbols.

Curiously, hatch is not a kwarg of the scatter function, but of [[http://matplotlib.org/api/collections_api.html#matplotlib.collections.Collection.set_hatch][collections]]. Anyway, let us see how to get the hatched symbols.

#+BEGIN_SRC python
import random
import numpy as np
import matplotlib.pyplot as plt

patterns = ('-', '+', 'x', '\\', '*', 'o', 'O', '.', '/')
markers = 'os<^>p*'
for pattern in patterns:
    plt.scatter(np.random.uniform(size=(3,1)), np.random.uniform(size=(3,1)), s=1000,
                marker=random.choice(markers),
                facecolor='white',
                hatch=3*pattern, label=pattern)

plt.legend(scatterpoints=1, loc='best')
plt.savefig('images/hatched-symbols.png')
#+END_SRC

#+RESULTS:

[[./images/hatched-symbols.png]]

There are some other interesting things you can do with [[http://matplotlib.org/examples/pylab_examples/filledmarker_demo.html][filled markers]], [[http://matplotlib.org/examples/pylab_examples/contourf_hatching.html][hatched contours]] and with [[http://matplotlib.org/examples/pylab_examples/hatch_demo.html][hatched bar graphs]]. Note this hatching is specific to plt.scatter. It does not work with plt.plot.
* TODO erf and erfc for switching functions
In a [[http://jkitchin.github.io/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions/][previous post]] I examined a way to switch between discontinuous functions smoothly using a sigmoid function. The [[http://en.wikipedia.org/wiki/Error_function][error function]] has similar properties to the sigmoid function we used previously, and the complementary error function (erfc) is defined as 1 - erf. So, these are two functions we could use to smoothly transition from one function to another.


#+BEGIN_SRC python
import numpy as np
from scipy.special import erf, erfc

xspan = np.linspace(-5, 5)

import matplotlib.pyplot as plt

plt.plot(xspan, 0.5 * (1 + erf(xspan)), xspan, 0.5 * erfc(xspan))
plt.legend(['erf', 'erfc'])
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
from scipy.special import erf, erfc

def fF_laminar(Re):
    return 16.0 / Re

def fF_turbulent_unvectorized(Re):
    # Nikuradse correlation for turbulent flow
    # 1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)
    # we have to solve this equation to get f
    def func(f):
        return 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    fguess = 0.01
    f, = fsolve(func, fguess)
    return f

# this enables us to pass vectors to the function and get vectors as
# solutions
fF_turbulent = np.vectorize(fF_turbulent_unvectorized)

# Now we plot the correlations.

Re1 = np.linspace(500, 3000)
f1 = fF_laminar(Re1)

Re2 = np.linspace(3000, 10000)
f2 = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label='laminar')
plt.plot(Re2, f2, label='turbulent')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()


def fanning_friction_factor(Re):
    alpha = 20
    f =  0.5 * erfc(alpha*(Re-3000))* fF_laminar(Re) + 0.5 * (1 + erf(alpha*(Re-3000))) * fF_turbulent(Re)
    return f

Re = np.linspace(500,10000);
f = fanning_friction_factor(Re);

# add data to figure 1
plt.figure(1)
plt.plot(Re,f, label='smooth transition')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:

* DONE Automating Adobe Acrobat Pro with python
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: automation,pdf
  :date:     2013/11/23 10:34:47
  :updated:  2013/11/23 10:34:47
  :END:

I have a need to automate Adobe Pro for a couple of applications:

1. I could use Adobe Pro to automatically add rubric pages to assignments before grading them. The rubric has embedded javascript that stores the grade inside the pdf file.
2. I could use Adobe Pro to extract information, e.g. grades, stored in a set of PDF files for analysis.

I came across this [[http://win32com.goermezer.de/content/view/232/288/][script]] to automate Adobe Pro using python and OLE automation.  Two other useful references are:

1. http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/iac_api_reference.pdf
2. http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/iac_developer_guide.pdf

In this post, we look at some simple code to get data out of a pdf.  We start with just opening a PDF file.

#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('writing-exams-in-orgmode.pdf')

app = Dispatch("AcroExch.AVDoc")

app.Open(src, src)

app.Close(-1)  # do not save on close
#+END_SRC

#+RESULTS:

Opening and closing a file is not that useful.  Here, we can get some information out of the file. The pdf we looked at above has a custom property =PTEX.Fullbanner= from pdflatex. We can extract it like this.

#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('writing-exams-in-orgmode.pdf')

app = Dispatch("AcroExch.AVDoc")

app.Open(src, src)
pddoc = app.GetPDDoc()
print pddoc.GetInfo('PTEX.Fullbanner')

print pddoc.GetNumPages()
app.Close(-1)  # do not save on close
#+END_SRC

#+RESULTS:
: This is MiKTeX-pdfTeX 2.9.4535 (1.40.13)
: 5


Finally, let us try inserting pages. I have a [[../../CMU/classes/06-625/rubric/rubric.pdf][rubric file ]] that I want to insert at the end of the [[writing-exams-in-orgmode.pdf][pdf]] above. We will open both documents, insert the rubric, and save the result as a new file.


#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('../../CMU/classes/06-625/rubric/rubric.pdf')
src2 = os.path.abspath('writing-exams-in-orgmode.pdf')

# It seems I need two of these
avdoc1 = Dispatch("AcroExch.AVDoc")
avdoc2 = Dispatch("AcroExch.AVDoc")

# this is the rubric
avdoc1.Open(src, src)
pddoc1 = avdoc1.GetPDDoc()
N1 = pddoc1.GetNumPages()

# this is the other doc
avdoc2.Open(src2, src2)
pddoc2 = avdoc2.GetPDDoc()
N2 = pddoc2.GetNumPages()

# Insert rubric after last page of the other doc. pages start at 0
pddoc2.InsertPages(N2 - 1, pddoc1, 0, N1, 0)

# save as a new file. 1 means full save at absolute path provided.
pddoc2.Save(1, os.path.abspath('./woohoo.pdf'))

# close files.
avdoc1.Close(-1)
avdoc2.Close(-1)
#+END_SRC

#+RESULTS:

Here is our result: [[./woohoo.pdf]]. I went ahead and gave myself an A ;).

** Summary
It looks like I can replace the dependence of my box-course code on all the python-based pdf libraries (which are not fully functional, and do not work on all pdfs), and on pdftk, with this automation approach of Adobe Pro. It is unfortunate that it is not a free program, but i would expect it to work on all PDF files, and it provides features like combining PDFs with their javascript, that /no/ other PDF package has. I have tried other PDF programs to combine the rubric and assignment page, but they all lose the javascript. With this method, I could keep a set of enriched rubric files for different types of assignments, and add them to assignments as part of the assessment process.
* TODO org-mode to json


** Introduction
This is an experiment to convert an org-mode document to a json representation.

** the code

#+BEGIN_SRC emacs-lisp
(princ (cddr (org-element-parse-buffer)))
#+END_SRC

#+RESULTS:
: ((headline (:raw-value org-mode to json :begin 60073 :end 60298 :pre-blank 2 :hiddenp nil :contents-begin 60094 :contents-end 60297 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :quotedp nil :CATEGORY blog :title (org-mode to json) :parent (org-data nil #1)) (headline (:raw-value Introduction :begin 60094 :end 60191 :pre-blank 0 :hiddenp nil :contents-begin 60110 :contents-end 60190 :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :quotedp nil :CATEGORY blog :title (Introduction) :parent #1) (section (:begin 60110 :end 60191 :contents-begin 60110 :contents-end 60190 :post-blank 1 :parent #2) (paragraph (:begin 60110 :end 60190 :contents-begin 60110 :contents-end 60190 :post-blank 0 :post-affiliated 60110 :parent #3) This is an experiment to convert an org-mode document to a json representation.
: ))) (headline (:raw-value the code :begin 60191 :end 60298 :pre-blank 1 :hiddenp nil :contents-begin 60204 :contents-end 60297 :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :quotedp nil :CATEGORY nil :title (the code) :parent #1) (section (:begin 60204 :end 60298 :contents-begin 60204 :contents-end 60297 :post-blank 1 :parent #2) (src-block (:language emacs-lisp :switches nil :parameters nil :begin 60204 :end 60280 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (princ (cddr (org-element-parse-buffer)))
:  :post-blank 1 :post-affiliated 60204 :parent #3)) (fixed-width (:begin 60280 :end 60297 :value nil
:  :post-blank 0 :post-affiliated 60291 :results () :parent #3))))))


* TODO Penalizing digital assignments that are turned in late

This semester I have experimented with using box.com to have students turn in assignments. The assignments often have deadlines. For homeworks, we were soft on this, and there was often time between the deadline and when assignments were "collected" for grading. As long as the assignments were available by the time we collected them, we gave students credit for the assignments. Still, some students turned in assignments after that, and we did not have a good strategy for dealing with that.

A new wrinkle came about when I started using box.com to give quizzes and exams. I learned how to make students collaborators on a folder for the duration of the quiz/exam, and then to turn off their ability to upload at the end of the quiz. The first time I ran this, students were unprepared for the amount of time it could take to upload, and a good fraction failed to turn in their quiz. They were /very/ unhappy. I tried modifying the approach to give them a visual timer, with a warning, and a buffer time to enable uploads. That helped, but some were still unable to upload in time. This puts you in an uncomfortable position of telling students they get no credit, or dealing with emails from them of their assignments after they are due, and then figuring out an appropriate penalty. The students are stressed out because they are worried about their grades, and they don't think it is fair. Even if they are deservedly so, worried, stressed out students aren't learning.

Now, I recognize these students should have turned it in when told to, and if this were a paper exam, there is a hard deadline of me walking out the door with the exams. Digitally turned in assignments do not have this kind of behavior. A way to reduce the overall stress around this is that rather than shutting off access to the upload, we should simply use an appropriate late penalty. That way, students get to turn in their work, which is psychologically less stressful, and they are appropriately penalized for being late.

Now, why is this difficult? It turns out it is not that easy to tell when a file is uploaded or modified on box.com. You can do it through the box.com api, but the timestamp comes in an unfamiliar form. Second, late is a difference in time.  The local time on a computer is not the same as the time on the box.com servers, so we cannot (or should not) use that difference to determine lateness.

#+BEGIN_SRC python
from box_course.box import *
import json

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

print json.dumps(jf, sort_keys=True, indent=4)
#+END_SRC

#+RESULTS:
#+begin_example
{
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
    "created_at": "2013-12-08T06:31:46-08:00",
    "created_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "description": "",
    "etag": "0",
    "id": "12178719122",
    "item_status": "active",
    "modified_at": "2013-12-08T06:31:47-08:00",
    "modified_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "name": "reference.txt",
    "owned_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "parent": {
        "etag": "0",
        "id": "1364917348",
        "name": "test",
        "sequence_id": "0",
        "type": "folder"
    },
    "path_collection": {
        "entries": [
            {
                "etag": null,
                "id": "0",
                "name": "All Files",
                "sequence_id": null,
                "type": "folder"
            },
            {
                "etag": "1",
                "id": "1328895168",
                "name": "group-course",
                "sequence_id": "1",
                "type": "folder"
            },
            {
                "etag": "0",
                "id": "1364917348",
                "name": "test",
                "sequence_id": "0",
                "type": "folder"
            }
        ],
        "total_count": 3
    },
    "purged_at": null,
    "sequence_id": "0",
    "sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "shared_link": null,
    "size": 0,
    "trashed_at": null,
    "type": "file"
}
#+end_example


I think the relevant information is:
#+BEGIN_EXAMPLE
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
#+END_EXAMPLE

These timestamps are described [[https://www.ietf.org/rfc/rfc3339.txt][here]]. These timestamps are related to utc time, and can be converted to local time like this:

#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

def utc_to_local(timestamp):
    utc = parser.parse(timestamp)
    to_zone = tz.gettz('America/New_York')
    return utc.astimezone(to_zone)

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

from dateutil import parser
dc = jf['content_created_at']
print utc_to_local(dc)
#+END_SRC

#+RESULTS:
: 2013-12-08 09:31:46-05:00

In fact, I did create that file around 9:31am on 12/8. The =-05:00= is related t the offset of our local time with utc.

Now, the key idea in calculating lateness is that I have a reference time on box.com now, by virtue of having created reference.txt at the beginning of the assignment. I created two assignment files, assignment1.txt and assignment2.txt that I uploaded about 30 seconds, and one minute after the reference.txt was created. Below, I calculate the amount of time elapsed between the reference file and assignment files.


#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
jf = get_file_information(j['id'])
t0 = jf['content_modified_at']

j1 = get_item('group-course/test/assignment1.txt')
jf1 = get_file_information(j1['id'])
t1 = jf1['content_modified_at']

j2 = get_item('group-course/test/assignment2.txt')
jf2 = get_file_information(j2['id'])
t2 = jf2['content_modified_at']

p2 = parser.parse(t2)
p1 = parser.parse(t1)
p0 = parser.parse(t0)

d1 = p1 - p0
d2 = p2 - p0

print d1.total_seconds()
print d2.total_seconds()
#+END_SRC

#+RESULTS:
: 25.0
: 63.0

So, now we have a quantitative way to measure lateness. It is not a speedy method, since you have to make several box.com api calls, but, we can say how late it is, and since we use a reference file created on box.com at the beginning of the assignment, we take out the local time issue. The reference file could be created at the end of the assignment to mark when it is done.

Now about the penalty function. This is arbitrary, but should be a function that decays from 100% credit to some lower level of credit that is appropriate. For a homework, you might choose 50% as a floor, with some hours of decay time, whereas for a quiz/exam, it should be minutes of decay time down to 0%. Linear decay is the simplest. Let us say we want the credit to go from 100% to 50% over a 5 minute span. It would look like this:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

@np.vectorize
def penalty(t):
    if t < (5 * 60):
        p = 1.0 - (1.0 - 0.5) / (5 * 60) * t
    else:
        p = 0.5
    return p

t = np.linspace(0, 600, 100)
p = penalty(t)

plt.plot(t, p)
plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-penalty.png')
#+END_SRC

#+RESULTS:

[[./images/example-penalty.png]]

There are many options for a smooth decrease. Let us examine this gaussian function. We define a function that decays in the normal distribution sense, and allows you to set upper and lower bounds. To go from 1.0 to 0.5 we use this code:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

def penalty(t, mu=0.0, sigma=5, ub=1.0, lb = 0.0):
    return (ub - lb) * np.exp(-(t-mu)**2 / (2 * sigma**2)) + lb

t = np.linspace(0, 30)
plt.plot(t, penalty(t, lb=0.5))

plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-gaussian-penalty.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/example-gaussian-penalty.png]]

You can see that after about 15 minutes (3 * sigma), the penalty will be


I think this would help reduce stress in the classroom, and make it more systematic to apply lateness penalties to assignments. I still have not worked out precisely how to integrate this into a grading workflow, since you need to run a script to get the penalties for each assignment, and then multiply the grade by it to get the penalized grade. You could grade normally, and have the script create a late file in the directory which is only used in calculating the overall grade.


* DONE Selectively exporting headlines in org-mode
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/12/08 16:35:35
  :updated:  2013/12/08 16:35:35
  :END:
I have on several occasions needed to selectively export only portions of an org document. For example, I may write a problem set or exam, and have some headlines that are the problems, and others that are the solutions. Or, I may have done some analysis in a headline, e.g. statistics of problem scores that I do not want in exported content, or I have a manuscript with a supporting information section that does not go in the exported manuscript, and the manuscript cannot go in the supporting information file.

org-mode supports [[http://www.gnu.org/software/emacs/manual/html_node/org/Selective-export.html][selective export]] through use of tags. However, this is inflexible if you want to export multiple different documents with different selective exports, unless you don't mind changing the settings, or commenting and uncommenting lines all the time.

Enter dynamic binding of variables in emacs-lisp. We can temporarily define variables, especially =org-export-select-tags= and =org-export-exclude-tags=, and write emacs-lisp code blocks to export the current document the way we want. First, let us create some headlines.

** problem 1                                                        :problem:
description of a hard problem
*** solution to problem 1                                          :solution:
it is an easy solution
** problem 2                                                        :problem:
what is the square root of 100?
*** solution to problem 2                                          :solution:
why it's 10 of course.

** Code to export                                                      :code:

*** Export just the problems
First, let us output this document with just the problems. The code block does that, just put your cursor in in block and press C-c C-c (in emacs of course).

#+BEGIN_SRC emacs-lisp
(let ((org-export-exclude-tags '("solution" "code"))
      (org-latex-default-packages-alist
       '(("" "lmodern" nil)
         ("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only nil)
      (ext-plist '()))
  (org-latex-export-to-pdf async subtreep visible-only body-only ext-plist))
(rename-file "blog.pdf" "blog-1.pdf")
#+END_SRC

#+RESULTS:

You get this: [[./blog-1.pdf]] which only has the problems in it.

*** Problems and solutions
Next, we consider the problems and the solutions. We cannot just get solutions in this document because solutions are nested in the problems.

#+BEGIN_SRC emacs-lisp
(let ((org-export-exclude-tags '("code"))
      (org-latex-default-packages-alist
       '(("" "lmodern" nil)
         ("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only nil)
      (ext-plist '()))
  (org-latex-export-to-pdf async subtreep visible-only body-only ext-plist))
(rename-file "blog.pdf" "blog-2.pdf" t)
#+END_SRC

#+RESULTS:

This document ([[./blog-2.pdf]]) now has problems and solutions. Note that neither of these documents has the section we labeled =:code:=.

** Summary
Tags are a nice way to label sections. In combination with dynamic binding, you can build code blocks that selectively export pieces of an org-file by temporarily defining the values of variables. In this example, there are four versions of this document: 1) the org-file that contains everything, 2) the html blog post, 3) a pdf with the problems, and 4) a pdf with problems and solutions. Good luck getting that out of a Word file ;)


#+LATEX_CLASS: revtex4-1
#+LATEX_CLASS_OPTIONS: [aps,prb,citeautoscript,preprint,citeautoscript,showkeys]
* TODO Exporting LaTeX manuscripts from org-mode
  :PROPERTIES:
  :categories: org-mode
  :END:
We have been using org-mode to write manuscripts for submission to journals for publication. Our typical workflow is writing in org-mode, and then using a custom export function to turn the document into LaTeX, and then compiling to pdf via pdflatex. This /mostly/ works great, except for the following two issues:

1. We use BibTex for references, and most journals want us to replace the \bibliography{} lines with the contents of the .bbl file so it is self-contained.
2. We use png files in the org file so they show up in emacs. However, most journals want eps files, and we have to manually remove the .png extension from the LaTeX file so it will build on the journal site (which does not use pdflatex).

I am exploring some code that would automate those things.

** Replacing the bibliography line
Starting with item one, we need to get the contents of the bbl file, and then replace the bibliography line with that. The .bbl file is typically named after the tex file, which is named after the org file. So, if the org-file is blog.org, the tex file would be blog.tex, and the corresponding bbl file would be blog.bbl.

#+BEGIN_SRC emacs-lisp
; derive bbl filename from org file
(concat (file-name-sans-extension (file-name-nondirectory (buffer-file-name))) ".bbl")
#+END_SRC

An alternative approach is to replace text using a regexp.
#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name)))
#+END_SRC

Now, we need a way to get the contents of the bbl file. This works:
#+BEGIN_SRC emacs-lisp
(let* ((bbl-file (replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name))))
       (contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string))))
  (princ contents))
#+END_SRC

#+RESULTS:
: You got the contents of blog.bbl!

Finally, we should replace the bibliography string in the tex file with the contents of the bbl file. This block seems to do that. I think as long as the bibliography line does not span more than one line, and that there is not more than one of them this should work fine.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (bbl-file (replace-regexp-in-string "org$" "bbl" org-file))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (bbl-contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string)))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string "\\\\bibliography{.*}" bbl-contents tex-contents))))
#+END_SRC

#+RESULTS:

A work flow here would be to run a code block that exports the org-file to LaTeX, then run the code block above to insert the bbl file.

** Removing the image extensions
We put the .png extension in the figure links in org-mode so that org-mode will show the images in the buffer. That is convenient for writing. It is also fine if one uses pdflatex to compile the resulting LaTeX source. Some journals, however, use latex to build the document, and latex does not support png files; encapsulated postscript is preferrable for latex.

Luckily, you do not have to specify a file extension to latex, it will automatically look for the right extension (.eps for latex, .pdf or .png for pdflatex). So, we just need to strip the extension off of the image paths. Here is a regular expression and code block that seems to do this correctly.

#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"
 "\includegraphics{./images/test.png}


\\includegraphics{image/with/no/extension}
other latex

\\includegraphics[width=2in]{images/figure2.png}

\\includegraphics[width=3in]{./images/bulkmodulus-volume.png}
")
#+END_SRC

#+RESULTS:
: includegraphics{./images/test}
:
:
: \includegraphics{image/with/no/extension}
: other latex
:
: \includegraphics[width=2in]{images/figure2}
:
: \includegraphics[width=3in]{./images/bulkmodulus-volume}


We can combine this with the previous work on replacing the bibliography to replace all the extensions like this.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}\.].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"  tex-contents))))
#+END_SRC

#+RESULTS:

** Putting this together
What we want to create is a function we could use to create the manuscript. There would be a function like this for different journals and/or publishers. For instance, APS journals use revtex, while ACS journals use achemso. There could be one publisher function that takes some options for the specific journal.

#+BEGIN_SRC emacs-lisp

#+END_SRC

* DONE Finding the box root directory on a local machine
  CLOSED: [2013-12-22 Sun 11:38]
  :PROPERTIES:
  :categories: box
  :date:     2013/12/22 10:26:24
  :updated:  2013/12/22 10:26:24
  :END:
I am working to automate some aspects of box.com, specifically to create collaborations in folders and tasks on files on my local computer at the command-line. I use Box Sync to mirror folders and files on my local computer, and I would like to open a prompt in one of these folders and type something like:
#+BEGIN_EXAMPLE
box collaborate --role editor someone@gmail.com
#+END_EXAMPLE
to add that person as an editor to my box folder.

The challenge is that I need to know the =id= of that folder on box. Box stores the files on their server by id, not by name, and the root box folder has an id of =0=. On my local computer, the box root folder is where =Box Sync= puts my synchronized files. In my box_course python module I wrote a function that will return the =id= of an item in box given the /box path/ which is relative to the box root directory. For example, here we can get the =id= for a folder called group-course.

#+BEGIN_SRC python
from box_course import box

print box.get_item('/group-course')
#+END_SRC

#+RESULTS:
: {u'sequence_id': u'1', u'etag': u'1', u'type': u'folder', u'id': u'1328895168', u'name': u'group-course'}

On my local computer, group course is located at C:\Users\jkitchin\Box Sync\group-course, and C:\Users\jkitchin\Box Sync is like the box root directory. So, the challenge is, if I am on the local computer in some directory, how do I determine the box path to that directory?

What I worked out is to start in the current directory, and check directories above this for a file that indicates you are in the box root directory. With Box Sync 3, that file was "Box Sync ReadMe.pdf", but Box Sync 4 does not include that file anymore. I just put a folder of that name in the Box Sync 4 root directory [fn:1].

Here is a way to start in a box directory, and walk up the path to look for the file. We get the path, and then split each directory off the end, checking for the existence of the file, until the path is gone.
#+BEGIN_SRC python
import os
# change into a box directory
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync

That gets us the box root directory. Now, we need to strip this off of the current working directory. We also need to replace all the backslashes that Windows uses with forward slashes so that we can get the id.

#+BEGIN_SRC python
import os
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

cwd = os.getcwd()

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
print cwd
print cwd.replace(wd, '').replace('\\','/')
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync
: C:\Users\jkitchin\Box Sync\group-course
: /group-course

This seems to work pretty well, but on some Windows machines, the drive letter is lower case, and then this does not work. In that case, we use =os.path.normcase= to make everything consistent.

#+BEGIN_SRC python
import os
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

from box_course import box

cwd = os.getcwd()

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
print cwd
bpath = os.path.normcase(cwd).replace(os.path.normcase(wd), '').replace('\\','/')

print bpath
print box.get_item(bpath)
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync
: C:\Users\jkitchin\Box Sync\group-course
: /group-course
: {u'sequence_id': u'1', u'etag': u'1', u'type': u'folder', u'id': u'1328895168', u'name': u'group-course'}

This seems to work so far. Something similar this is probably done in git repositories, to find the .git file. This is also a useful way to find a config file higher up the path.

* DONE An improved index function for emacs-lisp
  CLOSED: [2013-12-22 Sun 12:01]
  :PROPERTIES:
  :date:     2013/12/22 12:01:48
  :updated:  2013/12/22 12:02:06
  :categories: emacs-lisp
  :END:
I previously worked out an [[http://kitchingroup.cheme.cmu.edu/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp/][index]] function for a list of strings in emacs-lisp, but at the end I showed it would not work for arbitrary elements of a list. Here is an exercise to improve on that. The goal is a function that looks like this:
#+BEGIN_EXAMPLE
(index 1 '("a" 2 1 "b"))
#+END_EXAMPLE
that would return 2 in this case. Last time I used string=, which is why I could not find a number in the list. This time, we will use =equal= (see http://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html) which compares components of objects for equality. That should let us find arbitrary objects in a list.

Here is our improved function:

#+BEGIN_SRC emacs-lisp
(defun index (object list)
  "return the index of object in list"
  (let ((counter 0)
        (found nil))
    (catch 'finished
      (dolist (listelement list counter)
        (if (equal object listelement)
            (progn
              (setq found t)
              (throw 'finished counter))
          ;; else increment counter
          (incf counter)))
    ;; if we found it return counter otherwise return nil
    (if found counter nil))))
#+END_SRC

#+RESULTS:

Now, let us test some examples:

#+BEGIN_SRC emacs-lisp :results value
(index 1 '("a" 2 1 "b"))
#+END_SRC

#+RESULTS:
: 2

No problem finding a number in a list.

#+BEGIN_SRC emacs-lisp :results value
(index "b" '("a" 2 1 "b"))
#+END_SRC

#+RESULTS:
: 3

How about something more complicated, like a list in a list?
#+BEGIN_SRC emacs-lisp :results value
(index '(1 2) '("a" 2 1 (1 2) "b"))
#+END_SRC

#+RESULTS:
: 3

That looks good.

#+BEGIN_SRC emacs-lisp
(princ (index '(1 2) '("a" 2 1 (2 (1 2)) "b")))
#+END_SRC

#+RESULTS:
: nil

Note, we do not find the nested object. That is ok, the location of that object would require two indices, which this function is not designed for.

Here we consider an object of an a-list
#+BEGIN_SRC emacs-lisp :results value
(index '("nut" . "acorn") '(("nut" . "acorn") ("fruit" . "apple")))
#+END_SRC

#+RESULTS:
: 0

I am not quite sure how you would use that, but it does illustrate the generality of the index function!

* DONE Using data in a table in another org-file
  CLOSED: [2013-12-22 Sun 13:42]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/12/22 13:42:20
  :updated:  2014/01/16 07:30:30
  :END:
I have found using tables in an org-file as data sources to code blocks very convenient for documenting work. A typical work flow might go like this:
1. Use a code block to generate some data in an org-table.
2. Use another code block to analyze the data.

For example, here is a code block that prints data in a table [fn:2]:
#+BEGIN_SRC python :results raw
import numpy as np

print '#+tblname: cos-data'
print '| x | cos(x)|'
print '|-'

for x in np.linspace(0, 2*np.pi, 10):
    print '|{0}|{1}|'.format(x, np.cos(x))
#+END_SRC

#+RESULTS:
#+tblname: cos-data
| x | cos(x)|
|-
|0.0|1.0|
|0.698131700798|0.766044443119|
|1.3962634016|0.173648177667|
|2.09439510239|-0.5|
|2.79252680319|-0.939692620786|
|3.49065850399|-0.939692620786|
|4.18879020479|-0.5|
|4.88692190558|0.173648177667|
|5.58505360638|0.766044443119|
|6.28318530718|1.0|

Now, we use that table in a code block to plot the data. We do this by using some header arguments to the code block:

#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=cos-data
#+END_EXAMPLE

Then we can use the =data= variable inside the code block like this:

#+BEGIN_SRC python :var data=cos-data
import numpy as np
import matplotlib.pyplot as plt

data = np.array(data) # data is a list coming in
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('cos(x)')
plt.savefig('images/cos-plot.png')
#+END_SRC

#+RESULTS:

[[./images/cos-plot.png]]

That is pretty awesome, but what if we have data in a table from another org-file? It turns out we can use it too. I have data for the sin(x) stored in a table called =sin-data= in [[./sin.org]], which I now want to use. We can access that table like this in a header arg:

#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=sin.org:sin-data
#+END_EXAMPLE

And now use the data variable just like before!

#+BEGIN_SRC python :var data=sin.org:sin-data
import numpy as np
import matplotlib.pyplot as plt

data = np.array(data) # data is a list coming in
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.savefig('images/sin-plot.png')
#+END_SRC

#+RESULTS:

[[./images/sin-plot.png]]

This is a powerful capability, as it allows you to pull data from other files into your current analysis. For example, the supporting information files from some of our recent publications have org-files embedded in them with data stored in org-tables. You could use that data in your own analysis without having to type it in yourself. The only thing you need to do is make sure each table in a document is uniquely named.

Special thanks to Eric Schulte for pointing out the syntax for using external tables!




* TODO VASP in emacs
#+BEGIN_EXAMPLE
PREC = Normal              #  precision normal
ENCUT = 300                #  cutoff used throughout all calculations
LREAL = .FALSE.            #  real space projection yes / no
ISMEAR = 0                 #  method to determine partial occupancies
#+END_EXAMPLE

[[./images/vanilla-incar.png]]

Now with vasp-mode:

[[./images/vasp-mode-incar.png]]

* DONE Python as alternative to Matlab for engineering calculations
  CLOSED: [2013-12-30 Mon 16:05]
  :PROPERTIES:
  :categories: python
  :date:     2013/12/30 15:20:04
  :updated:  2013/12/30 21:15:44
  :END:
For the past year I have been seriously exploring whether Python could be used as a practical alternative to Matlab in engineering calculations, particularly in chemical engineering undergraduate and graduate courses. Matlab is very well suited for these calculations, and I have used it extensively in teaching in the past. For example, there is my Matlab blog (http://matlab.cheme.cmu.edu), and my cmu Matlab package that contains a very nice units package (https://github.com/jkitchin/matlab-cmu). Matlab is widely used and recognized as a standard software package in engineering. My university has a site license for Matlab, so it doesn't cost me or my students anything to use. Matlab is easy to install, and has almost everything we need out of the box. So why try using something else then? Here are the main reasons:

1. Not everyone has access to a "free" Matlab license, and Matlab may not be available to my students when they leave the University. Python offers a free, always available option to them.
2. There are several recent Python distributions that are easy to install, and contain almost everything we need for engineering calculations.
3. I have been increasingly integrating code into my lecture notes, and this is not easy with Matlab, but it is easy with Python.
4. I use Python exclusively in my research, and although Matlab and Python are similar, they are different enough that switching between them is bothersome to me. I do not like teaching students to use tools I do not regularly use, and I believe I can provide them with more value by teaching with tools I have a high level of proficiency in.

** The significance of an open-source alternative
Many people will be able to use Matlab or some other proprietary software that someone has paid for the license to use. Some people, however, will not have that option for a variety of reasons. Maybe the company they work for will not pay for the license, maybe they are unemployed, or entrepeneurs in a small startup that cannot afford it, maybe they are students at a University without a site license,... For these people Python is a viable option that is always available. That makes me happy.

** Easy to install Python distributions
An important development in using Python as an alternative to Matlab is the development of many "one-click" installers. Ten years ago it took me about 2 weeks to download and build a Python environment suitable for scientific and engineering calculations. That has kept me from trying to use Python in teaching in the past. Today, I can download a package and install one in about 10 minutes! More importantly, so can my students.

My favorite distribution is the Enthought Canopy distribution (https://www.enthought.com/products/canopy/). This distribution comes with all the essential python modules, and an integrated editor with IPython. It is available for Windows, Macs and Linux. They offer free academic licenses.

Another good alternative is the Anaconda distribution (https://store.continuum.io/cshop/anaconda/) by Continuum Analytics. It is also available for Windows, Macs and Linux. I have not used this one, but it looks like it would be very good. Anaconda comes with the Spyder editor. They offer free academic licenses.

Python(x,y) is available for Windows (http://code.google.com/p/pythonxy/) and comes with the Spyder editor.

WinPython (http://winpython.sourceforge.net/) is also available for Windows, and comes with the Spyder editor.

The point here is that there are many options available now that make installing a Python distribution as easy as installing packages like Matlab. Enthought Canopy also provides a "desktop environment" similar to Matlab with an editor, documentation browser, package manager and console that is pretty easy to use.

** Python + numpy/scipy/matplotlib does almost everything you need
Python by itself is not suitable for typical engineering calculations. You need the numerical, scientific and plotting libraries that provide that functionality. These are provided in numpy, scipy and matplotlib, which are included in the distributions described above.

Typical chemical engineering calculations involve one or more of the following kinds of math problems:

- [[http://docs.scipy.org/doc/numpy-dev/reference/routines.linalg.html][Linear algebra]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve][Root finding]] (nonlinear algebra)
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq][linear regression]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit][Nonlinear regression]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/tutorial/integrate.html][Integration and ordinary differential equations]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/tutorial/stats.html][statistics]]
- [[http://matplotlib.org/][plotting]]

All of these are doable out of the box with the Python distributions discussed above. You can find many examples of using these, and more on my PYCSE blog (http://kitchingroup.cheme.cmu.edu) and http://kitchingroup.cheme.cmu.edu/pycse/. In short, almost every example I put in the Matlab blog has been done in Python. The only ones I did not do yet are some of the interactive graphics with the steam tables. I have not had time to work those out in detail.

I have found it convenient to augment theses with a package I wrote called pycse (https://github.com/jkitchin/pycse).

- an ode integrator with events similar to the one in Matlab
- some numerical differentiation functions
- linear and nonlinear regression with confidence intervals
- some boundary value problem solvers
- a publish function to convert python scripts to PDF via LaTeX

This package is still a work in progress. Notably, there is not a really good units package in Python that works as well as my Matlab units package does. Two that come close are [[http://pythonhosted.org/quantities/][quantities]] and [[https://pint.readthedocs.org/en/latest/][pint]]. Both have some nuances that make them tricky for regular use, and both have some challenges in covering all the functions you might want to use them for.

** Python from the educator perspective
Make that my perspective. I have developed an approach to using code in my lectures where I use the code to reinforce the structure of the problems, and to analyze the solutions that result. Doing that means I need to have code to show students, and the output, and sometimes to run the code to illustrate something. I also like these examples integrated into my lecture notes, so they have the right context around them.

I have found that [[http://www.youtube.com/watch?v=1-dUkyn_fZA][Emacs+org-mode+python]] allows me to easily integrate notes, equations, images, code and output in one place, and then export it to a PDF which I can annotate in class. This ensures that the code and output stay synchronized, that the code is always right where it needs to be, in the right context, and that I can annotate actual code in class, and not pseudocode. This heavily influenced my decision to use Python because it leverages what I already know and want to do. In fact, using it makes me even better at what I already know and helps me learn more about it. That makes me happy!

Not everyone will be a content developer like this, but that is what I like to do. Python makes that process fun, and worth doing for me.

** Final thoughts
In my opinion Python is and is becoming a more viable alternative to other packages like Matlab for scientific and engineering calculations. I have used it exclusively for about a year solving all kinds of engineering problems that I used to solve in Matlab.

Python is different, for sure. The main differences in my opinion are:
 - Python is less consistent in syntax than Matlab. For example, there are two ODE solvers in scipy with incompatible syntax. That is a result of the fact that you install a Python distribution made of packages written by many different people with different needs.
 - There is duplicated functionality between numpy and scipy.
 - Some functionality in scipy is provided by external "scikits" (http://scikits.appspot.com/).
 - Support for boundary value problems and partial differential equations is not as good in Python as it is in Matlab [fn:3]. At the undergraduate level, this is not a big deal. It is not like the Matlab functions are that easy to use!
 - Data regression in Python is not as complete as in Matlab.
 - indexing in Python starts at 0, and uses [], whereas in Matlab it starts at 1 and uses ()
 - You have to import most functions into Python. In contrast, Matlab has them all in one big namespace.


It is certainly doable to use Python for many scientific and engineering calculations. This past Fall I took the plunge, and taught a whole core course in chemical reaction engineering using Python! It was a Master's level course with 59 graduate students in it. I have also taught a graduate elective course in Molecular Simulation using Python. I still have some polishing to do before I would teach this to undergraduates, but I think it is definitely worth trying!

* Invisible text in emacs
  :PROPERTIES:
  :categories: emacs
  :END:

Emacs supports [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Invisible-Text.html][invisible text]]. In other words, you can use code to set properties on text in a buffer that make it visible, or invisible. You can use code to change the invisibility properties of text. I do not know how to store the invisibility property though. You could put it a lisp file that is run to fontify the buffer, but that seems kind of annoying.

#+BEGIN_SRC emacs-lisp
(defun make-invisible (beginning end tag)
"make region invisible"
(interactive "r\nSEnter symbol: ")
(overlay-put (make-overlay beginning end)
                  'invisible tag))
#+END_SRC

** subsection 1
some text in 1

** subsection 2
more text in 2

** subsection 3
last section 3

** code
(mapcar (lambda (x) (add-to-invisibility-spec x)) '(sec1 sec2 sec3))
(mapcar (lambda (x) (remove-from-invisibility-spec x)) '(sec1 sec2 sec3))

[[elisp:(add-to-invisibility-spec 'sec1)]]
[[elisp:(remove-from-invisibility-spec 'sec1)]]

(add-to-invisibility-spec 'incorrect)
(remove-from-invisibility-spec 'incorrect)


(add-to-invisibility-spec 'correct)

* Conditional links in org-mode
I have been thinking about using org-files for educational content that is not necessarily linear, i.e. there is more than one path to get to the end. However, I still need some gateways to act as prerequisites for advanced topics. I would like for there to be some problems to solve that are required before you could get to the next stage. I am not sure org-mode is the best way to do that, but it is the best authoring tool, so I want to explore it.

The idea to explore today is a conditional link. When you click on it, some code is run to determine if you are ready to go to the next stage.

* textify html

#+BEGIN_EXAMPLE
 	<title>Philip Herron: Cython Book</title> 	<guid>http://redbrain.co.uk/?p=147</guid> 	<link>http://redbrain.co.uk/cython-book/</link> 	<description><p>Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. <a href="http://bit.ly/195ahQs">http://bit.ly/195ahQs</a></p> <p><a href="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"><img class="aligncenter size-full wp-image-148" alt="photo" src="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg" width="640" height="480" /></a>The code can be found: <a href="https://github.com/redbrain/cython-book">https://github.com/redbrain/cython-book</a></p></description> 	<pubDate>Tue, 10 Dec 2013 14:45:08 +0000</pubDate>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun ph (start end) (interactive "r")
 (setq output (libxml-parse-html-region start end)))
#+END_SRC

(cdr '(a nil b))


#+BEGIN_SRC emacs-lisp :results output
(setq phtml
'(html nil
      (head nil
            (title nil "Philip Herron: Cython Book")
            (guid nil "http://redbrain.co.uk/?p=147")
            (link nil))
      (body nil
            (p nil "http://redbrain.co.uk/cython-book/ 	"
               (description nil
                            (p nil "Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. "
                               (a
                                ((href . "http://bit.ly/195ahQs"))
                                "http://bit.ly/195ahQs"))
                            " "
                            (p nil
                               (a
                                ((href . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"))
                                (img
                                 ((class . "aligncenter size-full wp-image-148")
                                  (alt . "photo")
                                  (src . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg")
                                  (width . "640")
                                  (height . "480"))))
                               "The code can be found: "
                               (a
                                ((href . "https://github.com/redbrain/cython-book"))
                                "https://github.com/redbrain/cython-book")))
               (pubdate nil "Tue, 10 Dec 2013 14:45:08 +0000")))))


;; (defun print-elements-recursively (list)
;;        "Print each element of LIST on a line of its own.
;;      Uses recursion."
;;        (when list                            ; do-again-test
;;              (print (car list))              ; body
;;              (if (listp (cdr list)) (print-elements-recursively (cdr list)))
;;              (print-elements-recursively     ; recursive call
;;               (cdr list))))                  ; next-step-expression

;(print-elements-recursively phtml)

(defun print-list (lst)
 (when lst
   (if (atom (car lst))
     (print (car lst)) (print-list (cdr lst)))))


(print-list phtml)
#+END_SRC

#+RESULTS:
:
: html






** another approach

<p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA"><img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img></a>
</div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
[[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>

(defun ph (r1 r2) (interactive "r") (setq html (buffer-substring r1 r2)))
#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1]]"  html)
#+END_SRC

#+RESULTS:
: <p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA]]
: </div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
: [[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>


http://www.mkyong.com/regular-expressions/how-to-extract-html-links-with-regular-expression/

these worked in re-builder (C-c C-w) then c-y to get them

"<p>\\(.+?\\)</p>" \\1 is the stuff between them


#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]"  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>")
#+END_SRC

#+RESULTS:
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]



(url-file-local-copy "http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA")

[[./tst.png]]


** downloading images

#+BEGIN_SRC emacs-lisp :results raw
(defun download-src (arg)
  (format "[[%s][image]]" (save-match-data
                            (url-file-local-copy
                             (replace-regexp-in-string
                              "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"
                              "\\1"
                              arg)))))

(princ (replace-regexp-in-string "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>" #'download-src  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA">[[c:/Users/jkitchin/AppData/Local/Temp/url8408MBa][image]]</a>


** replacing <a>
#+BEGIN_SRC emacs-lisp :results raw
(princ (replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]" "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
[[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]

** some regexs
"<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>"  \\1 is the href \\2 is the target

"<img\\([^>]+\\)></img>"

"<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"  \\1 is the src

* Set a property on every heading
  :PROPERTIES:
  ::EXPORT_FILE_NAME:: Set a property on every heading
  :END:


  (org-map-entries
             (lambda ()
               (let ((title (nth 4 (org-heading-components))))


(org-map-entries
             (lambda ()
               (let ((level (nth 1 (org-heading-components)))
                     (title (nth 4 (org-heading-components))))
                 (if (= level 1)
                     (org-entry-put (point) ":EXPORT_FILE_NAME:" title))))
 nil nil)


* Section one
  :PROPERTIES:
  ::EXPORT_FILE_NAME:: Section one
  :END:
Section one text
* Section two
  :PROPERTIES:
  ::EXPORT_FILE_NAME:: Section two
  :END:
** Section two a
Section two text
* Section three
  :PROPERTIES:
  ::EXPORT_FILE_NAME:: Section three
  :END:
Section three text


* Retrieving ACS journal bibtex entries

#+BEGIN_SRC python
import requests, urllib

params= urllib.urlencode({'doi':'10.1021/ie400582a'})

url='http://pubs.acs.org/action/showCitFormats?{0}'.format(params)

data = {'doi':'10.1021/ie400582a',
'direct':'true',
'downloadFileName':'achs_iecred52_10788',
'format':'bibtex',
        'include':'cit',
        'submit':'Download Citation(s)'}

headers = {'content-type': 'multipart/form-data'}
r = requests.post(url, headers=headers, data=data,  files={})
print dir(r)
print dir(r.raw)
print r.raw.get_redirect_location()
#+END_SRC

#+RESULTS:
: ['__bool__', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__module__', '__new__', '__nonzero__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_content', '_content_consumed', 'apparent_encoding', 'close', 'connection', 'content', 'cookies', 'elapsed', 'encoding', 'headers', 'history', 'iter_content', 'iter_lines', 'json', 'links', 'ok', 'raise_for_status', 'raw', 'reason', 'request', 'status_code', 'text', 'url']
: ['CONTENT_DECODERS', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_body', '_connection', '_decoder', '_fp', '_original_response', '_pool', 'data', 'decode_content', 'from_httplib', 'get_redirect_location', 'getheader', 'getheaders', 'headers', 'read', 'reason', 'release_conn', 'status', 'strict', 'version']
: False


* Copy a bibtex entry with some formatting

#+BEGIN_SRC emacs-lisp
(defun formatted ()
  "copy entry to formatted string"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((bibtex-expand-strings t)
         (entry (bibtex-parse-entry t))
         (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
         (year  (reftex-get-bib-field "year" entry))
         (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
         (key (reftex-get-bib-field "=key=" entry))
         (journal (reftex-get-bib-field "journal" entry))
         (volume (reftex-get-bib-field "volume" entry))
         (issue (reftex-get-bib-field "issue" entry))
         (pages (reftex-get-bib-field "pages" entry))
         (doi (reftex-get-bib-field "doi" entry))
         (output))
    (setq output (concat (when author author) ", "
                         (when title title) ", "
                         (when journal journal) ", "
                         (when volume volume)
                         (if issue (format "(%s), " issue) ", ")
                         (when pages pages) ", "
                         (when year (format "(%s)." year))
                         (when doi (format " https://doi.org/%s" doi))))
    (kill-new output)))

#+END_SRC

Abild-Pedersen, F. and Greeley, J. and Studt, F. and  Rossmeisl, J. and Munter, T. R. and Moses, P. G. and  Sk\'ulason, E. and Bligaard, T. and N\o{}rskov,  J. K., Scaling Properties of Adsorption Energies for  Hydrogen-Containing Molecules on Transition-Metal  Surfaces, Phys. Rev. Lett., 99(1),016105, (2007). https://doi.org/10.1103/PhysRevLett.99.016105

* DONE Finding bibtex entries with non-ascii characters
  CLOSED: [2014-01-08 Wed 10:42]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/01/08 09:49:39
  :updated:  2014/01/08 09:49:39
  :END:

I have found that some journals cannot handle bibtex entries with non-ascii characters in them. Unfortunately, when you paste bibtex entries into your reference file from the web, there are often non-ascii characters in them. Emacs usually shows those characters just fine, so it is difficult to find them. Here is a little recipe to go through each entry to find entries with non-ascii characters. These range from accented characters, greek letters, degree symbols, dashes, fancy quotes, etc... Since they are hard to see by eye, we can let Emacs find them for us, and then replace them with the corresponding ascii LaTeX commands.

I found a function to find non-ascii characters here: http://www.emacswiki.org/emacs/FindingNonAsciiCharacters. Now, we use a modified version of this on each entry in a bibtex file. If we find a character, we will print an org-mode link to make it easy to get right to the entry.

#+BEGIN_SRC emacs-lisp
(defun contains-non-ascii-char-p ()
  "tests if buffer contains non-ascii character"
  (interactive)
  (let (point)
    (save-excursion
      (setq point
            (catch 'non-ascii
              (while (not (eobp))
                (or (eq (char-charset (following-char))
                        'ascii)
                    (throw 'non-ascii (point)))
                (forward-char 1)))))
    (if point
        (goto-char point)
      nil)))


(find-file "~/Dropbox/bibliography/references.bib")
(bibtex-map-entries (lambda (bibtex-key start end)
                      (save-restriction
                        ;; narrow so we only look at this entry. save-restriction will rewiden
                        (bibtex-narrow-to-entry)
                        (when (contains-non-ascii-char-p) (princ (format "cite:%s" bibtex-key)))))))
#+END_SRC

#+RESULTS:
: cite:suntivich-2011-perov-oxide

You can see I only had one reference in that file with a non-ascii character. I think it is best practice to replace these with pure LaTeX commands. See http://en.wikibooks.org/wiki/LaTeX/Special_Characters for a good reference on what commands are used for the accented characters.

* DONE Finding bibtex entries with no downloaded pdf
  CLOSED: [2014-01-08 Wed 10:42]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/01/08 10:27:29
  :updated:  2014/01/08 10:41:40
  :END:

We use bibtex for bibiliography management in our group. Almost every journal provides a utility to download bibtex entries, and you can pretty easily download bibtex entries from citeulike. It doesn't take too long though before you have a few hundred entries. You need some tools to interact with that database.

Bibtex-mode in Emacs provides some tools for working with your bibtex files. For example, you can (bibtex-validate) to check if entries are correct, and (bibtex-sort-buffer) to sort them by key.

I have a specific workflow to entering new entries. This is what I prefer to do:

1. Go to journal, get bibtex entry, paste into bibtex file.
2. delete the key that is used, if any
3. type C-c C-c to autogenerate a key of my style
4. Copy the key, download the pdf, and save the pdf as (format "%s.pdf" key) in my pdfs directory.
5. Make an entry in a notes file for that reference. These entries are initially tagged as TODO to remind me to organize them.

Doing this has some payoffs; my org-mode cite links can open either the bibtex entry, or the pdf file directly from the org-file! The notes file is also an org-file, which I can organize as I see fit.

Sometimes I am lazy, and do not get all these steps done, especially the pdf download step. I like to have local copies of the pdf files so I can read them even if I am offline, and because I often annotate them using a tablet PC. It also makes it easy to send them to my students if I need to. Periodically, I like to go through my bibtex database to do some maintenance, download missing files, and notes entries etc... The problem is how do I know which entries have downloaded pdfs or note entries? It is not that difficult with a bit of elisp.

#+BEGIN_SRC emacs-lisp
(find-file "~/Dropbox/bibliography/references.bib")
(bibtex-map-entries (lambda (bibtex-key start end)
                      (let ((type  (cdr (car (bibtex-parse-entry)))))
                        (unless (file-exists-p
                                 (format "~/Dropbox/bibliography/bibtex-pdfs/%s.pdf" bibtex-key))
                          (princ (format "%10s:  cite:%s has no pdf\n" type bibtex-key))))))
#+END_SRC

#+RESULTS:
#+begin_example
      Book:  cite:ambrose-2010-how-learn-works has no pdf
   article:  cite:gerken-2010-fluor-modul has no pdf
      Book:  cite:gray-1973-chemic-bonds has no pdf
   ARTICLE:  cite:kitchin-2003-tio2 has no pdf
   ARTICLE:  cite:kitchin-2012-prefac has no pdf
      Book:  cite:kittel-2005-introd-solid has no pdf
   ARTICLE:  cite:mccormick-2003-tio2-pd has no pdf
   ARTICLE:  cite:mhadeshwar-2004-nh3-ru has no pdf
      Misc:  cite:ni-website has no pdf
   ARTICLE:  cite:norskov-2006-respon has no pdf
      Book:  cite:reif-1965-fundam-statis has no pdf
   article:  cite:risch-2012-water-oxidat has no pdf
   ARTICLE:  cite:shultz-1995-prepar-and has no pdf
   ARTICLE:  cite:shultz-1997-prepar has no pdf
   ARTICLE:  cite:song-2002-h3pw1 has no pdf
#+end_example

Using that list, I can click on those links, which takes me to the entry in file. That entry probably has a url or doi that makes it easy to navigate to the journal page where I can download the pdf file. You could improve on the code above by filtering out only articles, for example.

* Making sure you have a notes entry for each bibtex entry
As I mentioned [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf/][here]], I like to have a notes entry for each bibtex entry in an org-mode file. There are a couple of reasons for that:
1. I can tag the org-mode entries to help me find entries later
2. I can organize the org-mode entries by topic, including using links to entries when they belong in multiple places.
3. I can mark the entry as TODO to make it easy to find unfiled entries
4. I can keep typed notes in these entries.

It is usually part of my workflow to create these entries when I enter the bibtex entry, but occasionally I do not get to that. As part of the regular maintenance of my bibtex file, I like to find entries with no notes entry, and make them.

* non-ascii characters
 "
 "

  \beta
 $^{\circ}$
 \v{a}
 '
 \'{e}
 \~{n}
 \'{i}
 \~{a}
 \v{s}
 \delta



* TODO Add time to a deadline
  :PROPERTIES:
  :categories: org-mode
  :END:
I have an application where an org-file is a template with some due dates in it. I would like to update the deadlines to make them all relative to today. In this post I explore a way to do that. The strategy is to find deadlines, parse the time out of the time stamp, add an appropriate amount of time, and replace the time stamp. For this exercise, we use this org-file, which has one DEADLINE of "2014-01-13 Mon", and I want to add 60 days to the time stamp.

Amazingly, emacs can parse time strings into a format that it can understand.
#+BEGIN_SRC emacs-lisp :results value raw
(date-to-time "<2014-01-13 Mon>")
#+END_SRC

#+RESULTS:
(21203 11392)

Now, we can add time to that format:
#+BEGIN_SRC emacs-lisp :results value raw
(let ((days (seconds-to-time (* 60 60 24 60))))
(time-add (date-to-time "<2014-01-13 Mon>") days))
#+END_SRC

#+RESULTS:
(21282 18048 0 0)

That does not make too much sense, so we can use another function to format it like a new time stamp.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((days (seconds-to-time (* 60 60 24 60))))
  (format-time-string "<%Y-%m-%d %a>"
                      (time-add (date-to-time "<2014-01-13 Mon>") days)))
#+END_SRC

#+RESULTS:
<2014-03-13 Thu>

Beautiful. Now we just search forward to find deadline, get the time stamp, add the time to it, and replace the line.


#+BEGIN_SRC emacs-lisp
(progn
  (save-excursion
    (re-search-forward "DEADLINE:\\s-*<\\(\\([0-9]\\{4\\}\\)-\\([0-9]\\{2\\}\\)-\\([0-9]\\{2\\}\\)\\s-\\(Mon\\|Tue\\|Wed\\|Thu\\|Fri\\|Sat\\|Sun\\)\\)>")
    (let ((ts (match-string 1))
          (days (seconds-to-time (* 60 60 24 60)))
          (new-ts))
      (setq new-ts (format-time-string "    DEADLINE: <%Y-%m-%d %a>"
                                       (time-add (date-to-time ts) days)))
      (beginning-of-line)
      (kill-line)
      (insert new-ts))))
#+END_SRC


That is it! An interesting application of this would be to make all the deadlines in an org-file relative to some baseline date. For example, you have a series of deadlines for assignments throughout a semester, and it would be tedious to update these by hand. Suppose you could just establish a new beginning date, and make all deadlines relative to that date.

** s1
    DEADLINE: <2014-09-06 Sat>

* Send email to a list of users
  :PROPERTIES:
  :categories: emacs, emacs-lisp
  :date:     2014/01/13 18:41:55
  :updated:  2014/01/13 18:42:59
  :END:

I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapcar to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.

#+BEGIN_SRC emacs-lisp
(defun send-mail (userid password)
  "send email to userid@andrew.cmu.edu containing their password"
  (interactive)
  (mail)
  (mail-to)
  (insert (format "%s@andrew.cmu.edu" userid))
  (mail-subject)
  (insert "[06-640] account information")
  (mail-text)
  (insert (format "
An account has been created on gilgamesh.cheme.cmu.edu
userid: %s
password: %s" userid password))
  (mail-send-and-exit))

(send-mail "jkitchin" "trustme99")
#+END_SRC

#+RESULTS:

That worked well. I ran the block and got the email.

Now, suppose I have this data:
#+tblname: users
| userid | password  |
|--------+-----------|
| user1  | trustme99 |
| user2  | foolme99  |
| user3  | blameme99 |

We can pass that to a source block as a list of lists that will look like this:
#+BEGIN_EXAMPLE
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
#+END_EXAMPLE

Then, we can use a mapcar to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.

#+BEGIN_SRC emacs-lisp :var data=users
(defun fun (a b)
  (princ (format "user: %s\npassword: %s\n" a b)))

(mapcar (lambda (x) (fun (car x) (cadr x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:

#+BEGIN_SRC emacs-lisp :var data=users
(defun fun (a b)
  (princ (format "user: %s\npassword: %s\n" a b)))

(mapcar (lambda (x) (fun (nth 0 x) (nth 1 x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99




* Email buffer after time out

(timer-duration "0.5 min")


#+BEGIN_SRC emacs-lisp
(run-at-time 5 nil
             (lambda (args)
(princ "uuuu")
               (let ((body (buffer-string)))
                 (mail)
                 (mail-to)
                 (insert "jkitchin@andrew.cmu.edu")
                 (mail-subject)
                 (insert "exam")
                 (mail-text)
                 (insert body)
                 (mail-send-and-exit))))
#+END_SRC

#+RESULTS:


(run-at-time 5 nil
             (lambda (args) (insert "done")))

"09:40pm" 10

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defvar jao-totd-timer (run-at-time "12:00am" (* 30 1) 'totd))
(cancel-timer jao-totd-timer)


(defun jao-cancel-totd
  (interactive)
  (cancel-timer jao-totd-timer))

(defun td ()
  (interactive)
  (with-output-to-temp-buffer "*my-timer*"
  (insert "done")))

(defvar jao-totd-timer (run-at-time "12:00am" 1 'td))
(cancel-timer jao-totd-timer)




* DONE Making org-mode links to files in Emacs packages
  CLOSED: [2014-01-19 Sun 15:23]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/01/19 12:42:27
  :updated:  2014/01/19 15:27:48
  :END:
Today I will make a new org-mode link that lets me make links to files inside of Emacs packages. These files may be installed in different places on different systems (e.g. in the system directory, in ELPA directories, or in custom directories), so we need a way to construct paths to them. The application of this is eventually I hope to have some emacs packages of documentation, and I would like to have links between the packages that work no matter how they are installed.

I want a syntax that looks like pkg:rainbow-mode==rainbow-mode-pkg.el. We will have a function that parses that to get the package, and the path to the file in the package. Emacs has a function to find the path to the file that defines a library. I chose == because it seems unlikely that would be a string in a package or path.

#+BEGIN_SRC emacs-lisp :results value
(locate-library "rainbow-mode")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode.elc

We can use that to construct the path to where we want. Say we want the file named "rainbow-mode-pkg.el"

#+BEGIN_SRC emacs-lisp :results value
(expand-file-name
 "rainbow-mode-pkg.el"
 (file-name-directory (locate-library "rainbow-mode")))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode-pkg.el

In org-mode links, the link path gets passed to a function. We can split the string like this to get the package and relative path we are referring to.

#+BEGIN_SRC emacs-lisp :results value
(split-string "rainbow-mode==rainbow-mode-pkg.el" "==")
#+END_SRC

#+RESULTS:
| rainbow-mode | rainbow-mode-pkg.el |

That is all of the pieces we need to construct the link function. Here it is.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg"
 (lambda (path)
   (let ((pkg) (relpath)
	 (splitpath (split-string path "==")))
     (setq pkg (car splitpath))
     (setq relpath (nth 1 splitpath))
     (find-file (expand-file-name
		 relpath
		 (file-name-directory (locate-library pkg)))))))
#+END_SRC

#+RESULTS:

pkg:rainbow-mode==rainbow-mode-pkg.el

This works too, but you have to use auctex-pkg as the package name.

pkg:auctex-pkg==doc/intro.texi

I think that is because locate-library looks for the /file/ a library is defined in. That is not quite the same as the root directory of a package. It turns out to be a little more complicated to find that. Below is some code I hacked up looking at the package.el code. First let us examine some pieces.

This gives us information about an installed package.

#+BEGIN_SRC emacs-lisp :results value
(assq 'auctex package-alist)
#+END_SRC

#+RESULTS:
: (auctex . [(11 87 2) nil Integrated environment for *TeX*])

We can get the version of the package like this

#+BEGIN_SRC emacs-lisp :results value
(package-version-join (package-desc-vers (cdr (assq 'auctex package-alist))))
#+END_SRC

#+RESULTS:
: 11.87.2

Ok, finally, we get the directory where it is installed like this:

#+BEGIN_SRC emacs-lisp :results value
(package--dir "auctex" "11.87.2")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Note that in some places we use a package symbol, and in other places a string name.Putting that together, we have this block to get the install-dir of a package. If we have a package symbol we can get the path like this.

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg 'auctex)
       (pkg-name (symbol-name pkg)) ; convert symbol to string
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Usually, we will have a string though. We just have to make it a symbol with the =intern= function.

#+BEGIN_SRC emacs-lisp :results value
(setq pkg-name "auctex")
(setq pkg (intern pkg-name))
(setq desc (cdr (assq pkg package-alist)))
#+END_SRC

#+RESULTS:
: [(11 87 2) nil "Integrated environment for *TeX*"]

Now, we have all the pieces to get the path from a package name in a string:

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg-name "auctex")
       (pkg (intern pkg-name))
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Let us use that to rewrite the link, and address a few other limitations. We will  use =org-open-link-from-string= so we can use org-link syntax in the path part of the link, e.g. to open a file at a line, or headline. Here is our new link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg2"
 (lambda (path)
   (let ((pkg) (relpath) (pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (let* ((pkg-symbol (intern pkg-name)) ;convert string to pkg
			  (desc (cdr (assq pkg-symbol package-alist)))
			  (version (package-version-join (package-desc-vers desc)))
			  (pkg-dir (package--dir pkg-name version)))
		     pkg-dir))
     (setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

Now, we can do all of these:
pkg2:auctex==doc/faq.texi
pkg2:auctex==doc/faq.texi::should
pkg2:auctex==doc/faq.texi::10
[[pkg2:auctex==doc/faq.texi::first place]]

Awesome!

Just for fun, I made a toy package called =package1= in my elpa directory. That package has an org file in it. Now, I can test out the following links:

pkg2:package1==intro.org

pkg2:package1==intro.org::*Miscellaneous

[[pkg2:package1==intro.org::*subheading with words]]

pkg2:package1==intro.org::#install-section

pkg2:package1==intro.org::intro-target

They all work! That works for packages installed via the package manager. However, when I try this with my custom installed org-mode, it does not work. If I run (describe-package 'org) I see that org is a build in package, and that there is an alternate version available. It does not point to my org-installation.

pkg2:org==doc/library-of-babel.org

#+BEGIN_SRC emacs-lisp
(princ (locate-library "org"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/org.elc

#+BEGIN_SRC emacs-lisp
(princ (package-installed-p "org"))
#+END_SRC

#+RESULTS:
: nil

Obviously, we need to check if the package is installed via package.el, or if we should look somewhere else. Let us take a final stab at this. Let us review the challenge.

#+BEGIN_SRC emacs-lisp
(print (locate-library "auctex"))
(print (locate-library "auctex-autoloads"))
#+END_SRC

#+RESULTS:
:
: nil
:
: "c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/auctex-autoloads.el"

We may have to check for a package-autoloads. Ww can wrap that in an =or= macro, which will return the first non-nil result.

#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "auctex"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/

Doing this on the org package shows that this points to a lisp directory.
#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "org"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/

So, let's try a final link function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg3"
 (lambda (path)
   (let ((pkg-name) (relpath)(pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (file-name-directory
		    (or (locate-library pkg-name)
			(locate-library (format "%s-autoloads" pkg-name)))))
(setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

#+RESULTS:

Now, we just have to make sure to use the right relative path. This link opens up an org-file in my installed version of org-mode: pkg3:org==../doc/library-of-babel.org

I don't know if there is a more clever way to create these links. There are two parts to them: 1) the package, and 2) the relative path. The link syntax isn't that rich to do it without parsing the linkpath.


* Alternatives to long complex format statements in emacs-lisp
 :PROPERTIES:
 :categories: emacs-lisp
 :date:     2014/01/20 09:50:26
 :updated:  2014/01/20 09:50:26
 :END:
At one point I had a string I wanted to fill in with a bunch of variables.

#+BEGIN_SRC emacs-lisp
(insert (format"
 :PROPERTIES:
  :Custom_ID: %s
  :AUTHOR: %s
  :JOURNAL: %s
  :YEAR: %s
  :VOLUME: %s
  :PAGES: %s
  :DOI: %s
  :URL: %s
 :END:
[[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"
key author journal year volume pages doi url key jorg-bib-pdf-directory key ))
#+END_SRC

I find that very difficult to use, because it is tedious to make sure all the variables are in the right order, and it is difficult to change later. In Python, you would be able to put named expansions in, e.g. {author} and then used named arguments. That does not exist as far as I know in emacs-lisp.

Below is an alternatme approach that uses concat to construct this string.

#+BEGIN_SRC emacs-lisp :results value
(let ((key "kitchin-2014")
      (author "Kitchin, J. R.")
      (journal "HACS")
      (year "2014")
      (volume "1")
      (pages "1--10")
      (doi "10.1.1.109/hacs.1.10")
      (url "http://hacs.org/10.1.1.109/hacs.1.10")
      (jorg-bib-pdf-directory "/home/jkitchin/pdfs"))

(concat "
 :PROPERTIES:
  :Custom_ID: " key "
  :AUTHOR: " author "
  :JOURNAL: " journal "
  :YEAR: " year "
  :VOLUME: " volume "
  :PAGES: " pages "
  :DOI: " doi "
  :URL: " url "
 :END:
[[cite:" key "]] [[file:" jorg-bib-pdf-directory "/" key ".pdf][pdf]]\n\n"))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is kind of interesting. It is a little tedious to use all the quotes. It seems like there should be soemthing like named expansions. Let us write one of our own. We will use a regular expression to find {:keyword} and a plist. There is a regexp to match this, and then we can take the characters from position 1 to the second to last character as the keyword. That is not beautiful to me, but it works here. Then we just get the keyword from the plist. The keywords in a plist are symbols, and we will have strings. We have to use the =intern= function to convert them to symbols.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s plist)
  "expand a template containing {:keyword} with the definitions in plist"
  (replace-regexp-in-string "{\\(:[^}]+\\)}"
			    (lambda (arg)
			      (let ((keyword (intern (substring arg 1 -1))))
				(format "%s" (plist-get plist keyword)))) s))

(let ((template "
 :PROPERTIES:
  :Custom_ID: {:key}
  :AUTHOR: {:author}
  :JOURNAL: {:journal}
  :YEAR: {:year}
  :VOLUME: {:volume}
  :PAGES: {:pages}
  :DOI: {:doi}
  :URL: {:url}
 :END:
[[cite:{:key}]] [[file:{:pdf-dir}/{:key}.pdf][pdf]]\n\n"))

(expand-template template
		 '(:key "kitchin-2014"
			:author "Kitchin, J. R."
			:journal "HACS"
			:year 2014
			:volume 1
			:pages "1--10"
			:doi "10.1.1.109/hacs.1.10"
			:url "http://hacs.org/10.1.1.109/hacs.1.10"
			:pdf-dir "/home/jkitchin/pdfs")))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is pretty close to what I am used to from python! I am surprised there aren't other solutions for this around. I looked, and couldn't find them.

* Another alternative to string templates
  :PROPERTIES:
  :categories: emacs-lisp
  :date:     2014/01/26 09:56:45
  :updated:  2014/01/26 09:56:45
  :END:

In the [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/][last post]] I explored a way to expand a string template that was
more readable than the usual format. Today I look at another approach
where I use sexp expansions to accomplish the same thing. The idea is
to embed lisp expressions and replace them by what they evaluate to.

In emacs-lisp, if we have a command in a string, we can "read" it, and
then eval it.

Here we get the user-full-name:
#+BEGIN_SRC emacs-lisp :results value
(eval (read "user-full-name"))
#+END_SRC

#+RESULTS:
: John Kitchin

We can use this on variables too.
#+BEGIN_SRC emacs-lisp :results value
(setq some-variable "test")
(eval (read "some-variable"))
#+END_SRC

#+RESULTS:
: test

So, if we use a syntax to identify what to replace, we can substitute
in the values. Let us try %() as the syntax.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %() with the eval of its contents"
  (replace-regexp-in-string "%(\\([^)]+\\))"
			    (lambda (arg)
			      (format "%s" (eval (read (substring arg 2 -1))))) s))


(let ((key "kitchin-2014")
      (author "Kitchin, J. R.")
      (journal "HACS")
      (year "2014")
      (volume "1")
      (pages "1--10")
      (doi "10.1.1.109/hacs.1.10")
      (url "http://hacs.org/10.1.1.109/hacs.1.10")
      (pdf-dir "/home/jkitchin/pdfs")
      (template "
 :PROPERTIES:
  :Custom_ID: %(key)
  :AUTHOR: %(author
  :JOURNAL: %(journal)
  :YEAR: %(year)
  :VOLUME: %(volume)
  :PAGES: %(pages)
  :DOI: %(doi)
  :URL: %(url)
 :END:
[[cite:%(key)]] [[file:%(pdf-dir)/%(key).pdf][pdf]]\n\n"))

(expand-template template))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is pretty nice. I like it better than the plist expansion I used
before. Presumably these variables would already be defined somewhere
in your code.

I thought of trying this on a more complex expansion, and discovered a
weakness in the regexp that finds the expansion values. It turns out
to be simpler to use %{} as the delimiter than %(), because you may
want nested parentheses. The regexp above does not correctly match
sets of parentheses.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
			    (lambda (arg)
			      (let ((sexp (substring arg 2 -1)))
				(format "%s" (eval (read sexp))))) s))

(expand-template "2 * 2 = %{(* 2 2)}")
#+END_SRC

#+RESULTS:
: 2 * 2 = 4


I am not sure this is a desirable way to make a template, with
multiline code to be expanded, but at least this works!

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
			    (lambda (arg)
			      (let ((sexp (substring arg 2 -1)))
				(format "%s" (eval (read sexp))))) s))

(expand-template "The result is %{(progn
  (if (> 4 3)
      'true
    'false))}")
#+END_SRC

#+RESULTS:
: The result is true

The regexp used in the expansion is not very robust. In particular if
there is a } in the code, it will probably fail because the regexp
does not match closing } correctly. Fixing that is beyond me right
now!


* DONE Language specific default headers for code blocks in org-mode
  CLOSED: [2014-01-27 Mon 13:44]
  :PROPERTIES:
  :categories: org-mode, emacs-lisp
  :date:     2014/01/26 12:06:12
  :updated:  2014/01/26 12:06:12
  :END:

I use code blocks in org-mode /a lot/. I usually code in Python, and
in Python I usually write code that prints output which I want to see. So I almost always
want the code blocks to return the output, and not the value of the
last function. I have set my default header args like this:
#+BEGIN_SRC emacs-lisp
org-babel-default-header-args
#+END_SRC

#+RESULTS:
| (:exports . both) | (:results . replace output) | (:session . none) | (:cache . no) | (:noweb . no) | (:hlines . no) | (:tangle . no) |

However, I would prefer that emacs-lisp blocks use value for the
results. I know I can get that by putting  =:results value=  in the
code block header, but that annoys me. I learned today from
http://orgmode.org/worg/org-contrib/babel/header-args.html that you
can make language specific default headers!

This code in my init file sets emacs-lisp specific default headers:
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:emacs-lisp
      (cons '(:results . "value")
	    (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC

That way I do not have type =:results value= at the top of every elisp
block. Of course, if I want the output I could specify =:results
output= in the block.

#+begin_src emacs-lisp
org-babel-default-header-args:emacs-lisp
#+end_src

#+RESULTS:
| (:results . value) | (:exports . both) | (:session . none) | (:cache . no) | (:noweb . no) | (:hlines . no) | (:tangle . no) |

Problem solved!

On a related note, I find I write so many blocks of python and elisp I
added these templates:
#+BEGIN_SRC emacs-lisp
;; add <p for python expansion
(add-to-list 'org-structure-template-alist
             '("p" "#+BEGIN_SRC python\n?\n#+END_SRC" "<src lang=\"python\">\n?\n</src>"))

;; add <el for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))
#+END_SRC

I probably could have also coded the :results header into those
too. They add a tidbit of convenience so I do not have to type python
or emacs-lisp after expanding a source block with <s.

* Clocking your time in org-mode
  CLOSED: [2014-01-27 Mon 13:46]
  :LOGBOOK:
  CLOCK: [2014-01-26 Sun 13:08]--[2014-01-26 Sun 13:16] =>  0:08
  CLOCK: [2014-01-26 Sun 13:04]--[2014-01-26 Sun 13:06] =>  0:02
  CLOCK: [2014-01-26 Sun 12:07]--[2014-01-26 Sun 12:10] =>  0:03
  :END:
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/01/27 13:46:21
  :updated:  2014/01/27 13:53:03
  :END:


I have some need for tracking how much time I spend on certain jobs,
e.g. committees, etc... because 1) I have to report this
information, 2) I need a better idea of how much time some things
take.  Org-mode supports the idea of "clocking in to a task". You run
(org-clock-in) in a heading, and it stores a time stamp. You do your
work in that heading, and when done, you (org-clock-out).

You can summarize your time with (org-clock-report) which puts a dynamic block in your file like this.

#+BEGIN: clocktable :maxlevel 2 :scope subtree :link t
#+CAPTION: Clock summary at [2014-01-26 Sun 13:36]
| Headline                       | Time   |      |
|--------------------------------+--------+------|
| *Total time*                   | *0:24* |      |
|--------------------------------+--------+------|
| [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::Clocking%20your%20time%20in%20org-mode][Clocking your time in org-mode]] | 0:24   |      |
| \__ [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::work%20in%20subheadings][work in subheadings]]        |        | 0:06 |
| \__ [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::Using%20clocking%20effectively][Using clocking effectively]] |        | 0:05 |
#+END:

You can update it by putting your cursor in the #+BEGIN line, and pressing C-c C-c.

** work in subheadings
   :LOGBOOK:
   CLOCK: [2014-01-26 Sun 13:02]--[2014-01-26 Sun 13:04] =>  0:02
   CLOCK: [2014-01-26 Sun 13:00]--[2014-01-26 Sun 13:02] =>  0:02
   CLOCK: [2014-01-26 Sun 12:11]--[2014-01-26 Sun 12:13] =>  0:02
   CLOCK: [2014-01-26 Sun 12:11]--[2014-01-26 Sun 12:11] =>  0:00
   :END:
It seems that the clock-in mechanism works on the heading you are
in. So whenever you clock in, it is specific to that heading. If you
clock-in more than once, multiple CLOCK entries are stored, unless you
modify org-clock-into-drawer. It seems like you probably want these CLOCK entries in a drawer, so you should put this in your init.el file:
#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
#+END_SRC

** Clock in to the right task
By default, (org-clock-in) creates clocks-in to the current headline. Org-mode seems to store a list of recently clocked tasks. You can access them by typing C-u C-c C-x C-i. You will be given some choices of which task to clock in to. You can switch to another task by doing this too.

** Using clocking effectively
   :LOGBOOK:
   CLOCK: [2014-01-26 Sun 13:31]--[2014-01-26 Sun 13:36] =>  0:05
   :END:
It will take some discipline and practice to use this effectively. It appears you can clock in any heading, and then use the clock report to aggregate all the times into one summary. That report can have a variety of scopes, from subtree to file. In that case, if you keep all relevant task information to a project in a file, you just clock in wherever you work in that file, and let the report keep track of it for you.

You could use this to track the amount of time you spend reviewing manuscripts, or doing work for a committee. You just need to remember to actually use it!

It might be interesting to setup code that would automatically clock in when you open a file, and then clock out when  you close it. Probably this would be done with hooks.

There is a nice [[http://sachachua.com/blog/wp-content/uploads/2014/01/2014-01-06-Tracking-time-with-Org-mode.png][map]] of using org-mode for clocking time [[http://sachachua.com/blog/wp-content/uploads/2014/01/2014-01-06-Tracking-time-with-Org-mode.png][here]].



* Set a headline to DONE
  CLOSED: [2014-01-27 Mon 13:50]

#+BEGIN_SRC emacs-lisp
(org-narrow-to-subtree)
(goto-char (point-min)) ; beginning of buffer
(org-todo 'done)
(widen)
#+END_SRC

#+RESULTS:


* Footnotes

[fn:1] Box Sync 4 renames your sync directory from "~/Documents/My Box Files" to "~/Box Sync".

[fn:2] You will have to read the raw org-source to see how the code-block arguments look.

[fn:3] It is true there are packages like FiPy (http://www.ctcms.nist.gov/fipy/) for PDEs, and scikits for BVPS, (http://scikits.appspot.com/bvp1lg, http://scikits.appspot.com/bvp_solver). But these are not easily installed on all platforms, and typically require some developer experience in compiling.
